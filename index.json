[{"content":"","permalink":"https://flecart.github.io/notes/bytecode-verification/","summary":"","title":"Bytecode Verification"},{"content":"","permalink":"https://flecart.github.io/notes/architecture-of-the-brain/","summary":"","title":"Architecture of the Brain"},{"content":"","permalink":"https://flecart.github.io/notes/object-orientation/","summary":"","title":"Object Orientation"},{"content":"","permalink":"https://flecart.github.io/notes/polimorfismo/","summary":"","title":"Polimorfismo"},{"content":"","permalink":"https://flecart.github.io/notes/systems-for-artificial-intelligence/","summary":"","title":"Systems for Artificial Intelligence"},{"content":"","permalink":"https://flecart.github.io/notes/rl-function-approximation/","summary":"","title":"RL Function Approximation"},{"content":"","permalink":"https://flecart.github.io/notes/proximal-policy-optimization/","summary":"","title":"Proximal Policy Optimization"},{"content":"","permalink":"https://flecart.github.io/notes/inheritance/","summary":"","title":"Inheritance"},{"content":"","permalink":"https://flecart.github.io/notes/typing-and-subtyping/","summary":"","title":"Typing and Subtyping"},{"content":"","permalink":"https://flecart.github.io/notes/group-relative-policy-optimization/","summary":"","title":"Group Relative Policy Optimization"},{"content":"","permalink":"https://flecart.github.io/notes/proximal-polixy-optimization/","summary":"","title":"Proximal Polixy Optimization"},{"content":"","permalink":"https://flecart.github.io/notes/classical-cyphers/","summary":"","title":"Classical Cyphers"},{"content":"","permalink":"https://flecart.github.io/notes/bayesian-optimization/","summary":"","title":"Bayesian Optimization"},{"content":"","permalink":"https://flecart.github.io/notes/datacenter-hardware/","summary":"","title":"Datacenter Hardware"},{"content":"","permalink":"https://flecart.github.io/notes/classi-oop/","summary":"","title":"Classi OOP"},{"content":"","permalink":"https://flecart.github.io/notes/teoria-dei-tipi/","summary":"","title":"Teoria dei Tipi"},{"content":"","permalink":"https://flecart.github.io/notes/data-analysis-methods-in-neural-science/","summary":"","title":"Data Analysis Methods in Neural Science"},{"content":"","permalink":"https://flecart.github.io/notes/firing-rate-based-network-models/","summary":"","title":"Firing-rate based Network models"},{"content":"","permalink":"https://flecart.github.io/notes/human-vision/","summary":"","title":"Human Vision"},{"content":"","permalink":"https://flecart.github.io/notes/intrinsic-motivation-and-playfulness/","summary":"","title":"Intrinsic Motivation and Playfulness"},{"content":"","permalink":"https://flecart.github.io/notes/memory-in-human-brain/","summary":"","title":"Memory in Human Brain"},{"content":"","permalink":"https://flecart.github.io/notes/synapses/","summary":"","title":"Synapses"},{"content":"","permalink":"https://flecart.github.io/notes/neural-imaging/","summary":"","title":"Neural Imaging"},{"content":"","permalink":"https://flecart.github.io/notes/neural-mechanisms/","summary":"","title":"Neural mechanisms"},{"content":"","permalink":"https://flecart.github.io/notes/the-neuron/","summary":"","title":"The Neuron"},{"content":"","permalink":"https://flecart.github.io/notes/birdsong-and-song-system/","summary":"","title":"Birdsong and Song System"},{"content":"","permalink":"https://flecart.github.io/notes/neuroeconomics/","summary":"","title":"Neuroeconomics"},{"content":"","permalink":"https://flecart.github.io/notes/conditioning-theory/","summary":"","title":"Conditioning Theory"},{"content":"","permalink":"https://flecart.github.io/notes/cloud-storage/","summary":"","title":"Cloud Storage"},{"content":"","permalink":"https://flecart.github.io/notes/green-computing/","summary":"","title":"Green Computing"},{"content":"","permalink":"https://flecart.github.io/notes/virtual-machines/","summary":"","title":"Virtual Machines"},{"content":"","permalink":"https://flecart.github.io/notes/communication-in-the-cloud/","summary":"","title":"Communication in the Cloud"},{"content":"","permalink":"https://flecart.github.io/notes/redundant-array-of-independent-disks/","summary":"","title":"Redundant Array of Independent Disks"},{"content":"","permalink":"https://flecart.github.io/notes/cloud-computing-services/","summary":"","title":"Cloud Computing Services"},{"content":"","permalink":"https://flecart.github.io/notes/cloud-reliability/","summary":"","title":"Cloud Reliability"},{"content":"","permalink":"https://flecart.github.io/notes/cluster-resource-management/","summary":"","title":"Cluster Resource Management"},{"content":"","permalink":"https://flecart.github.io/notes/confidential-computing/","summary":"","title":"Confidential Computing"},{"content":"","permalink":"https://flecart.github.io/notes/container-virtualization/","summary":"","title":"Container Virtualization"},{"content":"","permalink":"https://flecart.github.io/notes/content-delivery-networks/","summary":"","title":"Content Delivery Networks"},{"content":"","permalink":"https://flecart.github.io/notes/notions-of-security/","summary":"","title":"Notions of Security"},{"content":"","permalink":"https://flecart.github.io/notes/optimizations-for-dnn/","summary":"","title":"Optimizations for DNN"},{"content":"","permalink":"https://flecart.github.io/notes/cluster-management-policies/","summary":"","title":"Cluster Management Policies"},{"content":"","permalink":"https://flecart.github.io/notes/compute-express-link/","summary":"","title":"Compute Express Link"},{"content":"","permalink":"https://flecart.github.io/notes/queueing-theory/","summary":"","title":"Queueing Theory"},{"content":"","permalink":"https://flecart.github.io/notes/analysis-of-neural-codes/","summary":"","title":"Analysis of Neural Codes"},{"content":"","permalink":"https://flecart.github.io/notes/architettura-software-del-os/","summary":"","title":"Architettura software del OS"},{"content":"","permalink":"https://flecart.github.io/notes/skylake-microprocessor/","summary":"","title":"Skylake Microprocessor"},{"content":"","permalink":"https://flecart.github.io/notes/normalizing-flows/","summary":"","title":"Normalizing Flows"},{"content":"","permalink":"https://flecart.github.io/notes/autoregressive-modelling/","summary":"","title":"Autoregressive Modelling"},{"content":"","permalink":"https://flecart.github.io/notes/neural-networks/","summary":"","title":"Neural Networks"},{"content":"","permalink":"https://flecart.github.io/notes/the-perceptron-model/","summary":"","title":"The Perceptron Model"},{"content":"","permalink":"https://flecart.github.io/notes/advanced-3d-representations/","summary":"","title":"Advanced 3D Representations"},{"content":"","permalink":"https://flecart.github.io/notes/recurrent-neural-networks/","summary":"","title":"Recurrent Neural Networks"},{"content":"","permalink":"https://flecart.github.io/notes/backpropagation/","summary":"","title":"Backpropagation"},{"content":"","permalink":"https://flecart.github.io/notes/transformers/","summary":"","title":"Transformers"},{"content":"","permalink":"https://flecart.github.io/notes/convolutional-neural-network/","summary":"","title":"Convolutional Neural Network"},{"content":"","permalink":"https://flecart.github.io/notes/egocentric-vision/","summary":"","title":"Egocentric Vision"},{"content":"","permalink":"https://flecart.github.io/notes/generative-adversarial-networks/","summary":"","title":"Generative Adversarial Networks"},{"content":"","permalink":"https://flecart.github.io/notes/parametric-human-body-models/","summary":"","title":"Parametric Human Body Models"},{"content":"","permalink":"https://flecart.github.io/notes/autoencoders/","summary":"","title":"Autoencoders"},{"content":"","permalink":"https://flecart.github.io/notes/cmmrs-2025/","summary":"","title":"CMMRS 2025"},{"content":"","permalink":"https://flecart.github.io/notes/bayesian-information-criterion/","summary":"","title":"Bayesian Information Criterion"},{"content":"","permalink":"https://flecart.github.io/notes/the-market/","summary":"","title":"The Market"},{"content":"","permalink":"https://flecart.github.io/notes/parametric-modeling/","summary":"","title":"Parametric Modeling"},{"content":"","permalink":"https://flecart.github.io/notes/demand/","summary":"","title":"Demand"},{"content":"","permalink":"https://flecart.github.io/notes/budget-and-preferences/","summary":"","title":"Budget and Preferences"},{"content":"","permalink":"https://flecart.github.io/notes/structural-causal-models/","summary":"","title":"Structural Causal Models"},{"content":"","permalink":"https://flecart.github.io/notes/softmax-function/","summary":"","title":"Softmax Function"},{"content":"","permalink":"https://flecart.github.io/notes/data-plane/","summary":"","title":"Data Plane"},{"content":"","permalink":"https://flecart.github.io/notes/semantica-di-un-linguaggio/","summary":"","title":"Semantica di un linguaggio"},{"content":"","permalink":"https://flecart.github.io/notes/algoritmi-di-ordinamento/","summary":"","title":"Algoritmi di ordinamento"},{"content":"","permalink":"https://flecart.github.io/notes/sparse-matrix-vector-multiplication/","summary":"","title":"Sparse Matrix Vector Multiplication"},{"content":"","permalink":"https://flecart.github.io/notes/condensatori-nel-vuoto/","summary":"","title":"Condensatori nel vuoto"},{"content":"","permalink":"https://flecart.github.io/notes/reinforcement-learning-a-introduction/","summary":"","title":"Reinforcement Learning, a introduction"},{"content":"","permalink":"https://flecart.github.io/notes/tabular-reinforcement-learning/","summary":"","title":"Tabular Reinforcement Learning"},{"content":"","permalink":"https://flecart.github.io/notes/cache-optimization/","summary":"","title":"Cache Optimization"},{"content":"","permalink":"https://flecart.github.io/notes/logica-proposizionale/","summary":"","title":"Logica Proposizionale"},{"content":"","permalink":"https://flecart.github.io/notes/astrazione-sul-controllo/","summary":"","title":"Astrazione sul controllo"},{"content":"","permalink":"https://flecart.github.io/notes/fast-linear-algebra/","summary":"","title":"Fast Linear Algebra"},{"content":"","permalink":"https://flecart.github.io/notes/clustering/","summary":"","title":"Clustering"},{"content":"","permalink":"https://flecart.github.io/notes/markov-chains/","summary":"","title":"Markov Chains"},{"content":"","permalink":"https://flecart.github.io/notes/http-e-rest/","summary":"","title":"HTTP e REST"},{"content":"","permalink":"https://flecart.github.io/notes/fast-fourier-transforms/","summary":"","title":"Fast Fourier Transforms"},{"content":"","permalink":"https://flecart.github.io/notes/compiler-limitations/","summary":"","title":"Compiler Limitations"},{"content":"","permalink":"https://flecart.github.io/notes/diffusion-models/","summary":"","title":"Diffusion Models"},{"content":"","permalink":"https://flecart.github.io/notes/sicurezza-os/","summary":"","title":"Sicurezza OS"},{"content":"","permalink":"https://flecart.github.io/notes/wireless-attack-vectors/","summary":"","title":"Wireless attack vectors"},{"content":"","permalink":"https://flecart.github.io/notes/tls-ssl-protocol/","summary":"","title":"TLS-SSL protocol"},{"content":"","permalink":"https://flecart.github.io/notes/ipsec-protocol/","summary":"","title":"IPSec protocol"},{"content":"","permalink":"https://flecart.github.io/notes/sicurezza-delle-reti/","summary":"","title":"Sicurezza delle reti"},{"content":"","permalink":"https://flecart.github.io/notes/bag-of-words/","summary":"","title":"Bag of words"},{"content":"","permalink":"https://flecart.github.io/notes/performance-at-large-scales/","summary":"","title":"Performance at Large Scales"},{"content":"","permalink":"https://flecart.github.io/notes/design-patterns/","summary":"","title":"Design patterns"},{"content":"","permalink":"https://flecart.github.io/notes/bayesian-neural-networks/","summary":"","title":"Bayesian neural networks"},{"content":"","permalink":"https://flecart.github.io/notes/automi-e-regexp/","summary":"","title":"Automi e Regexp"},{"content":"","permalink":"https://flecart.github.io/notes/variational-inference/","summary":"","title":"Variational Inference"},{"content":"","permalink":"https://flecart.github.io/notes/multi-variable-derivatives/","summary":"","title":"Multi Variable Derivatives"},{"content":"","permalink":"https://flecart.github.io/notes/na%C3%AFve-bayes/","summary":"","title":"Naïve Bayes"},{"content":"","permalink":"https://flecart.github.io/notes/asymmetric-cryptography/","summary":"","title":"Asymmetric Cryptography"},{"content":"","permalink":"https://flecart.github.io/notes/spazi-vettoriali/","summary":"","title":"Spazi vettoriali"},{"content":"","permalink":"https://flecart.github.io/notes/bayesian-linear-regression/","summary":"","title":"Bayesian Linear Regression"},{"content":"","permalink":"https://flecart.github.io/notes/scheduler/","summary":"","title":"Scheduler"},{"content":"","permalink":"https://flecart.github.io/notes/introduzione-so/","summary":"","title":"Introduzione SO"},{"content":"","permalink":"https://flecart.github.io/notes/note-sullarchitettura/","summary":"","title":"Note sull'architettura"},{"content":"","permalink":"https://flecart.github.io/notes/processi-e-thread/","summary":"","title":"Processi e thread"},{"content":"","permalink":"https://flecart.github.io/notes/livello-isa/","summary":"","title":"Livello ISA"},{"content":"","permalink":"https://flecart.github.io/notes/memoria/","summary":"","title":"Memoria"},{"content":"","permalink":"https://flecart.github.io/notes/algebra-lineare-numerica/","summary":"","title":"Algebra lineare numerica"},{"content":"","permalink":"https://flecart.github.io/notes/bias-variance-trade-off/","summary":"","title":"Bias Variance Trade-off"},{"content":"","permalink":"https://flecart.github.io/notes/semirings/","summary":"","title":"Semirings"},{"content":"","permalink":"https://flecart.github.io/notes/transliteration-systems/","summary":"","title":"Transliteration systems"},{"content":"","permalink":"https://flecart.github.io/notes/sentiment-analysis/","summary":"","title":"Sentiment Analysis"},{"content":"","permalink":"https://flecart.github.io/notes/log-linear-models/","summary":"","title":"Log Linear Models"},{"content":"","permalink":"https://flecart.github.io/notes/language-models/","summary":"","title":"Language Models"},{"content":"","permalink":"https://flecart.github.io/notes/part-of-speech-tagging/","summary":"","title":"Part of Speech Tagging"},{"content":"","permalink":"https://flecart.github.io/notes/the-exponential-family/","summary":"","title":"The Exponential Family"},{"content":"","permalink":"https://flecart.github.io/notes/dependency-parsing/","summary":"","title":"Dependency Parsing"},{"content":"","permalink":"https://flecart.github.io/notes/devices-os/","summary":"","title":"Devices OS"},{"content":"","permalink":"https://flecart.github.io/notes/paginazione-e-segmentazione/","summary":"","title":"Paginazione e segmentazione"},{"content":"","permalink":"https://flecart.github.io/notes/reti-convoluzionali/","summary":"","title":"Reti convoluzionali"},{"content":"","permalink":"https://flecart.github.io/notes/determinanti/","summary":"","title":"Determinanti"},{"content":"","permalink":"https://flecart.github.io/notes/introduzione-ad-architettura/","summary":"","title":"Introduzione ad architettura"},{"content":"","permalink":"https://flecart.github.io/notes/central-processing-unit/","summary":"","title":"Central Processing Unit"},{"content":"","permalink":"https://flecart.github.io/notes/message-passing/","summary":"","title":"Message Passing"},{"content":"","permalink":"https://flecart.github.io/notes/memoria-virtuale/","summary":"","title":"Memoria virtuale"},{"content":"","permalink":"https://flecart.github.io/notes/livello-applicazione-e-socket/","summary":"","title":"Livello applicazione e socket"},{"content":"","permalink":"https://flecart.github.io/notes/linguaggi-deterministici-e-dpda/","summary":"","title":"Linguaggi Deterministici e DPDA"},{"content":"","permalink":"https://flecart.github.io/notes/linguaggi-liberi-e-pda/","summary":"","title":"Linguaggi liberi e PDA"},{"content":"","permalink":"https://flecart.github.io/notes/lrk-e-yacc/","summary":"","title":"LR(k) e YACC"},{"content":"","permalink":"https://flecart.github.io/notes/macchine-astratte/","summary":"","title":"Macchine Astratte"},{"content":"","permalink":"https://flecart.github.io/notes/nomi-e-scope/","summary":"","title":"Nomi e Scope"},{"content":"","permalink":"https://flecart.github.io/notes/semplificazione-grammatiche/","summary":"","title":"Semplificazione grammatiche"},{"content":"","permalink":"https://flecart.github.io/notes/top-down-parser/","summary":"","title":"Top-down Parser"},{"content":"","permalink":"https://flecart.github.io/notes/valutazione-espressioni/","summary":"","title":"Valutazione Espressioni"},{"content":"","permalink":"https://flecart.github.io/notes/control-plane/","summary":"","title":"Control Plane"},{"content":"","permalink":"https://flecart.github.io/notes/gaussians/","summary":"","title":"Gaussians"},{"content":"","permalink":"https://flecart.github.io/notes/anomaly-detection/","summary":"","title":"Anomaly Detection"},{"content":"","permalink":"https://flecart.github.io/notes/notazione-asintotica/","summary":"","title":"Notazione Asintotica"},{"content":"","permalink":"https://flecart.github.io/notes/massive-parallel-processing/","summary":"","title":"Massive Parallel Processing"},{"content":"","permalink":"https://flecart.github.io/notes/circuiti-sequenziali/","summary":"","title":"Circuiti Sequenziali"},{"content":"","permalink":"https://flecart.github.io/notes/active-learning/","summary":"","title":"Active Learning"},{"content":"","permalink":"https://flecart.github.io/notes/monte-carlo-methods/","summary":"","title":"Monte Carlo Methods"},{"content":"","permalink":"https://flecart.github.io/notes/estensioni-di-turing-e-altre-macchine/","summary":"","title":"Estensioni di Turing e altre macchine"},{"content":"","permalink":"https://flecart.github.io/notes/provably-approximately-correct-learning/","summary":"","title":"Provably Approximately Correct Learning"},{"content":"","permalink":"https://flecart.github.io/notes/dirichlet-processes/","summary":"","title":"Dirichlet Processes"},{"content":"","permalink":"https://flecart.github.io/notes/support-vector-machines/","summary":"","title":"Support Vector Machines"},{"content":"","permalink":"https://flecart.github.io/notes/beta-and-dirichlet-distributions/","summary":"","title":"Beta and Dirichlet Distributions"},{"content":"","permalink":"https://flecart.github.io/notes/markup/","summary":"","title":"Markup"},{"content":"","permalink":"https://flecart.github.io/notes/data-models-and-validation/","summary":"","title":"Data Models and Validation"},{"content":"","permalink":"https://flecart.github.io/notes/distributed-file-systems/","summary":"","title":"Distributed file systems"},{"content":"","permalink":"https://flecart.github.io/notes/counterfactual-invariance/","summary":"","title":"Counterfactual Invariance"},{"content":"","permalink":"https://flecart.github.io/notes/markov-processes/","summary":"","title":"Markov Processes"},{"content":"","permalink":"https://flecart.github.io/notes/graph-databases/","summary":"","title":"Graph Databases"},{"content":"","permalink":"https://flecart.github.io/notes/planning/","summary":"","title":"Planning"},{"content":"","permalink":"https://flecart.github.io/notes/document-stores/","summary":"","title":"Document Stores"},{"content":"","permalink":"https://flecart.github.io/notes/ensemble-methods/","summary":"","title":"Ensemble Methods"},{"content":"","permalink":"https://flecart.github.io/notes/linear-regression-methods/","summary":"","title":"Linear Regression methods"},{"content":"","permalink":"https://flecart.github.io/notes/fishers-linear-discriminant/","summary":"","title":"Fisher's Linear Discriminant"},{"content":"","permalink":"https://flecart.github.io/notes/kernel-methods/","summary":"","title":"Kernel Methods"},{"content":"","permalink":"https://flecart.github.io/notes/wide-column-storage/","summary":"","title":"Wide Column Storage"},{"content":"","permalink":"https://flecart.github.io/notes/apache-spark/","summary":"","title":"Apache Spark"},{"content":"","permalink":"https://flecart.github.io/notes/gaussian-processes/","summary":"","title":"Gaussian Processes"},{"content":"","permalink":"https://flecart.github.io/notes/cross-validation-and-model-selection/","summary":"","title":"Cross Validation and Model Selection"},{"content":"","permalink":"https://flecart.github.io/notes/rademacher-complexity/","summary":"","title":"Rademacher Complexity"},{"content":"","permalink":"https://flecart.github.io/notes/data-cubes/","summary":"","title":"Data Cubes"},{"content":"","permalink":"https://flecart.github.io/notes/introduction-to-big-data/","summary":"","title":"Introduction to Big Data"},{"content":"","permalink":"https://flecart.github.io/notes/querying-denormalized-data/","summary":"","title":"Querying Denormalized Data"},{"content":"","permalink":"https://flecart.github.io/notes/probabilistic-parsing/","summary":"","title":"Probabilistic Parsing"},{"content":"","permalink":"https://flecart.github.io/notes/kalman-filters/","summary":"","title":"Kalman Filters"},{"content":"","permalink":"https://flecart.github.io/notes/introduction-to-advanced-machine-learning/","summary":"","title":"Introduction to Advanced Machine Learning"},{"content":"","permalink":"https://flecart.github.io/notes/introduction-to-natural-language-processing/","summary":"","title":"Introduction to Natural Language Processing"},{"content":"","permalink":"https://flecart.github.io/notes/on-the-double-descent-phenomenon/","summary":"","title":"On The Double Descent Phenomenon"},{"content":"","permalink":"https://flecart.github.io/notes/campo-elettrico/","summary":"","title":"Campo elettrico"},{"content":"","permalink":"https://flecart.github.io/notes/leggi-di-ohm/","summary":"","title":"Leggi di Ohm"},{"content":"","permalink":"https://flecart.github.io/notes/potenziale-elettrostatico/","summary":"","title":"Potenziale Elettrostatico"},{"content":"","permalink":"https://flecart.github.io/notes/central-limit-theorem-and-law-of-large-numbers/","summary":"","title":"Central Limit Theorem and Law of Large Numbers"},{"content":"","permalink":"https://flecart.github.io/notes/equazioni-non-lineari/","summary":"","title":"Equazioni non lineari"},{"content":"","permalink":"https://flecart.github.io/notes/codifica-dei-caratteri/","summary":"","title":"Codifica dei caratteri"},{"content":"","permalink":"https://flecart.github.io/notes/normalizzazione-dei-database/","summary":"","title":"Normalizzazione dei database"},{"content":"","permalink":"https://flecart.github.io/notes/lagrange-multipliers/","summary":"","title":"Lagrange Multipliers"},{"content":"","permalink":"https://flecart.github.io/notes/limiti/","summary":"","title":"Limiti"},{"content":"","permalink":"https://flecart.github.io/notes/serie/","summary":"","title":"Serie"},{"content":"","permalink":"https://flecart.github.io/notes/banach-spaces/","summary":"","title":"Banach Spaces"},{"content":"","permalink":"https://flecart.github.io/notes/fatous-lemma/","summary":"","title":"Fatou's Lemma"},{"content":"","permalink":"https://flecart.github.io/notes/uniform-resource-identifier/","summary":"","title":"Uniform Resource Identifier"},{"content":"","permalink":"https://flecart.github.io/notes/maximum-entropy-principle/","summary":"","title":"Maximum Entropy Principle"},{"content":"","permalink":"https://flecart.github.io/notes/structured-query-language/","summary":"","title":"Structured Query Language"},{"content":"","permalink":"https://flecart.github.io/notes/derivate/","summary":"","title":"Derivate"},{"content":"","permalink":"https://flecart.github.io/notes/successioni/","summary":"","title":"Successioni"},{"content":"","permalink":"https://flecart.github.io/notes/optimal-minimax-facility-location/","summary":"","title":"Optimal Minimax Facility Location"},{"content":"","permalink":"https://flecart.github.io/notes/relational-algebra/","summary":"","title":"Relational Algebra"},{"content":"","permalink":"https://flecart.github.io/notes/bloom-filters/","summary":"","title":"Bloom Filters"},{"content":"","permalink":"https://flecart.github.io/notes/gestione-delle-risorse/","summary":"","title":"Gestione delle risorse"},{"content":"","permalink":"https://flecart.github.io/notes/merkle-trees/","summary":"","title":"Merkle Trees"},{"content":"","permalink":"https://flecart.github.io/notes/entropy/","summary":"","title":"Entropy"},{"content":"","permalink":"https://flecart.github.io/notes/tabelle-di-hash/","summary":"","title":"Tabelle di hash"},{"content":"","permalink":"https://flecart.github.io/notes/interactive-theorem-provers/","summary":"","title":"Interactive Theorem Provers"},{"content":"","permalink":"https://flecart.github.io/notes/spazi-di-probabilita/","summary":"","title":"Spazi di probabilita"},{"content":"","permalink":"https://flecart.github.io/notes/k-esimo-priority-q-dsu/","summary":"","title":"k-esimo priority-q DSU"},{"content":"","permalink":"https://flecart.github.io/notes/logica-meta-linguistica/","summary":"","title":"Logica meta-linguistica"},{"content":"","permalink":"https://flecart.github.io/notes/relazioni-fra-insiemi/","summary":"","title":"Relazioni fra insiemi"},{"content":"","permalink":"https://flecart.github.io/notes/poisson-processes/","summary":"","title":"Poisson processes"},{"content":"","permalink":"https://flecart.github.io/notes/index-b-trees-and-hashes/","summary":"","title":"Index, B-trees and hashes"},{"content":"","permalink":"https://flecart.github.io/notes/semafori/","summary":"","title":"Semafori"},{"content":"","permalink":"https://flecart.github.io/notes/object-detection-and-segmentation/","summary":"","title":"Object detection and Segmentation"},{"content":"","permalink":"https://flecart.github.io/notes/optimization-methods/","summary":"","title":"Optimization methods"},{"content":"","permalink":"https://flecart.github.io/notes/massimi-minimi-multi-variabile/","summary":"","title":"Massimi minimi multi-variabile"},{"content":"","permalink":"https://flecart.github.io/notes/autovalori-e-autovettori/","summary":"","title":"Autovalori e Autovettori"},{"content":"","permalink":"https://flecart.github.io/notes/html/","summary":"","title":"HTML"},{"content":"","permalink":"https://flecart.github.io/notes/css/","summary":"","title":"CSS"},{"content":"","permalink":"https://flecart.github.io/notes/metadati-web-e-web-semantico/","summary":"","title":"Metadati web e web semantico"},{"content":"","permalink":"https://flecart.github.io/notes/grafi/","summary":"","title":"Grafi"},{"content":"","permalink":"https://flecart.github.io/notes/fourier-series/","summary":"","title":"Fourier Series"},{"content":"","permalink":"https://flecart.github.io/notes/cauchy-schwarz-inequality/","summary":"","title":"Cauchy-Schwarz Inequality"},{"content":"","permalink":"https://flecart.github.io/notes/inverse-transform/","summary":"","title":"Inverse Transform"},{"content":"","permalink":"https://flecart.github.io/notes/alberi-di-decisione/","summary":"","title":"Alberi di decisione"},{"content":"","permalink":"https://flecart.github.io/notes/problemi-di-accoppiamento/","summary":"","title":"Problemi di accoppiamento"},{"content":"","permalink":"https://flecart.github.io/notes/reti-di-flusso/","summary":"","title":"Reti di flusso"},{"content":"","permalink":"https://flecart.github.io/notes/tarjan-e-mcmf/","summary":"","title":"Tarjan e MCMF"},{"content":"","permalink":"https://flecart.github.io/notes/asymptotic-equipartition-property/","summary":"","title":"Asymptotic Equipartition Property"},{"content":"","permalink":"https://flecart.github.io/notes/integrali/","summary":"","title":"Integrali"},{"content":"","permalink":"https://flecart.github.io/notes/grammatiche-regolari/","summary":"","title":"Grammatiche Regolari"},{"content":"","permalink":"https://flecart.github.io/notes/hopital-taylor-peano/","summary":"","title":"Hopital, Taylor, Peano"},{"content":"","permalink":"https://flecart.github.io/notes/accessibilit%C3%A0/","summary":"","title":"Accessibilità"},{"content":"","permalink":"https://flecart.github.io/notes/ambienti-di-sviluppo/","summary":"","title":"Ambienti di sviluppo"},{"content":"","permalink":"https://flecart.github.io/notes/cookie-e-autenticazione/","summary":"","title":"Cookie e autenticazione"},{"content":"","permalink":"https://flecart.github.io/notes/javascript/","summary":"","title":"Javascript"},{"content":"","permalink":"https://flecart.github.io/notes/storia-del-web/","summary":"","title":"Storia del web"},{"content":"","permalink":"https://flecart.github.io/notes/logistic-regression/","summary":"","title":"Logistic Regression"},{"content":"","permalink":"https://flecart.github.io/notes/on-intuitive-notions-of-probability/","summary":"","title":"On intuitive notions of probability"},{"content":"","permalink":"https://flecart.github.io/notes/algorithmic-probability/","summary":"","title":"Algorithmic Probability"},{"content":"","permalink":"https://flecart.github.io/notes/singular-value-decomposition/","summary":"","title":"Singular Value Decomposition"},{"content":"","permalink":"https://flecart.github.io/notes/minimi-quadrati/","summary":"","title":"Minimi quadrati"},{"content":"","permalink":"https://flecart.github.io/notes/descrizione-linguaggio/","summary":"","title":"Descrizione linguaggio"},{"content":"","permalink":"https://flecart.github.io/notes/introduction-to-databases/","summary":"","title":"Introduction to databases"},{"content":"","permalink":"https://flecart.github.io/notes/relational-model/","summary":"","title":"Relational Model"},{"content":"","permalink":"https://flecart.github.io/notes/programmazione-lineare/","summary":"","title":"Programmazione lineare"},{"content":"","permalink":"https://flecart.github.io/notes/norme-e-condizionamento/","summary":"","title":"Norme e Condizionamento"},{"content":"","permalink":"https://flecart.github.io/notes/tecniche-algoritmiche/","summary":"","title":"Tecniche algoritmiche"},{"content":"","permalink":"https://flecart.github.io/notes/advanced-sql/","summary":"","title":"Advanced SQL"},{"content":"","permalink":"https://flecart.github.io/notes/variabili-aleatorie/","summary":"","title":"Variabili aleatorie"},{"content":"","permalink":"https://flecart.github.io/notes/introduction-to-information-theory/","summary":"","title":"Introduction to Information Theory"},{"content":"","permalink":"https://flecart.github.io/notes/expressiveness-of-nn/","summary":"","title":"Expressiveness of NN"},{"content":"","permalink":"https://flecart.github.io/notes/topological-spaces/","summary":"","title":"Topological Spaces"},{"content":"","permalink":"https://flecart.github.io/notes/metric-spaces/","summary":"","title":"Metric Spaces"},{"content":"","permalink":"https://flecart.github.io/notes/time-and-space-complexity/","summary":"","title":"Time and Space Complexity"},{"content":"","permalink":"https://flecart.github.io/notes/connettivi-logici-correttezza-variabili/","summary":"","title":"Connettivi Logici, correttezza, variabili"},{"content":"","permalink":"https://flecart.github.io/notes/introduction-to-statistical-learning/","summary":"","title":"Introduction to statistical learning"},{"content":"","permalink":"https://flecart.github.io/notes/integrali-multi-dimensionali/","summary":"","title":"Integrali multi-dimensionali"},{"content":"","permalink":"https://flecart.github.io/notes/introduction-to-topology/","summary":"","title":"Introduction to Topology"},{"content":"","permalink":"https://flecart.github.io/notes/vapnik-chervonenkis-dimension/","summary":"","title":"Vapnik-Chervonenkis Dimension"},{"content":"","permalink":"https://flecart.github.io/notes/antenne/","summary":"","title":"Antenne"},{"content":"","permalink":"https://flecart.github.io/notes/architettura-e-livelli-1-2/","summary":"","title":"Architettura e livelli 1, 2"},{"content":"","permalink":"https://flecart.github.io/notes/cammini/","summary":"","title":"Cammini"},{"content":"","permalink":"https://flecart.github.io/notes/deduzione-naturale/","summary":"","title":"Deduzione naturale"},{"content":"","permalink":"https://flecart.github.io/notes/fisica-del-wireless/","summary":"","title":"Fisica del Wireless"},{"content":"","permalink":"https://flecart.github.io/notes/introduzione-a-reti/","summary":"","title":"Introduzione a reti"},{"content":"","permalink":"https://flecart.github.io/notes/livello-di-rete/","summary":"","title":"Livello di Rete"},{"content":"","permalink":"https://flecart.github.io/notes/livello-di-trasporto/","summary":"","title":"Livello di trasporto"},{"content":"","permalink":"https://flecart.github.io/notes/mac-wifi/","summary":"","title":"Mac Wifi"},{"content":"","permalink":"https://flecart.github.io/notes/modulazione-wireless/","summary":"","title":"Modulazione wireless"},{"content":"","permalink":"https://flecart.github.io/notes/network-address-translation/","summary":"","title":"Network Address Translation"},{"content":"","permalink":"https://flecart.github.io/notes/tecnologia-wireless/","summary":"","title":"Tecnologia Wireless"},{"content":"","permalink":"https://flecart.github.io/notes/vlan/","summary":"","title":"VLAN"},{"content":"","permalink":"https://flecart.github.io/notes/wifi-802-11/","summary":"","title":"Wifi 802-11"},{"content":"","permalink":"https://flecart.github.io/notes/block-ciphers/","summary":"","title":"Block Ciphers"},{"content":"","permalink":"https://flecart.github.io/notes/key-exchange-protocols/","summary":"","title":"Key Exchange protocols"},{"content":"","permalink":"https://flecart.github.io/notes/memory-corruption/","summary":"","title":"Memory Corruption"},{"content":"","permalink":"https://flecart.github.io/notes/otp-and-stream-ciphers/","summary":"","title":"OTP and Stream Ciphers"},{"content":"","permalink":"https://flecart.github.io/notes/the-tor-protocol/","summary":"","title":"The Tor protocol"},{"content":"","permalink":"https://flecart.github.io/notes/user-authentication/","summary":"","title":"User authentication"},{"content":"","permalink":"https://flecart.github.io/notes/algebra-logica/","summary":"","title":"Algebra Logica"},{"content":"","permalink":"https://flecart.github.io/notes/introduzione-a-logica/","summary":"","title":"Introduzione a Logica"},{"content":"","permalink":"https://flecart.github.io/notes/introduzione-algoritmi/","summary":"","title":"Introduzione algoritmi"},{"content":"","permalink":"https://flecart.github.io/notes/livello-os/","summary":"","title":"Livello OS"},{"content":"","permalink":"https://flecart.github.io/notes/porte-logiche/","summary":"","title":"Porte Logiche"},{"content":"","permalink":"https://flecart.github.io/notes/rappresentazione-delle-informazioni/","summary":"","title":"Rappresentazione delle informazioni"},{"content":"","permalink":"https://flecart.github.io/notes/relazioni-di-ricorrenza/","summary":"","title":"Relazioni di Ricorrenza"},{"content":"","permalink":"https://flecart.github.io/notes/semantica-intuizionista/","summary":"","title":"Semantica intuizionista"},{"content":"","permalink":"https://flecart.github.io/notes/sintassi-e-ri-strutturali/","summary":"","title":"Sintassi e RI strutturali"},{"content":"","permalink":"https://flecart.github.io/notes/strutture-di-dati-elementari/","summary":"","title":"Strutture di dati elementari"},{"content":"","permalink":"https://flecart.github.io/notes/teoria-assiomatica-degli-insiemi/","summary":"","title":"Teoria assiomatica degli insiemi"},{"content":"","permalink":"https://flecart.github.io/notes/verita-teorie-modelli-connotazione-denotazione/","summary":"","title":"Verita, Teorie, modelli, connotazione, denotazione"},{"content":"","permalink":"https://flecart.github.io/notes/alberi-bst-e-avl/","summary":"","title":"Alberi BST e AVL"},{"content":"","permalink":"https://flecart.github.io/notes/logica-del-primo-ordine/","summary":"","title":"Logica del Primo ordine"},{"content":"","permalink":"https://flecart.github.io/notes/gruppi-normali/","summary":"","title":"Gruppi Normali"},{"content":"","permalink":"https://flecart.github.io/notes/teorema-di-lagrange/","summary":"","title":"Teorema di Lagrange"},{"content":"","permalink":"https://flecart.github.io/notes/consensus-protocols/","summary":"","title":"Consensus protocols"},{"content":"","permalink":"https://flecart.github.io/notes/filesystem/","summary":"","title":"Filesystem"},{"content":"","permalink":"https://flecart.github.io/notes/goals-of-distributed-systems/","summary":"","title":"Goals of Distributed systems"},{"content":"","permalink":"https://flecart.github.io/notes/introduzione-a-blockchain/","summary":"","title":"Introduzione a blockchain"},{"content":"","permalink":"https://flecart.github.io/notes/monitor/","summary":"","title":"Monitor"},{"content":"","permalink":"https://flecart.github.io/notes/programmi-concorrenti/","summary":"","title":"Programmi Concorrenti"},{"content":"","permalink":"https://flecart.github.io/notes/syncronous-model/","summary":"","title":"Syncronous model"},{"content":"","permalink":"https://flecart.github.io/notes/replication-and-consistency/","summary":"","title":"Replication and consistency"},{"content":"","permalink":"https://flecart.github.io/notes/analisi-di-convessit%C3%A0/","summary":"","title":"Analisi di Convessità"},{"content":"","permalink":"https://flecart.github.io/notes/metodi-di-discesa/","summary":"","title":"Metodi di Discesa"},{"content":"","permalink":"https://flecart.github.io/notes/calcolo-differenziale/","summary":"","title":"Calcolo differenziale"},{"content":"","permalink":"https://flecart.github.io/notes/inner-product-spaces/","summary":"","title":"Inner product spaces"},{"content":"","permalink":"https://flecart.github.io/notes/analisi-multi-variabile/","summary":"","title":"Analisi multi-variabile"},{"content":"","permalink":"https://flecart.github.io/notes/duality-theory/","summary":"","title":"Duality Theory"},{"content":"","permalink":"https://flecart.github.io/notes/stirlings-approximation/","summary":"","title":"Stirling's Approximation"},{"content":"","permalink":"https://flecart.github.io/notes/insiemi-numerici/","summary":"","title":"Insiemi numerici"},{"content":"","permalink":"https://flecart.github.io/notes/r-e-intervalli/","summary":"","title":"R e Intervalli"},{"content":"","permalink":"https://flecart.github.io/notes/teoremi-base-analisi/","summary":"","title":"Teoremi Base Analisi"},{"content":"","permalink":"https://flecart.github.io/notes/introduzione-a-ottimizzazione-combinatoria/","summary":"","title":"Introduzione a ottimizzazione Combinatoria"},{"content":"","permalink":"https://flecart.github.io/notes/modelizzazione/","summary":"","title":"Modelizzazione"},{"content":"","permalink":"https://flecart.github.io/notes/simplesso-e-bb/","summary":"","title":"Simplesso e B\u0026B"},{"content":"","permalink":"https://flecart.github.io/notes/geometrie-di-spire/","summary":"","title":"Geometrie di spire"},{"content":"","permalink":"https://flecart.github.io/notes/applicazioni-lineari/","summary":"","title":"Applicazioni lineari"},{"content":"","permalink":"https://flecart.github.io/notes/base-e-dimensione/","summary":"","title":"Base e dimensione"},{"content":"","permalink":"https://flecart.github.io/notes/cambio-di-base/","summary":"","title":"Cambio di Base"},{"content":"","permalink":"https://flecart.github.io/notes/sistemi-lineari-e-determinanti/","summary":"","title":"Sistemi Lineari e determinanti"},{"content":"","permalink":"https://flecart.github.io/notes/introduzione-algebra/","summary":"","title":"Introduzione algebra"},{"content":"","permalink":"https://flecart.github.io/notes/algebra-modulare/","summary":"","title":"Algebra modulare"},{"content":"","permalink":"https://flecart.github.io/notes/measure-theory/","summary":"","title":"Measure Theory"},{"content":"","permalink":"https://flecart.github.io/notes/gruppi/","summary":"","title":"Gruppi"},{"content":"","permalink":"https://flecart.github.io/notes/gruppi-ciclici-e-permutazioni/","summary":"","title":"Gruppi ciclici e permutazioni"},{"content":"","permalink":"https://flecart.github.io/notes/cook-levin-and-savitch/","summary":"","title":"Cook-Levin and Savitch"},{"content":"","permalink":"https://flecart.github.io/notes/la-macchina-di-turing/","summary":"","title":"La macchina di Turing"},{"content":"","permalink":"https://flecart.github.io/notes/halting-theorem-and-reducibility/","summary":"","title":"Halting Theorem and Reducibility"},{"content":"","permalink":"https://flecart.github.io/notes/common-problems-in-theoretical-cs/","summary":"","title":"Common problems in Theoretical CS"},{"content":"","permalink":"https://flecart.github.io/notes/teorema-di-rice/","summary":"","title":"Teorema di Rice"},{"content":"","permalink":"https://flecart.github.io/notes/complexity-hierarchies/","summary":"","title":"Complexity Hierarchies"},{"content":"","permalink":"https://flecart.github.io/notes/fn-ordine-superiore/","summary":"","title":"Fn Ordine superiore"},{"content":"","permalink":"https://flecart.github.io/notes/probabilistic-turing-machines/","summary":"","title":"Probabilistic Turing Machines"},{"content":"","permalink":"https://flecart.github.io/notes/compression-algorithms/","summary":"","title":"Compression Algorithms"},{"content":"","permalink":"https://flecart.github.io/notes/bottom-up-parser-lr0/","summary":"","title":"Bottom-up Parser LR(0)"},{"content":"","permalink":"https://flecart.github.io/notes/bottom-up-parser-lr1/","summary":"","title":"Bottom-up Parser LR(1)"},{"content":"","permalink":"https://flecart.github.io/notes/explainability-of-cnn/","summary":"","title":"Explainability of CNN"},{"content":"","permalink":"https://flecart.github.io/notes/fondamenti-teorica/","summary":"","title":"Fondamenti teorica"},{"content":"","permalink":"https://flecart.github.io/notes/garbage-collection/","summary":"","title":"Garbage Collection"},{"content":"","permalink":"https://flecart.github.io/notes/interpolazione/","summary":"","title":"Interpolazione"},{"content":"","permalink":"https://flecart.github.io/notes/isomorfismi/","summary":"","title":"Isomorfismi"},{"content":"","permalink":"https://flecart.github.io/notes/object-detection/","summary":"","title":"Object Detection"},{"content":"","permalink":"https://flecart.github.io/notes/probabilita-condizionata-e-indipendenza/","summary":"","title":"Probabilita condizionata e indipendenza"},{"content":"","permalink":"https://flecart.github.io/notes/gestione-della-memoria/","summary":"","title":"Gestione della memoria"},{"content":"","permalink":"https://flecart.github.io/notes/algebra-dei-tipi/","summary":"","title":"Algebra dei tipi"},{"content":"","permalink":"https://flecart.github.io/notes/deblur-di-immagini/","summary":"","title":"Deblur di immagini"},{"content":"","permalink":"https://flecart.github.io/notes/gestione-delle-eccezioni/","summary":"","title":"Gestione delle eccezioni"},{"content":"","permalink":"https://flecart.github.io/notes/introduzione-alla-probabilita/","summary":"","title":"Introduzione alla probabilita"},{"content":"","permalink":"https://flecart.github.io/notes/calcolo-di-numeri-finiti/","summary":"","title":"Calcolo di numeri finiti"},{"content":"","permalink":"https://flecart.github.io/notes/model-of-analogies/","summary":"","title":"Model of Analogies"},{"content":"","permalink":"https://flecart.github.io/notes/introduction-to-algorithmic-information-and-complexity/","summary":"","title":"Introduction to Algorithmic Information and Complexity"},{"content":"","permalink":"https://flecart.github.io/notes/randomness/","summary":"","title":"Randomness"},{"content":"","permalink":"https://flecart.github.io/notes/divergenza-e-circuitazione/","summary":"","title":"Divergenza e Circuitazione"},{"content":"","permalink":"https://flecart.github.io/notes/design-del-database/","summary":"","title":"Design del database"},{"content":"","permalink":"https://flecart.github.io/notes/the-rlhf-pipeline/","summary":"","title":"The RLHF pipeline"},{"content":"","permalink":"https://flecart.github.io/notes/tokenization/","summary":"","title":"Tokenization"},{"content":"","permalink":"https://flecart.github.io/notes/database-logical-design/","summary":"","title":"Database logical design"},{"content":"","permalink":"https://flecart.github.io/notes/corrente-elettrica/","summary":"","title":"Corrente Elettrica"},{"content":"","permalink":"https://flecart.github.io/notes/the-database-management-system/","summary":"","title":"The Database Management System"},{"content":"","permalink":"https://flecart.github.io/notes/condensatori-con-dielettrici/","summary":"","title":"Condensatori con dielettrici"},{"content":"","permalink":"https://flecart.github.io/notes/dipolo-elettrico/","summary":"","title":"Dipolo elettrico"},{"content":"","permalink":"https://flecart.github.io/notes/spettrometri-di-massa/","summary":"","title":"Spettrometri di massa"},{"content":"","permalink":"https://flecart.github.io/notes/onde-elettromagnetiche/","summary":"","title":"Onde elettromagnetiche"},{"content":"","permalink":"https://flecart.github.io/notes/vettore-potenziale/","summary":"","title":"Vettore potenziale"},{"content":"","permalink":"https://flecart.github.io/notes/unified-modeling-language/","summary":"","title":"Unified Modeling Language"},{"content":"","permalink":"https://flecart.github.io/notes/magnetismo-nella-materia/","summary":"","title":"Magnetismo nella materia"},{"content":"","permalink":"https://flecart.github.io/notes/modelli-lineari-di-sviluppo/","summary":"","title":"Modelli Lineari di sviluppo"},{"content":"","permalink":"https://flecart.github.io/notes/scrum-method/","summary":"","title":"Scrum Method"},{"content":"","permalink":"https://flecart.github.io/notes/modelli-agile/","summary":"","title":"Modelli AGILE"},{"content":"","permalink":"https://flecart.github.io/notes/la-qualit%C3%A0-del-software/","summary":"","title":"La qualità del software"},{"content":"","permalink":"https://flecart.github.io/notes/general-swe-principles/","summary":"","title":"General SWE principles"},{"content":"","permalink":"https://flecart.github.io/notes/introduction-to-computational-statistics/","summary":"","title":"Introduction to computational statistics"},{"content":"","permalink":"https://flecart.github.io/notes/requisiti-e-backlog-del-software/","summary":"","title":"Requisiti e backlog del software"},{"content":"","permalink":"https://flecart.github.io/notes/scelta-del-po/","summary":"","title":"Scelta del PO"},{"content":"","permalink":"https://flecart.github.io/notes/sezioni-critiche/","summary":"","title":"Sezioni Critiche"},{"content":"","permalink":"https://flecart.github.io/notes/system-design/","summary":"","title":"System Design"},{"content":"","permalink":"https://flecart.github.io/notes/conduttori-elettrici/","summary":"","title":"Conduttori elettrici"},{"content":"","permalink":"https://flecart.github.io/notes/ampere-e-faraday/","summary":"","title":"Ampere e Faraday"},{"content":"","permalink":"https://flecart.github.io/notes/legge-di-coulomb/","summary":"","title":"Legge di Coulomb"},{"content":"","permalink":"https://flecart.github.io/notes/legge-di-gauss/","summary":"","title":"Legge di Gauss"},{"content":"","permalink":"https://flecart.github.io/notes/magnetismo/","summary":"","title":"Magnetismo"},{"content":"","permalink":"https://flecart.github.io/notes/accept-reject-algorithm/","summary":"","title":"Accept Reject algorithm"},{"content":"","permalink":"https://flecart.github.io/notes/kolmogorov-complexity/","summary":"","title":"Kolmogorov complexity"},{"content":"","permalink":"https://flecart.github.io/notes/project-management/","summary":"","title":"Project Management"},{"content":"Introduction When a human first learns to program, the first concepts typically encountered are control flow, statements, loops, then functions, recursive calls, types, classes. If the person continues with this journey, an encounter with ideas like design patterns, architectural patterns, and software engineering practices are quite likely. In one way or another, these abstractions enable its general user to write portable software, without ever considering the microarchitecture that actually runs the compiled binaries beneath all the these abstractions. This is Computer Science\u0026rsquo;s fundamental magic: abstraction and implementation. However, sometimes abstractions are not so cleanly separated; they interact in complex manners that go beyond just exposing interfaces and implementing these interfaces, they actually influence each other in complex manners. As every complex system, they may display some strange feedback loops (Hofstadter 2007). But this is another story.\nIn this article, we will focus on practical ideas of implementation of fast software. This goal is not achievable by staying at some precise level of abstraction, but needs to consider the entire software stack, from compiler to cache systems to hardware optimizations of the specific microarchitecture that runs that software. We will focus specifically on single core optimizations of the software.\nThe next sections will be divided as follows: in we will discuss historical progress in writing fast software, including the introduction of super-scalar architectures BLAS/LAPACK (Angerson et al. 1990), FFTW (Frigo \u0026amp; Johnson 1998), vectorization. Then we will move on with a discussion of the main established techniques of optimization possibilities that new hardware is enabling. Finally, we end with clear examples and experiments on how such written software is evidently faster in running in modern architectures.\nMost of this blog post has been a result of work following this paper (Huang et al. 2025) on practical optimization on specific CPU architectures of Clifford Kernels (generalization of imaginary kernels) useful for life sciences.\nMotivation Every computer scientist knows about compilers, cache mechanisms and some CPU architecture optimizations. However, few know about the optimizations that super-scalar architectures and later vectorization instructions have introduced in the last 30-40 years.\nSuper-scalar architectures have inherent form of parallelism; they execute more than one instruction per cycle using different parallel execution ports. Refer to the Intel i7 Skylake architecture for an example. Two things are important to notice here:\nEach architecture has usually more integer operation ports than floating point operations, which means flops are usually the bottleneck of the computation The upper limit of flops per cycle is easy to compute, and if you know the frequency of the core you can compute the flops per second. For example, in the figure we have two floating operation ports, each can execute one fused add-multiply operation per cycle, meaning four flops per cycle. If your processor runs at 4.8 Ghz, then your overall maximum theoretical upper bound is 19.2 Gigaflops per second. This value is usually never reachable due to data dependency patterns in the computation or memory transfer bottlenecks. Example of Intel Skylake microarchitecture. We can observe the memory hierarchy, with latency and throughput counted as number of cycles needed to fetch the request, and number of doubles that can be stored or retrieved in a single instruction cycle. On the left we see the different execution ports. On the bottom left, we observe the instruction decoder and automatic out-of-order execution hardware engine (instruction pool). Slide from ASL ETH 2024 course. See here.\nCompilers have limitations. Compilers are not able to optimize natively for these architectures. One requirement for compilers is the correctness of the compilation. Sadly, floating point operations do not possess associativity as one of their property. For example, consider the the following case:\n#include \u0026lt;iostream\u0026gt; int main() { double a = 1e16; double b = -1e16; double c = 1.0; double res1 = (a + b) + c; double res2 = a + (b + c); std::cout \u0026lt;\u0026lt; \u0026#34;(a + b) + c = \u0026#34; \u0026lt;\u0026lt; res1 \u0026lt;\u0026lt; std::endl; // 0 std::cout \u0026lt;\u0026lt; \u0026#34;a + (b + c) = \u0026#34; \u0026lt;\u0026lt; res2 \u0026lt;\u0026lt; std::endl; // 1 return 0; } Due to possible cases of overflow or underflow, floating-point operators adopt different approximation strategies that ultimately lead to different results. As we will see, this property is an important one.\nHistorical Results Modern processor architectures commonly support the parallel execution of independent instructions through multiple execution ports, a design principle known as superscalar execution (Johnson 1989). However, effective exploitation of these hardware capabilities requires software that is explicitly written or optimized to take advantage of instruction-level parallelism (ILP), register renaming, and out-of-order execution.\nEstablished linear algebra libraries such as LAPACK and BLAS have historically served as high-performance, portable foundations for numerical computations across platforms (Angerson et al. 1990). The ATLAS project further advanced this line of work by introducing automated empirical tuning techniques, enabling the generation of optimized kernels for different hardware configurations (Whaley \u0026amp; Dongarra 1998).\nDespite their effectiveness, these libraries primarily target general matrix and vector operations, and may not yield optimal performance for more specialized computational workloads. This limitation has motivated the development of domain-specific software frameworks such as FFTW, which exploits the structure of the fast Fourier transform to achieve high efficiency on a wide range of platforms (Frigo \u0026amp; Johnson 2005, Frigo \u0026amp; Johnson 1998). Note that here it is the mathematical structure itself that enabled certain kinds of optimization in its relative hardware. It\u0026rsquo;s nice to observe such interplay between mathematical structures, software compositions and hardware architectures within this subfield of computer science.\nEvery relevant fast numerical software is somewhat inspired to these libraries. Modern PyTorch (Paszke et al. 2019), numpy library, use LAPACK and BLAS cores underneath to have a performance close to the theoretical upper limit.\nIn this post, we will mainly explore the optimizations that were introduced within the LAPACK libraries.\nOptimization Strategies In this section, we will explore established optimization techniques for single-core superscalar architectures. We will be exploring established techniques, nevertheless, they have proved to be valid after decades of architecture design. For example, some of the recent optimizations on GPU architectures have clear and recognizable ideas taken from these pioneering works (Dao et al. 2022). Here we mainly focus on matrix-matrix multiplication.\nInstruction Level Parallelism If a program is written in a certain manner where some data dependencies are present, we cannot leverage full throughput of the processor. However, if we rewrite the computation to include both cycle unrolling and different accumulators, we can exploit the underlying hardware optimizations and reach a far better performance. As you can see with the examples below, we can have a 2x performance improvement with just this little trick. Simple but effective technique.\nMini Matrix-Matrix Multiplication Examples of forms of computation. (a) we see classical matrix-matrix multiplication: for each row and column we have a single value in C. Potentially for big matrices every element in B needs to be loaded again and again, creating memory bottlenecks. (b) blocked matrix matrix multiplication, where we better exploit cache locality to operate on the matrices. (c) Outer product for better ILP, only applied to very small matrices in the inner loop.\nTo understand this section, you will need a clear bachelor-level understanding of how CPU cache systems work. Another personally surprising reason why other more efficient algorithms for MMM multiplication are not actually faster than a good implementation of the naïve algorithm is due to cache-friendlyness limitations as we will see.\nWhen optimizing matrix-matrix multiplication (MMM) for single-core execution, a major bottleneck emerges not in arithmetic but in data movement, particularly cache misses. To understand and mitigate this, we analyze the cache behavior of naïve vs. blocked matrix multiplication. This section will guide you through that analysis and show how a seemingly simple refactoring, blocking, dramatically improves performance. Blocking is the idea of dividing the whole matrix-matrix multiplication in many smaller cache-friendly block-level matrix multiplications.\nNow, we consider the standard triple-loop implementation of matrix multiplication. We make the following assumptions:\nall matrices are stored in row-major order All the matrices are square matrices of size $n \\times n$: for (int i = 0; i \u0026lt; n; ++i) for (int j = 0; j \u0026lt; n; ++j) for (int k = 0; k \u0026lt; n; ++k) C[i][j] += A[i][k] * B[k][j]; In contrast, a blocked-matrix multiplication of block size $b \u003c n$ and $b$ divides $n$ is:\nfor (int ii = 0; ii \u0026lt; n; ii += b) for (int jj = 0; jj \u0026lt; n; jj += b) for (int kk = 0; kk \u0026lt; n; kk += b) for (int i = ii; i \u0026lt; ii + b; ++i) for (int j = jj; j \u0026lt; jj + b; ++j) for (int k = kk; k \u0026lt; kk + b; ++k) C[i][j] += A[i][k] * B[k][j]; As we will observe this version better exploits a cache\u0026rsquo;s spatial locality. %% we try to put some images to explain why this is better, needs one image per section I think. %%\nCache Miss Analysis: Naive vs Blocked In the following analysis, we will only consider cache size, but in real systems (Angerson et al. 1990 ), also TLB page size and other cache configurations like associativity, size, and line size, are kept into consideration.\nIn the naïve implementation, we repeatedly access entire rows of $A$, columns of $B$, and write single entries of $C$. Due to row-major layout, accessing columns of B is especially harmful because it causes non-contiguous memory accesses. We we assume a single row of $B$ is big enough that it doesn\u0026rsquo;t fit into the cache, this means we will load a whole line block for every access in $B$.\nEach access to a new element in a row or column causes a cache miss unless it’s already cached. We assume here a common cache block of 8 doubles and cache size of $\\gamma \\ll n$, we estimate:\nAccessing a row of $A$ causes $n / 8$ misses. Accessing a column of $B$ (non-contiguous) causes $n^{2}$ misses. So each entry computation causes about $9n / 8$ misses. Total number of entries computed: $n^{2}$. Total cache misses: $9n^{3} / 8$. Now compare this with blocked matrix multiplication, where the matrix is split into sub-blocks of size $b \\times b$. If we pick $b$ such that the entire sub-multiplication of blocks of size $b\\times b$ fits in the cache, we can observe far fewer losses. Let $\\gamma$ be the cache size as before. We require:\n$$ \\begin{align*} 3b^{2} \u0026\\leq \\gamma \u0026 \\text{ One block each of A, B, C} \\\\ \\implies \u0026b = \\sqrt{ \\frac{\\gamma}{3} } \\end{align*} $$$$ (n / b)^{2} \\cdot nb / 4 = n^{3} / 4b $$We can observe the number of cache misses is far lower compared to the previous case. The bigger the $b$ is better here.\nMicro Matrix-Matrix Multiplication After applying blocking to make our computation cache-friendly, we can push optimization even further by going to the register level. The idea is to trade faster and more parallelized register operations with a little higher number of operations.\nAnalysis of Loop Reordering. In a standard i-j-k ordering with indices set as #Mini Matrix-Matrix Multiplication, for each fixed (i,j) pair, we\u0026rsquo;re essentially computing a dot product: just 2n operations with $n$ data dependent additions. This has a lower instruction-level parallelism and lower number of operations compared to the next version:\nIf we flip to k-i-j ordering, we can observe the following. For each fixed $k$ we\u0026rsquo;re now performing a rank-1 update: taking an entire column from matrix A and an entire row from matrix B, and doing an outer product that updates the entire C block. This gives us $2n^{2}$ operations that are almost completely independent, correctly leveraging both instruction level parallelism and faster access with Cache blocks.\nWhat makes micro-MMMs so effective is that they exploit a balance between cache locality and instruction-level parallelism. The blocks are small enough that data stays in registers, but the computation pattern generates enough independent operations to keep all execution ports busy.\nLibraries like ATLAS, OpenBLAS, and Intel MKL all use variations of this technique. They\u0026rsquo;ll typically have hand-optimized micro-kernels for different tile sizes (2×2, 4×4, 6×8, etc.) depending on the target architecture\u0026rsquo;s register file size and execution port configuration.\nOther Operations Up until now, we covered some classical but general techniques for modern CPU architectures in the matrix-matrix setting. Sometimes we can take other considerations into account and further optimize by taking these into account.\nStrength Reduction. See the wikipedia page. Here we will just give the general idea. If we look at Agner Fog\u0026rsquo;s tables, we observe that most of the division operations are slow in terms of cycles with respect to multiplication. This motivates substituting some complex operations with equivalent or similar precision operations. With a similar idea, sometimes it is useful to cache or pre-compute intermediary results. Most of the times, it is difficult to identify when you can optimize with this tricks. Lots of the optimizations come from experience, or just a lot of trial and error.\nVectorization Operations Once we’ve optimized for instruction-level parallelism and cache locality, the next powerful lever is data-level parallelism, also known as vectorization.\nVectorization is the process of transforming scalar operations (working on one data element at a time) into SIMD (Single Instruction, Multiple Data) instructions that operate on multiple data elements in parallel. On x86 architectures, these are realized via AVX (Advanced Vector Extensions), SSE, or the newer AVX-512 instruction sets.\nA simple example: instead of computing\nfor (int i = 0; i \u0026lt; 4; ++i) C[i] = A[i] + B[i]; the compiler or programmer can generate a single SIMD instruction that does all four additions at once—assuming A, B, and C are properly aligned and stored contiguously. This is possible thanks to SIMD registers implemented in every modern architecture:\nAVX: 256-bit registers → 4 doubles or 8 floats AVX-512: 512-bit registers → 8 doubles or 16 floats Using these, you can execute operations like fused multiply-add (FMA) on multiple elements at once, within a single cycle. This gives a multiplicative factor to throughput, but only if your data layout and dependencies allow it.\n(a) a visual representation of AVX-style SIMD operations. Each SIMD register packs multiple doubles, and SIMD instructions operate element-wise on all packed values, executed as a single operation. (b) normal operations in for loop (4 times more operations)\nHand-Vectorization: Intrinsics and Assembly In many occasions, auto-vectorization, is not able to rewrite the computation in a manner that is compatible to vectorization: examples like loading from different parts of the memory, shuffling operations are beyond current compiler abilities. For this reason, if we already know the target architecture of our code, we can have some benefit by writing intrinsics: these are C-like wrappers for low-level SIMD instructions. For example, using AVX intrinsics:\n#include \u0026lt;immintrin.h\u0026gt; __m256d a = _mm256_load_pd(\u0026amp;A[i]); __m256d b = _mm256_load_pd(\u0026amp;B[i]); __m256d c = _mm256_add_pd(a, b); _mm256_store_pd(\u0026amp;C[i], c); You now manually pack, compute, and unpack using 256-bit wide registers. This has the highest performance gain in terms of throughput when the computation is compute bound, but it suffers from portability since this code runs only on machines with AVX intrinsics (mostly intel machines). In many cases, when data movement is the bottleneck, having these instructions would not even have any significant gain.\nThe next and final section will show a real example of these techniques applied in practice.\nExperiments We proceed with showing concrete results of the above optimization methods for two cases: (1) simple sum with Instruction-Level Parallelism, and (2) common matrix-matrix multiplication operations.\nWe run the experiments on an Intel Core i7-1280P, based on the Alder Lake architecture, with a base frequency of:\nPerformance cores: 1.8 GHz Efficient cores: 1.3 GHz This architecture features two ports for floating-point operations, and typical multiplication and addition instructions take four clock cycles.\nL1 Cache (Data): 48 KB (Golden Cove) L2 Cache: 1.25 MB (Golden Cove) L3 Cache: 24 MB total (3 MB × 8 Gracemont cores) Experiment code is released in the github page. We compile our code using GCC 13.3.0 with the following flags -O3 -march=native -ffast-math -fno-tree-vectorize -mfma -mavx2 We deactivate turboboost on the computer by setting the flag in /sys/devices/system/cpu/intel_pstate/no_turbo to 1 in the Linux System. The results are an average over 100 runs per function assuming cold cache, i.e. the values have not been loaded before into the CPU caches.\nResults We report speedups compared to the naïve baseline version. We observe a simple vectorization is able to provide the greatest speedup. Even simple ILP changes are enough to double the original performance. If we analyze the flops/cycle, we can observe the current version is far from optimal performance, but it is enough to showcase how simple methods can greatly enhance performance with these computations.\nInstruction-Level Parallelism. We observe that if we just unroll the loop, it is difficult to get any important speedup. Only if we add accumulators, we get more of the benefits present due to the intrinsic hardware parallelization primitives.\nMicro and Mini Matrix-Matrix-Multiplication. Remember, these techniques are useful to exploit better cache friendliness for the architecture, they become important when the matrix size grows, and whole matrices don\u0026rsquo;t fit into the caches anymore. If they do fit, these techniques lose their winning point. With the current architecture and cache size above, the working set (set of floating point numbers that are often re-used, sharing time-locality) of the matrix matrix multiplication is mostly the entire $B$ matrix, one row of $A$ and a cache line for $C$ for the standard matrix matrix multiplication: we approximate the needed size to be a single matrix, then we have that with $N \u003e \\sqrt{ \\frac{48000}{4} } \\approx 109$ the matrix does not fit into the L1 cache anymore (we divided by 4 since each floating point is 4 bytes) and starting from $N \u003e 559$ it does not fit into the L2 cache anymore.\nOn the slowdowns. We further notice that in the cold cache scenario, the small values for matrix size lose some of its time. Another slowdown that we observe and that we have not covered in this post is due to TLB cache misses for virtual paging, which is particularly relevant especially for power of two. You can observe that $512 \\cdot 4$ is exactly half of page size in common Linux systems.\nConclusion In this post, we covered the most common and established optimization techniques for single core CPU optimization. In particular, we covered important concepts like instruction-level parallelism, cache analysis and examples of cache friendly reformulation of the computations and showed how they can improve the performance of software in practice, delivering real speedups. We briefly touched over existing optimized software, like LAPACK/BLAS (Angerson et al. 1990) and frameworks like PyTorch that use these libraries underneath. Out in the wild, there are far more optimization techniques designed for some specific kinds of computation (Frigo \u0026amp; Johnson 1998, Dao et al. 2022), sparse computations, or GPU operations.\nCitation If you want to reference this work cite it as:\nHuang, Xuanqiang Angelo \u0026ldquo;Optimizing Single-Core CPU software.\u0026rdquo; X. Angelo Huang\u0026rsquo;s Blog (Oct 2025). https://flecart.github.io/posts/2025-10-21-optimizing-single-core-cpu-software/\nOr:\n@article{huang2025optimizingsingle, title = \u0026#34;Optimizing Single-Core CPU software.\u0026#34;, author = \u0026#34;Huang, Xuanqiang Angelo\u0026#34;, journal = \u0026#34;flecart.github.io\u0026#34;, year = \u0026#34;2025\u0026#34;, month = \u0026#34;Oct\u0026#34;, url = \u0026#34;flecart.github.io/posts/2025-10-21-optimizing-single-core-cpu-software/\u0026#34; } And take a look at the related paper in Huang et al. 2025.\nReferences [1] Angerson et al. “LAPACK: A Portable Linear Algebra Library for High-Performance Computers” Supercomputing '90:Proceedings of the 1990 ACM/IEEE Conference on Supercomputing 1990 [2] Frigo \u0026 Johnson “FFTW: An Adaptive Software Architecture for the FFT” IEEE 1998 [3] Hofstadter “I Am a Strange Loop” Basic Books 2007 [4] Huang et al. “Single-Core Superscalar Optimization of Clifford Neural Layers” arXiv preprint arXiv:2510.03290 2025 [5] Whaley \u0026 Dongarra “Automatically Tuned Linear Algebra Software” IEEE 1998 [6] Frigo \u0026 Johnson “The Design and Implementation of FFTW3” Proceedings of the IEEE Vol. 93(2), pp. 216--231 2005 [7] Dao et al. “FLASHATTENTION: Fast and Memory-Efficient Exact Attention with IO-awareness” Curran Associates Inc. 2022 [8] Johnson “Super-Scalar Processor Design” 1989 [9] Paszke et al. “PyTorch: An Imperative Style, High-Performance Deep Learning Library” None 2019 ","permalink":"https://flecart.github.io/posts/2025-10-21-optimizing-single-core-cpu-software/","summary":"Fully exploiting the abilities of modern hardware is hard. Commonly written software does not fully exploit all of the underlying hardware optimization abilities, and often needs specialized software to achieve better utilization. This post will explore some of the most common optimization techniques for single-core binaries executing in modern hardware. We will cover concepts as Instruction-Level Parallelism, cache analysis for specific computations and briefly touch over vectorization. We conclude with a short example showcasing how these techniques are actually used and an analysis of these results. We report a maximum of 10x speedup over the standard naïve matrix-matrix multiplication code.","title":"Optimizing Single-Core CPU software"},{"content":"This is my first blog post. I\u0026rsquo;s the first time I\u0026rsquo;m writing something that would be published on my personal web-page. Programmers are used to write hello world programs as first line when they first approach a new language. It\u0026rsquo;s been a long tradition. This is something similar for me in this moment as I write this.\nI\u0026rsquo;m writing the first blog post in my website, I still have no idea of what I will be talking about in the next posts, they will probably be some thoughts and ideas of things i learn along the way, likely related to tech or University.\nAnyway I aim to write some high-quality content, something the other people would consider as valuable. This first post is just useful to test the functionalities and looks of this small platform.\nSee you in the next posts.\nUPDATE\nI still haven´t got in the habit to write blog post in a regular manner, but i think now i have an activity that could help me to learn more about my fields of interest and also write more on my blog!\nI think that a two-week study of whatever subject I\u0026rsquo;m interested in and write a post for a week in which i explain what I have learned and my own thoughts about it could be a nice idea\nI\u0026rsquo;ll update this when I have more ideas about this.\n","permalink":"https://flecart.github.io/hello-world/","summary":"First blog post","title":"Hello World"}]