<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>X. Angelo Huang&#39;s Blog</title>
    <link>https://flecart.github.io/</link>
    <description>Recent content on X. Angelo Huang&#39;s Blog</description>
    <image>
      <title>X. Angelo Huang&#39;s Blog</title>
      <url>https://flecart.github.io/images/papermod-cover.png</url>
      <link>https://flecart.github.io/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <atom:link href="https://flecart.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Gruppi ciclici e permutazioni</title>
      <link>https://flecart.github.io/notes/gruppi-ciclici-e-permutazioni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gruppi-ciclici-e-permutazioni/</guid>
      <description>Gruppi ciclici e permutazioni Il gruppo ciclico Definizione gruppo ciclico Abbiamo definito in Gruppi per la prima volta il significato di gruppo ciclico generato da un elemento del gruppo, questo insieme si Ã¨ poi dimostrato essere un sottogruppo del gruppo
Un gruppo $G$ Ã¨ chiamato ciclico se esiste un $a \in G$ tel per cui $$ G = \left\{ a^{n} \mid n \in \mathbb{Z} \right\} $$ Dove a Ã¨ chiamato elemento generatore.</description>
    </item>
    <item>
      <title>Interactive Theorem Provers</title>
      <link>https://flecart.github.io/notes/interactive-theorem-provers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/interactive-theorem-provers/</guid>
      <description>Most of times the pattern of proving and verifying it is like this $prove \to verify$, that is: there is an entity that generates the solution, and then another that tries to verify it. But more expressive algorithms could be possible if there is interaction between the two entities, ones that try to prove it, and others try to verify it. From some point of view, this is similar from what AlphaGo does when searching, there is a part that guides the search, another that actually searches for it.</description>
    </item>
    <item>
      <title>Introduction to Topology</title>
      <link>https://flecart.github.io/notes/introduction-to-topology/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduction-to-topology/</guid>
      <description>This small note is an introduction to Topology that follows the introductory arguments of (Armstrong 2013).
Euler&amp;rsquo;s Theorem Basic definitions Polyhedron It&amp;rsquo;s a collection of plane polygons (see Programmazione lineare#Poliedro) such that:
Every polygon shares each of its edges with exactly another polygon We have vertexes that can be shared by many polygons. Informally we have a piece of surface with a vertex. Theorem statement If we have a Polygon $P$ such that</description>
    </item>
    <item>
      <title>Modelli AGILE</title>
      <link>https://flecart.github.io/notes/modelli-agile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/modelli-agile/</guid>
      <description>SocialitÃ  dello sviluppo del software (3) ðŸŸ¨- Si assume che
Ãˆ difficile assegnarsi i compiti, bisogni di utenti, tempi di consegna (+ persone difficile) Ãˆ facile scrivere software (almeno software classico, e non computazione scientifica) La gente sia brava tecnicamente che socialmente Ã¨ una cosa rara VS Waterfall (3) ðŸŸ¨++ Pianificare tutto come viene descritto nel modello del waterfall non Ã¨ possibile. Per i seguenti motivi
Non Ã¨ chiaro cosa vuole l&amp;rsquo;utente finale (quindi sarebbe meglio avere feedback continuo).</description>
    </item>
    <item>
      <title>Requisiti e backlog del software</title>
      <link>https://flecart.github.io/notes/requisiti-e-backlog-del-software/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/requisiti-e-backlog-del-software/</guid>
      <description>Introduzione sui requisiti del software Note introduttive In linguaggio naturale (dizionario) ðŸŸ¥+ Sono tutte le qualitÃ  necessarie per uno scopo ben determinato.
Secondo il prof. I requisiti sono dei desideri ossia ciÃ² che idealmente vorresti riguardo qualcosa (nel nostro caso il software). Ma credo sia anche una tendenza italiana di fare le cose meglio possibile senza mai soddisfare tutto
Functional requirements ðŸŸ© Sono ciÃ² che permetterÃ  di fare il sistema</description>
    </item>
    <item>
      <title>Expressiveness of NN</title>
      <link>https://flecart.github.io/notes/expressiveness-of-nn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/expressiveness-of-nn/</guid>
      <description>The perceptron Slide summary of working of perceptron
Note on the bias: it is only useful to move the treshhold where to consider the output to be 1 and where to be 1.
Now we ask what can be predicted by a perceptron?
Hyperplanes Hyperplanes, because that equation is an hyperplane, so we are sure that we can predict an hyperplane, and that it, and itâ€™s only it. (itâ€™s predicting wheter it can be above or below that line).</description>
    </item>
    <item>
      <title>Problemi di ricerca</title>
      <link>https://flecart.github.io/notes/problemi-di-ricerca/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/problemi-di-ricerca/</guid>
      <description>Ripasso Prox: 36 Ultima modifica: December 29, 2022 3:24 PM Primo Abbozzo: June 30, 2022 2:38 PM Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ— Studi Personali: No
Elementi di ripasso September 10, 2022
Mi sono scordato gli stati possibili. Quasi niente sulla ricerca per algoritmi non deterministici e non osservabili. 2 Problemi di ricerca In questa prima parte si tratta di ricerca semplice, ossia si utilizza un modello basato su obiettivi, di struttura atomica, in un ambiente che risulti singolo-agente, episodico, totalmente osservabile, deterministico, statico, discreto, conosciuto.</description>
    </item>
    <item>
      <title>AccessibilitÃ </title>
      <link>https://flecart.github.io/notes/accessibilit%C3%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/accessibilit%C3%A0/</guid>
      <description>Ci chiediamo come facciamo a rendere sistemi informatici accessibili a persone attraverso certe tecnologie.
Slide esempi di disabilitÃ 
Ãˆ meglio renderlo accessibile perchÃ© Ã¨ illegale (nel senso che stai facendo una discriminazione verso un certo insieme di persone).
WGAC Queste sono alcuni principi di accessibilitÃ , basati su 4 principi fondamentali
4 principi del WGAC POUR per facilitÃ  di ricordarsi
Perceivable (che ci siano le informazioni necessarie per l&amp;rsquo;accessibilitÃ ) Operable Understandable Robus Linguaggio Il tag del linguaggio Ã¨ utilizzato per sapere in che accento leggere e dare gli ordini.</description>
    </item>
    <item>
      <title>Consensus protocols</title>
      <link>https://flecart.github.io/notes/consensus-protocols/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/consensus-protocols/</guid>
      <description>Introduzione Vogliamo tenere in modo sincronizzato alcune macchine, questo Ã¨ il nostro obiettivo. Questo Ã¨ un problema abbastanza difficileâ€¦ Come tenere in sync se ci sono alcuni nodi maligni o la rete che non Ã¨ bona?
Assunzioni principali (2) Esiste internet Esiste Crittografia Queste sono le assunzioni che non saranno mai rilassate per lâ€™intero corso, diciamo che sono la nostra base su cui possiamo andare a costruire la base per il nostro studio.</description>
    </item>
    <item>
      <title>Control Plane</title>
      <link>https://flecart.github.io/notes/control-plane/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/control-plane/</guid>
      <description>Tipologie di control plane La control plane Ã¨ la parte al livello di rete che si occupa di riempire le tabelle di istradamento dei router. In questo caso si possono in generare dividere gli algoritmi in due grandi famiglie
Centralizzati, anche chiamati algoritmi LS( Link state) perchÃ© devono conoscere in che modo sono collegati i router fra di loro. Solitamente le SDN ossia software defined networking di cui abbiamo parlato in Data Plane utilizzano questi metodi, c&amp;rsquo;Ã¨ un server centralizzato (che per ragioni di tolleranza puÃ² anche essere distribuito, perÃ² diciamo che Ã¨ esterno al router la decisione) Distribuiti in cui nessuno ha informazioni complete sulla rete, ma Ã¨ possibile scambiarsi informazioni sui vicini e congiungere cosÃ¬ al percorso piÃ¹ breve.</description>
    </item>
    <item>
      <title>Programmi Concorrenti</title>
      <link>https://flecart.github.io/notes/programmi-concorrenti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/programmi-concorrenti/</guid>
      <description>Vorremmo cercare di stabilire una teoria riguardante programmi che vengono eseguiti appunto concorrentemente, senza una esecuzione classica uno dpo lâ€™altro
Esempio mini-programma rallentamento
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;pthread.h&amp;gt; void test(void *s) { for (int i = 0; i &amp;lt; 10; i++) { printf(&amp;#34;%s\n&amp;#34;, s); for (int j = 0; j &amp;lt; 100000000; j++); } } int main(int argc, char *argv[]) { pthread_t t1, t2; pthread_create(&amp;amp;t1, NULL, (void *)test, &amp;#34;Uno&amp;#34;); pthread_create(&amp;amp;t2, NULL, (void *)test, &amp;#34;Due&amp;#34;); pthread_join(t1, NULL); pthread_join(t2, NULL); } Example output:</description>
    </item>
    <item>
      <title>Strutture</title>
      <link>https://flecart.github.io/notes/strutture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/strutture/</guid>
      <description>Ultima modifica: November 2, 2021 10:50 AM Primo Abbozzo: November 2, 2021 9:22 AM Studi Personali: No
Elementi di ripasso Strutture Caratteristiche La caratteristica principale Ã¨ che le strutture permettono di avere valori eterogenei mentre prima avevamo solo array, ossia valori omogenei, uguali fra di loro.
Questo Ã¨ anche il modo solito con cui fare dei database! Teneere roba ordinata
Sintassi Accesso Blablabla
Copia Si puÃ² copiare un array in modo molto semplice, basta un uguale, mentre invece con gli array non si poteva semplicemente copiare (perchÃ© copiava il pointer) ora a quanto pare copia in automatico.</description>
    </item>
    <item>
      <title>Algorithmic Probability</title>
      <link>https://flecart.github.io/notes/algorithmic-probability/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algorithmic-probability/</guid>
      <description>&amp;ldquo;Information theory must precede probability theory, and not be based on it. By the very essence of this discipline, the foundations of information theory have a finite combinatorial character.&amp;rdquo; Kolmogorov, A. N. (1983).Â Combinatorial foundations of information theory and the calculus of probabilities.
Russian mathematical surveys,Â 38Â (4), 29-40.
&amp;ldquo;it is clear that elements requiring an extremely large number of words for their definition should be considered as having an extremely low probability.</description>
    </item>
    <item>
      <title>Codifica dei caratteri</title>
      <link>https://flecart.github.io/notes/codifica-dei-caratteri/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/codifica-dei-caratteri/</guid>
      <description>Sull&amp;rsquo;encoding Introduzione ðŸŸ© Ossia trattiamo metodi per codificare caratteri dei linguaggi umani, come ASCII, UCS e UTF.
Digitalizzare significa encodarlo in un sistema che possa essere memorizzato su un dispositivo di memorizzazione elettronico. Ovviamente non possiamo mantenere l&amp;rsquo;informazione cosÃ¬ come Ã¨, ma vogliamo memorizzarne una forma equivalente, ma piÃ¹ facile da manipolare dal punto di vista del computer. Creiamo quindi un mapping, o anche isomorfismo tra il valore di mappatura (o encoding), solitamente un valore numerico, tra il singolo valore atomico originale e il numero.</description>
    </item>
    <item>
      <title>Connettivi Logici, correttezza, variabili</title>
      <link>https://flecart.github.io/notes/connettivi-logici-correttezza-variabili/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/connettivi-logici-correttezza-variabili/</guid>
      <description>8.1 Dimostrazione teorema invarianza 8.1.1 Introduzione Basi: Due proposizioni sono equivalenti quando valgono sugli stessi mondi.
quindi $\forall v, \llbracket F \rrbracket ^v \equiv \llbracket G \rrbracket ^ v$.
Vogliamo dire che dati un buco presente in una proposizione, queste valgono sempre, sono in effetti equivalenti. Il buco la prendo come una variabile proposizionale. (riempire = rimpiazare il buco)
8.1.2 Operazione di sostituzione Si puÃ² notare che ci sono 4 casi base, mentre le altre 4 sono per ricorsione strutturale.</description>
    </item>
    <item>
      <title>Uniform Resource Identifier</title>
      <link>https://flecart.github.io/notes/uniform-resource-identifier/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/uniform-resource-identifier/</guid>
      <description>Ripasso: May 14, 2023 Ultima modifica: June 17, 2023 11:54 PM Primo Abbozzo: February 24, 2023 1:33 PM Studi Personali: No
Elementi di ripasso URI Sono stata LA vera invenzione di Berners Lee accennati in Storia del web. Il problema Ã¨ avere un modo per identificare una risorsa in modo univoco sullâ€™internet.
Introduzione La risorsa ðŸŸ© Una risorsa Ã¨ qualunque struttura che sia oggetto di scambio tra applicazioni allâ€™interno del World Wide Web.</description>
    </item>
    <item>
      <title>Bottom-up Parser LR(0)</title>
      <link>https://flecart.github.io/notes/bottom-up-parser-lr0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bottom-up-parser-lr0/</guid>
      <description>Descrivo ora alcune domande utili per ripasso:
Quali sono schematicmente quali sono le operazioni migliori per un parser top-down? Cosa Ã¨ un prefisso viabile? Quali sono i conflitti possibli, e come risolverliâ€¦ Non sai nemmeno definire inmodo formale cosa sia un item Bottom up Intro shift-reduce e LR ðŸŸ© Slide
In breve:
Shift = simbolo terminale messo nella stack Riduzione utilizzando una produzione LR = dettura da Sinistra, creazione della stringa da destra (derivazione rightmost) Algoritmo classico ðŸŸ¨+ Quello che credo che intendevo per questo algoritmo classico Ã¨ quello non deterministico, nel senso che prova a fare backtracking, finchÃ© non ha finito tutte le possibilitÃ , oppure trova la derivazione giusta.</description>
    </item>
    <item>
      <title>Neural Networks</title>
      <link>https://flecart.github.io/notes/neural-networks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/neural-networks/</guid>
      <description>Introduction: a neuron Skipped. Look at Andrew Ng&amp;rsquo;s Coursera course for this part. Historical notes are (Rosenblatt 1958).
Structure Linear + activation In pratica possiamo dire che un neurone in questa parte di AI Ã¨ una funzione lineare (quindi che non fa altro che $w^Tx + b$ di solito indicata con $z$) ossia moltiplicazione lineare, e poi una funzione non lineare tra 0 e 1 che mi indica o meno se la cosa Ã¨ attivata o meno.</description>
    </item>
    <item>
      <title>Cookie e autenticazione</title>
      <link>https://flecart.github.io/notes/cookie-e-autenticazione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cookie-e-autenticazione/</guid>
      <description>Ripasso: May 14, 2023 Ultima modifica: May 6, 2023 6:25 PM Primo Abbozzo: March 30, 2023 4:20 PM Studi Personali: No
Cookies Gli utilizzi piÃ¹ soliti sono per Autenticazione e per Autorizzazione, perchÃ© sono delle informazioni che il server genera e mette al client, come se fossero dei segreti cifrati.
Cookie Questi sono una estensione di netscape, che si appoggiano al protocollo HTTP per implementare certe funzionalitÃ  (soprattutto il fatto di essere stateless, quindi Ã¨ utile per avere informazioni sugli stati su qualcosa.</description>
    </item>
    <item>
      <title>IPSec protocol</title>
      <link>https://flecart.github.io/notes/ipsec-protocol/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/ipsec-protocol/</guid>
      <description>Questo Ã¨ un protocollo di sicurezza a livello Rete e non piÃ¹ a livello socket!
PerchÃ© vorremmo avere sicurezza a questo livello? Ãˆ una cosa troppo comune da dover mettere a livello superiore (ma solitamente viene messa a questo livello per la sicurezza, quindi non Ã¨ implementata ovunque per dire), quindi IPsec vuole facilitare l&amp;rsquo;implementazione dei principi CIA a un livello piÃ¹ basso, in modo che sia flessibile e customizzabile.</description>
    </item>
    <item>
      <title>LR(k) e YACC</title>
      <link>https://flecart.github.io/notes/lrk-e-yacc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/lrk-e-yacc/</guid>
      <description>LR(k) Grammatiche LR(k) ðŸŸ© Anche in questo caso proviamo a generalizzare il concetto dei pirmi k caratteri, in modo da generalizzare in qualche senso il concetto di LR(k), quindi andiamo a modificare la closure considerando ora first k
Per ricordarti come si calcolava first k, andare a guardare Top-down Parser
il problema che poi diventa pratico riguardo questo Ã¨ l&amp;rsquo;impossibilitÃ  di gestire stringhe lunghezza k che sono una assurditÃ  (esponenziale per la lunghezza)</description>
    </item>
    <item>
      <title>Variabili aleatorie</title>
      <link>https://flecart.github.io/notes/variabili-aleatorie/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/variabili-aleatorie/</guid>
      <description>Variabili aleatorie discrete Con le variabili aleatorie cominciamo ad entrare nel noccio della questione, finalmente possiamo in un certo senso legare lâ€™outcome di un evento, alla probabilitÃ  dellâ€™evento.
Definizione VA ðŸŸ© Si definisce variabile aleatoria $X$ una funzione da $\Omega \to E$, con Omega il nostro spazio campionario, e $E$ qualunque insieme (quando $E = \mathbb{R}$ si parla di variabile aleatoria reale
Quindi un esempio classico per il dado, potremmo definire una variabile aleatoria dallo spazio campionario $\Omega = [1, 2, 3, 4, 5, 6]$ ai reali, tali che $X(1) = 1, X(2) = 2$ etc, in questo senso stiamo facendo una funzione fra abitanti di insiemi diversi, ma resta una funzione.</description>
    </item>
    <item>
      <title>Gestione della memoria</title>
      <link>https://flecart.github.io/notes/gestione-della-memoria/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gestione-della-memoria/</guid>
      <description>Memoria statica Elementi in memoria statica (4) ðŸŸ©- Variabili globali Istruzioni macchina Costanti (Variabili locali, paramentri e ritorno di funzione?) Le primi tre elementi descritti di sopra sono sicuramente presenti dopo la fase di compilazione, infatti sono allocati dal compilatore in una zona presente nellâ€™eseguibile (un esempio Ã¨ il READONLY per le stringhe in C).
Quindi se vogliamo
Avere funzioni ricorsive Potere allocare e deallocare variabili in modo dinamico Abbiamo bisogno di far uso di Pila o Heap, che riescano a cresere e restringersi in modo dinamico.</description>
    </item>
    <item>
      <title>Introduzione alla probabilita</title>
      <link>https://flecart.github.io/notes/introduzione-alla-probabilita/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-alla-probabilita/</guid>
      <description>Note: Questo corso Ã¨ troppo astratto. PiÃ¹ che probabilitÃ  tratta di teoria della Misura. Quindi affossatoâ€¦
Link della serie: https://www.youtube.com/watch?v=172m7qVy_FQ&amp;amp;list=PLrb6X_RiBI94b6dzCx-QwM-r0aZpJyPxS
Campo (di probabilitÃ ) Nota:
2 e 3 â‡’ 4
2 e 4 â‡’ 3
Quindi 3 e 4 sono interscambiabili, e si potrebbe eliminare uno dei due.
Anche il fatto che il vuoto sia presente in F si puÃ² omettere. combinando 1 e 2 ottengo il vuoto (complementare dellâ€™insieme che prenda tutto).</description>
    </item>
    <item>
      <title>Lagrange Multipliers</title>
      <link>https://flecart.github.io/notes/lagrange-multipliers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/lagrange-multipliers/</guid>
      <description>This is also known as Lagrange Optimization or undetermined multipliers. Some of these notes are based on Appendix E of (Bishop 2006), others were found when studying bits of rational mechanics.
Let&amp;rsquo;s consider a standard linear optimization problem $$ \begin{array} \\ \min f_{0}(x) \\ \text{subject to } f_{i}(x) \leq 0 \\ h_{j}(x) = 0 \end{array} $$ Lagrangian function And let&amp;rsquo;s consider the Lagrangian function associated to this problem defined as $$ \mathcal{L}(x, \lambda, \nu) = f_{0}(x) + \sum \lambda_{i}f_{i}(x) + \sum\nu_{j}h_{j}(x) $$ We want to say something about this function, because it is able to simplify the optimization problem a lot, but first we want to study this mathematically.</description>
    </item>
    <item>
      <title>Leggi di Ohm</title>
      <link>https://flecart.github.io/notes/leggi-di-ohm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/leggi-di-ohm/</guid>
      <description>Gli argomenti della lezione 31 Ottobre sono circa da pagina 164 fino a 185 del mazzoldi.
Leggi di Ohm Introduzione microscopica ðŸŸ© Sappiamo che $$ \vec{J} = -n e \vec{v}_{d} ne^{2} t \frac{\vec{E}}{m} $$ Vedi analisi della velocitÃ  di deriva col modello del 1900 in Corrente Elettrica.
Dove abbiamo utilizzato la definizione di densitÃ  di corrente e la velocitÃ  fra collisioni ed altre Questo Ã¨ una motivazione per considerare la densitÃ  di corrente come se fosse nello stesso verso.</description>
    </item>
    <item>
      <title>Logica Proposizionale</title>
      <link>https://flecart.github.io/notes/logica-proposizionale/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/logica-proposizionale/</guid>
      <description>Con la logica proposizionale studiamo le denotazioni che hanno un valore di veritÃ , ovvero deve essere una sentenza assertiva. Studio solamente le connotazioni che hanno una capacitÃ  denotativa, in quanto Ã¨ solo quello ch emi importa.
6.1 La sintassi Vengono qui definite le produzioni che valgono in ogni singolo mondo.
$$ F ::= \top|\bot|A|B|...|\not F| F \wedge F| F \vee F| F \implies F $$ Questa Ã¨ la BNF della nostra sintassi.</description>
    </item>
    <item>
      <title>Magnetismo</title>
      <link>https://flecart.github.io/notes/magnetismo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/magnetismo/</guid>
      <description>Introduzione ai campi magnetici Introduzione storica (non impo) ðŸŸ© Il magnetismo Ã¨ stato in primi osservato e documentato da Greci, che hanno osservato che materiali metallici come ferro, questo Ã¨ successo in magnesia, una penisola dell&amp;rsquo;Asia minore, mentre elettro era piÃ¹ sull&amp;rsquo;ambra, che credo fosse il nome dato a quel materiale.
Una cosa nota era che se vicino a un materiale magnetico, venivano create linee con materiale ferroso all&amp;rsquo;estremitÃ  (limatura magnetica).</description>
    </item>
    <item>
      <title>Sistemi Lineari e determinanti</title>
      <link>https://flecart.github.io/notes/sistemi-lineari-e-determinanti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/sistemi-lineari-e-determinanti/</guid>
      <description>4.1 Sistemi lineari La cosa buona Ã¨ che possiamo analizzare il sistema lineare utilizzando tutti i teoremi che abbiamo sviluppato finora, quindi siamo molto piÃ¹ potenti per attaccare questo problema.
Definiamo un sistema lineare cosÃ¬
$Ax = b$ con A la matrice associata.
4.1.1 Preimmagine Data una applicazione lineare $F:V \to W$, allora la controimmagine Ã¨ l&amp;rsquo;insieme dei vettori di V che fanno a finire in quel punto, in matematichese:</description>
    </item>
    <item>
      <title>Convolutional NN</title>
      <link>https://flecart.github.io/notes/convolutional-nn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/convolutional-nn/</guid>
      <description>Introduction to convolutional NN The convolution operator ðŸŸ©- Il prodotto di convoluzione Ã¨ matematicamente molto contorto, anche se nella pratica Ã¨ una cosa molto molto semplice. In pratica voglio calcolare il valore di un pixel in funzione di certi suoi vicini, moltiplicati per un filter che in pratica Ã¨ una matrice di pesi, che definisce un pattern lineare a cui sarei interessato di cercare nellâ€™immagine.
Slides ed esempi (molto piÃ¹ chiaril)</description>
    </item>
    <item>
      <title>Database logical design</title>
      <link>https://flecart.github.io/notes/database-logical-design/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/database-logical-design/</guid>
      <description>Introduzione al design logico Conoscenze sul carico dell&amp;rsquo;applicazione, ossia se ha piÃ¹ read rispetto a writes per esempio, sono dei priors in pratica Un design concettuale spiegato in precedenza. E si avrÃ  in output un design logico con anche un po&amp;rsquo; di documentazione. bisogna in questa fase valutare la performance principalmente su indicatori, ossia una operazione quante istanze visiterÃ ? Invece di garanzie sul numero di transazioni al secondo.
Indicatori visti (2) Costo di una operazione: viene valutato in termini di numero di occorrenze di entitÃ  e associazioni che mediamente vanno visitate per rispondere a una operazione sulla base dÃ¬ dati; questa schematizzazione Ã¨ molto forte e, pur nelle semplici valutazioni che svilupperemo, sarÃ  talvolta necessario riferirci a un criterio piÃ¹ fine; Occupazione di memoria: viene valutato in termini dello spazio di memoria (misurato per esempio in numero di byte) necessario per memorizzare i dati descritti dallo schema.</description>
    </item>
    <item>
      <title>Object detection and Segmentation</title>
      <link>https://flecart.github.io/notes/object-detection-and-segmentation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/object-detection-and-segmentation/</guid>
      <description>Definition of problems Object detection Bisogna trovare all&amp;rsquo;interno dell&amp;rsquo;immagine quali siano gli oggetti presenti, e in piÃ¹ vogliamo sapere dove siano quindi utilizzare una bounding box per caratterizzarli sarebbe buono.
Object segmentation Ãˆ riuscire a caratterizzare categoria per categoria per singoli pixelsm e per questo motivo potrei riuscire a fare delle image map in cui colorare singoli oggetti in una categoria.
Datasets Example datasets Pascal VOC 2012 Coco datasets Cityscapes dataset Autogenerated datasets But I don&amp;rsquo;t know much about these datasets Applications Auto drive Campo medico (per segmentazione medica o riconoscimento immagini).</description>
    </item>
    <item>
      <title>Agente Logico</title>
      <link>https://flecart.github.io/notes/agente-logico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/agente-logico/</guid>
      <description>Introduzione Nozioni base Questi sono le parole chiave di questo capitolo, ci permettono di parlare con chiarezza riguardo lâ€™agente logico.
Sentence
Knowledge Base
Axiom
Inference
background knowledge
Knowledge representation language
Knowledge level
Implementation level
Esempio generale di agente logico
Logica proposizionale Sintassi del linguaggio Descrivere la BNF della logica proposizionale.
per sapere cosa sia la BNF di questo Ã¨ molto piÃ¹ facile rifarsi agli appunti di logica presi durante lâ€™anno di corso 2021/2022 Logica Proposizionale.</description>
    </item>
    <item>
      <title>Calcolo di numeri finiti</title>
      <link>https://flecart.github.io/notes/calcolo-di-numeri-finiti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/calcolo-di-numeri-finiti/</guid>
      <description>1 Calcolo dei numeri finiti Il calcolo Ã¨ numerico perchÃ© si differenzia rispetto a un calcolo normale perchÃ© Ã¨ finito.
1.1 Errore nei calcoli 1.1.1 Tipologie di errore (5) ðŸŸ© Errore di misura, dovuto alle imperfezioni dello strumento di misura dei dati del problema. Errore di troncamento, quando un procedimento infinito viene realizzato come procedimento finito. (esempio: calcolo del valore di una funzione tramite sviluppo in serie, perchÃ© dato che lâ€™algoritmo deve essere finito, devo prima o poi interrompere il calcolo, ecco qui lâ€™errore).</description>
    </item>
    <item>
      <title>OTP and Stream Ciphers</title>
      <link>https://flecart.github.io/notes/otp-and-stream-ciphers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/otp-and-stream-ciphers/</guid>
      <description>XOR operation Ãˆ una operazione binaria abbastanza semplice perÃ² ci sarÃ  importante per andare ad analizzare dei cifrari di un certo genere. Come il ONE TIME PAD che faremo fra poco in OTP and Stream Ciphers.
Teorema cifratura con XOR Prendiamo $X$ una variabile aleatoria in $\left\{ 0,1 \right\}^{n}$ uniforme, sia $Y$ una variabile aleatoria su uno stesso dominio come vogliamo. Tali per cui $X, Y$ siano indipendenti Allora avremo che $C = X \oplus Y$ Ã¨ una variabile aleatoria uniforme.</description>
    </item>
    <item>
      <title>Structured Query Language</title>
      <link>https://flecart.github.io/notes/structured-query-language/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/structured-query-language/</guid>
      <description>Data types Default data types ðŸŸ© I tipi di dati sono
Carattere numero data tempo intervallo di tempo booleano blob (binario) clob (carattere) Setting custom data types ðŸŸ© Ma possono essere definiti anche tipi di dati custom, la sintassi Ã¨ simile
CREATE DOMAIN Grade AS SMALLINT DEFAULT NULL CHECK (value &amp;gt;= 18 AND value &amp;lt;= 30) Altering existing domains ðŸŸ© In cui posso mettere anche dei check custom.
DROP DOMAIN Per cancellare il domain lÃ¬ presente</description>
    </item>
    <item>
      <title>Architettura e livelli 1, 2</title>
      <link>https://flecart.github.io/notes/architettura-e-livelli-1-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/architettura-e-livelli-1-2/</guid>
      <description>PerchÃ© a stack ðŸŸ©- Capire lâ€™architettura significa capire la struttura (lâ€™organizzazione) del nostro app e comprenderne i motivi (i sottoproblemi risolti) che ogni livello prova a risolvere
La soluzione che Ã¨ stata individuata, e ha rappresentato uno dei principali cardini del successo delle reti e della nascita di Internet, Ã¨ data dalla separazione delle classi di protocolli in livelli. La struttura dei livelli dei protocolli di rete prende il nome di architettura dei protocolli di rete.</description>
    </item>
    <item>
      <title>Debugging</title>
      <link>https://flecart.github.io/notes/debugging/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/debugging/</guid>
      <description>Ultima modifica: February 25, 2023 2:07 PM Primo Abbozzo: November 9, 2021 3:00 PM Studi Personali: No
Il debugging Ã¨ un ambito che interessa molto a Lanese perchÃ© Ã¨ molto affine al suo ambito di ricerca.
Condizioni di correttezza Un programma di si dice corretto quando restituisce il valore voluto per ogni condizione di input
Esempi di programmi sbagliati Un programma che a volte si pianta e non va piÃ¹. Un programma con cicli infiniti.</description>
    </item>
    <item>
      <title>Grammatiche Regolari</title>
      <link>https://flecart.github.io/notes/grammatiche-regolari/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/grammatiche-regolari/</guid>
      <description>Introduzione Definizione grammatica regolare ðŸŸ© Definizione
In pratica posso avere solamente come terminali a, oppure un suffisso a su un non terminale.
Queste grammatiche sono interessanti perchÃ© Ã¨ molto facile costruire un automa che sia in grado di riconoscere questo linguaggio.
Seguendo una definizione piÃ¹ lasca possono anche accettare dei nonterminali epsilon
Espressione regolare a NFA ðŸŸ© Questa sezione Ã¨ anche presente in Automi e Regexp, perÃ² Ã¨ riportata qui cosÃ¬ câ€™Ã¨ lâ€™insieme di tutte le cose in un unico posto.</description>
    </item>
    <item>
      <title>Hello World</title>
      <link>https://flecart.github.io/hello-world/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/hello-world/</guid>
      <description>First blog post</description>
    </item>
    <item>
      <title>Livello di Rete</title>
      <link>https://flecart.github.io/notes/livello-di-rete/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/livello-di-rete/</guid>
      <description>Reti di Reti Le parti importanti per questo sono Data Plane e Control Plane (che ha saltato quasi tutto, ma almeno dijkstra lo dovresti fare bene)
Introduzione (puoi skippare ðŸŸ©) La puoi skipppare perchÃ© tratta in modo molto generare parti che saranno trattati in modo piÃ¹ approfondito in seguito. La parte importante forse Ã¨ il riassunto di cosa faccia questo livello.
Discussione rete locale globale Slide
No, non Ã¨ possible creare una connessione globale utilizzando le tecnologie locali, come hub, switch e simili, perchÃ© causerebbe flooding e impedirebbe scalabilitÃ  e crescita dinamica che Ã¨ classica della rete</description>
    </item>
    <item>
      <title>NaÃ¯ve Bayes</title>
      <link>https://flecart.github.io/notes/na%C3%AFve-bayes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/na%C3%AFve-bayes/</guid>
      <description>Introduzione a NaÃ¯ve Bayes Bisognerebbe in primo momento avere benissimo in mente il significato di probabilitÃ  condizionata e la regola di naive Bayes in seguito.
Bayes ad alto livello ðŸŸ© Da un punto di vista intuitivo non Ã¨ altro che predire la cosa che abbiamo visto piÃ¹ spesso in quello spazio Assunzioni principali per naÃ¯ve Bayes ðŸŸ© I sample di input sono condizionalmente indipendenti uno con l&amp;rsquo;altro. Questo permette di utilizzare questa ipotesi $$ P(X_{1}\dots X_{n} | Y = y_{i}) = \prod_{i}^{n} P(X_{i} | Y) $$ E permette di rendere la parte di inferenza anche molto semplice perchÃ© per classificare un caso basta prendere label con la probabilitÃ  maggiore.</description>
    </item>
    <item>
      <title>Storia del web</title>
      <link>https://flecart.github.io/notes/storia-del-web/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/storia-del-web/</guid>
      <description>Guerre dei browser Prima guerra ~1995
Fra netscape, una forma di rete (?) che poi viene ripresa da firefox da Mozilla, dopo che Ã¨ stato mandato in bancarotta da Microsoft (che ha ancora con IE una grandissima fetta del mercato in questo primo periodo).
Secondo periodo di guerra ~2010
Quando arriva chrome, che vuole creare un browser che risolva tutti i problemi per creare integrazioni sui browser di altre aziende), mentre IE ha perso interesse per nuove features, che in questo periodo sono capi del proprio mercato.</description>
    </item>
    <item>
      <title>User authentication</title>
      <link>https://flecart.github.io/notes/user-authentication/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/user-authentication/</guid>
      <description>The user authentication is one of the most important parts for computer security, because every security policy starts with authentication. This authentication should be easy to use, if not users will not use this. So this should be a good compromise.
Parts of authentication security security:
Registration Authentication check Recovery These three are the main parts of security. Some challenges in user authentication Intermediate principals A part that we will not cover are the intermediate principals which attach the mean of transmission or intermediate devices used in the transmission.</description>
    </item>
    <item>
      <title>Central Limit Theorem and Law of Large Numbers</title>
      <link>https://flecart.github.io/notes/central-limit-theorem-and-law-of-large-numbers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/central-limit-theorem-and-law-of-large-numbers/</guid>
      <description>Bounds Markov Bound Questo bound Ã¨ abbastanza banale se fatto da un punto di vista grafico, comunque afferma che $$ P(X \geq y) \leq \frac{E[X]}{y} $$ Il motivo Ã¨ che $$ yP(X \geq y) = y\int _{x =y}^{+\infty} f(x) \, dx \leq \int _{x=y}^{+\infty} x f(x) \, d \leq \int _{-\infty}^{+\infty}xf(x) \, d = E[X] $$ Il che finisce la dimostrazione.
Chebychev Bound Questa Ã¨ una conseguenza abbastanza diretta sul bound precedente: Afferma che $$ P(\mid x - E[X] \mid \geq y) \leq \frac{\sigma^{2}}{y^{2}} $$ E in pratica dice che all&amp;rsquo;infinito viene tutto compattata sul valore atteso La dimostrazione Ã¨ abbastanza semplice, si sostituisce $(x - E[X])^{2}$ su $X$ di Markov e $\varepsilon^{2}$ a $y$ e poi si dovrebbe giÃ  avere il risultato</description>
    </item>
    <item>
      <title>Devices OS</title>
      <link>https://flecart.github.io/notes/devices-os/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/devices-os/</guid>
      <description>Devices Categorizzazione (6)ðŸŸ¨- Trasferimento dei dati Accesso al device sinconia del trasferimento condivisone fra processi VelocitÃ  del trasferimento I/O direction (scrittura o lettura) Vediamo che molte caratteristiche sono riguardo il trasferimento
Slide categorizzazione I/O
Blocchi o caratteri ðŸŸ©- Slide devices blocchi o caratteri
Tecniche di gestione devices (4) ðŸŸ¨- Buffering Possiamo mettere un buffer per favorire la comunicazione fra i devices. la cos amigliore che fa Ã¨ creare maggiore efficienza. Un altro motivo Ã¨ la velocitÃ  diversa di consumo.</description>
    </item>
    <item>
      <title>La macchina di Turing</title>
      <link>https://flecart.github.io/notes/la-macchina-di-turing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/la-macchina-di-turing/</guid>
      <description>Introduzione Note filosofiche (non impo) Bisogna in primo momento cercare di definire cosa Ã¨ la computazione e cosa Ã¨ un computer. Aristotele faceva la distinzione fra proprietÃ  essenziali e accidentali. Quelle essenziali sono proprie dell&amp;rsquo;oggetto.
Una sedia puÃ² essere fatta di legno o di metallo, ma questa proprietÃ  Ã¨ accidentale, ovvero, essa rimane una sedia indipendentemente dal materiale di cui Ã¨ fatta.
Solitamente in matematica si prova ad astrarre (vedi Astrazione sul controllo per nota generale sull&amp;rsquo;astrazione).</description>
    </item>
    <item>
      <title>Macchine Astratte</title>
      <link>https://flecart.github.io/notes/macchine-astratte/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/macchine-astratte/</guid>
      <description>Definizione ed esempi per macchine astratte ðŸŸ© Una macchina astratta Ã¨ un qualunque insieme di algoritmi e strutture di dati che permettono di memorizzare ed eseguire il linguaggio $L$, quindi una macchina astratta esiste per esguire il proprio linguaggio (inteso come insieme finito di istruzioni primitive che riesce ad comprendere e eseguire).
Si puÃ² proprio dire che esiste una simbiosi fra macchina e linguaggio. Si potrebbe dire che la macchina fisica Ã¨ soltanto una implementazione FISICA di un linguaggio, ossia una macchina che capisce ed esegue quel linguaggio e che sia solamente un caso particolare della macchina astratta.</description>
    </item>
    <item>
      <title>Porte Logiche</title>
      <link>https://flecart.github.io/notes/porte-logiche/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/porte-logiche/</guid>
      <description>In questa nota andiamo a trattare argomenti come tabelle di veritÃ . Mappe di Karnaugh. E piccolissima introduzione ai circuiti integrati.
Boole Un signor Boole ha creato le basi dell&amp;rsquo;algebra booleana su cui si basano le porte logiche dei computer moderni.
Tabelle di veritÃ  Le tabelle di veritÃ  sono sufficienti per descrivere il funzionamento di una porta logica.
Questa cosa Ã¨ possibile grazie alla limitatezza delle funzioni all&amp;rsquo;interno dell&amp;rsquo;insieme $\{0,1\}$ dominio di partenza e fine dell&amp;rsquo;algebra booleana.</description>
    </item>
    <item>
      <title>Scrum Method</title>
      <link>https://flecart.github.io/notes/scrum-method/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/scrum-method/</guid>
      <description>Introduzione (idea principale) In breve: essence card ðŸŸ©- Giallo = Prodotto. Metafora staffetta-rugby ðŸŸ© Con altri metodi si fanno produzioni stile staffetta, ossia un membro sta fermo, finchÃ© non ha il testimone e poi si uccide correndo&amp;hellip; Il metodo piÃ¹ utile ispirato a scrum Ã¨ rugby, che tutti si muovo insieme collaborando. Un po&amp;rsquo; di tutto Ã¨ fatto durante lo sprint
Cicli di base (3) ðŸŸ© Planning: in cui vengono scelti i task da eseguire durante questo sprint, solitamente questo viene preso da un subset dei task descritti dal product owner.</description>
    </item>
    <item>
      <title>Bayesian Networks</title>
      <link>https://flecart.github.io/notes/bayesian-networks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bayesian-networks/</guid>
      <description>Questi network bayesiani sono proprio dei grafi, che permettono una migliore comprensione delle relazioni causali o diagnostici fra le probabilitÃ 
Esempio rete bayesiana
Note generali Introduzione alla rete classica Una rete bayesiana ci permette di semplificare di molto il calcolo della full disjoint probability table, rendendola in questo modo
Ossia andiamo a utilizzare una probabilitÃ  locale, o sparsa per fare i conti, cosa che semplifica molto, e quindi velocizza il calcolo.</description>
    </item>
    <item>
      <title>Cook-Levin and Savitch</title>
      <link>https://flecart.github.io/notes/cook-levin-and-savitch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cook-levin-and-savitch/</guid>
      <description>Cook Levin theorem is important because says that in 1971 if $SAT \in P$ then $NP = P$. We will start with this idea to define the concept of NP-completeness. Let&amp;rsquo;s start with the basics.
Poly-reduction Def: poly-reductionðŸŸ© We say that two languages $L$ and $L&#39;$ defines over alphabet $\Sigma$. We say that $LÂ´$ is poly (mapping)-reducible in $L$, $L&#39; \leq_{p} L$ when a $TM$ that computes polynomial time a function $f: \Sigma^{*} \to \Sigma^{*}$ such that $$ x \in L&#39; \iff f(x) \in L $$ This is very similar to the Halting Theorem and Reducibility#Mapping reducibility.</description>
    </item>
    <item>
      <title>Isomorfismi</title>
      <link>https://flecart.github.io/notes/isomorfismi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/isomorfismi/</guid>
      <description>Gli isomorfismi sono delle proprietÃ  fondamentali per stabilire una sorta di equivalenza fra i gruppi. Utilizziamo questi isomorfismi per parlare della stessa cosa ma in modi diversi.
3.1 Introduzione 3.1.1 Definizione Un gruppo si dice isomorfo rispetto ad un altro gruppo se, in paroloni semplici, esiste una funzione bigettiva tale che preservi l&amp;rsquo;operazione del gruppo.
In altre parole
$$ \phi:A \to B,\phi(ab) = \phi(a)\phi(b) $$ 3.1.2 Step di dimostrazione Esiste un modo preciso per dimostrare se due gruppi sono isomorfi.</description>
    </item>
    <item>
      <title>Legge di Coulomb</title>
      <link>https://flecart.github.io/notes/legge-di-coulomb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/legge-di-coulomb/</guid>
      <description>Introduzione elettromagnetismo Note storiche: triboelettricitÃ  Il concetto di campo Ã¨ fondamentale per l&amp;rsquo;elettromagnetismo (vs forza in meccanica) da un punto di vista storico Ã¨ nato tramite l&amp;rsquo;osservazione in fenomeni come lo strofinio fra vetro e pelle, dopo il quale hanno osservato ci fosse una forza nascosta (appunto ombra dal greco di electron). Il vetro si caricava poi abbastanza da poter attrarre carta per esempio. esempio dell&amp;rsquo;esperimento. Se viene fatto invece fra due lastre in vetro invece diventa repulsiva invece che attrattiva.</description>
    </item>
    <item>
      <title>Tabelle di hash</title>
      <link>https://flecart.github.io/notes/tabelle-di-hash/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/tabelle-di-hash/</guid>
      <description>5.1 Introduzione 5.1.1 Prototipo Vogliamo implementare le operazioni del prototipo dizionario presentato in Strutture di dati elementari, e vogliamo fare solo queste 3 ma molto bene.
Insert O(1) Delete O(1) Search in O(1) La struttura dati di hash riesce a fare bene queste singole operazioni
Si vedrÃ  che l&amp;rsquo;array modificato Ã¨ il modo migliore per avere questo hash, solo generalizzando un modo per indicizzarlo che non saranno numeri (indici).
Noteremo che in media hanno operazioni costanti queste tabelle di hash (nel caso peggiore sempre lineare).</description>
    </item>
    <item>
      <title>Basi di programmazione</title>
      <link>https://flecart.github.io/notes/basi-di-programmazione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/basi-di-programmazione/</guid>
      <description>1.1 Identificatori e dichiarazioni 1.1.1 Il nome simbolico/simbolico e fisico Nome simbolico: nome leggibile da esseri umani diverso dal nome numerico con cui se lo ricorda il computer
ðŸ’¡ Fai attenzione alle possibili variabili per il nome simbolico! Attenzione
1.1.2 Dichiarazione dei nomi esempio:
int n; Quello che il programma fa sotto Ã¨ creare memoria per la variabile.
1.2 Tipi di dato Ricordarsi che
1.2.1 Int 4 bytes in memoria</description>
    </item>
    <item>
      <title>Classi OOP</title>
      <link>https://flecart.github.io/notes/classi-oop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/classi-oop/</guid>
      <description>Introduzione a OOP Per la definizione di classe andare a guardare Object orientation, perÃ² lo ripeto in questa occasione, Ã¨ solamente un modello su cui andare a costruire degli oggetti.
CapisaldiðŸŸ© Incapsulazione Astrazione EreditarietÃ  Dispatch dinamico Costruttori ðŸŸ©- Il costruttore Ã¨ un codice utilizzato per inizializzare correttamente lo stato interno. Le regole sono le stesse dei metodi sovraccaricati (dinamica per la chiamata, statica per il numero dei parametri che prende in input).</description>
    </item>
    <item>
      <title>Design del database</title>
      <link>https://flecart.github.io/notes/design-del-database/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/design-del-database/</guid>
      <description>Processo design del database Il design Some design steps (3) (non impo) How to gather requirements? ðŸŸ¨+ Come si puÃ² raccogliere i dati degli utilizzatori?
parlare col il personale che dovrÃ  utilizzare questi sistemi Documentazione esistente Interview di persone che dovrÃ  utilizzare queste risorse O Moduli per fare sampling Top-down approach La cosa brutta Ã¨ che questi requisiti non possono essere standardizzati, ci sono molte necessitÃ , molto diverse fra i loro, quindi Ã¨ utile andare a parlare con gli esperti e capire cosa abbiano bisogno per i dati.</description>
    </item>
    <item>
      <title>Reti Preparazione Esami</title>
      <link>https://flecart.github.io/notes/reti-preparazione-esami/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/reti-preparazione-esami/</guid>
      <description>Ultima modifica: May 1, 2023 10:37 AM Primo Abbozzo: April 30, 2023 5:06 PM Studi Personali: No
Elementi di ripasso 2022-06-10 Es 3 (sicurezza) Testo [15] Alice spedisce a Bob un messaggio M1 molto grande con la sola garanzia di non ripudiabilitÃ  (ovvero Alice non potrÃ  mai dimostrare di avere spedito un messaggio diverso da quello ricevuto da Bob), ma non serve privacy (tutti possono leggere M1). Bob in seguito risponde ad Alice con un messaggio m2 molto piccolo del quale deve essere perÃ² data garanzia di mittente (solo Bob puÃ² averlo spedito), di privacy (nessuno oltre ad Alice puÃ² leggerlo) e non Replay (ovvero Alice deve accettarlo una volta sola da Bob).</description>
    </item>
    <item>
      <title>Teoremi Base Analisi</title>
      <link>https://flecart.github.io/notes/teoremi-base-analisi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/teoremi-base-analisi/</guid>
      <description>Def: Massimo minimo relativo (locale) Sia $x_{0} \in \mathcal{A}$ si dice punto di massimo relativo (o locale) se: $$ \exists r &gt; 0 : f(x) \leq f(x_{0}), \, \forall x \in \mathcal{A} \cap I_{r}(x_{0}) $$ Dove $I_{r}(x_{0}) = \left[ x_{0} -r, x_{0} + r \right]$, Ã¨ un intorno
Def: Massimo minimo assoluto Sia $x_{0} \in \mathcal{A}$ si dice punto di massimo assoluto se vale $$ f(x) \leq f(x_{0}), \, \forall x \in \mathcal{A} $$ Fermat 6.</description>
    </item>
    <item>
      <title>Calcolo differenziale</title>
      <link>https://flecart.github.io/notes/calcolo-differenziale/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/calcolo-differenziale/</guid>
      <description>10.1 Derivata parziale La derivata vuole descrivere quanto varia una funzione al variare dell&amp;rsquo;input. Ma ora siamo in piÃ¹ dimensioni, quindi vogliamo descrivere il variare dell&amp;rsquo;input come il variare della distanza euclidea
$\dfrac{\delta f}{\delta x}(x,y) = \lim _{h \to 0} \dfrac{f(x + h, y) - f(x, y)}{h}$ ovvero sto facendo variare solamente una variabile (la y in questo caso Ã¨ come se fosse una costante!?) Questo Ã¨ un rapporto incrementale su una direzione.</description>
    </item>
    <item>
      <title>Derivate</title>
      <link>https://flecart.github.io/notes/derivate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/derivate/</guid>
      <description>5.1 Geometria introduttiva 5.1.1 Tangente e pendenza Si puÃ² trovare la relazione fra la pendenza della retta e la tangente.
Possiamo analizzare la retta dal punto di vista analitico, della formula e si puÃ² dimostrare che data una retta nella forma $y = mx + q$ $m$ Ã¨ la pendenza della retta.
5.1.2 Formula generale delle rette Dati qualunque due punti .$(x_1, y_1), (x_2, y_2)$ possiamo dire che la pendenza Ã¨ esprimibile come</description>
    </item>
    <item>
      <title>Garbage Collection</title>
      <link>https://flecart.github.io/notes/garbage-collection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/garbage-collection/</guid>
      <description>On dangling pointers Tombstones ðŸŸ© Slides tombstones
Quando alloco, alloco anche una tombstone, e tutti i riferimenti passano per quella. (quindi ho due dereference per lâ€™accesso) quando vado a deallocare segno la tombstone come RIP, NULL.
Dopo molto tempo ho il problema del cimitero che diventa molto grande. Anche se non punta piÃ¹ a niente, il cimitero.
Keys and locks ðŸŸ© Un pÃ² di overhead in piÃ¹ dal punto di vista della memoria, che Ã¨ doppio</description>
    </item>
    <item>
      <title>Memoria</title>
      <link>https://flecart.github.io/notes/memoria/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/memoria/</guid>
      <description>4.1 Caratteristiche della Memoria La gerarchia della memoria, piÃ¹ si va giÃ¹ piÃ¹ spazio si ha, piÃ¹ Ã¨ lento il caricamento delle informazioni
4.1.1 Catalogazione della memoria Le tipologie di memoria sono presenti a fianco.
In generale piÃ¹ la memoria Ã¨ veloce da riprendere, piÃ¹ Ã¨ costosa da memorizzare (c&amp;rsquo;Ã¨ poco spazio)
4.1.2 Byte e Word Il libro a pagina 74 parte con la discussione del perchÃ© si Ã¨ preferito evitare la BCD (Binary coded decimal, in cui i numeri da 0 a 9 erano codificato da 4 bit), per questioni di efficienza.</description>
    </item>
    <item>
      <title>Metodi di Discesa</title>
      <link>https://flecart.github.io/notes/metodi-di-discesa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/metodi-di-discesa/</guid>
      <description>Introduzione ai metodi di discesa. Generali sui metodi di discesa Vogliamo creare algoritmi che riescano a trovare i punti di minimo delle funzioni non vincolate.
In generale si trova un punto stazionario (condizioni necessarie) ma non Ã¨ garantito lo stato ottimo.
Solitamente sono divisi in first order methods in cui viene considerata solamente la derivata prima della funzione. E cose di metodi superiori.
Condizioni di arresto classiche (2) ðŸŸ©- Slide</description>
    </item>
    <item>
      <title>Programmazione lineare</title>
      <link>https://flecart.github.io/notes/programmazione-lineare/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/programmazione-lineare/</guid>
      <description>Vogliamo cercare di restare nel nostro spazio delle soluzioni ammissibili, senza dover stare ad esplorare tutto, vogliamo andare a concentrarci su una parte specifica di essa. Vogliamo utilizzare una struttura fondamentale per i problemi di programmazione lineare, che Ã¨ quello con cui vogliamo andare a fare. Il fatto Ã¨ che spostandoci leggermente da un punto tra le soluzioni, possiamo gestire in modo molto semplice il modo con cui si sposta la retta dei valori.</description>
    </item>
    <item>
      <title>VLAN</title>
      <link>https://flecart.github.io/notes/vlan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/vlan/</guid>
      <description>Ultima modifica: May 17, 2023 3:14 PM Primo Abbozzo: May 17, 2023 1:48 PM Studi Personali: No
Elementi di ripasso VLAN Introduzione Quando abbiamo una switch, ma vogliamo allo stesso momento andare a creare piÃ¹ LAN, allora abbiamo bisogno delle VLAN. Questi switch che hanno delle VLAN si chiamano managed switches
Queste vlan sono numerate (ricorda lâ€™espericomento cn LUCA!).
Il problema Sono un protocollo livello 2 (Link-Layer, di collegamento), non vorremmo per esempio che un broadcast di una certa rete vada anche in altre reti che non centrino praticamente nulla, come possiamo vedere in figura.</description>
    </item>
    <item>
      <title>Alberi di decisione</title>
      <link>https://flecart.github.io/notes/alberi-di-decisione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/alberi-di-decisione/</guid>
      <description>Introduzione agli alberi di decisione Setting del problema ðŸŸ©- Spazio delle ipotesi Definizione spazio ipotesi ðŸŸ©&amp;mdash; Per spazio delle ipotesi andiamo a considerare l&amp;rsquo;insieme delle funzioni rappresentabili dal nostro modello. Questo implica che l&amp;rsquo;allenamento ricerca l&amp;rsquo;ipotesi ossia la parametrizzazione ottimale del nostro modello, ottimale in quanto minimizza l&amp;rsquo;errore che viene compiuto nel training set.
L&amp;rsquo;insieme iniziale si puÃ² anche considerare come inductive bias ossia il restringimento solamente a certe ipotesi e non tutte.</description>
    </item>
    <item>
      <title>Antenne</title>
      <link>https://flecart.github.io/notes/antenne/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/antenne/</guid>
      <description>Omnidirezionali Antenne omnidirezionali ðŸŸ© Slides antenne omnidirezionali
Il senso di omnidirezionale Ã¨ in tutte le direzioni dell&amp;rsquo;antenna (nota: non Ã¨ isotropico, perchÃ© non Ã¨ da un singolo punto).
in passato era importante andare a guardare la direzione per trovare la polarizzazione migliore. Praticamente irradia a 360 gradi sul piano permedicolare allâ€™antenna.
Esempio pattern di radiazione
Questo genere di antenne sono irrealizzabili la piÃ¹ simile Ã¨ la antenna dipolo dipolo, ma comunque non rispetta le antenne in questo verso diciamo.</description>
    </item>
    <item>
      <title>Grafi</title>
      <link>https://flecart.github.io/notes/grafi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/grafi/</guid>
      <description>Rappresentazione e terminologia Operazioni importanti
Definizione di grafo Ãˆ un insieme di nodi e di archi. (prendili da insiemi corretti)
Metodi di rappresentazione Liste di incidenza (In pratica numero tutti gli archi e storo il valore dell&amp;rsquo;arco incidente per ogni nodo)
Liste di adiacenza Classico usato per cp, si storano direttamente pointer a nodi di interesse
Matrici di adiacenza Se esiste un arco fra due nodi, metto un uno in questa posizione (si puÃ² utilizzare una cosa simile per mantenere il peso di un arco)</description>
    </item>
    <item>
      <title>HTTP e REST</title>
      <link>https://flecart.github.io/notes/http-e-rest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/http-e-rest/</guid>
      <description>HTTP HYPERTEXT-TRANSFER-PROTOCOL
Caratteristiche principali (3) ðŸŸ¨ Slide caratteristiche
Comunicazioni fra client e server, e quanto sono comunicate le cose si chiude la connessione e ci sono politiche di caching molto bone (tipo con i proxy) Generico: perchÃ© Ã¨ un protocollo utilizzato per caricare moltissime tipologie di risorse! Stateless, ossia non vengono mantenute informazioni su scambi vecchi, in un certo modo ne abbiamo parlato in Sicurezza delle reti quando abbiamo parlato di firewall stateless.</description>
    </item>
    <item>
      <title>Introduzione a blockchain</title>
      <link>https://flecart.github.io/notes/introduzione-a-blockchain/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-a-blockchain/</guid>
      <description>Blockchain stack Vogliamo andare ora a descrivere la stack delle blockchain, in modo simile a quanto fatto con le internet, perchÃ© anche qui possiamo organizzarlo a stack!
Nota: le astrazioni fra questi layer non sono definiti bene come osi osint.
Layer - 0 Internet Internet (semi-reliable point-to-point communication) and cryptography (specifically, cryptographic hash functions and secure digital signatures).
Layer - 1 Consensus Ci concentreremo sui protocolli di questo per la maggior parte di quanto faremo!</description>
    </item>
    <item>
      <title>La qualitÃ  del software</title>
      <link>https://flecart.github.io/notes/la-qualit%C3%A0-del-software/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/la-qualit%C3%A0-del-software/</guid>
      <description>Dato che il software sta diventando sempre piÃ¹ diffuso, diventa sempre piÃ¹ importante andare a definire delle metriche che possano garantirne la qualitÃ , ossia la non frequenza di errori o bug che possono in qualche modo limitarne la qualitÃ .
Error, Fault and Failure Secondo la definizione esatta data da IEEE, questi tre termini hanno un significato ben specifico, molto diverso.
Error, sono comportamenti non previsti da un comportamento dell&amp;rsquo;utente, oppure il programmatore capisce male le specifiche.</description>
    </item>
    <item>
      <title>Nomi e Scope</title>
      <link>https://flecart.github.io/notes/nomi-e-scope/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/nomi-e-scope/</guid>
      <description>I Nomi e oggetti Oggetti denotati e identificatoriðŸŸ© I nomi sono sequenze di caratteri o numeri aka: token alfanumerico (anche IDENTIFICATORE (per token guardare Grammatiche Regolari) utilizzate principalmente come Astrazione sul controllo e sui dati (quindi sono cose molto piÃ¹ facili da ricordare rispetto il suo encoding binario o a indirizzi). Infatti utilizziamo i nomi per evitare di interessarci di informazioni come lâ€™indirizzo di memoria del nostro dato o per creare una interfaccia con visibili solo nome della procedura e parametri.</description>
    </item>
    <item>
      <title>Relazioni di Ricorrenza</title>
      <link>https://flecart.github.io/notes/relazioni-di-ricorrenza/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/relazioni-di-ricorrenza/</guid>
      <description>Iterazione Questo metodo semplicemente consiste di calcolare tutte le operazioni e scriverlo con una notazione asintotica.
slide
Sostituzione (induzione) slide
Analisi della relazione di ricorrenza di fibonacci
Si puÃ² dimostrare utilizzando l&amp;rsquo;induzione che una relazione di questo tipo
$$ T(n) = \begin{cases} O(1) \\ T(n-1) + T(n-2) + 1 \end{cases} $$ Si trova che Ã¨ $O(2^n), \Omega(2^{n/2})$
Analisi finale.
Si puÃ² creare una stima corretta, utilizzando la formula per il calcolo di fibonacci (che dimostri facendo osservazioni su una funzione generatrice di essa, una serie infinita).</description>
    </item>
    <item>
      <title>Reti convoluzionali</title>
      <link>https://flecart.github.io/notes/reti-convoluzionali/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/reti-convoluzionali/</guid>
      <description>Abbiamo trattato i modelli classici in Convolutional NN. Con i vecchi files di notion
Il Kernel I punti interessanti delle immagini sono solamente i punti di cambio solo che attualmente siamo in stato discreto, quindi ci Ã¨ difficile usare una derivata, si usano kernel del tipo: $\left[ 1, 0, -1 \right]$, che sarÃ  positivo se cresce verso sinistra, negativo se scende. feature map Sono delle mappe che rappresentano alcune informazioni interessanti della nostra immagine.</description>
    </item>
    <item>
      <title>The Database Management System</title>
      <link>https://flecart.github.io/notes/the-database-management-system/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/the-database-management-system/</guid>
      <description>Struttura del DBMS Introduzione ai DBMS Schema riassuntivo #### Operazioni classiche Ci stiamo chiedendo, come facciamo a descrivere i processi che portano alla comprensione della query e della retrieval degli elementi utili? Questo deve fare il DBMS, ossia capace di - Aggiornare tuple - Trovare tuple - Gestire gli accessi - Gestire accessi concorrenti? ### Query processor #### Query compiler (3) ðŸŸ© - Parsing (crea l&#39;albero di derivazione per la nostra query) - Pre-processing (fa check semantici sulla query) - Optimization, si occupa lui di migliorare L&#39;ottimizzazione #### Execution engine ðŸŸ© Esegue l&#39;effettiva computazione per la query, ed Ã¨ il punto d&#39;incontro col resto (indexes, e logging per dire) Esegue il piano di esecuzione che probabilmente un livello superiore ha calcolato Interagisce con tutti gli altri componenti del db (ad esempio Log per transazioni e durabilitÃ , buffer e scheduler delle operazioni prolly).</description>
    </item>
    <item>
      <title>The RLHF pipeline</title>
      <link>https://flecart.github.io/notes/the-rlhf-pipeline/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/the-rlhf-pipeline/</guid>
      <description>https://huyenchip.com/2023/05/02/rlhf.html Ã¨ un blog post che lo descrive in modo abbastanza dettagliato e buono.
Introduzione a RLHF Questo Ã¨ il processo che Ã¨ quasi la migliore per la produzione di LLM moderni (maggior parte si basano su questo per dire).
Struttura generale Si puÃ² dire che RLHF si divida in 3 parti fondamentali
Completion il modello viene allenato a completare parole dal web,solitamente Ã¨ molto inutile Fine tuning per le singole task, per esempio riassumere, rispondere in certo modo etc.</description>
    </item>
    <item>
      <title>Alberi BST e AVL</title>
      <link>https://flecart.github.io/notes/alberi-bst-e-avl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/alberi-bst-e-avl/</guid>
      <description>Alberi BST e AVL 4.1 Alberi binari di ricerca (BST) Queste sono delle varianti rispetto all&amp;rsquo;albero, descritto in modo molto sommario sopra (binario perchÃ© ogni nodo ha al massimo due figli, mentre l&amp;rsquo;albero puÃ² averne quanti se ne vuole).
4.1.1 Introduzione La caratteristica principale dell&amp;rsquo;albero di ricerca Ã¨ una condizione sulle chiavi (che hanno i figli).
Infatti questo albero binario di ricerca si puÃ² vedere come una implementazione della struttura astratta del dizionario.</description>
    </item>
    <item>
      <title>Estensioni di Turing e altre macchine</title>
      <link>https://flecart.github.io/notes/estensioni-di-turing-e-altre-macchine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/estensioni-di-turing-e-altre-macchine/</guid>
      <description>Sono variazioni possibili equivalenti: â€¢ Nastri addizionali â€¢ Testine addizionali â€¢ Nastri infiniti su entrambi i lati â€¢ Non-determinismo â€¢ Scelta probabilistica â€¢ Scelta quantistica Si puÃ² dire che la definizione di TM Ã¨ stata robusta nella storia perchÃ© tantissimi formalismi che intuitivamente sembrano essere molto diversi rispetto alla TM alla fine possono essere dimostrate essere equivalenti.
Turing con nastri addizionali Questo Ã¨ presente in modo abbastanza facile sul Sipser.</description>
    </item>
    <item>
      <title>Halting Theorem and Reducibility</title>
      <link>https://flecart.github.io/notes/halting-theorem-and-reducibility/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/halting-theorem-and-reducibility/</guid>
      <description>Halting theorem Questo Ã¨ un problema fondamentale, che abbiamo trattato anche in Fondamenti teorica#Halting problem, ma qui lo ritrattiamo, perchÃ© cosÃ¬ lo rifacciamo per bene. In parte Ã¨ stato trattato anche al corso di Logica.
Enunciato Halting theoremðŸŸ© Questo Ã¨ molto simile a quanto presente sul (Sipser 2012). Ossia consideriamo il linguaggio $$ HALT = \left\{ \langle x, y \rangle \in \Sigma^{*} \times \Sigma^{*}: x = code(M),M \text{ si ferma su } x\right\} $$ Dimostrazione Halting theoremðŸŸ© La parte del sÃ¬ Ã¨ facile perchÃ© basta eseguirlo e vedere che si ferma (quindi abbiamo una La macchina di Turing#La macchina di Turing universale.</description>
    </item>
    <item>
      <title>Livello applicazione e socket</title>
      <link>https://flecart.github.io/notes/livello-applicazione-e-socket/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/livello-applicazione-e-socket/</guid>
      <description>Livello trasporto Protocolli classici Introduzione a TCP e UPD Il quarto livello dei protocolli dellâ€™architettura di Internet Ã¨ il livello trasporto (transport), ed Ã¨ basato su due protocolli in particolare: il Transmission Control Protocol (TCP) e lo User Data Protocol (UDP), che possono essere usati in alternativa tra loro.
Questo Ã¨ nel genere di *connession oriented e non, il primo, TCP Ã¨ connection oriented, l&amp;rsquo;altro no, questa Ã¨ lâ€™unica differenza fra i due.</description>
    </item>
    <item>
      <title>Notazione Asintotica</title>
      <link>https://flecart.github.io/notes/notazione-asintotica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/notazione-asintotica/</guid>
      <description>Introduzione alla notazione asintotica Cercare di definire il tempo impiegato da una funzione per essere eseguita in termini di DIMENSIONE dell&amp;rsquo;input. **(il numero di bit a livello basso basso)
Ma abbiamo il problema di misura, in quanto dobbiamo considerare delle variabili che siano indipendenti rispetto alla macchina.
Caratteristiche della notazione Vogliamo considerare una notazione asintotica (che guarda quanto fa il comportamento verso l&amp;rsquo;infinito)
Funzione di costo Modelli asintotici Abbiamo trattato di o-piccolo e ogrande in Analisi.</description>
    </item>
    <item>
      <title>Polimorfismo</title>
      <link>https://flecart.github.io/notes/polimorfismo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/polimorfismo/</guid>
      <description>Introduzione Monoforfo ðŸŸ© Quando non posso utilizzare un tipo come parametro. Ossia non possiamo definire una funzione generica.
Slide monomorfismo
Polimorfismo Polimorfismo, come dice il nome, significa avere tante forme, in questo caso tanti tipi. Ma avere tanti tipi non Ã¨ una cosa ambigua? Questa cosa si risolve solitamente a compile time (facendo checks di sottotipo, oppure dispatch della funzione corretta).
Tipologie di Polimorfismo (3) ðŸŸ© Slide tipologie di monomorfismo</description>
    </item>
    <item>
      <title>Project Management</title>
      <link>https://flecart.github.io/notes/project-management/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/project-management/</guid>
      <description>Project, product management, project management Bisogna capire queste definizioni. Vedere https://dynamik.vercel.app/ingegneria-del-software/lucidi/13-gestione-del-progetto.pdf?from=informatica, slide 5 per definizione
Progetto: inizia e finisce in tempo preciso. Ãˆ importante comunque ricordare gli steps principali per il progetto ossia ideazione, creazione, mantenimento, rilascio, e poi morte, questo in genere Ã¨ per qualunque progetto.
Project Manager Compiti principali (costi e risorse) Vedere se il progetto Ã¨ fattibile Allocare risorse Monitorare come sta andando. (preventivo e consuntivo). Work Breakdown structure Descrizione WBS Ãˆ una suddivisione del progetto in piccoli sottoparti che si possono gestire in modo autonomo.</description>
    </item>
    <item>
      <title>Tarjan e MCMF</title>
      <link>https://flecart.github.io/notes/tarjan-e-mcmf/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/tarjan-e-mcmf/</guid>
      <description>Questa sezione la tengo separata rispetto agli altri per favorire lo studio, cosÃ¬ questa roba nuova la ripasso piÃ¹ spesso, in seguito si puÃ² accorpare.
Goldberg Tarjan/Push-relabel Questo algoritmo Ã¨ importante perchÃ© introduce ragionamenti sul minimo locale che possa alla fine essere ricomposto come soluzione globale.
Questa lezione youtube lo spiega da Dio
Preflusso ðŸŸ© Slide
La parte nuova di questa cosa Ã¨ che i vincoli di bilanciamento possono diventare una disuguaglianza.</description>
    </item>
    <item>
      <title>Top-down Parser</title>
      <link>https://flecart.github.io/notes/top-down-parser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/top-down-parser/</guid>
      <description>Top-down Algoritmo di parsing ðŸŸ© Slide
Questo si potrebbe considerare come algoritmo classico di parsing con non determinismo. (vado avanti, ed esploro tutto, senza look ahead).
Esempio di esecuzione
Commenti efficienza di sopra ðŸŸ© Ãˆ molto inefficiente, in particolare si potrebbe trovare una compessitÃ  esponenziale del tipo
$O(b^{|w|})$, con b il massimo numero di produzioni. (la produzione maggiore la espando sempre!)
Slide
Si puÃ² rendere molto piÃ¹ efficiente con un valore di lookahead.</description>
    </item>
    <item>
      <title>Autoencoders</title>
      <link>https://flecart.github.io/notes/autoencoders/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/autoencoders/</guid>
      <description>In questa serie di appunti proviamo a descrivere tutto quello che sappiamo al meglio riguardanti gli autoencoders Blog di riferimento Blog secondario che sembra buono
Introduzione agli autoencoders L&amp;rsquo;idea degli autoencoders Ã¨ rappresentare la stessa cosa attraverso uno spazio minore, in un certo senso Ã¨ la compressione con loss. Per cosa intendiamo qualunque tipologia di dato, che puÃ² spaziare fra immagini, video, testi, musica e simili. Qualunque cosa che noi possiamo rappresentare in modo digitale possiamo costruirci un autoencoder.</description>
    </item>
    <item>
      <title>Common problems in Theoretical CS</title>
      <link>https://flecart.github.io/notes/common-problems-in-theoretical-cs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/common-problems-in-theoretical-cs/</guid>
      <description>This note is useful to gather in a single place the description of some common problems in CS and their theoretical implications explained in other notes.
The Clique problem Description of the problem This problem is in NP, find all sub-graphs where all nodes are connected (this set of nodes forms a complete graph).
We can prove that the problem is in NP because there is an easy non-deterministic algorithm that computes it.</description>
    </item>
    <item>
      <title>CSS</title>
      <link>https://flecart.github.io/notes/css/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/css/</guid>
      <description>Cascading Style Sheets Inizialmente HTML era per la presentazione, abbiamo ancora un pÃ² di attributi storici e tag storici per questa parte di presentazione descritto in HTML e Markup.
Introduzione Ãˆ un linguaggio indipendente per la descrizione della grafica. La cosa bella Ã¨ iil fatto di essere indipendente, quindi Ã¨ adatto a HTML, a XML e simili.
Una cosa particolare Ã¨ il cascading quindi il fatto che dichiarazioni piÃ¹ nuove sovrascrivano o espandino dichiarazione vecchie.</description>
    </item>
    <item>
      <title>Effetti del linguaggio</title>
      <link>https://flecart.github.io/notes/effetti-del-linguaggio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/effetti-del-linguaggio/</guid>
      <description>In questa nota proviamo a cercare di descrivere bene l&amp;rsquo;analisi degli effetti del linguaggio che possono avere a che fare con theory of mind.
(Mahowald et al. 2023) Inizia a fare una bella analisi riguardante la differenza di conoscenza sintattica e funzionale del linguaggio. Molte references all&amp;rsquo;aspetto del cervello per quella roba.
References [1] Mahowald et al. â€œDissociating Language and Thought in Large Language Models: A Cognitive Perspectiveâ€ 2023</description>
    </item>
    <item>
      <title>Problemi di accoppiamento</title>
      <link>https://flecart.github.io/notes/problemi-di-accoppiamento/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/problemi-di-accoppiamento/</guid>
      <description>I problem idi accoppiamento sono abbastanza comuni per ottimizzazione a grafi. In questa serie di note andiamo a trattare brevemente i problemi principali, con un accenno veloce ad alcuni algoritmi di soluzione per esse.
Grafo bipartitoðŸŸ© Un grafo bipartito Ã¨ un insieme $(O \cup D), (A)$ di nodi e di archi. Tutti i nodi sono o fra i nodi di origine oppure fra i nodi di destinazione, e gli archi sono solamente collegati fra nodi di origine e nodi di destinazione.</description>
    </item>
    <item>
      <title>Gestione delle risorse</title>
      <link>https://flecart.github.io/notes/gestione-delle-risorse/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gestione-delle-risorse/</guid>
      <description>Gestione delle risorse Introduzione Definizione classe, fungibilitÃ  Classe di risorse sono un insieme di risorse fra loro equivalenti (nel senso che uno puÃ² rimpiazzare lâ€™uso dell&amp;rsquo;altro), anche detti fungibili.
Statico o dinamico Anche in economia ci sono tali definizioni! Queste risorse possono essere allocate staticamente o dinamicamente, in modo simile a quanto abbiamo detto in Gestione della memoria.
Statico quando giÃ  in fase di compilazione del processo, o di avviamento del processo gli dÃ² la memoria, e quella sarÃ  per tutti il tempo della sua vita.</description>
    </item>
    <item>
      <title>Introduzione a ottimizzazione Combinatoria</title>
      <link>https://flecart.github.io/notes/introduzione-a-ottimizzazione-combinatoria/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-a-ottimizzazione-combinatoria/</guid>
      <description>Lâ€™ottimizzazione combinatoria Ã¨ un altro nome per la ricerca operativa. Ãˆ uno strumento utile a prendere le decisioni migliori, fatto sta che Ã¨ anche molto utile al machine learning e si potrebbe dire che ne sia una base, questa Ã¨ una cosa molto buona.
Ricerca operativa Questo Ã¨ un campo a forte impatto economico perchÃ© prova a minimizzare i costi e massimizzare i profitti.
Steps ðŸŸ©, ðŸŸ¨ Individuazione del problema (almeno riconoscere che ci sia un problema) Raccoglimento dei dati Modellizzazione del problema Ricerca di una soluzione Analisi dei risultati della soluzione La ricerca operativa si interessa principalmente degli step 3 e 4, nonostante gli steps non sempre vengono eseguiti in maniera lineare, ma câ€™Ã¨ un ciclo di feedback a riguardo.</description>
    </item>
    <item>
      <title>Wireless attack vectors</title>
      <link>https://flecart.github.io/notes/wireless-attack-vectors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/wireless-attack-vectors/</guid>
      <description>In this note we will talk about some common ways to attack wireless based devices.
Attacking an automated door Usually these doors are opened by radio frequency keys, and can be opened easily (e.g. replay attacks, Jam the frequency)
Jamming This is the easiest way to attack. Just send many signals to make a certain frequency un-usable in our space. But with Frequency hopping this attack is solved. See Tecnologia Wireless#Frequency Hopping But this method could be easily known and observed (enables eavesdropping, against confidentiality, a principle in Theoretical Notions of Security#CIAA principles of security.</description>
    </item>
    <item>
      <title>Base e dimensione</title>
      <link>https://flecart.github.io/notes/base-e-dimensione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/base-e-dimensione/</guid>
      <description>2.1 Basi 2.1.1 Definizione Un insieme di vettori $v_1,...,v_n$ sono basi di uno spazio vettoriale $V$ se sono soddisfatte queste proprietÃ 
$V = \langle v_1,...,v_n\rangle$ $v_1,...,v_n$ sono linearmente indipendenti Dalla proprietÃ  2 potremmo anche dire che Ã¨ il minimo insieme di vettori necessario per avere questa base.
Finitamente generato
Se l&amp;rsquo;insieme dei vettori nella base Ã¨ finito allora posso dire che Ã¨ finitamente generato
Ma possiamo trovare anche spazi che non sono finitamente generati come $\R[x]$ che non hanno un numero finito di basi (perchÃ© dipende dal grado dei polinomi che puÃ² essere infinito).</description>
    </item>
    <item>
      <title>Condensatori nel vuoto</title>
      <link>https://flecart.github.io/notes/condensatori-nel-vuoto/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/condensatori-nel-vuoto/</guid>
      <description>Introduzione ai condensatori Analisi introduttiva condensatori: tubi di flusso ðŸŸ© Consideriamo un **tubo di flusso infinitesimo** come in immagine. abbiamo che $dQ$ Ã¨ la carica totale dentro al cubo. Tale che segua le linee di campo. Il flusso totale sarebbe $$ \oint_{\Sigma} \vec{E} \cdot d\vec{s} = \frac{Q_{T}}{\varepsilon_{0}} $$ Sappiamo anche che $$ \vec{E}_{1}d\vec{s}_{1} + \vec{E}_{2}d\vec{s}_{2} = \frac{dQ_{T}}{\varepsilon_{0}} $$ Ma scegliamo il cubo di flusso in modo che le superfici siano **perpendicolari al nostro campo**, e cosÃ¬ posso considerare il problema da un puro punto di vista **scalare**.</description>
    </item>
    <item>
      <title>Integrali</title>
      <link>https://flecart.github.io/notes/integrali/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/integrali/</guid>
      <description>8.1 Introduzione 8.1.1 Il problema che risolve Vogliamo cercare di creare un metodo matematico che sia utile per calcolare area di qualunque curva.
L&amp;rsquo;idea principale per risolvere questo problema Ã¨ approssimare l&amp;rsquo;area, lo facciamo utilizzando rettangoli, la formalizzazione sarÃ  molto aiutata dal limite.
8.1.2 Sottografico di funzione $$ A = \{ (x,y) \in \R^2 | x \in D(f(x)), 0\leq y \leq f(x)\} $$ Praticamente sto prendendo tutti in punti positivi sotto al grafico.</description>
    </item>
    <item>
      <title>Reinforcement Learning, a introduction</title>
      <link>https://flecart.github.io/notes/reinforcement-learning-a-introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/reinforcement-learning-a-introduction/</guid>
      <description>Introduzione Una delle idee migliori riguardanti questo campo del reinforcement learning Ã¨ il focus sul processo decisionale del singolo agente, condizionato al reward che lâ€™ambiente esterno gli dÃ  (feedback). Il setting classico di questo genere di problemi Ã¨ un caso speciale della caratterizzazione presente in lâ€™intelligenza.
Abbiamo in questo caso un agente allâ€™interno del suo ambiente. Lâ€™agente Ã¨ in grado di interagire col suo ambiente attraverso alcune azioni ben definite, e lâ€™ambiente restituisce un feedback ad ogni azione.</description>
    </item>
    <item>
      <title>Scheduler</title>
      <link>https://flecart.github.io/notes/scheduler/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/scheduler/</guid>
      <description>Il suo scopo principale Ã¨ gestire l&amp;rsquo;avvicendamento dei processi. Ad esempio sospendere il processo che chiede I/O. O un sistema time sharing, quando arriva un interrupt sul time.
Solitamente il nome scheduler Ã¨ solamente un gestore dell&amp;rsquo;avvicendamento, si puÃ² quindi utilizzare per indicare scheduler di altro tipo.
Note introduttive Diagramma di Gantt Questo Ã¨ il diagramma per presentare lo scheduling, ossia da quando a quando Ã¨ eseguito cosa
Esempio gantt</description>
    </item>
    <item>
      <title>Transformers</title>
      <link>https://flecart.github.io/notes/transformers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/transformers/</guid>
      <description>TODO.
Positional encoding We need to keep positional information about the contents.
Th: High dimensional unit vectors are almost always orthogonal This theorem states that given $a, b \in \mathbb{R}^{n}$, and $\lVert a \rVert = \lVert b \rVert = 1$ we have that it is highly probable that $a \cdot b &lt; \varepsilon$. For a small epsilon. This is not exactly a formal proof (we haven&amp;rsquo;t formalized the idea of highly probable).</description>
    </item>
    <item>
      <title>Advanced SQL</title>
      <link>https://flecart.github.io/notes/advanced-sql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/advanced-sql/</guid>
      <description>Check function A volte puÃ² essere molto pesante, perchÃ©
What does check do? Viene utilizzato per introdurre un constraint check per avere sicurezza su un range. Check e innestamenti ðŸŸ©- PuÃ² essere che certe implementazioni non permettano il check innestato, questo Ã¨ una cosa molto pesante, perchÃ© ogni modifica deve andare a rifare la modifica ai subalterni, quindi questo Ã¨ pesante pesante.
Assertions ðŸŸ©&amp;ndash; Sono dei check fatti al livello dello schema, quindi valgono sempre, e possono essere riutilizzati in table diversi credo.</description>
    </item>
    <item>
      <title>Analisi multi-variabile</title>
      <link>https://flecart.github.io/notes/analisi-multi-variabile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/analisi-multi-variabile/</guid>
      <description>In questo capitolo cerchiamo di andare oltre alla singola dimensione per l&amp;rsquo;analisi.
Lo spazio $\mathbb{R}^{n}$ Possiamo definire uno spazio Rn come il prodotto cartesiano fra l&amp;rsquo;insieme R un numero di volte uguale a n $\mathbb{R} \times \mathbb{R} \times ... \times\mathbb{R} = \mathbb{R}^n$
Allora un tipico elemento in Rn Ã¨ nella forma $(x_1,...,x_n)$, questo elemento si chiama punto, mentre gli elelmenti in R che costituiscono questo elemento si chiamano componenti.
Osservazione La maggior parte dei risultati che dimostro nello spazio ordinario (R3) si puÃ² dimostrare per Rn, non andiamo piÃ¹ nel dettaglio perchÃ© i problemi che ho in spazi maggiori sono parte di materiale per analisi 2</description>
    </item>
    <item>
      <title>Asymmetric Cryptography</title>
      <link>https://flecart.github.io/notes/asymmetric-cryptography/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/asymmetric-cryptography/</guid>
      <description>Public Key Encryption We now define a formally what is a public key encryption
Formal definition of Public Key Encryption We define a 3-tuple formed as follows: $(G, E, D)$ where
$G$ is the generator for the private and public keys, from now on identified as $(pk, sk)$ (public key and secret key) $E(pk, m)$ the encryption algorithm, that takes the $pk$ and the message in input $D(sk, c)$ the decryption algorithm, that takes the $sk$ and the ciphertext in input.</description>
    </item>
    <item>
      <title>Classical Cyphers</title>
      <link>https://flecart.github.io/notes/classical-cyphers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/classical-cyphers/</guid>
      <description>Introduzione a Crittografia al corso di crittografia di Christof Paar su Youtube, con aggiunte del corso Unibo.
Classifications and definitions Classification nowadays as many many applications like, and itâ€™s a increasing important field
Cryptology (2) ðŸŸ© La branca comunemente riferita come crittografia Ã¨ divisa principalmente in due campi crittografia e cryptanalysis in cui una cerca di creare nuovi metodi per cifrare i messaggi, e lâ€™altro prova ad attaccare questi messaggi ritrovando il messaggio originale.</description>
    </item>
    <item>
      <title>Continuity</title>
      <link>https://flecart.github.io/notes/continuity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/continuity/</guid>
      <description>This is one of the most basic, but important concepts in topology. We want to define this concept clearly and precisely as a mathematician would do it. These ideas are used in real analysis quite often, but here we want to restate some important things
Definitions Open sets Closed sets </description>
    </item>
    <item>
      <title>The Neuron</title>
      <link>https://flecart.github.io/notes/the-neuron/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/the-neuron/</guid>
      <description>La struttura del neurone Parti strutturali principali (2) ðŸŸ© Possiamo identificare tre parti principali per quanto riguarda la struttura di un singolo neurone
Assoni che si occupano di mandare activation potential signal all&amp;rsquo;esterno, a comunicare con altre cellule. Il segnale che parte dall&amp;rsquo;assone inizia da una sezione che viene chiamato segmento iniziale. Dentriti che si occupano di ricevere segnali da altri neuroni. Gli assoni e dentriti non sono connessi, ma c&amp;rsquo;Ã¨ un piccolo spazio in mezzo a questi che si chiama Synaptic cleft, (la scoperta di questo Ã¨ stato di stupore, in passato pensavano che fosse una cosa continua il cervello, invece abbiamo qualche piccola unitÃ  discreta, scoperto con la colorazione d&amp;rsquo;argento metodi di Golgi) l&amp;rsquo;informazione in questo spazio pre e post sinaptico Ã¨ gestito da neurotrasmettitori.</description>
    </item>
    <item>
      <title>TLS-SSL protocol</title>
      <link>https://flecart.github.io/notes/tls-ssl-protocol/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/tls-ssl-protocol/</guid>
      <description>First time we talked about this was in Sicurezza delle reti#Protocollo SSL But that was a simple toy model.
Secure Socket Layer Secure socket Layer and TLS add security (see security principles in Theoretical Notions of Security) on the transport layers, whereas IPSec protocol adds it to the network level. So this works on a higher level of abstraction following the ISO OSI framework Architettura e livelli 1, 2#Livelli ISO/OSI.</description>
    </item>
    <item>
      <title>Entropy</title>
      <link>https://flecart.github.io/notes/entropy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/entropy/</guid>
      <description>Entropy Questo Ã¨ stato creato da 1948 Shannon in (Shannon 1948). Questa nozione Ã¨ basata sulla nozione di probabilitÃ , perchÃ© le cose rare sono piÃ¹ informative rispetto a qualcosa che accade spesso. This is dependent on the notion of the Shannon information content defined as $$ h(x = a_{i}) = \log_{2}\frac{1}{P(x = a_{i})} $$ We will see that the entropy is a weighted average of the information, so the expected information content in a distribution.</description>
    </item>
    <item>
      <title>Fourier Series</title>
      <link>https://flecart.github.io/notes/fourier-series/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/fourier-series/</guid>
      <description>Intuition The most important observation that allows Fourier series approximation is that given $k = 1, 2, \dots$ we have that $$ \frac{1}{\sqrt{ 2\pi }}, \frac{\cos(kx)}{\sqrt{ \pi }}, \frac{\sin(kx)}{\sqrt{ \pi }}, \dots $$ Form a infinitely dimensional orthonormal basis given the integral relations $$ \int_{0}^{2\pi} (\sin (kx))^{2} \, dx = \int_{0}^{2\pi} (\cos(kx))^{2} \, dx = \pi $$ $$ \int_{0}^{2\pi}\sin(kx)\sin(hx) \, dx = \int_{0}^{2\pi}\cos(kx)\cos(hx) \, dx = 0 $$ And that $$ \int_{0}^{2\pi}\sin(kx)\cos(hx) \, dx = \int_{0}^{2\pi} \sin(kx) \, dx = \int_{0}^{2\pi}\cos(hx) \, dx = 0 $$ Proofs of the relations In this section we quickly prove why the above equations hold.</description>
    </item>
    <item>
      <title>Optimization methods</title>
      <link>https://flecart.github.io/notes/optimization-methods/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/optimization-methods/</guid>
      <description>Metodi altri sono trovare una approssimazione facile da calcolare (simile all&amp;rsquo;approccio del modello surrogato credo). Ma nel nostro caso proviamo a trovare metodi di esplorare lo spazio dei parametri in modo intelligente.
Deterministic methods Sono utilizzabili quando ci sono delle proprietÃ  come convessitÃ , limitatezza, continuitÃ .
Newton Raphson method Molte implementazioni in R usano questo metodo, Ã¨
Perfetto quando $h$ Ã¨ quadratico, e in statistica molti problemi sono quadratici e funziona in modo perfetto Ma in cose non lineari si ha meno performance (perchÃ© l&amp;rsquo;hessiana Ã¨ molto instabile per l&amp;rsquo;inversione, si dice che Ã¨ mal condizionata, e si fa con attenzione.</description>
    </item>
    <item>
      <title>Analisi di ConvessitÃ </title>
      <link>https://flecart.github.io/notes/analisi-di-convessit%C3%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/analisi-di-convessit%C3%A0/</guid>
      <description>Questo argomento Ã¨ stato trattato durante dopo la discussione dei Massimi minimi multi-variabile, perÃ² Ã¨ stato ripreso anche nella forma R to R, quindi credo necessiti di un foglio a parte.
Affine set Lines Let&amp;rsquo;s take two points in $\mathbb{R}$ $x_{1}, x_{2}$, if we consider the parametrization $$ x = \theta x_{1} + (1 - \theta)x_{2} $$ This is a parametrization of the line Example:
Def: affine set A combination where the coefficients add up to 1.</description>
    </item>
    <item>
      <title>Bag of words</title>
      <link>https://flecart.github.io/notes/bag-of-words/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bag-of-words/</guid>
      <description>Bag of words only takes into account the count of the words inside a document, ignoring all the syntax and boundaries. This method is very common for email classifications techniques.
Introduzione a bag of words Faremo una introduzione di applicazione di NaÃ¯ve Bayes applicato alla classificazione di documenti.
Setting del problema ðŸŸ¨+ Questo Ã¨ una parte che Ã¨ importante nel caso volessimo fare document classification. e simili, In questa brevissima introduzione cerchiamo di calcolare $$ \theta_{i, \text{word}, l} = P(X_{i} = \text{word} | Y = l) $$ Ossia quanto Ã¨ probabile che una parola sia word, che appaia alla posizione i, data la categoria $l$ del documento Assumendo che non dipenda dalla posizione posso solamente contare le parole per documento fregandomene della posizione, questa Ã¨ l&amp;rsquo;idea che ha portato ai primi approcci in questo campo.</description>
    </item>
    <item>
      <title>Linguaggi Deterministici e DPDA</title>
      <link>https://flecart.github.io/notes/linguaggi-deterministici-e-dpda/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/linguaggi-deterministici-e-dpda/</guid>
      <description>DPDA Definizione (2)ðŸŸ© La definizione di DPDA Ã¨ molto simile a quella trattata in Linguaggi liberi e PDA, con solo costraints sulla deterministicitÃ , che si traducono in due condizioni:
Al massimo posso avere un risultato per ogni coppia di lettura e simbolo su stack Se ho una transizione senza leggere, posso avere solo quella Slide
Linguaggio libero deterministico Un linguaggio Ã¨ libero deterministico se esiste un PDA che lo riconosce per stato finale.</description>
    </item>
    <item>
      <title>Metadati web e web semantico</title>
      <link>https://flecart.github.io/notes/metadati-web-e-web-semantico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/metadati-web-e-web-semantico/</guid>
      <description>Ripasso: May 19, 2023 Ultima modifica: May 11, 2023 8:38 PM Primo Abbozzo: May 5, 2023 2:21 PM Studi Personali: No
Metadati web https://csunibo.github.io/tecnologie-web/lucidi/teoria/23-metadati.pdf https://csunibo.github.io/tecnologie-web/lucidi/teoria/24-a-web-semantico-lod-rdf-json-ld.pdf
inconfrontabilitÃ  del sapere Stessa informazione in forme diverse Stessa parola per cose diversa. Serializzazione La semantica Ã¨ relegata alle applicazioni che devono decidere in che modo interpretarli, oppure esseri umani.
PICS Platform for Internet Content Selection vuole cercare di tenere sotto controllo i materiali del film.</description>
    </item>
    <item>
      <title>Tecniche algoritmiche</title>
      <link>https://flecart.github.io/notes/tecniche-algoritmiche/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/tecniche-algoritmiche/</guid>
      <description>In questa nota andiamo a parlare in modo sommario (si impara probabilmente molto meglio con la pratica) di generali tipologie di approcci che esistono per affrontare problemi di tipo algoritmico.
Divide et impera Introduzione Abbiamo giÃ  visto L&amp;rsquo;utilizzo di questa tecnica per quick e merge sort in Algoritmi di ordinamento
Questa tecnica si focalizza in tre passi fondamentali:
Dividere il problema in sotto-problemi Risolvere il sotto-problema Mergiare le soluzioni di questi sotto-problemi.</description>
    </item>
    <item>
      <title>Algebra dei tipi</title>
      <link>https://flecart.github.io/notes/algebra-dei-tipi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algebra-dei-tipi/</guid>
      <description>Equivalenza dei tipi (2) ðŸŸ© Quando possiamo dire che due tipi siano uguali? Solitamente vengono utilizzati due metodi:
Equivalenza Nominale Quando un nuono tipo introduce un nuovo nome diverso fra tutti i presenti. Credo cosÃ¬ vada golang. Quindi in questo caso si puÃ² dire che un tipo Ã¨ equivalente solamente a sÃ© stesso.
Vogliamo fare in questo modo perchÃ© se definiamo un nuovo tipo solitamente dovrebbe avere funzioni diverse, quindi Ã¨ giusto che sia diverso da uqello iniziale.</description>
    </item>
    <item>
      <title>Javascript</title>
      <link>https://flecart.github.io/notes/javascript/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/javascript/</guid>
      <description>Ripasso: May 14, 2023 Ultima modifica: May 6, 2023 6:25 PM Primo Abbozzo: March 20, 2023 3:16 PM Studi Personali: No
Elementi di ripasso Javascript Obiettivo principale Ã¨ esegurie codice clientside
Un pÃ² di storia nato allâ€™inizio della prima guerra dei browser (da netscape, explorer Ã¨ in visual basic comunque non compatibile con JS) come il fratellino di java nel senso che runnava ovunque, attualmente Ã¨ ECMAScript, ed Ã¨ la versione migliore.</description>
    </item>
    <item>
      <title>Livello ISA</title>
      <link>https://flecart.github.io/notes/livello-isa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/livello-isa/</guid>
      <description>il livello isa Ã¨ il livallo delle istruzioni
8.1 Struttura Solitamente le istruzioni sono divise in due parti:
8.1.1 Opcode e indirizzamento Opcode
Questo opcode indica la tipologia di istruzione.
Per esempio per l&amp;rsquo;architettura HACK Ã¨ il primo bit, che indica se Ã¨ una istruzione C oppure una istruzione A.
Questo insieme poi alle altre istruzioni che definiscono cosa deve fare costituiscono OPcode.
Indirizzamento
Poi c&amp;rsquo;Ã¨ una sezione che indirizza, cioÃ¨ dice all&amp;rsquo;istruzione cosa deve prendere e dove deve salvare.</description>
    </item>
    <item>
      <title>Logica meta-linguistica</title>
      <link>https://flecart.github.io/notes/logica-meta-linguistica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/logica-meta-linguistica/</guid>
      <description>Con questo documento iniziamo a parlare di logica, alcuni paradossi famosi all&amp;rsquo;interno di questo mondo.
Paradossi Metalinguistici Antinomie e Paradossi Antinomia Definizione di antinomia Ã¨ un ragionamento corretto da cui deriva una conclusione errata, probabilmente Ã¨ l&amp;rsquo;insieme o campo in cui stiamo operando ad essere errato e bisogna cercare di ridefinirlo in modo piÃ¹ corretto, in quanto le premesse erano accettabili
Paradosso Paradosso quando il ragionamento corretto va contro l&amp;rsquo;intuizione, come il paradosso dei gemelli in fisica e simili.</description>
    </item>
    <item>
      <title>N-Bandit Problem</title>
      <link>https://flecart.github.io/notes/n-bandit-problem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/n-bandit-problem/</guid>
      <description>Impostazione del problema Supponiamo di stare giocando a n slot machine contemporaneamente. Queste macchine hanno internamente un valore di reward che non conosciamo. Ad ogni step possiamo scegliere una singola macchina e andare a tirare la sua leva. Riceviamo il valore del reward nascosto con un pÃ² di rumore. Vogliamo capire nel lungo quale sia la strategia che possa dare migliore reward medio possibile.
Questo Ã¨ un semplice problema, ma lo possiamo considerare un fulcro molto importante per poter comprendere il problema del reinforcement learning.</description>
    </item>
    <item>
      <title>Probabilistic Turing Machines</title>
      <link>https://flecart.github.io/notes/probabilistic-turing-machines/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/probabilistic-turing-machines/</guid>
      <description>Introduction to the probabilistic Turing Machine Most of real phenomena are better comprehended by a probabilistic view. This pushes to build a formal model that takes probability into account
Def: Probabilistic TM Take a non deterministic TM La macchina di Turing. At each step there is a fair coin-flip that has two legal branches. So the probability of a certain branch is $$ \mathbb{P}(b) = 2^{-k} $$ Where $k$ is the length of the branch.</description>
    </item>
    <item>
      <title>Backpropagation</title>
      <link>https://flecart.github.io/notes/backpropagation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/backpropagation/</guid>
      <description>Backpropagation is perhaps the most important algorithm of the 21th century. It is used everywhere in machine learning. It has also connected to computing marginal distributions. This is the motivation why all machine learning scientists, all data scientists should understand this algorithm very well. An important observation is that this algorithm is linear: the time complexity is the same as the forward pass. Karpathy has a nice resource for this topic.</description>
    </item>
    <item>
      <title>Divergenza e Circuitazione</title>
      <link>https://flecart.github.io/notes/divergenza-e-circuitazione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/divergenza-e-circuitazione/</guid>
      <description>Scalare Scalare e gradiente ðŸŸ© Un campo scalare assegna a ogni punto dello spazio un valore reale, quindi Ã¨ naturalmente rappresentabile tramite una funzione $$ \varphi(x, y, z) : \mathbb{R}^{3} \to \mathbb{R} $$ Un esempio abbastanza naturale Ã¨ il gradiente del valore scalare che si indica con $$\vec{\nabla}\varphi = ( \frac{\delta\varphi}{\delta x}, \frac{\delta\varphi}{\delta y}, \frac{\delta\varphi}{\delta z}) = \frac{\delta\varphi}{\delta x} \hat{i} + \frac{\delta\varphi}{\delta y} \hat{j} + \frac{\delta\varphi}{\delta z} \hat{k}$$ Se consideriamo il gradiente da solo Ã¨ un campo vettoriale (dice la direzione della derivata multidimensionale).</description>
    </item>
    <item>
      <title>Fondamenti teorica</title>
      <link>https://flecart.github.io/notes/fondamenti-teorica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/fondamenti-teorica/</guid>
      <description>https://virtuale.unibo.it/pluginfile.php/1295166/mod_resource/content/0/Lez18-Gorrieri.pdf
Halting problem Questo asserisce che non esiste nessun programma che sia in grado di decidere la terminazione di un altro programma
Questo Ã¨ un problema che ci Ã¨ interessante perchÃ© vorremmo costruire un compilatore che sia in grado di osservare tutti gli errori possibili del programma. Come vedremo tra poco la risposta sarÃ  negativa.
Dimostrazione tesi ðŸŸ¨++ Supponiamo che questo programma esista, lo chiamiamo check(P) che restituisce 0 se termina 1 se non termina, allora devo poter essere in grado di scrivere un programma di questo genere</description>
    </item>
    <item>
      <title>Hopital, Taylor, Peano</title>
      <link>https://flecart.github.io/notes/hopital-taylor-peano/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/hopital-taylor-peano/</guid>
      <description>7.1 De Hopital 7.1.1 Lemmi preliminari Questo lemma preliminare era giÃ  presente per la prova del teorema degli zeri
Questo lemma Ã¨ molto interessante perchÃ© mette in relazione il finito (le successioni) con l&amp;rsquo;infinito (i reali) In molte dimostrazioni si dÃ  per scontato questo lemma, ma Ã¨ una sottigliezza importante che giustifica l&amp;rsquo;utilizzo di successioni per limiti reali. Ci permette di semplificare molto le dimostrazioni perchÃ© riusciamo a trattare le successioni molto meglio.</description>
    </item>
    <item>
      <title>Introduction to Convex Optimization</title>
      <link>https://flecart.github.io/notes/introduction-to-convex-optimization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduction-to-convex-optimization/</guid>
      <description>A brief history This field was quite developed in 1970 (started in 1920) when mathematicians had the same problem over and over again and needed a name. But this was only the theory. The practical applications came later. A modern use is in machine learning a statistics.
Form historical point of view
1947 simplex method popularized by Dantzig at Stanford Many people in soviet union in the Â´60 worked on this (they already know about he applications!</description>
    </item>
    <item>
      <title>Introduzione ad architettura</title>
      <link>https://flecart.github.io/notes/introduzione-ad-architettura/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-ad-architettura/</guid>
      <description>1.1 Il principio di astrazione/implementazione Astrazione per macchine livello n con linguaggi n.
1.2 I livelli principali di astrazione Livelli in breve
1.2.1 Livello 0 Qua Ã¨ utile indagare la
Porte Logiche in cui si indagano in un modo molto alto il funzionamento di porte
Ãˆ il livello fisico delle porte logiche e dell&amp;rsquo;ingegneria elettrica.
1.2.2 Livello 1 Link utili potrebbero essere la CPU e storia degli elaboratori
Circuiti Sequenziali Ossia la Memoria</description>
    </item>
    <item>
      <title>Spazi vettoriali</title>
      <link>https://flecart.github.io/notes/spazi-vettoriali/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/spazi-vettoriali/</guid>
      <description>Spazi vettoriali 1.1 Piano cartesiano 1.1.1 Definizione Possiamo considerare il piano cartesiano come l&amp;rsquo;insieme $\R^2$ potremmo dire che esiste una corrispondenza fra una coordinata e un punto del piano, una volta che abbiamo definito un punto di origine. Si puÃ² vedere anche come corrispondenza biunivoca con vettori del piano per l&amp;rsquo;origine (parte dall&amp;rsquo;origine).
Questa cosa vale anche per uno spazio n-dimensionale, non soltanto due, ma per semplicitÃ  di introduzione di questo lo faccio con 2</description>
    </item>
    <item>
      <title>Analysis of Neural Codes</title>
      <link>https://flecart.github.io/notes/analysis-of-neural-codes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/analysis-of-neural-codes/</guid>
      <description>Metodi di registrazione informazione Ci stiamo chiedendo in che modo possiamo registrare attivitÃ  del cervello e quindi cercare di fare decoding delle informazioni presenti Prima parliamo di alcune tecniche non invasive che ci permettono di vedere alcune attivitÃ  presenti nel cervello.
Metodi macroscopici Functional Magnetic Resonance Imaging Un metodo Ã¨ fMRI. (ci sono cose ) TODO capire come funziona
Electro-Encephalo-Gram EEG che prende direttamente dai segnali Ma il drawback di entrambi Ã¨ che non registrano attivitÃ  del singolo array.</description>
    </item>
    <item>
      <title>Conduttori elettrici</title>
      <link>https://flecart.github.io/notes/conduttori-elettrici/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/conduttori-elettrici/</guid>
      <description>Campo elettrico nei materiali Se prendiamo un conduttore, gli elettroni in questi materiali sono liberi, significa che sono liberi di muoversi come vogliono, si puÃ² dire che &amp;ldquo;vadano in giro&amp;rdquo; (per esempio questo vale per il rame).
il reticolo cristallino Ã¨ al struttura regolare che Ã¨ comune nei materiali, in cui gli atomi sono sempre a distanza costante (o comunque a pattern regolari) uno dall&amp;rsquo;altro $r$ per esempio.
Campo e materiali (6) Schermatura del campo (!</description>
    </item>
    <item>
      <title>Goals of Distributed systems</title>
      <link>https://flecart.github.io/notes/goals-of-distributed-systems/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/goals-of-distributed-systems/</guid>
      <description>Dependable systems Introduzione Possiamo individuare alcune proprietÃ  dei sistemi distribuiti. PerÃ² non siamo riusciti a renderli logicamente validi. Sono ancora un pÃ² misti di linguaggio naturale e della sua ambiguitÃ ! Comunque possiamo ridurci per guardare quanto un sistema sia affidabile a guardare poche sue caratteristiche precise.
Caratteristiche fondamentali (4) Queste proprietÃ  sono pensate naturalmente caratterizzanti dei sistemi. In particolare dovrebbero essere tutti misurabili.
Availability
Che risponde nellâ€™istante in cui fai una richiesta.</description>
    </item>
    <item>
      <title>Inferential Social Learning</title>
      <link>https://flecart.github.io/notes/inferential-social-learning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/inferential-social-learning/</guid>
      <description>This is a theory from developmental psychology. It concerns about how a child is learning from a teacher. I discovered this field with (Gweon et al. 2023). But it is quite difficult to know how this could be useful for machines (not enough technical details about how).
The main idea is that
Childrens need to infer about teacher&amp;rsquo;s mental states to learn (I don&amp;rsquo;t know if this is true, but personally I don&amp;rsquo;t think is always true, you can learn with just a book, inferring mental states is not a necessity) Teacher&amp;rsquo;s need to choose the best example.</description>
    </item>
    <item>
      <title>Linguaggi liberi e PDA</title>
      <link>https://flecart.github.io/notes/linguaggi-liberi-e-pda/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/linguaggi-liberi-e-pda/</guid>
      <description>In questa parte del nostro percorso nei linguaggi di programmazione proviamo ad espandere NFA e DFA in modo che possano riconoscere linguaggi come $ww^r | w \in \{a, b\}^*$ , con r maggiore o uguale a zero (r per dire che Ã¨ il contrario di w) (questo linguaggio per il pumping lemma).
Push-down automata Introduzione automi a pila (7)ðŸŸ© &amp;ndash; Lâ€™idea principale per espandere gli NFA Ã¨ il concetto di stato o memoria, avere quindi una stack o pila puÃ² rendere molto piÃ¹ espressivo queste entitÃ .</description>
    </item>
    <item>
      <title>Magnetismo nella materia</title>
      <link>https://flecart.github.io/notes/magnetismo-nella-materia/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/magnetismo-nella-materia/</guid>
      <description>Analisi macroscopica Setting dell&amp;rsquo;esperimento ðŸŸ© Provare a guardare 269 del Mazzoldi. (227 per la defivazione della forza.) Si puÃ² dimostrare che $$ \vec{F} = -\vec{\nabla} \cdot U \implies F = -\vec{\nabla}(\vec{m} \cdot \vec{B}) = \pm m \frac{dB}{dx} $$ La prima relazione si deriva da definizione di lavoro e forza. (esteso al caso di una forza applicata su spira che non Ã¨ banale, facciamola brevemente).
Sappiamo che $U = - m \cdot B$, quindi Ã¨ vero che $dW = -dU = i d \Phi (B)$ e poi utilizzando una proprietÃ  del gradiente in Divergenza e Circuitazione abbiamo $$ Fds = dW = -dU = i \nabla \Phi(B) ds \implies F = i\nabla \Phi(B) = m \cdot \nabla B = -\nabla U $$ La cosa da notare Ã¨ che per campi uniformi abbiamo che si puÃ² definire il lavoro.</description>
    </item>
    <item>
      <title>R e Intervalli</title>
      <link>https://flecart.github.io/notes/r-e-intervalli/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/r-e-intervalli/</guid>
      <description>2.1 NecessitÃ  e caratteristiche di R 2.1.1 Radici di N non perfetti e Q $\sqrt{n} \in \mathbb{Q} \implies n \text{ Ã¨ quadrato perfetto}$
Fai lemma della divisibilitÃ  fra due numeri
Lemma: Dati $m,n,l$ tali che $MCD(m,l)=1$ e $l | m n$ allora allora $l | n$ Questo si risolve con ragionamenti sui fattori di m e n. Per dimostrare che Ã¨ razionale la radice di solamente una radice perfetta parto da un numero razionale, faccio certi ragionamenti e scoprirÃ² alla fine che il numero deve essere una radice perfetta.</description>
    </item>
    <item>
      <title>Rappresentazione della conoscenza</title>
      <link>https://flecart.github.io/notes/rappresentazione-della-conoscenza/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/rappresentazione-della-conoscenza/</guid>
      <description>Questo Ã¨ stato un capitolo molto vasto, che andava in certi punti a toccare la filosofia, la fisica. Un aspetto, quello di codifica delle informazioni reali in un ambiente logico (che per quanto i miei pregiudizi siano, ritengo una cosa molto impossibile, molto limitata e altrettanto impossibile). Si tratta dello studio della logica per rappresentazione di conoscenza.
Fatto sta che mi sembra assurdamente teorico tanto da non aver nessun utilizzo (probabilmente mi sbaglio di grosso), e che sia roba da filosofi.</description>
    </item>
    <item>
      <title>Semantica intuizionista</title>
      <link>https://flecart.github.io/notes/semantica-intuizionista/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/semantica-intuizionista/</guid>
      <description>Molto importante questo documento per avere chiara la differenza fra la logica intuizionista e la Logica Proposizionale classica.
Questa logica intuizionista non si preoccupa del noumeno platonico, ma solo di una prova reale.
Introduzione:
wikipedia
9 11 Scopi di intuizionista (3) Semantica dell&amp;rsquo;evidenza â†’ costruzione della prova Semantica della conoscenza diretta = conoscenza diretta Semantica della calcolabilitÃ  = programma, algoritmo della soluzione 9.1 Invenzione o scoperta La semantica intuizionista vede la matematica come una creazione (e questa cosa interessa molto all&amp;rsquo;informatico perchÃ© Ã¨ una prova.</description>
    </item>
    <item>
      <title>Valutazione Espressioni</title>
      <link>https://flecart.github.io/notes/valutazione-espressioni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/valutazione-espressioni/</guid>
      <description>Espressioni, Comandi, Ricorsione Espressioni Con espressione intendiamo una entitÃ  sintattica, che una volta valutata ritornerÃ  un valore, oppure non termina, in questo caso si dice che la espressione Ã¨ INDEFINITA.
Questa Ã¨ una definizione Ã¨ leggermente ambigua dato che non abbiamo una definizione precisa di valutazoine, che Ã¨ fortemente dipendente dalla macchina astratta in cui viene eseguito.
Notazioni (sintassi possibili) (3) ðŸŸ© Notazione infissa
Questa Ã¨ la notazione classica matematica, per cose tipo $a -b$, in cui l&amp;rsquo;operando sta nel mezzo degli operatori.</description>
    </item>
    <item>
      <title>Algebra modulare</title>
      <link>https://flecart.github.io/notes/algebra-modulare/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algebra-modulare/</guid>
      <description>Algebra modulare Assunzioni Andiamo ora ad assumere l&amp;rsquo;esistenza e correttezza di alcune cose di base. (in teoria si possono dimostrare da cose piÃ¹ di base, ma non ho tempo).
Teorema fondamentale dell&amp;rsquo;algebra Ogni numero intero si fattorizza in modo unico.
Algoritmo di Euclide La conseguenza piÃ¹ importante di questo teorema, dovuto ad Euclide Ã¨ che se ho $a, b \in \mathbb{Z}$ allora esistono resto e dividendo fra i due. Ossia $\exists q, p : a\mid b = qk + p$ per qualche $k$ intero</description>
    </item>
    <item>
      <title>Algoritmi di ordinamento</title>
      <link>https://flecart.github.io/notes/algoritmi-di-ordinamento/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algoritmi-di-ordinamento/</guid>
      <description>6.1 Introduzione 6.1.1 Lâ€™importanza del topic Gli algoritmi di ordinamento sono molto di base per la comprensione dell&amp;rsquo;ampio raggio degli algoritmi. Utilizzano l&amp;rsquo;analisi, introducono tecniche di risoluzione dei problemi computazionali come greedy, divide et impera e simile. Permettono un primo uso di astrazioni e l&amp;rsquo;analisi di sottoproblemi.
6.1.2 Il problema Il problema Ã¨ trovare una permutazione di un insieme di numeri iniziali tale per cui tale insieme di numeri si ordinato:</description>
    </item>
    <item>
      <title>Corrente Elettrica</title>
      <link>https://flecart.github.io/notes/corrente-elettrica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/corrente-elettrica/</guid>
      <description>Introduzione alla corrente elettrica Considerazioni generali Elettroni liberi nei materiali Ricorda che Ã¨ un reticolo cristallino, con un elettrone nell&amp;rsquo;ultimo orbitale poco legato, quindi facilmente ionizzabile, in cui gli elettroni si possono muovere facilmente, e abbiamo che $n \approx 8.5 \times 10^{28} \frac{e^{-}}{m^{3}}$ nel rame Per l&amp;rsquo;argento abbiamo 5.9 con stesso ordine di grandezza.
VelocitÃ  media elettroni senza campo elettrico ðŸŸ© Se Ã¨ isotropo, gli elettroni si muovo in generale a caso e la velocitÃ  media dipendente dall&amp;rsquo;eccitazione termica (in teoria cinetica dei gas Ã¨ studiata sta cosa).</description>
    </item>
    <item>
      <title>Inverse Transform</title>
      <link>https://flecart.github.io/notes/inverse-transform/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/inverse-transform/</guid>
      <description>How can we transform a uniform into a random variable? It is true that we have $$ F(x) = \int _{-\infty}^{x} f(t) \, dt $$ A volte la densitÃ  non Ã¨ definita, mentre la funzione cumulativa lo Ã¨ , per questo spesso cominciamo a definire partendo dalla definizione.
Suppose we have a $x \sim F_{X}(x)$ where $F$ is a cumulative distribution function, same thing, we just need to take the set, normal cumulative distribution function that we saw a lot in other courses.</description>
    </item>
    <item>
      <title>Spazi di probabilita</title>
      <link>https://flecart.github.io/notes/spazi-di-probabilita/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/spazi-di-probabilita/</guid>
      <description>La probabilitÃ  Termini Esito ed esperimenti aleatorio Lâ€™evento Ã¨ quello che accade, mentre un esperimento aleatorio qualcosa di cui vogliamo andare a misurare la probabilitÃ  diciamo. Esperimento aleatorio: esperimento di cui non conosciamo il risultato con certezza. Esito: risultato dellâ€™esperimento aleatorio
Spazio campionario ed evento Spazio campionatorio Lo spazio campionatorio Ã¨ l&amp;rsquo;insieme di tutti gli stati possibili per una certa cosa da misurare (ossia di un esperimento aleatorio), gli stati sono talvolta anche chiamati sample points oppure outcomes in modo piÃ¹ semplice.</description>
    </item>
    <item>
      <title>Wifi 802-11</title>
      <link>https://flecart.github.io/notes/wifi-802-11/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/wifi-802-11/</guid>
      <description>In this document, we will discuss the actual Wi-Fi standard that we can find in the market.
The initial slides consist of extensive lists of Wi-Fi technologies and their uses, such as Bluetooth network, Wi-Fi network, long-range Wi-Fi, and 3G network.
However, they are currently out of service.
Service Sets Basic Service Set There are various divisions within the service set, each of which provides certain types of service.
In the basic service, we have things like SSID, which is the service set identifier that is broadcasted in the beacon as described in Mac Wifi.</description>
    </item>
    <item>
      <title>Circuit Motifs</title>
      <link>https://flecart.github.io/notes/circuit-motifs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/circuit-motifs/</guid>
      <description>Work like (Luo 2021) show that our brain has naturally some types of circuits, which can be classified mainly as 4 types as described in (Wang et al.):
References [1] Luo â€œArchitectures of Neuronal Circuitsâ€ Science Vol. 373(6559), pp. eabg7285 2021
[2] Wang et al. â€œCircuitNet: A Generic Neural Network to Realize Universal Circuit Motif Modelingâ€</description>
    </item>
    <item>
      <title>Fisica del Wireless</title>
      <link>https://flecart.github.io/notes/fisica-del-wireless/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/fisica-del-wireless/</guid>
      <description>Introduzione Radio ðŸŸ© &amp;lt;img src=&amp;quot;/images/notes/image/universita/ex-notion/Fisica del Wireless/Untitled.png&amp;quot; alt=&amp;quot;image/universita/ex-notion/Fisica del Wireless/Untitled&amp;quot;&amp;gt; Antenna: converte corrente in segnali radiorequenza e viceversa. le segnali radiofrequenza sono onde radio con frequenza diversa per rappresentare 1 o 0. Un altro modo per mandare 1 o 0 sarebbe semplicemente cambiare lâ€™intensitÃ  della onda, mantenendo la stessa frequenza.
Viene utilizzata una variazione di potenziale elettrico per creare il segnale, dovrebbe essere un oscillatore armonico in pratica credo. Creando questo flusso di elettroni, crea anche un campo elettromagnetico a lui ortogonale, questa Ã¨ lâ€™onda radio, che si propaga alla velocitÃ  della luce.</description>
    </item>
    <item>
      <title>Mac Wifi</title>
      <link>https://flecart.github.io/notes/mac-wifi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/mac-wifi/</guid>
      <description>Introduzione Ricordiamo che vogliamo cercare di arbitrare lâ€™accesso al canale fisico sottostante. In questo momento andiamo ad assumere di avere giÃ  tutto lâ€™impianto di trasmissione fisica che abbiamo in Tecnologia Wireless, Modulazione wireless Fisica del Wireless.
Obiettivi: Arbitraggio del singolo canale fisico (la tesi di dottorato del prof era su collision avoidance di wifi). Sia in tempo Sia in spazio (come gestire il segnale mandato nello stesso spazio) Utilizzo minimo di energia Quality of service Adaptive behaviour (come il 6G che vuole andare ad utilizzare AI per fare predizione).</description>
    </item>
    <item>
      <title>Sicurezza delle reti</title>
      <link>https://flecart.github.io/notes/sicurezza-delle-reti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/sicurezza-delle-reti/</guid>
      <description>Obiettivi della sicurezza (!!!) ðŸŸ© Vogliamo creare delle reti che abbiamo certe garanzie di sicurezza, soprattutto:
ConfidenzialitÃ , non vorremmo che il nostro messaggio sia intercettabile e leggibili da persone intermedie IntegritÃ : non vogliamo che messaggi possano essere cambiati senza intervento del sender Autenticazione: vorremmo sapere con chi stiamo parlando, e vorremmo essere sicuri che non stiano mentendo sullâ€™identitÃ . Sicurezza operativa(Availability): vorremmo essere in grado di poter continuare a fornire il servizio (quindi non sia possibile dossare, o installare malware che modifichino il comportamento del servizio).</description>
    </item>
    <item>
      <title>Stirling&#39;s Approximation</title>
      <link>https://flecart.github.io/notes/stirlings-approximation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/stirlings-approximation/</guid>
      <description>This note will give a brief derivation of Stirling&amp;rsquo;s approximation. This bound is often useful for factorials. $$ x! \approx x^{x}e^{-x}\sqrt{ 2\pi x } \iff \ln x! \approx x\ln x - x + \frac{1}{2} \ln(2\pi x) $$ This proof (more like an interesting justification). is taken from page 2 of (MacKay 2003).
Let&amp;rsquo;s start with a Poisson distribution with mean $\lambda$ $$ P(r \mid \lambda) = \frac{e^{-\lambda}\lambda^{r}}{r!} $$ If $\lambda$ is large and $r \approx \lambda$, this distribution is approximated by a Gaussian distribution (it is often referred as a discrete Gaussian see Poisson processes).</description>
    </item>
    <item>
      <title>Unified Modeling Language</title>
      <link>https://flecart.github.io/notes/unified-modeling-language/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/unified-modeling-language/</guid>
      <description>Cosa Ã¨ UML Ã¨ un linguaggio di modelling (molto vecchio) ma ancora di continua evoluzione, da un punto di vista storico Ã¨ nato insieme ai concetti di Object Oriented Programming che ora Ã¨ molto presente all&amp;rsquo;interno dell&amp;rsquo;industria, descritto bene in Classi OOP, anche se in questa occasione sviluppata in maniera molto piÃ¹ intuitiva (grafica).
PerchÃ© serve ðŸŸ© Per cercare di comunicare quanto necessario riguardo struttura e dinamicitÃ  dell&amp;rsquo;architettura.
Struttura di UML Structural Diagram ðŸŸ¨++ These diagrams focus on representing the static structure of a system.</description>
    </item>
    <item>
      <title>Descrizione linguaggio</title>
      <link>https://flecart.github.io/notes/descrizione-linguaggio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/descrizione-linguaggio/</guid>
      <description>Introduzione Per questa parte câ€™Ã¨ un sacco di roba in comune con Tecniche di definizione di semantica (4) ðŸŸ©
Trattiamo alcune caratteristiche che descrivono ad alto livello un linguaggio di programmazione. Ãˆ da notare che questa parte della spiegazione del linguaggio non Ã¨ limitante al solo linguaggio di programmazione, Ã¨ utile per analizzare tutti i linguaggi (tranne la parte di implementazione)
Sintassi ðŸŸ©- Relazione fra segni. si occupa di decidere quando una frase Ã¨ corretta.</description>
    </item>
    <item>
      <title>Logistic Regression</title>
      <link>https://flecart.github.io/notes/logistic-regression/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/logistic-regression/</guid>
      <description>Introduzione alla logistic regression Questo documento, per come Ã¨ scritto, lo giudico il 2024-08-10 Lettera a Nicole pressochÃ© inutile.
Giustificazione del metodo Questo Ã¨ uno dei modelli classici, creati da Minsky qualche decennio fa In questo caso andiamo direttamente a computare il valore di $P(Y|X)$ durante l&amp;rsquo;inferenza, quindi si parla di modello discriminativo.
Introduzione al problema Supponiamo che
$Y$ siano variabili booleane $X_{i}$ siano variabili continue $X_{i}$ siano indipendenti uno dall&amp;rsquo;altro.</description>
    </item>
    <item>
      <title>Map of Mind Theories</title>
      <link>https://flecart.github.io/notes/map-of-mind-theories/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/map-of-mind-theories/</guid>
      <description>This note is just useful to classify some classical views of mind theories
Mentalism Si basa sull&amp;rsquo;idealismo Hegeliano Questo lo citiamo ma non ne parliamo proprio
Attribute theory In cui sÃ¬ Ã¨ materialista, ma c&amp;rsquo;Ã¨ qualcosina in piÃ¹ che non ho ben capito.
Dualism In cui si pensa che esistono due componenti indipendenti (nel senso che uno puÃ² vivere senza l&amp;rsquo;altro).
Cartesian dualism Quello di Cartesio e della ghiandola pineale</description>
    </item>
    <item>
      <title>Measure Theory</title>
      <link>https://flecart.github.io/notes/measure-theory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/measure-theory/</guid>
      <description>Ultima modifica: September 18, 2022 9:43 AM Primo Abbozzo: September 16, 2022 9:52 AM Studi Personali: Yes
Elementi di ripasso Measure Theory Introduzione Requirements of the measure function Vorremmo cercare di estendere il concetto di misurabilitÃ  a gruppi molto piÃ¹ ampi di un singolo intervallo, vorrei creare una funzione che sia in grado di misurare degli insiemi. *su vedrÃ  che sono impossibili).
ImpossibilitÃ  di questi requirements (assurdo) Costruzione dellâ€™insieme di interesse</description>
    </item>
    <item>
      <title>Norme e Condizionamento</title>
      <link>https://flecart.github.io/notes/norme-e-condizionamento/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/norme-e-condizionamento/</guid>
      <description>Errore inerente Bisogna cercare di generalizzare il concetto di errore e lo si fa con la norma
Norma vettoriale Ãˆ una funzione da $f: \mathbb{R}^n \to \mathbb{R}$ indicata con due barrette, questa funzione mi dÃ  un concetto di distanza.
ProprietÃ  della norma Si definisce una norma una funzione che soddisfa queste proprietÃ 
$\lVert x \rVert \geq 0$ per ogni $x \in \mathbb{R}^{n}$ $\lVert x \rVert = 0 \iff x = 0$ $\lVert \alpha x \rVert = \lvert \alpha \rvert \lVert x \rVert$ per ogni $x \in \mathbb{R}^{n}$ e $\alpha \in \mathbb{R}$ Vale la disuguaglianza triangolare, ossia $\forall x, y \in \mathbb{R}^{n}, \lVert x + y \rVert \leq \lVert x \rVert + \lVert y \rVert$.</description>
    </item>
    <item>
      <title>Object Detection</title>
      <link>https://flecart.github.io/notes/object-detection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/object-detection/</guid>
      <description>Introduction Semantic segmentation Vorremo trovare regioni che corrispondano a categorie diverse. E dividere in questo modo lâ€™immagine secondo zone di informazione.
Object detection Vogliamo trovare il piÃ¹ piccolo box che vada a contenere lâ€™oggetto. Questo Ã¨ fatto con il bounding box.
In questo caso la funzione di loss Ã¨ un pÃ² piÃ¹ difficile da definire, si utilizza la funzione intersection over union con le aree, in pratica la percentuale di immagine comune diciamo.</description>
    </item>
    <item>
      <title>Object orientation</title>
      <link>https://flecart.github.io/notes/object-orientation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/object-orientation/</guid>
      <description>Ripasso Prox: 10 Ripasso: May 29, 2023 Ultima modifica: May 19, 2023 10:33 AM Primo Abbozzo: May 8, 2023 9:20 AM Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ‘ Studi Personali: No
Elementi di ripasso Object orientation il tipo di dato astratto Introduzione Per questi tipi di dato non ci interessa di sapere cosa ci sia sotto (storato come bit? storato come sabbia boh), ci interessa solamente che abbia quei metodi, che possiamo in un certo senso identificare come la sua capsula, opaca in questo caso.</description>
    </item>
    <item>
      <title>Poisson processes</title>
      <link>https://flecart.github.io/notes/poisson-processes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/poisson-processes/</guid>
      <description>Introduzione ai processi di Poisson Arrival processes Sia una sequenza di variabili aleatorie $0 &lt; S_{1} &lt; S_{2} &lt; \dots$ (il fatto che sia positivo significa che per ogni elemento del dominio vale che quell&amp;rsquo;elemento Ã¨ &amp;lt;, non so se mi sono spiegato.) Il fatto che siano crescenti ci permette di metterli in linea, perchÃ© siamo sicuri che $S_{2}$ produrrÃ  un valore maggiore di $S_{1}$.
Incline a questo c&amp;rsquo;Ã¨ anche il arrival counting process che semplicemente va a contare il numero di arrivi (indicati dagli $S_{i}$).</description>
    </item>
    <item>
      <title>Simplesso e B&amp;B</title>
      <link>https://flecart.github.io/notes/simplesso-e-bb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/simplesso-e-bb/</guid>
      <description>Algoritmo del simplesso Ricerca della direzione migliore Ricerca dello step Pseudocodice Slide
B sono gli indici di partenza, poi questi vengono aggiornati
In riga 5 vado a checkare se ho direzioni di crescita possibili, se Ã¨ tutto positivo non ne ho.
in riga 6, si sceglie il piÃ¹ piccol per evitare loop.
L&amp;rsquo;idea in generale va in questo modo
Cerco di trovare il duale e confrontarlo con la x attuale Se sono uguali, allora ho trovato lâ€™ottimo ed esco Altrimenti cerco una direzione di crescita che sia anche ammissibile Continuo fino a trovare un vertice, se ho il vertice allora mi muovo lÃ¬ e riapplico, altrimenti Ã¨ illimitata, se non esiste un vertice.</description>
    </item>
    <item>
      <title>Ambienti di sviluppo</title>
      <link>https://flecart.github.io/notes/ambienti-di-sviluppo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/ambienti-di-sviluppo/</guid>
      <description>Ultima modifica: March 24, 2023 7:35 PM Primo Abbozzo: March 24, 2023 2:23 PM Studi Personali: No
Ambienti di sviluppo Ambiente di sviluppo Ã¨ diverso rispetto allâ€™ambiente di deploy! bisognare fare delle differenze, sono dell macchine diverse, in questa sezione di documenti andiamo a parlare di norme e modi di lavorare per facilitare il metodo di sviluppo.
Note di compatibilitÃ  Front-end Le compatibilitÃ , soprattutto per cose browser (quindi front-end) cambiano molto spesso, come fare a trackare queste cose?</description>
    </item>
    <item>
      <title>Applicazioni lineari</title>
      <link>https://flecart.github.io/notes/applicazioni-lineari/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/applicazioni-lineari/</guid>
      <description>3.1 Introduzione e definizione Si definisce applicazione lineare una funzione (omomorfica) che preserva la struttura dello spazio vettoriale, ossia vale che
$$ f:V \to W, \text{ tale che } \\ f(u + v) = f(u) +f(v)\\, f(\lambda v) = \lambda f(v) $$ Vengono mantenute alcune caratteristiche principali. In modo simile si possono definire omomorfismi per tutte le altre strutture algebriche, la cosa importante Ã¨ che lo spazio d&amp;rsquo;arrivo possieda ancora tutte le stesse operazioni.</description>
    </item>
    <item>
      <title>Campo elettrico</title>
      <link>https://flecart.github.io/notes/campo-elettrico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/campo-elettrico/</guid>
      <description>Introduzione Intuizione del campo elettrostatico Elettrostatico vs elettrodinamico ðŸŸ© Andiamo a chiamare elettrostatico perchÃ© nel nostro caso non si sta muovendo nessuna carica all&amp;rsquo;itnerno di questo campo.
ProprietÃ  del campo elettrostatico (5) ðŸŸ¨ Le linee di forza in ogni punto dello spazio sono tangenti e concorde al campo in quel punto; le linee di forza si addensano dove l&amp;rsquo;intensitÃ  del campo e maggiore; le linee di forza non si incrociano mai, in quanto in ogni punto il campo Ã¨ definito univocamente e non puÃ² avere due direzioni distinte.</description>
    </item>
    <item>
      <title>Fn Ordine superiore</title>
      <link>https://flecart.github.io/notes/fn-ordine-superiore/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/fn-ordine-superiore/</guid>
      <description>Questa parte Ã¨ strettamente collegata conl a parte di Astrazione sul controllo.
Si parla di passare le funzioni come dati. e quindi possono essere passati come se fossero dei parametri.
un linguaggio di programmazione Ã¨ di ordine superiore qualora ammetta funzioni sia come parametro che come risultato di altre funzioni.
La parte molto simile alla precedente Ã¨ il fatto di valutare la funzione nell&amp;rsquo;ambiente iniziale, quindi bisogna utilizzare un sistema simile a quello del passaggio per nome.</description>
    </item>
    <item>
      <title>Insiemi numerici</title>
      <link>https://flecart.github.io/notes/insiemi-numerici/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/insiemi-numerici/</guid>
      <description>ðŸ’¡ Questa prima parte degli appunti Ã¨ fortemente mancante 1.1 Insiemistica Tutta Questa prima roba di insiemistica Ã¨ fatta molto meglio nel corso di logica, in particolare in questo documento
Teoria assiomatica degli insiemi
1.1.1 Definizione e caratteristiche degli insiemi Definizione di Campo ordinato (operazioni fra certi insiemi, sia per la addizione, per la moltiplicazione e simili) Corpo commutativo
Sono definiti somma e moltiplicazione e proprietÃ  come commutativitÃ , associativitÃ , distributiva, inversi, opposti, zero e nullo</description>
    </item>
    <item>
      <title>Introduzione a Logica</title>
      <link>https://flecart.github.io/notes/introduzione-a-logica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-a-logica/</guid>
      <description>Lo scopo della logica Ã¨
Correttezza del ragionamento, anche verificata attraverso algoritmi predittivi. Si svilupperanno linguaggi logici I metodi per la veridicitÃ  di una sentenza. PossibilitÃ  e metodi del ragionamento logico Completezza e non-deducibilitÃ  di alcuni ragionamenti NecessitÃ  di completezza delle ipotesi: piÃ¹ ipotesi = ragionamento valido? Completezza delle tesi, impossibile. Una necessitÃ  della logica Ã¨ Meta-logica:
La logica si deve cercare di basare su certe basi, spesso queste non sono certe, perÃ² danno un certo grado di sicurezza â†’ Se la base Ã¨ solida allora tutto il ragionamento di una parte Ã¨ giusta</description>
    </item>
    <item>
      <title>Key Exchange protocols</title>
      <link>https://flecart.github.io/notes/key-exchange-protocols/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/key-exchange-protocols/</guid>
      <description>Metodi di key exchange
Trusted Key parties (sono come Certificate authorities studiati in Sicurezza delle reti) Merkle Puzzles DH protocol Trusted Third parties Squared Key problem Un problema abbastanza ovvio Ã¨ che per storare le chiavi di tutti c&amp;rsquo;Ã¨ una necessitÃ  $O(n^{2})$ on $O(n)$ users Se c&amp;rsquo;Ã¨ un trusted key parties il numero delle chiavi si riduce di molto, ritorna ad essere lineare!
Protocols Toy Exchange protocolðŸŸ© TTP = Trusted Third party (simile a quanto poi si avrÃ  in Asymmetric Cryptography) Questa Ã¨ la base del servizio di Kerberos!</description>
    </item>
    <item>
      <title>Sezioni Critiche</title>
      <link>https://flecart.github.io/notes/sezioni-critiche/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/sezioni-critiche/</guid>
      <description>Ripasso Prox: 80 Ripasso: May 21, 2023 Ultima modifica: March 12, 2023 10:00 AM Primo Abbozzo: October 8, 2022 11:30 AM Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ‘ Studi Personali: No
Elementi di ripasso 2 Sezioni Critiche Introduzione La parte di un programma che utilizza una o piÃ¹ risorse condivise viene detta sezione critica (critical section, o CS)
Andiamo in questa altra parte a valutare certe soluzioni:
Programma dâ€™esempio ðŸŸ© Vorremmo garantire che a = b invariante.</description>
    </item>
    <item>
      <title>Theoretical Notions of Security</title>
      <link>https://flecart.github.io/notes/theoretical-notions-of-security/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/theoretical-notions-of-security/</guid>
      <description>CIAA principles of security We have already outlined these principles in Sicurezza delle reti and talked about the concepts of authentication and integrity. Here we try to deepen these concepts and delve a little bit more on the attack vectors These are acronyms, usually called CIA and AAA for infrastructure
Confidentiality This is one concerns about the secrecy of the sent message. We do not want others to be able to access and read what we are doing.</description>
    </item>
    <item>
      <title>Word Embeddings</title>
      <link>https://flecart.github.io/notes/word-embeddings/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/word-embeddings/</guid>
      <description>Theory Johnson-Lindenstrauss Lemma This lemma basically says that semantic embedding is possible, without giving a real algorithm to do so. This seems to be a nice resource about this lemma.
For any $0 &lt; \varepsilon &lt; 1$ and any $k$ bigger than $f(\varepsilon)\log n$ (see the reference for $f(\varepsilon)$ its a simple function). The for any $n \in \mathbb{R}^{d}$ there is a function $f: \mathbb{R}^{d} \to \mathbb{R}^{k}$ such that $\forall x_{i} x_{j} \in A$ we have $$ (1 - \varepsilon)\lVert x_{i} - x_{j} \rVert ^{2} \leq \lVert f(x_{i}) - f(x_{j}) \rVert^{2} \leq (1 + \varepsilon) \lVert x_{i} - x_{j} \rVert ^{2} $$ It says that the pairwise distances can be preserved (if meaning is relation between different entities, then this is everything that is needed to keep that concept almost unaltered.</description>
    </item>
    <item>
      <title>Automi e Regexp</title>
      <link>https://flecart.github.io/notes/automi-e-regexp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/automi-e-regexp/</guid>
      <description>Per lâ€™analisi lessicale vogliamo cercare di ricordare le parole legali all&amp;rsquo;interno di questo linguaggio e questo Ã¨ fatto con i linguaggi regolari.
Introduzione a analizzatori lessicali Token ðŸŸ© Struttura del token Ã¨ fatto da due parti
Identificatore della classe del token Identificatore del valore del token Pattern e lessema ci sono direi boh Pattern e Lessema ðŸŸ© I pattern sono una descrizione generale della forma dei valori di una classe di token.</description>
    </item>
    <item>
      <title>Duality Theory</title>
      <link>https://flecart.github.io/notes/duality-theory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/duality-theory/</guid>
      <description>Ãˆ una branca dell&amp;rsquo;algebra lineare che ci permette di semplificare tutti i concetti.
Intro dualitÃ ðŸŸ© &amp;lt;img src=&amp;quot;/images/notes/image/universita/ex-notion/Programmazione lineare/Untitled 8.png&amp;quot; alt=&amp;quot;image/universita/ex-notion/Programmazione lineare/Untitled 8&amp;quot;&amp;gt; Si fa una sorta di trasposta alla matrice di A. y Ã¨ pari al numero di righe di A La trasformazione al duale Ã¨ molto facile, ed Ã¨ abbastanza intuitiva una volta che capiamo che vogliamo andare a fare lâ€™upper bound.
DualitÃ  asimmetrica ðŸŸ¥+ Teorema debole di dualitÃ  ðŸŸ© Slide</description>
    </item>
    <item>
      <title>Integrali multi-dimensionali</title>
      <link>https://flecart.github.io/notes/integrali-multi-dimensionali/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/integrali-multi-dimensionali/</guid>
      <description>Andremo ad analizzare integrali di funzioni continue su insiemi semplici (domini normali) .
Introduzione Y-semplice e regolaritÃ  Ãˆ un insieme semplice di punti, in pratica, se considero un intervallo limitato e due funzioni definite in questo intervallo tale che una Ã¨ sempre minore dellâ€™altra, lâ€™insieme y-semplice sono i punti compresi fra queste
Definizione del libro Intuizione integrale Definizione del prof.
Dato un insieme semplice A e una funzione continua $f:A \to R$ allora Ã¨ ben definito lâ€™integrale</description>
    </item>
    <item>
      <title>Markov Chains</title>
      <link>https://flecart.github.io/notes/markov-chains/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/markov-chains/</guid>
      <description>Introduzione alle catene di Markov La proprietÃ  di Markov Una sequenza di variabili aleatorie $X_{1}, X_{2}, X_{3}, \dots$ gode della proprietÃ  di Markov se vale:
$$ P(X_{n}| X_{n - 1}, X_{n - 2}, \dots, X_{1}) = P(X_{n}|X_{n-1}) $$ Ossia posso scordarmi tutta la storia precedente, mi interessa solamente lo stato precedente per sapere la probabilitÃ  attuale.
Da un punto di vista filosofico/fisico, ha senso perchÃ© mi sta dicendo che posso predire lo stato successivo se ho una conoscenza (completa, (lo dico io completo, originariamente non esiste)) del presente.</description>
    </item>
    <item>
      <title>Serie</title>
      <link>https://flecart.github.io/notes/serie/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/serie/</guid>
      <description>Questo Ã¨ un tentativo di aggiungere un argomento che non era presente quando abbiamo fatto il corso due anni fa. Inizio la scrittura il 2024-03-03. Questo non Ã¨ stato trattano nel corso, ma Ã¨ importante per molte cose. Quindi introduco questo appunto.
Introduzione alle serie Le serie infinite sono dei mostri strani perchÃ© non si comportano spesso come dovrebbero.
Definizione di convergenza Sia data una funzione $(a_{n})_{n=0}^{\infty}$ una funzione da $\mathbb{N} \to \mathbb{R}$, possiamo dire che questa serie Ã¨ convergente se la somma cumulativa $f_{n} = \sum_{n = 0}^{n} a_{n}$ ha un limite finito, ossia $$ \lim_{ n \to \infty } f_{n} = c $$ con $c$ un numero reale.</description>
    </item>
    <item>
      <title>Strutture di dati elementari</title>
      <link>https://flecart.github.io/notes/strutture-di-dati-elementari/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/strutture-di-dati-elementari/</guid>
      <description>3.1 Introduzione 3.1.1 Cosa sono Le strutture di dati si interessano solamente di come memorizzare i dati, non necessariamente va a memorizzare un tipo di dato concreto.
Quindi + sul come - sul cosa.
3.1.2 Prototipo e implementazione Avevamo introdotto la differenza fra algoritmo e programma all&amp;rsquo;inizio del corso, andiamo ora a definire la differenza fra prototipo e implementazione:
Prototipo:
va a fare una descrizione dei metodi che deve avere una determinata struttura di dati.</description>
    </item>
    <item>
      <title>Vettore potenziale</title>
      <link>https://flecart.github.io/notes/vettore-potenziale/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/vettore-potenziale/</guid>
      <description>Introduzione al vettore potenziale Definizione vettore potenziale ðŸŸ© Possiamo sempre scrivere il campo $\vec{B}$ come $$ \vec{B} = \vec{\nabla} \times \vec{A} $$ Con un campo vettoriale a caso $\vec{A}$, vedremo che questo campo avrÃ  qualche utilitÃ  per fare i calcoli.
Possiamo notare che soddisfa la proprietÃ  dell campo solenoidale citato in Magnetismo, infatti
$$ \vec{\nabla} \cdot \vec{B} = \vec{\nabla} \cdot (\vec{\nabla} \times \vec{A}) = 0 $$ PerchÃ© sappiamo che la divergenza del rotore (questo operatore dico) Ã¨ sempre nullo per ragioni di Cauchy, se ne parla in Divergenza e Circuitazione.</description>
    </item>
    <item>
      <title>Bias Variance Trade-off</title>
      <link>https://flecart.github.io/notes/bias-variance-trade-off/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bias-variance-trade-off/</guid>
      <description>Introduction Ãˆ una cosa ormai risaputa che c&amp;rsquo;Ã¨ una sorta di trade-off fra la varianza e il bias per una certo modello. Aumentare la varianza del modello certamente ci permetterÃ  di avere un modello che abbia un errore di training molto basso, perÃ² appena vede dei dati nuovi non sarÃ  in grado di generalizzare correttamente. Dall&amp;rsquo;altra parte avere un bias alto significa avere un modello eccessivamente semplice, poco flessibile, che comunque allenato non riesce ad avere una grande accuratezza nÃ© in fase di allenamento, nÃ© di in fase di validazione o di test.</description>
    </item>
    <item>
      <title>Condensatori con dielettrici</title>
      <link>https://flecart.github.io/notes/condensatori-con-dielettrici/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/condensatori-con-dielettrici/</guid>
      <description>introduzione ai dielettrici Esperimenti metalli e dielettrici ðŸŸ© Verso gli anni del 1840 Faraday ha fatto molti sistematici esperimenti per scoprire come si comportava il potenziale e il campo elettrico di fronte a certi materiali. Sono stati principalmente posti delle sostanza (conduttrici o meno) in mezzo a lastre di condensatori, e hanno misurato come cambiava il potenziale elettrico fra le due lastre (che si puÃ² vedere attraverso il modo con cui cambiano sull&amp;rsquo;elettroscopio).</description>
    </item>
    <item>
      <title>CPU e storia degli elaboratori</title>
      <link>https://flecart.github.io/notes/cpu-e-storia-degli-elaboratori/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cpu-e-storia-degli-elaboratori/</guid>
      <description>2 Storia 2.1 0: Computer Meccanici dal 1600 a oggi
2.2 1: Computer a Valvole Principalmente i computer della seconda guerra mondiale
2.3 2: Computer a Transistor Abbattere i costi
2.4 3: Circuiti stampati Computazione parallela Multiprogrammazione (Caricamento di piÃ¹ programmi) 2.5 4: VLSI PossibilitÃ  di creare tansissimi transistor
2.6 5: Computer moderni 2.6.1 Computer Ubiqui 2.6.2 Computer invisibili 2.7 VelocitÃ  di calcolo 2.7.1 Flops and MIPS 3 CPU La struttura moderna degli elaboratori sono basati principalmente sull&amp;rsquo;architettura di Von Neuman, l&amp;rsquo;unica differenza Ã¨ che gli elementi di questa architettura.</description>
    </item>
    <item>
      <title>Gestione delle eccezioni</title>
      <link>https://flecart.github.io/notes/gestione-delle-eccezioni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gestione-delle-eccezioni/</guid>
      <description>Introduzione Metodi alternativi di gestione degli errori (3) ðŸŸ© A volte le computazioni falliscono. Potremmo gestirle con i result come accennato in Polimorfismo, perÃ² diventa molto macchinoso fare tutte le funzioni che debbano inoltrare solamente delle results. bisogna trovare un modo piÃ¹ naturale. Ecco che arriva una gestione delle eccezioni direttamente nel linguaggio. Si tratta un sistema di comunicazione degli errori.
ALTRI METODI
Results, stile monadico, vedi sopra. definire dei valori eccezionali (questo si va spesso in C) Il chiamato dice al chiamante una cosa da chiamare quando fallisce.</description>
    </item>
    <item>
      <title>Algebra lineare numerica</title>
      <link>https://flecart.github.io/notes/algebra-lineare-numerica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algebra-lineare-numerica/</guid>
      <description>In questa sezione andiamo ad indagare metodi di scomposizione, iterativi e non. Ci sono molte matrici importanti per questa parte che dovremmo prendere confidenza.
Immagini Lab 2 images
Metodo di gauss Vogliamo cercare un metodo per calcolare soluzioni a sistemi di equazione del genere:
$Ax = b$, classico. Supponiamo che questo sistema abbia una soluzione.
Il nostro obiettivo sarebbe scomporre la matrice $A = LU$ come prodotto di due matrici Lower triangular e Upper triangular.</description>
    </item>
    <item>
      <title>Modulazione wireless</title>
      <link>https://flecart.github.io/notes/modulazione-wireless/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/modulazione-wireless/</guid>
      <description>Introduzione Digital modulation ðŸŸ¨ Slide introduzione
Modulazione digitale: prendiamo un dato digitale e trasmesso con un segnale analogico, come le RF.
ASK: amplitude shift keying
FSK: frequency shift
PSK: phase shift
Questi sono i tre metodi principali, che dipendono dalle caratteristiche dellâ€™onda descritte in Fisica del Wireless.
TRE CARATTERISTICHE
Power
Resistenza interferenze. (robustezza)
ANALOG MODULATION
Per modulare un segnale analogico si utilizzano principalemente AM o FM, amplitude o frequency modulation, raramente si utilizza PM.</description>
    </item>
    <item>
      <title>Principal Component Analysis</title>
      <link>https://flecart.github.io/notes/principal-component-analysis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/principal-component-analysis/</guid>
      <description>See https://peterbloem.nl/blog/pca series. The main idea is to find the directions with the most variance in a dataset. Those will be principal components.
There is a very easy derivation present in (Bishop &amp;amp; Bishop 2024). It is also known as the Kosambi-Karhunen-LoÃ¨ve transform (you will probably like this name more if you are from physics). Another good resource is the Wilkinson.
Technique setting Le&amp;rsquo;t say we have $\left\{ \boldsymbol{x}_{n} \right\}$ observations of dimension $D$ and $n \in \left\{ 1, \dots, N \right\}$.</description>
    </item>
    <item>
      <title>Block Ciphers</title>
      <link>https://flecart.github.io/notes/block-ciphers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/block-ciphers/</guid>
      <description>Utilizzano blocchi per cifra invece che stream generators. $n$ bits in input and $m$ bits in output generally a key is expanded into multiple keys, one for each rounds, and applied to a round function that iterates on the $m$.
DES 56 bit 3DES 56*3 bit di chiave AES che puÃ² andare a 128, 196 o 256 Solitamente i stream ciphers studiati in OTP and Stream Ciphers sono piÃ¹ veloci. Cipher Speed MB/sec RC4 126 Salsa20 643 Sosemanuk 727 AES 13 3DES 109 Data Encryption Standard - 1974 da IBM su commissione di NSA (Horst Feistel designed Lucifer at IBM in early 1970) - 1976 DES is federal standard with key-len 56 bits and block-len 64 bits.</description>
    </item>
    <item>
      <title>Compression Algorithms</title>
      <link>https://flecart.github.io/notes/compression-algorithms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/compression-algorithms/</guid>
      <description>Lempel-Ziv-Welch Algorithm Introduzione sul funzionamento Primo scan con un dizionario indexato dei singoli caratteri Poi viene cercato di raggruppare caratteri a coppie. Se una coppia Ã¨ giÃ  presente nel dizionario, allora aggiungo al dizionario una cosa piÃ¹ lunga e metto un code diverso Esempio di sopra. La cosa carina Ã¨ che il dizionario si puÃ² ricostruire in fase di decoding.
Tutti gli altri, tipo zip, gzip, png si basano poi su questa idea.</description>
    </item>
    <item>
      <title>Data Plane</title>
      <link>https://flecart.github.io/notes/data-plane/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/data-plane/</guid>
      <description>Ripasso Prox: 30 Ripasso: May 20, 2023 Ultima modifica: May 14, 2023 5:18 PM Primo Abbozzo: March 10, 2023 12:10 PM Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ— Studi Personali: No
Introduzione Data or Control plane come fanno i router a fare forwarding dei pacchetti? e decidere come mandare? Come fanno a passare. Sono le tabelle di instradamento. Si puÃ² dire di end-to-end perchÃ© solamente il sender e receiver andranno a livello applicazione, e leggeranno le cose (se criptato veramente solo loro riescono a fare questo).</description>
    </item>
    <item>
      <title>Gruppi Normali</title>
      <link>https://flecart.github.io/notes/gruppi-normali/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gruppi-normali/</guid>
      <description>Elementi di ripasso Gruppi normali e quoziente Introduzione Definizione normalitÃ  Test del sottogruppo normale Dimostrazione
Il gruppo quoziente Lâ€™importanza del gruppo normale Ã¨ che quando esso vale, possiamo avere il gurppo fattore
Dimostrazione
!</description>
    </item>
    <item>
      <title>Introduction to data-bases</title>
      <link>https://flecart.github.io/notes/introduction-to-data-bases/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduction-to-data-bases/</guid>
      <description>Basi di dati Cosa Ã¨ un database? (2) ðŸŸ© Si potrebbe intendere come un insieme di dati strutturato, utili per certi obiettivi di enterprise, aziende pubbliche o simili (uno delle necessitÃ  che la rivoluzione informatica ha piÃ¹ contribuito diciamo.)
Un altro significato piÃ¹ importante Ã¨
Un insieme di dati gestito da un Database Management System
Tristemente con questa definizione anche excel Ã¨ un DBMS&amp;hellip;
Solitamente sono utilizzati per gestire grandi quantitÃ  di dati.</description>
    </item>
    <item>
      <title>Processi e thread</title>
      <link>https://flecart.github.io/notes/processi-e-thread/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/processi-e-thread/</guid>
      <description>Il processo e la gestione dell&amp;rsquo;esecuzione Ã¨ uno dei compiti principali dei sistemi operativi. Lo vuole fare in maniera efficace ed efficiente, come descritto in Note sullâ€™architettura.
Slide schema generale tabelle
Processi Il process control block Ã¨ la struttura di dati principali da comprendere.
Ha una tabella dei file aperti, che sono dei file descriptor (all&amp;rsquo;interno della propria struttura di dati), riferiti a una tabella dell&amp;rsquo;interno sistema credo, e questi puntano a un VNode che permette di localizzarlo nella memoria secondaria.</description>
    </item>
    <item>
      <title>Relazional Model</title>
      <link>https://flecart.github.io/notes/relazional-model/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/relazional-model/</guid>
      <description>This is the classical format that we encounter, it is the format used for relational databases introduced in databases course introduction, introduced in (Codd 1970).
Introduzione, i modelli di dati Lista modelli di dati (4) Nel tempo sono stati sviluppati molti modelli di dati:
Relational Data Model: This is the most common data model and uses tables to represent data. It organizes data into rows and columns, where each row represents a record, and each column represents an attribute of that record.</description>
    </item>
    <item>
      <title>Deblur di immagini</title>
      <link>https://flecart.github.io/notes/deblur-di-immagini/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/deblur-di-immagini/</guid>
      <description>Origini di sfocatura &amp;lt;img src=&amp;quot;/images/notes/image/universita/ex-notion/Immagini/Untitled.png&amp;quot; alt=&amp;quot;image/universita/ex-notion/Immagini/Untitled&amp;quot;&amp;gt; Rumore causata da problemi fisici che sono errori di lettura del segnale analogico Questo si indica anche come errore gaussiano bianco e si puÃ² considerare additivo. Rumore causato dalla digitalizzazione, quindi dalla discretizzazione di essa. Slide formalizzazione errori per sfocatura
Point spread function Un unico pixel bianco sembra influenzare il suo ambiente nero, come in immagine
Vorremmo utilizzare delle funzioni ce siano in grado di approssimare questa funzione.</description>
    </item>
    <item>
      <title>Inner product spaces</title>
      <link>https://flecart.github.io/notes/inner-product-spaces/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/inner-product-spaces/</guid>
      <description>This set of notes tries to fix what I haven&amp;rsquo;t learned in 2021 course in algebra. It&amp;rsquo;s about inner product spaces. A good online reference on the topic is wilkinson.
Definitions Inner product space We define the vector space $V$ to be a inner product space, if we define a inner product operator ($\langle \cdot, \cdot \rangle : V \times V \to R$) such that the following are valid:
It is linear on both arguments: $$ \langle \alpha x_{1} + \beta x_{2}, y \rangle = \alpha \langle x_{1}, y \rangle + \beta \langle x_{2}, y \rangle $$ It is a symmetric operator: $\langle x, y \rangle = \langle y, x \rangle$ It is positive definite that is we have $\forall x \in V: \langle x, x \rangle \geq 0$ with equality only if $x = \boldsymbol{0}$ An example of such operator is the classical cosine distance which is just the angle, or euclidean distance.</description>
    </item>
    <item>
      <title>Livello OS</title>
      <link>https://flecart.github.io/notes/livello-os/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/livello-os/</guid>
      <description>9.1 Caratteristiche Il sistema operativo non ha sempre avuto una interfaccia grafica.
9.1.1 In generale Principalmente Ã¨ un gestore delle risorse come il disco, la CPU, l&amp;rsquo;output e l&amp;rsquo;input.
Ãˆ qualcosa che si infrappone come interfaccia fra le applicazioni e quello che Ã¨ presente sotto.
9.1.2 Ambiti principali 9.2 Paginazione Al programma non interessa se effettivamente Ã¨ presente in memoria fisica questa quantitÃ  di memoria, si di solito basta sempre.</description>
    </item>
    <item>
      <title>Modelizzazione</title>
      <link>https://flecart.github.io/notes/modelizzazione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/modelizzazione/</guid>
      <description>Programmazione lineare Programmazione lineare contiene alcuni algoritmi utili per risolvere certi problemi di ottimizzazione.
Introduzione Andiamo in questa sezione a definire un problema di programmazione lineare
Definizione ðŸŸ©- Variabili reali che saranno le variabili del nostro problema, sono in numero finito (eg. tutti in Rn) Funzione obiettivo che ci definisce il costo $f: \R^n \to \R$ Vincoli lineari che limitano il dominio delle variabili reali e li mettono in relazione fra di loro Se le variabili appartengono agli interi andiamo a parlare di programmazione lineare intera.</description>
    </item>
    <item>
      <title>Replication and consistency</title>
      <link>https://flecart.github.io/notes/replication-and-consistency/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/replication-and-consistency/</guid>
      <description>Ultima modifica: January 5, 2023 9:59 AM Primo Abbozzo: January 4, 2023 10:02 AM Studi Personali: No
Replication and consistency Introduzione Ci sono due vantaggi principali nella replicazione dei dati
VelocitÃ  Vicinanza geografica (quindi meno tempo ad andare a tornare) Maggiore computazione, quindi avere molti piÃ¹ processori che cercano di offrire lo stesso servizio. AffidabilitÃ  CosÃ¬ se una sede diventa corrotta, posso avere abbondanza, avere una copia da una altra parte, cosÃ¬ non perdo le informazioni!</description>
    </item>
    <item>
      <title>Semantica di un linguaggio</title>
      <link>https://flecart.github.io/notes/semantica-di-un-linguaggio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/semantica-di-un-linguaggio/</guid>
      <description>Vincoli sintattici contestuali Intro: dipendenze da contesto ðŸŸ© I vincoli sintattici non sono esprimibili tramite BNF perchÃ© dipendono dal contesto, mentre le grammatiche libere sono per definizione libere da contesto, vogliamo quindi trovare una soluzione a questo problema. Vengono usati metodi Ad-Hoc nella fase di analisi semantica del programma.
Grammatiche dipendenti dal contesto
Queste grammatiche sono molto piÃ¹ complicate (e lente) rispetto a quelle libere da contesto, quindi Ã¨ poco pratico e non utilizzabile (tempo esponenziale, quindi non finisce mai).</description>
    </item>
    <item>
      <title>Semplificazione grammatiche</title>
      <link>https://flecart.github.io/notes/semplificazione-grammatiche/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/semplificazione-grammatiche/</guid>
      <description>Gestione del non determinismo Il modo piÃ¹ facile per gestire il non determinsmo Ã¨ semplificare le grammatiche quindi andiamo a vedere metodi per fare ciÃ².
Semplificazione grammatiche (5) Slide
No produzioni del tipo $A \to \varepsilon$ per bottom up (altrimenti va allâ€™infinito!) No produzioni unitarie, cosÃ¬ evito cicli in cui da A derivo sÃ© stesso. No simboli inutili No ricorsione sinistra (divergenza per top-down) Fattorizzazione della grammatica Eliminazione delel produzioni nulle Vogliamo creare un algoritmo utile ad eliminare le produzioni che non ci piacciono.</description>
    </item>
    <item>
      <title>Syncronous model</title>
      <link>https://flecart.github.io/notes/syncronous-model/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/syncronous-model/</guid>
      <description>Introduction Da ricordare il &amp;ldquo;The State Machine Replication (SMR) Problem&amp;rdquo; in Consensus protocols che Ã¨ importantissimo per comprendere questa parte.
Storia locale Transazioni al singolo noto Problema del sync fra tutti questi nodi.
Goal of SMR solution in blockchains Andiamo a considerare alcune proprietÃ  di safety e liveness Programmi Concorrenti
Consistenza i nodi devono essere daccordo su quale transazione mettere prima e dopo â†’ stessa storia per tutte le transazioni. (con la possibilitÃ  di alcuni nodi che siano indietro, ma solo prefisso!</description>
    </item>
    <item>
      <title>Asymptotic Equipartition Property</title>
      <link>https://flecart.github.io/notes/asymptotic-equipartition-property/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/asymptotic-equipartition-property/</guid>
      <description>Sembra essere molto simile a Central Limit Theorem and Law of Large Numbers perÃ² per Entropy. This is also called Shannon&amp;rsquo;s source coding theorem see here
Enunciato AEP Data una serie di variabili aleatorie $X_{1}, X_{2}, \dots$ i.i.d. $\sim p(x)$ se vale che $$ -\frac{1}{n} \log p(X_{1}, X_{2}, \dots, X_{n}) \to H(X) $$ in probability (la definizione data in Central Limit Theorem and Law of Large Numbers#Convergence in probability).
Un modo alternativo per enunciarla Ã¨ cosÃ¬, segue il metodo in (MacKay 2003).</description>
    </item>
    <item>
      <title>Cammini</title>
      <link>https://flecart.github.io/notes/cammini/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cammini/</guid>
      <description>Ultima modifica: October 17, 2021 10:38 AM Primo Abbozzo: October 16, 2021 5:16 PM Studi Personali: No
Elementi di ripasso 1 Cammini 1.1 Il cammino minimo 1.1.1 Definizione e caratteristiche 1.1.2 Costi negativi Sono cose molto brutte
1.1.3 Cammino minimo semplice Costruzione di cammini minimi 1.2 Vertici 1.2.1 definizione distanza fra due vertici Costo del cammino minimo che li connette
Condizione di bellman Albero dei cammini minimi Rilassamento Definizione Si va a vedere dove non funziona la disuguaglianza triangolare, se localmente non funziona ovvero se per esempio succede $D_{xu} + \omega(u,y) &lt; D_{xy}$ per qualche vertice all&amp;rsquo;interno del grafo, so di per certo che la distanza $D_{xy}$ non Ã¨ una distanza, quindi possiamo riassegnarla in modo che verifichi la disuguaglianza</description>
    </item>
    <item>
      <title>Introduzione SO</title>
      <link>https://flecart.github.io/notes/introduzione-so/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-so/</guid>
      <description>Scopi del sistema operativo ðŸŸ© Un sistema operativo Ã¨ una astrazione sul HW che permette di
Gestire lâ€™esecuzione di piÃ¹ programmi assieme (concorrenza), tramite virtualizzazione CPU e Memoria Gestire le risorse (Quindi I/O, RAM, Memoria, Networking) Fornisce una interfaccia di programmazione (API) molto piÃ¹ generale e potente, in grado di astrarre da dettagli di livello basso, vicini allâ€™Hardware (come device drivers). Quindi in breve il SO Ã¨ n programma che crea un ambiente civile per i programmi in cui interagire, e facilita molto il lavoro al programmatore per la sua interfaccia nuova.</description>
    </item>
    <item>
      <title>lâ€™intelligenza</title>
      <link>https://flecart.github.io/notes/lintelligenza/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/lintelligenza/</guid>
      <description>1 Introduzione Lâ€™intelligenza artificiale Ã¨ un campo in velocissima espansione, con giÃ  un mercato enorme di un trillion dollars.
Inoltre il suo campo di studi spazia da moltissimi campi, Ã¨ per questo che quasi potresti considerarla universale.
1.1 Lâ€™intelligenza artificiale 1.1.1 Cosa Ã¨ (2) Nel tempo si Ã¨ cercato di definire con esattessa cosa sia lâ€™intelligenza artificiale. In generare si Ã¨ basato su alcuni parametri cardine ossia:
La capacitÃ  di replicare attivitÃ  umane / la capacitÃ  di applicare attivitÃ  razionali La capacitÃ  di ragionare / il comportamento intelligente Su questi due binomi sono stati fatti dei modelli, andiamo ora a scoprire in che senso lâ€™intelligenza artificiale Ã¨ intelligente.</description>
    </item>
    <item>
      <title>Ampere e Faraday</title>
      <link>https://flecart.github.io/notes/ampere-e-faraday/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/ampere-e-faraday/</guid>
      <description>Relazioni con fili - Ampere Legge di Biot-Savart/Formalizzazione esperienza di Ampere ðŸŸ© Poniamo che ho due fili in cui scorra della corrente, voglia capire la forza per unitÃ  di lunghezza del filo uno su due e viceversa.
So che entrambi generano campo magnetico So che il campo magnetico induce forza su correnti in movimento. Supponiamo che la loro distanza sia $D$, allora avremo che: Per la prima legge so: $$ d\vec{B} = \mu_{0}i d\vec{l} \times \frac{\hat{r}}{4\pi r^{2}} $$ da questo posso calcolare il campo magnetico totale, in un modo simile a quanto fatto in precedenza per il campo elettrico (solo che in questo caso abbiamo il prodotto seno, quindi l&amp;rsquo;angolo che conviene scegliere Ã¨ un po&amp;rsquo; diverso), e una volta che ho questo posso usare la seconda legge per avere la forza, questo Ã¨ il piano.</description>
    </item>
    <item>
      <title>Log degli esercizi</title>
      <link>https://flecart.github.io/notes/log-degli-esercizi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/log-degli-esercizi/</guid>
      <description>Ultima modifica: May 13, 2023 4:44 PM Primo Abbozzo: January 14, 2023 11:55 AM Studi Personali: No
Log esercizi fatti Data, compito, C1 fatto? c2 fatto?
2022.09.06 [http://www.cs.unibo.it/~renzo/so/compiti/2022.09.06.tot.pdf] (36 KB) X X 2022.07.20 [http://www.cs.unibo.it/~renzo/so/compiti/2022.07.20.tot.pdf] (36 KB) X X (non me lo ricordo) 2022.06.21 [http://www.cs.unibo.it/~renzo/so/compiti/2022.06.21.tot.pdf] (40 KB) X X X 2022.06.01 [http://www.cs.unibo.it/~renzo/so/compiti/2022.06.01.tot.pdf] (36 KB) X X 2022.02.14 [http://www.cs.unibo.it/~renzo/so/compiti/2022.02.14.tot.pdf] (40 KB) X X 2022.01.17 [http://www.cs.unibo.it/~renzo/so/compiti/2022.01.17.tot.pdf] (36 KB) X X X X 2021.09.15 [http://www.</description>
    </item>
    <item>
      <title>Memory of the Brain</title>
      <link>https://flecart.github.io/notes/memory-of-the-brain/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/memory-of-the-brain/</guid>
      <description>La memoria e l&amp;rsquo;apprendimento Breve classificazione Basata sulla consapevolezza Basata sul tempo Basata sulla funzione Importanza della dimensione temporale Memoria a breve termine Memoria a lungo termine Anatomia della memoria nel cervello Il caso di H. M. </description>
    </item>
    <item>
      <title>Network Address Translation</title>
      <link>https://flecart.github.io/notes/network-address-translation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/network-address-translation/</guid>
      <description>NAT Network address translation Introduzione Col il NAT possiamo avere tutto lo spazio degli IP di cui abbiamo bisogno, che perÃ² non sono esposti. All&amp;rsquo;esterno vengono esposte solamente lâ€™IP del NAT.
Schema classico NAT
Quindi in breve
All&amp;rsquo;esterno Ã¨ esposto solamente l&amp;rsquo;indirizzo del router, il router, a seconda della porta giusta, dÃ  in risposta al computer giusto, quindi all&amp;rsquo;interno della nostra rete conosciamo tutti gli indirizzi IP giusti.
Addr translation table ðŸŸ© Sembra che ad ogni richiesta ci sia una table di transizione all&amp;rsquo;interno del router che matcha porta â†’ indirizzo locale corretto!</description>
    </item>
    <item>
      <title>Tokenization</title>
      <link>https://flecart.github.io/notes/tokenization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/tokenization/</guid>
      <description>Introduction to tokenization Tokenization is the process of converting normal strings into small little pieces that could be fed into one of our models. It usually comes from a tradition in programming languages, as we can see in Automi e Regexp where we define a specific token to have a known pattern, usually recognized by regular expressions.
There have been historically been many approaches to tokenization, let&amp;rsquo;s see a few:</description>
    </item>
    <item>
      <title>Function approximation</title>
      <link>https://flecart.github.io/notes/function-approximation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/function-approximation/</guid>
      <description>We have enormous state functions, having a generic approssimation could really help! We want to use a differentiable value function so that we can use gradient descent to optimize it, for example a good way of loss would be $$ J(w) = \mathbb{E}_\pi[(V^\pi(s) - \hat{V}^\pi(s;w))^2] $$ The second one is parametrized with $w$. There are two ways (recuperali!) MC policy or Time differential (that is boostrapped, instead the Monte carlo uses a full simulation in order to know what to use).</description>
    </item>
    <item>
      <title>Interpolazione</title>
      <link>https://flecart.github.io/notes/interpolazione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/interpolazione/</guid>
      <description>Vogliamo in questa sezione andare ad indagare la costruzione di funzioni che passano in tutti i punti che vogliamo, appunto interpolare. La funzione Ã¨ molto simile alla regressione trattata in Minimi quadrati (con il metodo della regressione, chiamato anche approssimazione ai minimi quadrati).
Quindi mentre la precedente voleva andare a minimizzare l&amp;rsquo;errore, questo attuale va a creare proprio da 0 la funzione che ci passa sempre.
Introduzione Andremo a creare una funzione f tale che per ogni x in input si abbia esattamente la y in output</description>
    </item>
    <item>
      <title>Introduzione algoritmi</title>
      <link>https://flecart.github.io/notes/introduzione-algoritmi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-algoritmi/</guid>
      <description>0 Introduzione 0.1 Lâ€™algoritmo Vogliamo cercare di creare algoritmi, ovvero soluzioni a problemi computazionali che non dipendono dal linguaggio di programmazione.
0.1.1 Definizione Procedura per risolvere un problema in un numero finito di passi (quindi un algoritmo deve finire)
0.1.2 Origine della parola Il nome &amp;ldquo;algoritmo&amp;rdquo; deriva da un nome di un matematico persiano dell 800 d.c. Muhammad ibn Musa al-Khwarizmi, che latinizzato diventa algorithmi, quindi i latini hanno creato la parola!</description>
    </item>
    <item>
      <title>Scelta del PO</title>
      <link>https://flecart.github.io/notes/scelta-del-po/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/scelta-del-po/</guid>
      <description>La cosa che rende il PO diverso rispetto agli sviluppatori Ã¨ la conoscenza delle necessitÃ  del cliente. Questo permette di prioritizzare del task e capire in che modo dovrebbe essere il prodotto finale. In questo modo si crea una vision del prodotto. Pensiamo che il PO debba condividere questa informazione e prendere decisioni di gruppo.
Domande da fare: La user interface, come sembra il wireframe? Pensavamo di utilizzare i social solamente per i login, pensavate di utilizzare anche per altro durante il gioco?</description>
    </item>
    <item>
      <title>Accept Reject algorithm</title>
      <link>https://flecart.github.io/notes/accept-reject-algorithm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/accept-reject-algorithm/</guid>
      <description>Some useful links Main results: https://jblevins.org/notes/accept-reject
Intuition: https://en.wikipedia.org/wiki/Rejection_sampling
La cosa Ã¨ che faccio sampling fra due distribuzioni diverse e devo settare anche un parametro (e a seconda di certe cose diventa molto lento).
Introduzione al metodo Vorrei utilizzare una funzione $g$ per generarne una altra, questo Ã¨ il fulcro del concetto. L&amp;rsquo;idea principale Ã¨:
Conosco la funzione densitÃ  della funzione $f$ che voglio andare a generare Riesco a generare seguendo una funzione semplice, la chiamo $g$, candidate density.</description>
    </item>
    <item>
      <title>Complexity Hierarchies</title>
      <link>https://flecart.github.io/notes/complexity-hierarchies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/complexity-hierarchies/</guid>
      <description>Intractable problems are solvable in principle, but in reality they require so much time or space that there no physical computers that can solve them in reasonable time. We would like to define a clear hierarchy of these set of problems.
Space Hierarchies Def: Space constructible We say that a function $f: \mathbb{N} \to \mathbb{N}$ such that $f(n) \geq O(\log n)$ is space constructible if there exists a function from $1^{n} \to \langle f(n) \rangle$ is $O(f(n))$ space complexity.</description>
    </item>
    <item>
      <title>Gruppi</title>
      <link>https://flecart.github.io/notes/gruppi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gruppi/</guid>
      <description>Definizione gruppo Qualunque insieme piÃ¹ operazione tale per cui:
Esistenza dell&amp;rsquo;inverso per ogni elemento $\forall g \in G, \exists g^{-1} \in G : gg^{-1} = e$ Esistenza di un elemento neutro $\exists e \in G: \forall g \in G, eg = g$ AssociativitÃ : $(gh)f = g(hf)$ Closure: $\forall g, h \in G \implies gh \in G$ UnicitÃ  dellâ€™elemento neutro Supponiamo di avere un gruppo $G$ e due elementi neutri $e, f$ Allora abbiamo che $ae = a = af$ perÃ² se moltiplichiamo per l&amp;rsquo;inversa abbiamo che $a^{-1}ae = a^{-1}af \implies e = f$</description>
    </item>
    <item>
      <title>Introduction to computational statistics</title>
      <link>https://flecart.github.io/notes/introduction-to-computational-statistics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduction-to-computational-statistics/</guid>
      <description>What is it for Estimation Sampling generate numbers from any distribution! (distributions are important in statistics). Density Cumulative distribution (and others similar). Optimization how to find computationally the min and max of functions. Generating?
Random (difficile anche filosoficamente definire cosa significa questo). Molto importante perchÃ© si assume in Comp stats che abbiamo il random vero, e questa assunzione che non vale puÃ² rompere cose. And independent Sample proportion Average of something (example of the lake cannonball).</description>
    </item>
    <item>
      <title>Memoria virtuale</title>
      <link>https://flecart.github.io/notes/memoria-virtuale/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/memoria-virtuale/</guid>
      <description>Memoria virtuale PerchÃ© Ã¨ utile la MV? ðŸŸ¨- I programmi non usano tutta la memoria, ma pensano di averla tutta disponibile dal suo punto di vista. L&amp;rsquo;idea principale Ã¨ che molte zone di memoria sono inutili per lungo tempo, possono essere utilizzati per altro.
caricamento codice dinamico Per esempio anche a caricare il codice di un compilatore Ã¨ diviso in fasi, se andiamo a caricare tutto, stiamo utilizzando solo un pezzo piccolo, tanta inefficienza, se una pagina contiene una parte del compilatore potrei caricare in memoria solamente le parti eseguite sul momento, giusto per fare un esempio diciamo.</description>
    </item>
    <item>
      <title>Monte carlo integration</title>
      <link>https://flecart.github.io/notes/monte-carlo-integration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/monte-carlo-integration/</guid>
      <description>DI Law of Large Numbers e Central limit theorem ne parliamo in Central Limit Theorem and Law of Large Numbers. Usually these methods are useful when you need to calculate following something similar to Bayes rule, but don&amp;rsquo;t know how to calculate the denominator, often infeasible integral. We estimate this value without explicitly calculating that.
Interested in $\mathbb{P}(x) = \frac{1}{z} \mathbb{P}^{*}(x) = \frac{1}{Z} e^{-E(x)}$ Can evaluate E(x) at any x.</description>
    </item>
    <item>
      <title>Partially synchronous model</title>
      <link>https://flecart.github.io/notes/partially-synchronous-model/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/partially-synchronous-model/</guid>
      <description>Ultima modifica: January 3, 2023 3:59 PM Primo Abbozzo: January 3, 2023 3:58 PM Studi Personali: No
Elementi di ripasso Argomento https://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf</description>
    </item>
    <item>
      <title>Recurrent Neural Networks</title>
      <link>https://flecart.github.io/notes/recurrent-neural-networks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/recurrent-neural-networks/</guid>
      <description>Introduzione ai RNN Vorremmo costruire un modello che fosse in grado di predire delle cose che dipendono da vecchie sequenze (quindi un network che abbia in un qualche senso la memoria di un coso passato).
Riassunto in slide Formalizzazione del network Stato interno La differenza principale col percettrone Ã¨ la presenza di uno stato interno nascosto, che continua a trasformarsi a seconda degli input, lo chiamiamo interno perchÃ© non Ã¨ dato in output, ma viene se</description>
    </item>
    <item>
      <title>Relazioni fra insiemi</title>
      <link>https://flecart.github.io/notes/relazioni-fra-insiemi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/relazioni-fra-insiemi/</guid>
      <description>Coppia ordinata Definizione di Kuratowsky Una coppia ordinata Ã¨ definita dall&amp;rsquo;insieme
$$ \langle X, Y \rangle = \{X, \{X, Y\}\} $$ Ãˆ quindi chiaro che due coppie ordinate sono uguali fra di loro nel caso in cui gli elementi sono uguali ma anche la loro posizione sono uguali
Teorema caratterizzazione delle coppie
Definizione di Wiener $$ (X,Y) := \{\{\{X\}, \varnothing\}, \{\{Y\}\}\} $$ Definizione di Hausdorff $$ (X,Y) := \{\{X, 1\}, \{X,2\}\} $$ ProprietÃ  fondamentale coppie ordinate Due coppie ordinate si dicono uguali se e solo se il primo elemento dei due sono uguali e la stessa cosa per il secondo</description>
    </item>
    <item>
      <title>Spettrometri di massa</title>
      <link>https://flecart.github.io/notes/spettrometri-di-massa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/spettrometri-di-massa/</guid>
      <description>Particelle in campi magnetici Moto in campo magnetico uniforme ðŸŸ© Se abbiamo una particella carica con velocitÃ  uniforme in campo magnetico uniforme, come abbiamo detto in precedenza, una forza centripeta, questo farÃ  curvare la carica, una cosa interessante sarebbe provare a capire raggio di curvatura della nostra carica. Sotto in immagine abbiamo l&amp;rsquo;esempio di curvatura. $$ F = qvB= ma = \frac{mv^{2}}{r} \implies r = \frac{mv^{2}}{qvB} = \frac{mv}{qB} = \frac{p}{qB} $$ Dove $p$ Ã¨ la quantitÃ  di moto, quantitÃ  che credo sia relazionata al lavoro ed inerzia, parte di fisica 1 che non ho studiato da piÃ¹ di due anni.</description>
    </item>
    <item>
      <title>Deduzione naturale</title>
      <link>https://flecart.github.io/notes/deduzione-naturale/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/deduzione-naturale/</guid>
      <description>La deduzione naturale Ã¨ un possibile sistema deduttivo che utilizza il linguaggio naturale per questo motivo piÃ¹ beginner friendly. Lo facciamo prima per la Logica Proposizionale che Ã¨ molto facile
Il sistema deduttivo Poniamo l&amp;rsquo;esistenza di Assiomi (formule in una certa logica) e regole di inferenza definite sotto. Esempi sono $P \vdash \varphi$ se $\varphi$ Ã¨ un assioma. O altre cose simili con $\land$ e simili&amp;hellip;
Una dimostrazione allora Ã¨ una sequenza di $\varphi_{1}, \dots, \varphi_{n}$ dove $\varphi_{i}$ Ã¨ derivata con le regole di inferenza e $\varphi_{1}, \dots, \varphi_{i - 1}$.</description>
    </item>
    <item>
      <title>General SWE principles</title>
      <link>https://flecart.github.io/notes/general-swe-principles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/general-swe-principles/</guid>
      <description>This small note sections tries to fix 5 important concepts in software engineering
Sub-system and modules ðŸŸ© We need to differentiate from sub-system, which is a part of a system that tries to achieve some objective, and a module, which is more language specific way of saying imported file, or set of functions or classes.
Information hiding ðŸŸ© This is a very important principle present in object oriented programming. Within this philosophy we should be able to access only public methods or data, this allows the construction of abstractions that allow us to think at a higher level.</description>
    </item>
    <item>
      <title>Introduzione algebra</title>
      <link>https://flecart.github.io/notes/introduzione-algebra/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-algebra/</guid>
      <description>Tutta sta parte si fa in modo formale in Sistemi Lineari e determinanti, quindi potresti saltarla totalmente
Equazioni lineari L&amp;rsquo;obiettivo dell&amp;rsquo;algebra lineare Ã¨ risolvere n equazioni con n sconosciuti di primo grado. Cosa che ci riesce con grandissimo successo! Andiamo ora a definire meglio cosa Ã¨ una equazione lineare
Definizione Una equazione lineare Ã¨ una equazione a coefficienti appartenenti a un certo campo (che puÃ² essere R) e incognite il cui grado Ã¨ 1 e che siano indipendenti:</description>
    </item>
    <item>
      <title>Legge di Gauss</title>
      <link>https://flecart.github.io/notes/legge-di-gauss/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/legge-di-gauss/</guid>
      <description>Introduzione alla legge di gauss Giustificazione con angoli solidi ðŸŸ¨&amp;ndash; Pagina 69 del Mazzoldi. Vogliamo chiederci quanto sia il flusso in qualunque superficie Da un punto di vista infinitesimo abbiamo che (perchÃ© il flusso Ã¨, intuitivamente, la parte perpendicolare rispetto la superficie che abbiamo) $$ d\Phi = \vec{E}\cdot \vec{dS} = \lvert \vec{E} \rvert \lvert \vec{dS} \rvert \cos \theta = \frac{1}{4\pi\varepsilon_{0}}\frac{1}{r^{2}} ds = \frac{Q}{4\pi\varepsilon}d\Omega $$ Il secondo passaggio Ã¨ giustificabile andando su coordinate polari considerando l&amp;rsquo;angolo solido di un oggetto quindi non dovrebbe essere un problema.</description>
    </item>
    <item>
      <title>Preparazione Esame</title>
      <link>https://flecart.github.io/notes/preparazione-esame/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/preparazione-esame/</guid>
      <description>Ultima modifica: June 21, 2023 9:07 PM Primo Abbozzo: June 17, 2023 11:59 PM Studi Personali: No
URI Cosa sono? Per cosa vengono utilizzati? Che differenza c&amp;rsquo;Ã¨ fra URL e URN? sintassi dellâ€™URI Alcuni esempi di schema (e relativo utilizzo e sintassi per lâ€™URI) IRI e IDN, cosa sono? Cosa sono i CURIE? Cosa Ã¨ URL Ref e come viene risolto Cosa Ã¨ uri resolution, e cosa uri dereference? Cosa Ã¨ LOD?</description>
    </item>
    <item>
      <title>System Design</title>
      <link>https://flecart.github.io/notes/system-design/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/system-design/</guid>
      <description>NOTA: tolgo dalle note perchÃ© non mi sembra importante.
Introduction to system design Packages vs diagrams ðŸŸ©- Packages fisica implementazione, perchÃ© Ã¨ una cosa utile per lo sviluppo Diagrams logica visualizzazione perchÃ© aiuta solamente a comprendere meglio come funziona il sistema in toto. Components What is a component (3) ðŸŸ¨ Ãˆ una entitÃ  totalmente indipendente che funziona a sÃ©, un esempio Ã¨ il dll, dynamically loaded libraries presente nei sistemi di windows.</description>
    </item>
    <item>
      <title>Teoria assiomatica degli insiemi</title>
      <link>https://flecart.github.io/notes/teoria-assiomatica-degli-insiemi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/teoria-assiomatica-degli-insiemi/</guid>
      <description>2.1 Elementi di base 2.1.1 Definizione e caratteristiche Tutto Ã¨ un insieme (su questo si basa la maggior parte della matematica) Efficace nella descrizione degli oggetti (infiniti Ã¨ ez), ma non Ã¨ efficiente nel calcolo in quanto non dÃ  nessun indizio sul&amp;rsquo;implementazione in memoria o sul modo per calcolarlo, c&amp;rsquo;Ã¨ solo una associazione Si puÃ² concludere che per l&amp;rsquo;informatico non serve a molto questa teoria, ma Ã¨ la base per la matematica.</description>
    </item>
    <item>
      <title>Algebra Logica</title>
      <link>https://flecart.github.io/notes/algebra-logica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algebra-logica/</guid>
      <description>Strutture algebriche Differenza matematica e informatica Una osservazione per quanto riguarda la logica intuizionista Ã¨ che sta a metÃ  fra matematica e informatica perchÃ© la dimostrazione intuizionista possiede in sÃ© un algoritmo e una struttura di dati.
Infatti di solito l&amp;rsquo;informatico scrive senza fare la dimostrazione dell&amp;rsquo;algoritmo mentre il matematico scrive la dimostrazione senza fare l&amp;rsquo;algoritmo (inoltre puÃ² definire degli enti ed oggetti che non siano rappresentabili come dati in quanto possono essere infiniti.</description>
    </item>
    <item>
      <title>Explainability of CNN</title>
      <link>https://flecart.github.io/notes/explainability-of-cnn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/explainability-of-cnn/</guid>
      <description>Introduction Capire in che modo una rete convoluzionale ci puÃ² dare insight migliori su come funzionano questi networks.
Visualizzazione dei hidden layers Slide visualization
Potremmo fissare una immagine anche a caso, e modificare la x in modo che sia piÃ¹ simile a quanto vuole computare il neurone. In questo modo genero una immagine che generi una activation forte nel neuron trainato, e si potrebbe dire che sia il genere di immagine che viene generata da essa.</description>
    </item>
    <item>
      <title>Memory Corruption</title>
      <link>https://flecart.github.io/notes/memory-corruption/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/memory-corruption/</guid>
      <description>First of all, we need to have a strong understanding of how a program allocates memory during its execution. See Memoria, Memoria virtuale and other notes about Nomi e Scope, Gestione della memoria. The thing you have to remember is that
Every new function call allocates a new block, with his local variables. How the calling parameters are stored in the stack How the heap is allocated (common heap algos are in Gestione della memoria) How the stack grows (and how it can overflow it, and overwriting important data).</description>
    </item>
    <item>
      <title>Proximal Polixy Optimization</title>
      <link>https://flecart.github.io/notes/proximal-polixy-optimization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/proximal-polixy-optimization/</guid>
      <description>This documents attempts to briefly present the algorithm and some experiments found online about it. The following repo seems to be a good resource: here.
Usually, PPO is explained as an actor critic framework. This means there is an agent that acts on the environment, and then there is a critic that collects the feedback from the environment. The main idea about this framework is to select a policy that is similar, so that it is less probable that a bad policy, a very different policy from the original is selected.</description>
    </item>
    <item>
      <title>Teoria dei Tipi</title>
      <link>https://flecart.github.io/notes/teoria-dei-tipi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/teoria-dei-tipi/</guid>
      <description>Ripasso Prox: 30 Ripasso: June 6, 2023 Ultima modifica: May 14, 2023 6:13 PM Primo Abbozzo: March 13, 2023 9:20 AM Studi Personali: No
Elementi di ripasso Teoria dei Tipi Introduzione Definizione ðŸŸ©â€” Un metodo sintattico praticabile per dimostrare l&amp;rsquo;assenza di determinati comportamenti del programma, fatto classificando le unitÃ  sintattiche in base ai tipi di valore che assumono
Vogliamo che fosse praticabile nel senso che effettivamente lo possiamo implementare, cioÃ¨ ci permettono di avere certe tipologie di garanzia.</description>
    </item>
    <item>
      <title>HTML e Markup</title>
      <link>https://flecart.github.io/notes/html-e-markup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/html-e-markup/</guid>
      <description>Markup Introduzione alle funzioni del markup ðŸŸ© La semantica di una parola Ã¨ caratterizzata dalla mia scelta (design sul significato). Non mi dice molto, quindi proviamo a raccontare qualcosa in piÃ¹.
Definiamo markup ogni mezzo per rendere esplicita una particolare interpretazione di un testo.
In particolare Ã¨ un modo per esplicitare qualche significato. (un pÃ² come la punteggiatura, che da qualche altra informazione oltre le singole parole, rende piÃ¹ chiaro l&amp;rsquo;uso del testo).</description>
    </item>
    <item>
      <title>Index, B-trees and hashes</title>
      <link>https://flecart.github.io/notes/index-b-trees-and-hashes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/index-b-trees-and-hashes/</guid>
      <description>Indexes Trattiamo qui di alcuni metodi che sono utilizzati per costruire indici
Introduction to indexes Gli indici sono una struttura di dati aggiuntiva che ci permette di ricercare piÃ¹ in fretta alcuni valori per le queries. In questa sezione proviamo ad approfondire in che modo possono essere costruite e gestite.
Search keys ðŸŸ© Sono in breve la cosa che vogliamo andare a cercare. Solitamente sono nella forma &amp;lt;key, label&amp;gt;, che ci permette di trovare in fretta il label, che si potrebbe intendere come il valore che noi stiamo provando a cercare.</description>
    </item>
    <item>
      <title>Paginazione e segmentazione</title>
      <link>https://flecart.github.io/notes/paginazione-e-segmentazione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/paginazione-e-segmentazione/</guid>
      <description>Memoria sistema Operativo Guradare Memoria virtuale Per vedere come vengono rimpiazzate le pagine
In quest sezione andiamo a parlare di come fanno molti processi a venire eseguiti insieme, anche se lo spazio di memoria fisico Ã¨ lo stesso. Andiamo quindi a parlare di spazio di indirizzi, risoluzione di questi indirizzi logici, segmentazione e paginazione. (e molto di piÃ¹!)
MMU Controlla se lâ€™accesso di memoria Ã¨ bono o meno. (traduzione fra indirizzo logico e fisico)</description>
    </item>
    <item>
      <title>Proximal Policy Optimization</title>
      <link>https://flecart.github.io/notes/proximal-policy-optimization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/proximal-policy-optimization/</guid>
      <description>(Schulman et al. 2017) Ã¨ uno degli articoli principali che praticamente hanno dato via al campo. Anche questo Ã¨ buono per Policy gradients:
https://lilianweng.github.io/posts/2018-04-08-policy-gradient/
Introduzione a PPO References [1] Schulman et al. â€œProximal Policy Optimization Algorithmsâ€ 2017</description>
    </item>
    <item>
      <title>Reti di flusso</title>
      <link>https://flecart.github.io/notes/reti-di-flusso/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/reti-di-flusso/</guid>
      <description>Questi problemi sono una sottoclasse della programmazione lineare con variabili reali. (Alcuni riescono a riconoscere se un problema Ã¨ in questa forma, e lo risolvono in modo istantaneo se questo succede).
Un problema dei router Ã¨ un classico problema di flusso, che si risolvono con questi algoritmi polinomiali
Note introduttive Rete, terminologia ðŸŸ© Slide
Lo sai Grafi. ma andiamo a ripeterlo
Grafo def Def arco e il loro peso (discreto o continuo) Nodi Cose nuove:</description>
    </item>
    <item>
      <title>Semafori</title>
      <link>https://flecart.github.io/notes/semafori/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/semafori/</guid>
      <description>Introduzione Concetto principale ðŸŸ©- Ãˆ sempre stato introdotto da Dijkstra, 1965 (Cooperating Sequential Processes) utilizzato come strumento di cooperazione semplice
Questo Ã¨ un sistema fortemente ispirato dai semafori che regolano gli incroci stradali.
due o piÃ¹ processi possono cooperare attraverso semplici segnali, in modo tale che un processo possa essere bloccato in specifici punti del suo programma finchÃ© non riceve un segnale da un altro processo
Primitive dei semafori ðŸŸ©- Il semaforo solitamente Ã¨ una variabile intera non negativa.</description>
    </item>
    <item>
      <title>CSP problems</title>
      <link>https://flecart.github.io/notes/csp-problems/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/csp-problems/</guid>
      <description>Costraint Satisfaction Problems.
Definizione Caratteristiche Variabili Dominio per ogni variabile Costraints per ogni variabile Queste tre sono elementi che definiscono un problema di soddisfazione delle restrizioni, una soluzione Ã¨ un assegnamento di variabili che soddisfi ogni restrizioone e sia allâ€™interno del dominio
Consistenza Vogliamo andare a limitare il dominio valutando le consistenze possibili
Consistenza del punto Si puÃ² dire che un punto sia consistente se le sue variabili possibili non viola nessuna restrizione unaria: eg.</description>
    </item>
    <item>
      <title>Equazioni non lineari</title>
      <link>https://flecart.github.io/notes/equazioni-non-lineari/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/equazioni-non-lineari/</guid>
      <description>Per trovare i zeri di una funzione continua non lineare non esistono alcuni metodi diretti che ci portano subito a una soluzione. Per questo motivo andremo ad analizzare molteplici pasis iterativi per trovare i zeri di una funzione.
La discussione di convergenza di ordine p Ã¨ stata giÃ  discussa qui Note introduttive convergenza e iterazione , per quanto riguarda i metodi iterativi per risolvere sistemi di equazioni lineari
Globale e local Ricordiamo di Norme e Condizionamento, in cui il condizoinamento era piÃ¹ o meno una stima di quanto cambia la soluzione quando cambia brevemente l&amp;rsquo;input.</description>
    </item>
    <item>
      <title>Filesystem</title>
      <link>https://flecart.github.io/notes/filesystem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/filesystem/</guid>
      <description>PerchÃ© filesystem? Questa Ã¨ l&amp;rsquo;idea presa dall&amp;rsquo;archivio, come se fosse un ufficio che deve tenere delle pratiche ordinate in cartelle e cartelloni.
Lâ€™utilizzo principale Ã¨ dare un interfaccia comune di accesso ai dispositivi. perchÃ© dispositivi diversi hanno sotto modi di accedere diversi, questa interfaccia facilita molto l&amp;rsquo;accesso.
Informazioni dei files (5+) ðŸŸ¨ Il file Ã¨ lâ€™unitÃ  logica di memorizzazione. il formato che c&amp;rsquo;Ã¨ dentro Ã¨ gestito dall&amp;rsquo;applicazione, non dal file system!</description>
    </item>
    <item>
      <title>Introduction to statistical learning</title>
      <link>https://flecart.github.io/notes/introduction-to-statistical-learning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduction-to-statistical-learning/</guid>
      <description>#statistics
Introduzione This is a short introduction to statistical learning, made with the help of the book ISLP (mi sento positivo ad affrontare la lettura di questo libro, ora che sta in python non lo vedo piÃ¹ come un libro solamente per statistici)
statistical learning refers to a set of approaches for estimating $f$ .
Utilizzi del statistical learning Solitamente sono due gli utilizzi Predizione e inferenza. Per predizione intendiamo il miglior modello che possa produrre le Y che ancora non conosciamo.</description>
    </item>
    <item>
      <title>Introduction to Theory of Mind</title>
      <link>https://flecart.github.io/notes/introduction-to-theory-of-mind/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduction-to-theory-of-mind/</guid>
      <description>In this note I will try to write down some of my own research I conducted in this field for my bachelor&amp;rsquo;s thesis. This will be a set of notes that try to describe what Theory of Mind (ToM) is generally considered to be in the scientific community.
What is Theory of Mind? This term has been popularized by (Premack &amp;amp; Woodruff 1978) in the study of Chimpanzees. In his seminal article in 1978, Premack describes the theory of mind as the ability of individuals to ascribe mental states of themselves and other individuals, such as sensory perceptions, beliefs, and desires, and the ability to use this knowledge about other individuals to predict their behaviour.</description>
    </item>
    <item>
      <title>Limiti</title>
      <link>https://flecart.github.io/notes/limiti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/limiti/</guid>
      <description>Riguardare Successioni per avere primo attacco sui limiti
4.1 Limiti finiti al finito 4.1.1 Intorno sferico Dato l&amp;rsquo;insieme $\mathbb{R}$ si definisce l&amp;rsquo;intorno sferico aperto di $x \in \mathbb{R}$ di raggio $r \in \mathbb{R}$ l&amp;rsquo;insieme $I_r(x) = (x -r, x + r)$ questa nozione Ã¨ molto importante per definire il limite. Lo useremo subito su un punto di accumulazione
4.1.2 Punto di accumulazione Un punto di accumulazione $x$ di un insieme $A \subseteq \mathbb{R}$ Ã¨ un punto tale per cui mi posso avvicinare in modo indefinito in quel punto.</description>
    </item>
    <item>
      <title>Modelli Lineari di sviluppo</title>
      <link>https://flecart.github.io/notes/modelli-lineari-di-sviluppo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/modelli-lineari-di-sviluppo/</guid>
      <description>Introduzione ai modelli lineari Processi di sviluppo Definizione Lâ€™insieme strutturato di attivitÃ , eventi, documenti e procedure necessari per la costruzione di un sistema software
Cosa viene descritto (4) ðŸŸ© Questo Ã¨ proprio quanto vuole studiare l&amp;rsquo;ingegneria del software -&amp;gt; metodi di sviluppo, in modo da portare i migliori risultati possibile.
Nella formazione classica va a definire 4 concetti (soprattutto utili nel lavoro di gruppo, al fine di comunicare nella maniera piÃ¹ efficace):</description>
    </item>
    <item>
      <title>Relational Algebra</title>
      <link>https://flecart.github.io/notes/relational-algebra/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/relational-algebra/</guid>
      <description>Introduzione all&amp;rsquo;algebra relazionale Confronto con relazioni matematiche Le relazioni come le intendiamo in database sono leggermente diverse rispetto a quelle presenti per le relazioni matematiche:
Non conta l&amp;rsquo;ordine Ci sono gli attributi Per il resto se introduciamo questo sistema per tenere conto delle astrazioni, possiamo analizzarle matematicamente, e questo ci fornisce qualche sicurezza in piÃ¹ diciamo.
Definition of tuples ðŸŸ© Le relazioni sono esattamente quelle definite in matematica, perÃ² noi aggiungiamo anche gli attributi, in modo da poter considerare l&amp;rsquo;ordine delle colonne non importante.</description>
    </item>
    <item>
      <title>Sintassi e RI strutturali</title>
      <link>https://flecart.github.io/notes/sintassi-e-ri-strutturali/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/sintassi-e-ri-strutturali/</guid>
      <description>Programmare e dimostrare sono sostanzialmente la stessa attivitÃ  ~Coen
Ma non secondo l&amp;rsquo;industria&amp;hellip;
4.1.1 Definizione e necessitÃ  Branca della linguistica, studia creazione di proposizione e il loro collegamento per la creazione di un periodo
In seguito la semantica dÃ  un metodo a queste proposizioni in modo che abbiano un senso.
Utile o necessario per la definizione del linguaggio artificiale 4.1.2 Alfabeto, stringa, linguaggio e grammatica Alfabeto: Insieme non vuoto di simboli (che spesso sono diversi fra di loro) Stringa seguenza finita (vuoto Ã¨ possibile) di simboli $\epsilon = \varnothing$ Linguaggio: insieme di stringhe (di qualunque tipo, finito o infinito).</description>
    </item>
    <item>
      <title>Teorema di Lagrange</title>
      <link>https://flecart.github.io/notes/teorema-di-lagrange/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/teorema-di-lagrange/</guid>
      <description>Classi laterali Dimostrazione dei lemmi sopra. La cosa interessante di questa parte Ã¨ possiamo usare una classe laterale per partizionare il gruppo iniziale!
Il teorema di Lagrange Dividere significa che **partiziona** l&#39;insieme iniziale in alcuni insiemi distinti. L&#39;insieme $G:H$ Ã¨ l&#39;insieme che contiene tutti i cosets, credo. Dimostrazione
|G:H| = |G|/|H| |a| divide |G| Ossia un corollario dopo il teorema di Lagrange. La cosa citata Ã¨ dimostrata in Gruppi ciclici e permutazioni#Criterio $a {i} = a {j}$.</description>
    </item>
    <item>
      <title>Training a NN</title>
      <link>https://flecart.github.io/notes/training-a-nn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/training-a-nn/</guid>
      <description>Ultima modifica: March 11, 2023 7:22 PM Primo Abbozzo: March 8, 2023 6:05 PM Studi Personali: No
Elementi di ripasso Training of NN How can we be sure that we can train well our function?
Dataset quality (this cannot be changed in training time) Models and parameters of our model, we can describe it as $L(x, \theta)$, and we try to minimize this function. Training approaches Random perturn weights, this is ispired by evolution, but itâ€™s slow and not effective (and we can make things worse in many ways) Predict adjustments, usually we can analitically define what is the best way to minimize the loss, so we would like to follow that slope and go down!</description>
    </item>
    <item>
      <title>Architettura software dellâ€™OS</title>
      <link>https://flecart.github.io/notes/architettura-software-dellos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/architettura-software-dellos/</guid>
      <description>A seconda dell&amp;rsquo;utilizzatore lâ€™OS puÃ² essere molte cose, come solamente lâ€™interfaccia se sei un programmatore, servizi (se sei un utente, ma gran parte dei servizi sono astratti e l&amp;rsquo;utente ne puÃ² anche essere a non-conoscenza).
Ma se sei un programmatore OS ti interessa capire le componenti principali dellâ€™OS
Slide componenti OS alto livello
Introduzione sui componenti (salto) Questa parte la salto perchÃ© Ã¨ una descrizione molto generale di cosa si occupa Lâ€™os verso drivers, processi, filesystem I/O, quindi non Ã¨ molto importante</description>
    </item>
    <item>
      <title>Cauchy-Schwarz Inequality</title>
      <link>https://flecart.github.io/notes/cauchy-schwarz-inequality/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cauchy-schwarz-inequality/</guid>
      <description>This note briefly states and proves one of the most famous inequalities in geometry/analysis.
Theorem Statement Given $2n$ real numbers (you can see these two also as $n$ dimensional vectors), such as $x_{1}, \dots, x_{n}$ and $y_{1}, \dots, y_{n}$ then we have that $$ \left( \sum_{i = 1}^{n} x_{i}y_{i} \right) ^{2} \leq \left( \sum_{i= 1}^{n} x^{2}_{i} \right) \left( \sum_{i = 1}^{n} y^{2}_{i} \right) $$ In vectorial form we can rewrite this as $$ \lvert \langle u, v \rangle \rvert ^{2} \leq \langle u, u \rangle \cdot \langle v, v \rangle $$ with $u = \left( x_{1}, \dots, x_{n} \right)$ and $v = \left( y_{1}, \dots, y_{n} \right)$ and the $\langle \cdot, \cdot \rangle$ operator is the inner product.</description>
    </item>
    <item>
      <title>Introduzione a reti</title>
      <link>https://flecart.github.io/notes/introduzione-a-reti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-a-reti/</guid>
      <description>Questa nota raccoglie note introduttive al corso di reti dei calcolatori fatto all&amp;rsquo;universitÃ  di Bologna.
0.1.1 Definizione di rete di calcolatori (2) ðŸŸ©- I requisiti sono principalmente 2
Essere autonomi nel calcolo (capacitÃ  di eseguire dei programmi) Essere interconnessi (capacitÃ  di ricevere ed inviare dei segnali) Gli scopi sono principalmente per la comunicazione fra utenti o calcolatori.
Non-esempi
Rete telefonica, non sono autonomi Rete televisiva Esempi
Smartphones con wi-fi WWW E-mail Una rete di calcolatori Ã¨ un insieme di dispositivi autonomi, cioÃ¨ in grado di eseguire e svolgere autonomamente i compiti programmati di calcolo e di comunicazione, interconnessi tra loro da supporti fisici alla trasmissione di segnali.</description>
    </item>
    <item>
      <title>Model of Analogies</title>
      <link>https://flecart.github.io/notes/model-of-analogies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/model-of-analogies/</guid>
      <description>The human ability of making analogies proceeds in such a way as to keep complexity minimal.
PerchÃ© facciamo questo? PerchÃ© Ã¨ la cosa piÃ¹ semplice da fare! Anche su Vapnik&amp;rsquo;s dimensions Ã¨ simile questa idea!
Occam razor, Epicuro, con Solomonoff che ha risolto problema dell&amp;rsquo;induzione che Hume pensava di fare con abitudini. Attualmente IQ tests provano a misurare la capacitÃ  di estendere questo.
Analogia Studiamo l&amp;rsquo;analogia come oggetto matematico perchÃ© sembra essere una capacitÃ  molto difficile da generalizzare e utilizzare nelle macchine.</description>
    </item>
    <item>
      <title>Normalizzazione dei database</title>
      <link>https://flecart.github.io/notes/normalizzazione-dei-database/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/normalizzazione-dei-database/</guid>
      <description>Introduzione alla normalizzazione PerchÃ© si normalizza? ðŸŸ© Cercare di aumentare la qualitÃ  del nostro database, perchÃ© praticamente andiamo a risolvere delle anomalie possibili al nostro interno, e questo aiuta per la qualitÃ .
Tipologie di anomalie (!) (4) ðŸŸ¨+ Ridondanze, non vorrei avere la stessa informazione espressa piÃ¹ volte in troppi punti. Update non consistente, quando per aggiornare un singolo valore devo aggiornare moltissime altre tuple dipendenti da essa. Deletion non consistente, la presenza di certe entitÃ  Ã¨ strettamente dipendente da presenza di altri, nell&amp;rsquo;esempio in questione sulle slides, se elimino tutti gli utenti, elimino anche i progetti su cui hanno partecipato, mentre invece dovrebbero essere separati.</description>
    </item>
    <item>
      <title>Planning automatico</title>
      <link>https://flecart.github.io/notes/planning-automatico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/planning-automatico/</guid>
      <description>Planning Automatico Vogliamo andare a creare un programma che sia in grado di creare un piano per fare una azione, andiamo in questo capitolo gli algoritmi storicamente migliori adatti a risolvere questo problema
Il problema di pianificazione Andiamo a rappresentare il nostro problema di pianificazione con un linguaggio molto simile alla Logica del Primo ordine.
Ãˆ il PDDL ossia il Planning domain definition language
PDDL Questo linguaggio Ã¨ definito da</description>
    </item>
    <item>
      <title>Teorema di Rice</title>
      <link>https://flecart.github.io/notes/teorema-di-rice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/teorema-di-rice/</guid>
      <description>Introduction to the Rice Theorem Ci sono molti teoremi che non possono essere decisi, vedere Halting Theorem and Reducibility. Qui andiamo a chiederci quale sia l&amp;rsquo;insieme dei problemi decidibili.
ProprietÃ  dei linguaggi TMðŸŸ© Data una macchina $\mathcal{M}$ definiamo il suo linguaggio come $$ L_{\mathcal{M}} = \left\{ x \in \Sigma^{*}: \mathcal{M} \text{ accetta } x \right\} $$ Allora con questa definizione di linguaggio possiamo dire che una proprietÃ , ossia una funzione da tutti i $TM$ possibili a $\left\{ 0, 1 \right\}$ tale per cui se il linguaggio riconosciuto Ã¨ lo stesso, ossia $$ L_{\mathcal{M}} = L_{\mathcal{M}&#39;} \implies P(\mathcal{M}) = P(\mathcal{M}&#39;) $$ Definiamo questa non triviale se esiste una macchina per cui Ã¨ 0, e una per cui Ã¨ 1 (ossia non Ã¨ costante).</description>
    </item>
    <item>
      <title>The Tor protocol</title>
      <link>https://flecart.github.io/notes/the-tor-protocol/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/the-tor-protocol/</guid>
      <description>Some notes Mix-based systemsðŸŸ¨ Created in 1981 by David Chaum. Very similar to the previous one, in practice, in the end, it acts as a proxy but not only does it take and receive, but it also mixes together the packets it has received from the sources, applying its key.
Disadvantage: The public-private mixing system is very slow. For this reason, a network of nodes is established, each having a symmetric key, making it much faster.</description>
    </item>
    <item>
      <title>Attention</title>
      <link>https://flecart.github.io/notes/attention/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/attention/</guid>
      <description>This note tries to summarize what I think I know about the attention architecture in Transformers. First introduced in (Bahdanau et al. 2014). Attention is an architecture used in Transformers to encode a soft version of dictionaries. Usually it is called self-attention when everything we want is just trying to change the values of the $X$ with a value. This value is called attention weight.
In standard attention based architectures the self-attention layer is computed as follows.</description>
    </item>
    <item>
      <title>Design patterns</title>
      <link>https://flecart.github.io/notes/design-patterns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/design-patterns/</guid>
      <description>Introduction to design patterns Introduzione personale ðŸŸ© I design patterns sono simili a dei plug and play, ossia delle soluzioni che hanno funzionato bene in passato e che sono ora riutilizzati. Solitamente dovrebbe essere una abilitÃ  implicita, cioÃ¨ un buon programmatore Ã¨ in grado di fare senza pensarci, dovrebbe essere automatico. Infatti quando uno fa il design non lo fa esplitamente seguendo un certo modello, ma farlo solitamente risulta utile per guidare il processo.</description>
    </item>
    <item>
      <title>Determinanti</title>
      <link>https://flecart.github.io/notes/determinanti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/determinanti/</guid>
      <description>Determinanti I determinanti sono un numero associato alle matrici quadrate. PiÃ¹ o meno ne sono il riassunto.
ProprietÃ  Le prime 3 sono quelle fondamentali per calcolare il tutto, i numeri dopo il 3 sono alcune conseguenze.
det I = 1
Cambiare righe â†’ cambiare il segno della determinante.
(Importante)
Se moltiplico una riga per una costante, il determinante Ã¨ moltiplicato per questa costante. Se sommo una costante a una riga, allora il determinante Ã¨ una somma strana&amp;hellip; Immagine di esempio</description>
    </item>
    <item>
      <title>Livello di trasporto</title>
      <link>https://flecart.github.io/notes/livello-di-trasporto/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/livello-di-trasporto/</guid>
      <description>Guardare la parte equivalente in Note Esame che Ã¨ simile.
Livello di trasporto Si parla di livello logico di trasporto, ma gran parte ne abbiamo giÃ  parlato in Livello applicazione e socket di UDP, TCP e Socket. trasporto end-to-end, nel senso che livello traporto viene visto solamente ad inizio e alla fine, in tutti i nodi intermedi non Ã¨ visto sto pacchetto.
UDP (3) ðŸŸ©- Slide UDP
Classico inizio e fine porta del socket.</description>
    </item>
    <item>
      <title>Message Passing</title>
      <link>https://flecart.github.io/notes/message-passing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/message-passing/</guid>
      <description>ora abbiamo alcune primitive per passarci i messaggi, vogliamo creare metodo in modo che i processi si possano sincronizzare mandando messaggi.
la memoria Ã¨ sempre privata.
Primitive Send e receive ðŸŸ© Send
Spedizione del messaggio input deve avere un identificato al processo su cui spedire. Se si vuole espandere si possono avere multicast e broadcasting ma non li studieremo in questo corso.
Receive
Ricevi messaggi
Tassonomia dei message passing (!)ðŸŸ© Slide</description>
    </item>
    <item>
      <title>Onde elettromagnetiche</title>
      <link>https://flecart.github.io/notes/onde-elettromagnetiche/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/onde-elettromagnetiche/</guid>
      <description>Prendiamo La legge di Ampere-Maxwell $$ \vec{\nabla} \times \vec{B} = \mu_{0}\vec{J} + \mu_{0}\varepsilon_{0} \frac{\delta \vec{E}}{\delta t} $$ E la legge di Faraday neumann Lenz $$ \vec{\nabla} \times \vec{E} = - \frac{\delta \vec{B}}{\delta t} $$ Con questi abbiamo le onde elettromagnetiche.
Nel vuoto possiamo dire che non abbiamo densitÃ  di corrente, per questo posso andare nel vuoto, sono due cose che si autosostengono. Sono simmetriche a meno di costante.
Questo ci dice che</description>
    </item>
    <item>
      <title>Successioni</title>
      <link>https://flecart.github.io/notes/successioni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/successioni/</guid>
      <description>3.1 Successioni $$ \begin{cases} f: \mathbb{N} \to \mathbb{R} \\ n \to f(n) \\ \{a\}_{n \in \mathbb{N}} \vee a_n \end{cases} $$ Ãˆ una funzione che mappa dai naturali ai Reali indicata spesso solamente come $$ \left\{ a \right\} _{n \in \mathbb{N}} $$ 3.1.1 Immagine e successione L&amp;rsquo;immagine di una successione (l&amp;rsquo;insieme dei suoi elementi) non Ã¨ una successione! la successione Ã¨ anche ordinata.
3.1.2 Limitazioni della successione Come per gli insiemi si puÃ² definire se l&amp;rsquo;insieme Ã¨ limitato superiormente, inferiormente o entrambi, a seconda di come lo definiamo in questo modo possiamo poi farci altri ragionamenti</description>
    </item>
    <item>
      <title>Time and Space Complexity</title>
      <link>https://flecart.github.io/notes/time-and-space-complexity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/time-and-space-complexity/</guid>
      <description>In this note we explore a theme of time and space complexity. Those are cardinal themes in Theoretical CS. Time -&amp;gt; execution step bounds on algorithms Space -&amp;gt; the cells visited by a Turing Machine when executed.
Introduction to Time Complexity This note will build upon know techniques of algorithms analysis explained in Notazione Asintotica. We will need big-$O$ notation and $o$ notation. L&amp;rsquo;idea Ã¨ che il problema di decisione Ã¨ decidibile se limito la lunghezza del teorema.</description>
    </item>
    <item>
      <title>Circuiti Sequenziali</title>
      <link>https://flecart.github.io/notes/circuiti-sequenziali/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/circuiti-sequenziali/</guid>
      <description>7.1 Introduzione 7.1.1 PerchÃ© usarli Sono utili per mantenere delle informazioni nel tempo
7.1.2 Caratteristiche Hanno feedback cioÃ¨ ci sono degli output che tornano dentro al circuito, quindi Ã¨ molto difficile senza sapere niente cosa succede dentro
Questo circuito non Ã¨ combinatorio, che Ã¨ formalizzabile in modo deterministico con l&amp;rsquo;lgebra booleana.
7.1.3 Il Bit di memoria Questo bit ha due input, un load e un input, se il load Ã¨ attivo comincia a storare, altrimenti l&amp;rsquo;output Ã¨ sempre il bit che ha memoriazzato.</description>
    </item>
    <item>
      <title>Dipolo elettrico</title>
      <link>https://flecart.github.io/notes/dipolo-elettrico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/dipolo-elettrico/</guid>
      <description>Questo problema Ã¨ stato trattato in modo un po&amp;rsquo; piÃ¹ semplificato (nel caso in cui la carica era esattamente a metÃ  in Campo elettrico#Dipolo elettrico). Questo problema Ã¨ stato storico, utilizzato per analizzare l&amp;rsquo;atomo.
Potenziale del dipolo elettrico ðŸŸ©&amp;ndash; Per il principio di sovrapposizione possiamo affermare che $$ V(P) = V_{r^{+}} + V_{r^{-}} = \frac{q}{4\pi\varepsilon_{0}}\left( \frac{1}{r^{+}} - \frac{1}{r^{-}} \right) $$ Ora possiamo fare certe approssimazioni, supponendo che $r \gg a$ con $r$ la congiungente fra il centro del dipolo e il nostro punto e $a$ la distanza fra le cariche, possiamo affermare che $$ r^{+} - r^{-} = -a \cos \theta $$ Sappiamo che l&amp;rsquo;angolo Ã¨ lo stesso (piÃ¹ o meno), perchÃ© sappiamo che i due reggi sono ora paralleli (come assunsione di semplificazione) Inoltre abbiamo che $r^{+}r^{-} = r^{2}$ perchÃ© il punto Ã¨ molto lontano allora possiamo affermare che $$ \left( \frac{1}{r^{+}} - \frac{1}{r^{-}} \right) = \frac{a\cos \theta}{r^{2}} $$ a $$ V(P) = \frac{1}{4\pi\varepsilon_{0}}\frac{qa\cos \theta}{r^{2}} = \frac{1}{4\pi\varepsilon_{0}}\frac{P\cos \theta}{r^{2}} = \frac{1}{4\pi\varepsilon_{0}} \frac{\vec{P}\cdot \hat{r}}{r^{2}} $$ Direttamente proporzionale al momento di tipolo Inversamente proporzionale al quadrato del raggio.</description>
    </item>
    <item>
      <title>Geometrie di spire</title>
      <link>https://flecart.github.io/notes/geometrie-di-spire/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/geometrie-di-spire/</guid>
      <description>Spire Spira quadrata Questo Ã¨ descritto nell&amp;rsquo;esempio 8.1 del Mazzoldi. Ãˆ stato descritto anche in un esercizio in classe (non Ã¨ importante).
Spira circolare ðŸŸ© Vedere pagina 245 Vogliamo cercare il valore del campo sull&amp;rsquo;asse della spira circolare. Questo Ã¨ semplice, basta usare la prima di Laplace e trovare l&amp;rsquo;apporto del campo magnetico al centro. Si puÃ² anche pensare come momento magnetico, allora si utilizza sempre lo stesso discorso per la spira quadrata classica e il suo momento.</description>
    </item>
    <item>
      <title>Kolmogorov complexity</title>
      <link>https://flecart.github.io/notes/kolmogorov-complexity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/kolmogorov-complexity/</guid>
      <description>Gran parte di quanto scrivo ora Ã¨ tratto da (Li &amp;amp; VitÃ¡nyi 2019). Chaitin, Kolmogorov e Solomonoff hanno elaborato il tema in modo indipendente e allo stesso tempo verso gli anni &amp;lsquo;60!
Solomonoff lo ha trovato sul problema dell&amp;rsquo;induzione all&amp;rsquo;etÃ  di 38 anni, Kolmogorov invece era giÃ  tardi, ha giÃ  trovato gli assiomi della probabilitÃ  e poi nel 65 cerca randomness. Mentre Chaiten Information = Computation e non probabilitÃ , nel 68 all&amp;rsquo;etÃ  di 19 anni.</description>
    </item>
    <item>
      <title>Minimi quadrati</title>
      <link>https://flecart.github.io/notes/minimi-quadrati/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/minimi-quadrati/</guid>
      <description>Note matematiche introduttive Vettori ortonormali ðŸŸ© Questa parte Ã¨ fatto molto meglio in Inner product spaces.
Due vettori si dicono ortonormali se $vv^T = ||v|| = 1$ e sono ortogonali, ossia $v_i v^T_j = 0$ con i e j diversi fra di loro
Matrici ortogonale (4) ðŸŸ©- Matrici si dicono ortonomali se le sue colonne sono vettori sono ortonormali
Matrici ortonormali sono isometrie, cioÃ¨ mantengono le distanze. Queste matrici sono tutte non singolari e quadrate per definizione La sua inversa Ã¨ ortogonale La sua inversa Ã¨ uguale alla trasposta slide ProprietÃ  matrice ortonormale</description>
    </item>
    <item>
      <title>Note sullâ€™architettura</title>
      <link>https://flecart.github.io/notes/note-sullarchitettura/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/note-sullarchitettura/</guid>
      <description>Interrupt Descrizione iniziale ðŸŸ© Di interrupt e trap se nâ€™Ã¨ parlato un pÃ² in Livello ISA di architettura, ora andiamo ad approfondire come viene gestito a livello SO.
Un interrupt Ã¨ un segnale che viene mandato o da un dispositivo hardware (di solito dopo la fine di un processo input output) oppure da software, in questo caso viene chiamato trap che Ã¨ un interrupt software sincrono..
Slide Interrupt Hardware e software</description>
    </item>
    <item>
      <title>Astrazione sul controllo</title>
      <link>https://flecart.github.io/notes/astrazione-sul-controllo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/astrazione-sul-controllo/</guid>
      <description>Significato di astrazione L&amp;rsquo;astrazione Ã¨ una cosa fondamentale nell&amp;rsquo;informatica, lâ€™abbiamo visto anche nella prima lezione in assoluto per architettura, il sistema a strati di Architettura e livelli 1, 2 reti e simili.
Il principali metodi sono astrazioni sul controllo e sui dati sui dati stiamo cominciando a parlarne in Teoria dei Tipi.
Le astrazioni sono utili a nascondere dettagli per qualche fenomeno o simile (ricorda l&amp;rsquo;esempio della mappa, che non Ã¨ il territorio Ã¨ una astrazione su essa, che contiene ancora informazioni utili).</description>
    </item>
    <item>
      <title>k-esimo priority-q DSU</title>
      <link>https://flecart.github.io/notes/k-esimo-priority-q-dsu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/k-esimo-priority-q-dsu/</guid>
      <description>Questo documento Ã¨ totalmente concentrato sull&amp;rsquo;analisi del problema della selezione del k-esimo elemento.
7.1 Introduzione al problema Dato un array di elementi vogliamo cercare di trovare un modo efficiente per selezionare il k-esimo elemento, ossia un elemento che sia maggiore di k-1 elementi
7.1.1 Note sull&amp;rsquo;utilizzo Questo algoritmo Ã¨ utile per esempio per sapere cosa displayare in una pagina di ricerca, perchÃ© per esempio posso avere blocchi di tanta roba 140k, mentre ovviamente posso selezionare solamente un blocco ristretto.</description>
    </item>
    <item>
      <title>Logica del Primo ordine</title>
      <link>https://flecart.github.io/notes/logica-del-primo-ordine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/logica-del-primo-ordine/</guid>
      <description>Logica del primo ordine Questa Ã¨ la logica piÃ¹ utilizzata dai matematici
Limitatezza della logica proposizionale La logica proposizionale classica non Ã¨ in grado di ragionare sull&amp;rsquo;infinito Fino ad ora abbiamo utilizzato una metalogica per giustificare il per ogni e l&amp;rsquo;esiste nelle dimostrazioni fin&amp;rsquo;ora.
Dobbiamo quindi dare una definizione piÃ¹ formale dei quantificatori.
Obiettivo della logica del primo ordine Si puÃ² quindi identificare come l&amp;rsquo;obiettivo della logica di primo ordine l&amp;rsquo;introduzione dei quantificatori dell&amp;rsquo;universale e dell&amp;rsquo;esiste</description>
    </item>
    <item>
      <title>Monitor</title>
      <link>https://flecart.github.io/notes/monitor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/monitor/</guid>
      <description>Questo Ã¨ un modo di piÃ¹ alto livello per creare programmazione concorrente.
Introduzione ai monitor Questo costrutto per la programmazione concorrente, prende molto dalla programmazione agli oggetti, abbiamo delle variabili presenti al monitor, private solamente accessibili ad essa, tramite procedure che sono mutex automaticamente!
Elementi costituenti ðŸŸ© Dati locali Sequenza di inizializzazione Procedure di entrata Appena provo a chiamare una procedura, questa Ã¨ fatta giÃ  in mutua esclusione!.
E possono modificare dati locali solo tramite chiamate a sue procedure</description>
    </item>
    <item>
      <title>Probabilita condizionata e indipendenza</title>
      <link>https://flecart.github.io/notes/probabilita-condizionata-e-indipendenza/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/probabilita-condizionata-e-indipendenza/</guid>
      <description>Condizionata Definizione ðŸŸ© Andiamo a definire una probabilitÃ  di un evento $A$, condizionata a un evento non nullo $B$, come
$$ P(A|B) = \dfrac{P(A\cap B)}{P(B)} $$ Questo Ã¨ la cosa fondamentale per poter considerare cose come bayes perchÃ© in questo modo abbiamo una certa relazione fra causa ed effetto e anche il contrario! Cosa che ci piace molto molto molto.
La definizione di sopra Ã¨ un probabilitÃ  ðŸŸ© Dimostrazione mia</description>
    </item>
    <item>
      <title>Randomness</title>
      <link>https://flecart.github.io/notes/randomness/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/randomness/</guid>
      <description>Introduzione alla RandomicitÃ  Questo Ã¨ principalmente basato su (Li &amp;amp; VitÃ¡nyi 2019) Capito 1.9 Sembra che la nozione di random sia alla fine una cosa molto profonda. Per esempio, un caso lampante che le definizioni non funzionano nel caso di numeri trascendenti Ã¨ che catalogano i numeri di $\pi$ come se fossero casuali, mentre in realtÃ  possono essere trovati mediante procedimenti precisi. Ãˆ una distinzione filosoficamente molto interessante.
Alla fine sembra ci sia un link molto diretto con la crittografia, si puÃ² vedere (Stinson 2005).</description>
    </item>
    <item>
      <title>Rappresentazione delle informazioni</title>
      <link>https://flecart.github.io/notes/rappresentazione-delle-informazioni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/rappresentazione-delle-informazioni/</guid>
      <description>6.1 Codifiche Si utilizzano codifiche, che sono delle convenzioni, qualcosa che un gruppo di umani ha deciso fosse utile darci un significato.
6.1.1 Codifica posizionale Dove $d_i$ Ã¨ il valore in posizione $i$ e $b$ Ã¨ la base
$$ \sum_{i=0}^k d_ib $$ 6.1.2 Ottale, esadecimale e binario Queste sono le codifiche principali per i computer in quanto sono comodi da visualizzare. Inoltre Ottale e esadecimale in particolare sono riassunti dei binari, cioÃ¨ sono dei sottoinsiemi che possiedono ancora tutte le caratteristiche e quindi sono comodi</description>
    </item>
    <item>
      <title>Sicurezza OS</title>
      <link>https://flecart.github.io/notes/sicurezza-os/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/sicurezza-os/</guid>
      <description>Possiamo classificare tre aree generali quando si parla di sicurezza informatica:
Hardware Software human-ware. Non tratteremo in particolare esattamente come ogni campo viene declinato, perÃ² possiamo
Una altra tendenza generale Ã¨ che piÃ¹ Ã¨ complessa piÃ¹ Ã¨ insicura. e questo senso di insicurezza cresce in modo maggiore rispetto al lineare.
Security principles Open Design perchÃ© cosÃ¬ puÃ² essere scrutata da piÃ¹ persone Economy of mechanism spiegata sotto. Fail-safe defaults questo molto importante perchÃ© molti sistemi hanno dei default che possono essere exploitati.</description>
    </item>
    <item>
      <title>Tecnologia Wireless</title>
      <link>https://flecart.github.io/notes/tecnologia-wireless/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/tecnologia-wireless/</guid>
      <description>Introduzione Spettro del wireless networks (skip) Slide spettro Wirelesss networks
Questo solamente la classica differenziazione fra radio, visibile, raggi x raggi gamma etcetera.
Se andiamo a guardare le onde radio, quelle che ci interessano, se ho frequenza alta ho densitÃ  di frequenza alta, se ho frequenza bassa ho alta capacitÃ  di suparamento di ostacoli.
ISM Ã¨ una banda da 2 a 5.0 GHz e c&amp;rsquo;Ã¨ tutto il WiFi, bluetooth. (anche wifi a 5 ghz.</description>
    </item>
    <item>
      <title>Cambio di Base</title>
      <link>https://flecart.github.io/notes/cambio-di-base/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cambio-di-base/</guid>
      <description>Nozioni da avere prima di Cambio di Base Applicazioni lineari La definizione di applicazione lineare La matrice associata L&amp;rsquo;esistenza e unicitÃ  di una applicazione lineare rispetto a una base Le coordinate di un punto rispetto a una base. Matrice del Cambio di Base Se ho due spazi vettoriali
Intuizione in $R$ Le coordinate dei punti in $R$ sono uguali a $V$ per le basi canoniche, ma questo vale solamente per $R$, ora vogliamo andare a dire una cosa piÃ¹ forte, il cambio di base Poi sarÃ  importantissimo questa nozione, applicazione di base in ML Ã¨ Principal Component Analysis.</description>
    </item>
    <item>
      <title>Introduction to Algorithmic Information and Complexity</title>
      <link>https://flecart.github.io/notes/introduction-to-algorithmic-information-and-complexity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduction-to-algorithmic-information-and-complexity/</guid>
      <description>Quick introduction Si assume che la descrizione piÃ¹ intelligente di un qualcosa Ã¨ la stringa piÃ¹ corta che descrive quella, un po&amp;rsquo; forse Ã¨ arbitrario, perchÃ© minore complessitÃ , non Ã¨ detto che sia direttamente relazionata con la difficoltÃ  di descriverla.
Nel caso di AIT, diciamo che una cosa random non Ã¨ compressibile, altrimenti posso scriverla in modo piÃ¹ compatto. Ãˆ importante stabilire che l&amp;rsquo;alfabeto che abbiamo per rappresentare qualcosa Ã¨ fissato a priori.</description>
    </item>
    <item>
      <title>Autovalori e Autovettori</title>
      <link>https://flecart.github.io/notes/autovalori-e-autovettori/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/autovalori-e-autovettori/</guid>
      <description>Ha senso solamente parlare di autovettori quando si ha una applicazione lineare con stesso dominio e stesso codominio.
Vorremmo trovare una buona matrice che sia diagonale.
6.1 DiagonalizzabilitÃ  6.1.1 Definizione per funzione e matrice Questo perchÃ© vorrei una base in cui si abbia un matrice diagonale. (quindi probabilmente P Ã¨ una matrice identitÃ ).
PerchÃ© ci piacciono le matrici diagonali
Se ho una matrice diagonale, si ha che l&amp;rsquo;applicazione lineare Ã¨ un semplice scaling dei vettori della base.</description>
    </item>
    <item>
      <title>Bottom-up Parser LR(1)</title>
      <link>https://flecart.github.io/notes/bottom-up-parser-lr1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bottom-up-parser-lr1/</guid>
      <description>Si puÃ² osservare che per il parser costruito in Bottom-up Parser LR(0), non riesce a riconoscere di linguaggi semplici come $L = \{a, ab\}$.
Esempio di quanto detto Parser SLR(1) Questi parser qui utilizzano lâ€™idea del look ahead ampiamente utilizzata in Top-down Parser, per escludere molte produzioni.
La s sta per simple, perchÃ© utilizza una idea semplice :D, credo ahah boh.
Riduzione con follow ðŸŸ© noi vogliamo ridurre solamente se ho follow corretto il terminale finale della stringa.</description>
    </item>
    <item>
      <title>Introduzione sistemi operativi</title>
      <link>https://flecart.github.io/notes/introduzione-sistemi-operativi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-sistemi-operativi/</guid>
      <description>Ultima modifica: March 1, 2023 9:52 AM Primo Abbozzo: October 16, 2021 6:09 PM Studi Personali: Yes
Elementi di ripasso 1 Introduzione In questa sezione andiamo ad indagare cosa fa il sistema operativo
Note Generali 4 Parti di un sistema di calcolo Struttura Memoria Vedi Memoria per il corso di Architettura
Tipologie di SO BimodalitÃ  SO Utente e Kernel
Interrupt, Trap, System or Supervisor Call System call ðŸŸ©- per maggiori info sui modi di chiamata delle syscall</description>
    </item>
    <item>
      <title>Massimi minimi multi-variabile</title>
      <link>https://flecart.github.io/notes/massimi-minimi-multi-variabile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/massimi-minimi-multi-variabile/</guid>
      <description>Matrice Jacobiana Ãˆ un modo per scrivere il gradiente di una funzione quando Ã¨ in una certa forma.
Data una funzione $f: \mathbb{R}^n \to \mathbb{R}^p$ ossia per esempio $x=(x_1,...,x_n) \to(f_1(x),...,f_p(x))$ Se le p funzioni di arrivo sono differenziabili, allora la matrice Jacobiana Ã¨ definita in questo modo:
$$J_f(x) = \begin{pmatrix} \delta_{x_1} f_1(x) &amp;amp; &amp;hellip; &amp;amp; \delta_{x_n} f_1(x)\ . &amp;amp; . &amp;amp; . \ \delta_{x_1} f_p(x) &amp;amp; &amp;hellip; &amp;amp; \delta_{x_n} f_p(x)</description>
    </item>
    <item>
      <title>Verita, Teorie, modelli, connotazione, denotazione</title>
      <link>https://flecart.github.io/notes/verita-teorie-modelli-connotazione-denotazione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/verita-teorie-modelli-connotazione-denotazione/</guid>
      <description>Questa Ã¨ una necessitÃ  per stabilire il significato di una sintassi definiti.
5.1 VeritÃ  e RealtÃ  La veritÃ  ha solamente senso quando lo si relaziona con un mondo sensibile, ossia il mondo che si puÃ² percepire con i nostri sensi.
5.1.1 VeritÃ  parametrica e assoluta Se un esperimento Ã¨ ripetibile all&amp;rsquo;interno del mondo sensibili allora questa Ã¨ considerata come una veritÃ  parametrica, ossia dipende da uno stato del mondo sensibile.</description>
    </item>
  </channel>
</rss>
