<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>X. Angelo Huang&#39;s Blog</title>
    <link>https://flecart.github.io/</link>
    <description>Recent content on X. Angelo Huang&#39;s Blog</description>
    <image>
      <title>X. Angelo Huang&#39;s Blog</title>
      <url>https://flecart.github.io/images/papermod-cover.png</url>
      <link>https://flecart.github.io/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 30 Nov 2022 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://flecart.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Fondamenti teorica</title>
      <link>https://flecart.github.io/notes/fondamenti-teorica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/fondamenti-teorica/</guid>
      <description>Ripasso Prox: 40 Ripasso: May 30, 2023 Ultima modifica: June 9, 2023 2:56 PM Primo Abbozzo: December 10, 2022 11:39 AM Stato: 🌕🌕🌕🌗🌑 Studi Personali: No
Elementi di ripasso Elementi di computabilità https://virtuale.unibo.it/pluginfile.php/1295166/mod_resource/content/0/Lez18-Gorrieri.pdf
Halting problem Questo asserisce che non esiste nessun programma che sia in grado di decidere la terminazione di un altro programma
Questo è un problema che ci è interessante perché vorremmo costruire un compilatore che sia in grado di osservare tutti gli errori possibili del programma.</description>
    </item>
    <item>
      <title>Analisi di Convessità</title>
      <link>https://flecart.github.io/notes/analisi-di-convessit%C3%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/analisi-di-convessit%C3%A0/</guid>
      <description>Ripasso Prox: 20 Ripasso: May 22, 2022 Ultima modifica: October 8, 2022 12:08 PM Primo Abbozzo: May 2, 2022 3:23 PM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Questo argomento è stato trattato durante dopo la discussione dei Massimi minimi multi-variabile, però è stato ripreso anche nella forma R to R, quindi credo necessiti di un foglio a parte.
Affine set Lines Let&amp;rsquo;s take two points in $\mathbb{R}$ $x_{1}, x_{2}$, if we consider the parametrization $$ x = \theta x_{1} + (1 - \theta)x_{2} $$ This is a parametrization of the line</description>
    </item>
    <item>
      <title>Calcolo di numeri finiti</title>
      <link>https://flecart.github.io/notes/calcolo-di-numeri-finiti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/calcolo-di-numeri-finiti/</guid>
      <description>1 Calcolo dei numeri finiti Il calcolo è numerico perché si differenzia rispetto a un calcolo normale perché è finito.
1.1 Errore nei calcoli 1.1.1 Tipologie di errore (5) 🟩 Errore di misura, dovuto alle imperfezioni dello strumento di misura dei dati del problema. Errore di troncamento, quando un procedimento infinito viene realizzato come procedimento finito. (esempio: calcolo del valore di una funzione tramite sviluppo in serie, perché dato che l’algoritmo deve essere finito, devo prima o poi interrompere il calcolo, ecco qui l’errore).</description>
    </item>
    <item>
      <title>Cammini</title>
      <link>https://flecart.github.io/notes/cammini/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cammini/</guid>
      <description>Ultima modifica: October 17, 2021 10:38 AM Primo Abbozzo: October 16, 2021 5:16 PM Studi Personali: No
Elementi di ripasso 1 Cammini 1.1 Il cammino minimo 1.1.1 Definizione e caratteristiche 1.1.2 Costi negativi Sono cose molto brutte
1.1.3 Cammino minimo semplice Costruzione di cammini minimi 1.2 Vertici 1.2.1 definizione distanza fra due vertici Costo del cammino minimo che li connette
Condizione di bellman Albero dei cammini minimi Rilassamento Definizione Si va a vedere dove non funziona la disuguaglianza triangolare, se localmente non funziona ovvero se per esempio succede $D_{xu} + \omega(u,y) &amp;lt; D_{xy}$ per qualche vertice all&amp;rsquo;interno del grafo, so di per certo che la distanza $D_{xy}$ non è una distanza, quindi possiamo riassegnarla in modo che verifichi la disuguaglianza</description>
    </item>
    <item>
      <title>Connettivi Logici, correttezza, variabili</title>
      <link>https://flecart.github.io/notes/connettivi-logici-correttezza-variabili/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/connettivi-logici-correttezza-variabili/</guid>
      <description>Ripasso Prox: 15 Ripasso: December 22, 2021 Ultima modifica: September 30, 2022 3:19 PM Primo Abbozzo: November 19, 2021 8:34 PM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso Dubbi passati Dimostrazione del teorema di invarianza Proprietà dei connettivi logici Dimostrazione della correttezza Dimostrazione delle variabili Teorema di compattezza, cosa è 8 Connettivi logici 8.1 Dimostrazione teorema invarianza 8.1.1 Introduzione Basi: Due proposizioni sono equivalenti quando valgono sugli stessi mondi.</description>
    </item>
    <item>
      <title>CPU e storia degli elaboratori</title>
      <link>https://flecart.github.io/notes/cpu-e-storia-degli-elaboratori/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cpu-e-storia-degli-elaboratori/</guid>
      <description>Ripasso Prox: 40 Ripasso: December 23, 2021 Ultima modifica: February 23, 2023 6:18 PM Primo Abbozzo: September 26, 2021 2:22 PM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso Dubbi vecchi Le tappe principali dell&amp;rsquo;evoluzione del computer fino ai giorni moderni Capire bene la differenza fra CISC e RISC, in particolare il significato di microprogrammazione Capire bene la differenza fra parallelismo livello processore e livello istruzione, SIMD e MIMD Prefetch istruzioni Come funziona la predizione dei salti.</description>
    </item>
    <item>
      <title>Introduction to computational statistics</title>
      <link>https://flecart.github.io/notes/introduction-to-computational-statistics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduction-to-computational-statistics/</guid>
      <description>What is it for Estimation Sampling generate numbers from any distribution! (distributions are important in statistics). Density Cumulative distribution (and others similar). Optimization how to find computationally the min and max of functions. Generating?
Random (difficile anche filosoficamente definire cosa significa questo). Molto importante perché si assume in Comp stats che abbiamo il random vero, e questa assunzione che non vale può rompere cose. And independent Sample proportion Average of something (example of the lake cannonball).</description>
    </item>
    <item>
      <title>La qualità del software</title>
      <link>https://flecart.github.io/notes/la-qualit%C3%A0-del-software/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/la-qualit%C3%A0-del-software/</guid>
      <description>Dato che il software sta diventando sempre più diffuso, diventa sempre più importante andare a definire delle metriche che possano garantirne la qualità, ossia la non frequenza di errori o bug che possono in qualche modo limitarne la qualità.
Error, Fault and Failure Secondo la definizione esatta data da IEEE, questi tre termini hanno un significato ben specifico, molto diverso.
Error, sono comportamenti non previsti da un comportamento dell&amp;rsquo;utente, oppure il programmatore capisce male le specifiche.</description>
    </item>
    <item>
      <title>Modelizzazione</title>
      <link>https://flecart.github.io/notes/modelizzazione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/modelizzazione/</guid>
      <description>Ripasso Prox: 24 Ripasso: December 29, 2022 Ultima modifica: December 27, 2022 4:53 PM Primo Abbozzo: September 30, 2022 9:34 AM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
Elementi di ripasso Stranamente ho ancora alcuni problemi a ricordarmi i modelli teorici per la modellizzazione di problemi, ma durante la modellizzazione di un problema concreto mi pare facile, semmai qualche esercizio a tempo settimanale può aiutare per questo. Bisogna fareesercizi pesanti su sta roba, non la sai per niente bene dal lato pratico, che è quello che importa per l’esame…</description>
    </item>
    <item>
      <title>Rappresentazione delle informazioni</title>
      <link>https://flecart.github.io/notes/rappresentazione-delle-informazioni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/rappresentazione-delle-informazioni/</guid>
      <description>Ripasso Prox: 13 Ripasso: December 22, 2021 Ultima modifica: October 27, 2022 12:16 PM Primo Abbozzo: October 5, 2021 1:03 PM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
Elementi di ripasso Dubbi passati Capire perché nel calcolo dell&amp;rsquo;errore
Dimostrazione sottrazione fra due numeri
Capire meglio come è fatto la somma di due cifre in questa architettura capire meglio il codice di Hamming per correzione di un bit (provare a rifare l&amp;rsquo;esercizio da solo) Are esercizi su hamming e floating point December 8, 2021 6:21 PM 6 Rappresentazione delle informazioni 6.</description>
    </item>
    <item>
      <title>Elettromagnetismo esercizi fatti</title>
      <link>https://flecart.github.io/notes/elettromagnetismo-esercizi-fatti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/elettromagnetismo-esercizi-fatti/</guid>
      <description>Esercizi random 18-10 Questi si riferiscono ad esercizi prevalentemente fatti in Campo elettrico
Esercizio 1 $$ \vec{E} = - \alpha y^{3} \hat{i} - 3\alpha xy^{2} \hat{j} -3\beta z^{2}\hat{k} $$ Vogliamo andare a calcolare $V(x, y , z)$
check campo conservativo (altrimenti TODO: capire il perché, non riesco a calcolare questo se non è conservativo) Check del rotore, e si vede che è conservativo. Probabilmente allora il potenziale dipende dal percorso, ma questa cosa non ci piace affatto (quindi rende senza senso) Scelgo il percorso (e spezzetto tutti i percorsi.</description>
    </item>
    <item>
      <title>Grammatiche Regolari</title>
      <link>https://flecart.github.io/notes/grammatiche-regolari/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/grammatiche-regolari/</guid>
      <description>Ripasso Prox: 60 Ripasso: June 1, 2023 Ultima modifica: June 1, 2023 12:46 PM Primo Abbozzo: October 21, 2022 1:09 PM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso Domande chieste
Grammatiche regolari Introduzione Definizione grammatica regolare 🟩 Definizione
In pratica posso avere solamente come terminali a, oppure un suffisso a su un non terminale.
Queste grammatiche sono interessanti perché è molto facile costruire un automa che sia in grado di riconoscere questo linguaggio.</description>
    </item>
    <item>
      <title>Relazioni fra insiemi</title>
      <link>https://flecart.github.io/notes/relazioni-fra-insiemi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/relazioni-fra-insiemi/</guid>
      <description>Ripasso Prox: 40 Ripasso: December 24, 2021 Ultima modifica: September 30, 2022 3:18 PM Primo Abbozzo: October 6, 2021 11:03 AM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso Vecchi dubbi Classe di equivalenza Dimostrazione della proprietà fondamentale della coppia ordinata di Kuratowsky Costruzione di R. Definizione di spazio di funzioni 21/11 ho ripassato, prodotto cartesiano, funzioni, spazi, classi equiv, insiemi quoziente, dovrei ancora ripassare la dimostrazione di suriettiva e iniettiva presenti in laboratorio Anche definizione e dimostrazione di Cantor, insiemi infiniti, costruzione di R, Z, N.</description>
    </item>
    <item>
      <title>Scelta del PO</title>
      <link>https://flecart.github.io/notes/scelta-del-po/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/scelta-del-po/</guid>
      <description>La cosa che rende il PO diverso rispetto agli sviluppatori è la conoscenza delle necessità del cliente. Questo permette di prioritizzare del task e capire in che modo dovrebbe essere il prodotto finale. In questo modo si crea una vision del prodotto. Pensiamo che il PO debba condividere questa informazione e prendere decisioni di gruppo.
Domande da fare: La user interface, come sembra il wireframe? Pensavamo di utilizzare i social solamente per i login, pensavate di utilizzare anche per altro durante il gioco?</description>
    </item>
    <item>
      <title>Semafori</title>
      <link>https://flecart.github.io/notes/semafori/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/semafori/</guid>
      <description>Ripasso Prox: 120 Ripasso: September 28, 2023 Ultima modifica: May 19, 2023 10:28 AM Primo Abbozzo: October 15, 2022 10:22 AM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso Semafori Introduzione Concetto principale 🟩- È sempre stato introdotto da Dijkstra, 1965 (Cooperating Sequential Processes) utilizzato come strumento di cooperazione semplice
Questo è un sistema fortemente ispirato dai semafori che regolano gli incroci stradali.
due o più processi possono cooperare attraverso semplici segnali, in modo tale che un processo possa essere bloccato in specifici punti del suo programma finché non riceve un segnale da un altro processo</description>
    </item>
    <item>
      <title>Word Embeddings</title>
      <link>https://flecart.github.io/notes/word-embeddings/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/word-embeddings/</guid>
      <description>Word2Vec Paper di riferimento: (Mikolov et al. 2013).
Video youtube intuitivo Blog pratico
È stato uno dei primi approcci che provano a fare un embedding semantico del significato delle parole. Semplicemente andare a fare Tokenization per andare a encodare le parole non è sufficiente, perché questi non hanno nessun apporto semantico alle parole.
In questo caso vogliamo rappresentare una parola tramite vettori. Il vettore alla fine non sarà altro che il layer lineare iniziale per fare all&amp;rsquo;associazione.</description>
    </item>
    <item>
      <title>Astrazione sul controllo</title>
      <link>https://flecart.github.io/notes/astrazione-sul-controllo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/astrazione-sul-controllo/</guid>
      <description>Ripasso Prox: 46 Ripasso: May 27, 2023 Ultima modifica: May 6, 2023 12:48 PM Primo Abbozzo: March 20, 2023 10:46 AM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso Astrazione sul controllo Significato di astrazione L&amp;rsquo;astrazione è una cosa fondamentale nell&amp;rsquo;informatica, l’abbiamo visto anche nella prima lezione in assoluto per architettura, il sistema a strati di Architettura e livelli 1, 2 reti e simili.
Il principali metodi sono astrazioni sul controllo e sui dati sui dati stiamo cominciando a parlarne in Teoria dei Tipi.</description>
    </item>
    <item>
      <title>Reinforcement Learning, a introduction</title>
      <link>https://flecart.github.io/notes/reinforcement-learning-a-introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/reinforcement-learning-a-introduction/</guid>
      <description>Ripasso Prox: 40 Ripasso: May 20, 2023 Ultima modifica: April 10, 2023 2:32 PM Primo Abbozzo: January 26, 2023 10:00 PM Stato: 🌕🌕🌕🌑🌑 Studi Personali: No
Reinforcement Learning Introduzione Una delle idee migliori riguardanti questo campo del reinforcement learning è il focus sul processo decisionale del singolo agente, condizionato al reward che l’ambiente esterno gli dà (feedback). Il setting classico di questo genere di problemi è un caso speciale della caratterizzazione presente in l’intelligenza.</description>
    </item>
    <item>
      <title>Devices OS</title>
      <link>https://flecart.github.io/notes/devices-os/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/devices-os/</guid>
      <description>Ripasso Prox: 30 Ripasso: May 17, 2023 Ultima modifica: April 29, 2023 11:56 AM Primo Abbozzo: March 29, 2023 11:18 AM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
Elementi di ripasso Devices OS Devices Categorizzazione (6)🟨- Trasferimento dei dati Accesso al device sinconia del trasferimento condivisone fra processi Velocità del trasferimento I/O direction (scrittura o lettura) Vediamo che molte caratteristiche sono riguardo il trasferimento
Slide categorizzazione I/O
Blocchi o caratteri 🟩- Slide devices blocchi o caratteri</description>
    </item>
    <item>
      <title>Gruppi ciclici e permutazioni</title>
      <link>https://flecart.github.io/notes/gruppi-ciclici-e-permutazioni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gruppi-ciclici-e-permutazioni/</guid>
      <description>Ripasso Prox: 14 Ripasso: April 30, 2022 Ultima modifica: June 29, 2022 9:42 AM Primo Abbozzo: March 20, 2022 4:36 PM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Gruppi ciclici e permutazioni Il gruppo ciclico Definizione gruppo ciclico Abbiamo definito in Gruppi per la prima volta il significato di gruppo ciclico generato da un elemento del gruppo, questo insieme si è poi dimostrato essere un sottogruppo del gruppo
Un gruppo $G$ è chiamato ciclico se esiste un $a \in G$ tel per cui $$ G = \left\{ a^{n} \mid n \in \mathbb{Z} \right\} $$ Dove a è chiamato elemento generatore.</description>
    </item>
    <item>
      <title>Introduzione ad architettura</title>
      <link>https://flecart.github.io/notes/introduzione-ad-architettura/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-ad-architettura/</guid>
      <description>Ripasso Prox: 40 Ripasso: January 8, 2022 Ultima modifica: October 27, 2022 12:15 PM Primo Abbozzo: September 21, 2021 7:04 PM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso Dubbi vecchi (se ti va rispovera)
Quale è la differenza fra Microarchitettura e il livello assembly? Non vanno entrambi a fare istruzioni eseguite livello macchina? Dici assembly ha bisogno di essere tradotto?
1. Livelli di astrazione 1.1 Il principio di astrazione/implementazione Astrazione per macchine livello n con linguaggi n.</description>
    </item>
    <item>
      <title>Processi e thread</title>
      <link>https://flecart.github.io/notes/processi-e-thread/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/processi-e-thread/</guid>
      <description>Ripasso Prox: 45 Ripasso: May 29, 2023 Ultima modifica: April 29, 2023 11:27 AM Primo Abbozzo: March 8, 2023 9:55 AM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
Elementi di ripasso Processi e thread Il processo e la gestione dell&amp;rsquo;esecuzione è uno dei compiti principali dei sistemi operativi. Lo vuole fare in maniera efficace ed efficiente, come descritto in Note sull’architettura.
Slide schema generale tabelle
Processi Il process control block è la struttura di dati principali da comprendere.</description>
    </item>
    <item>
      <title>Programmazione lineare</title>
      <link>https://flecart.github.io/notes/programmazione-lineare/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/programmazione-lineare/</guid>
      <description>Ripasso Prox: 6 Ripasso: December 31, 2022 Ultima modifica: December 27, 2022 10:37 AM Primo Abbozzo: November 25, 2022 8:55 AM Stato: 🌕🌕🌕🌑🌑 Studi Personali: No
Programmazione lineare Vogliamo cercare di restare nel nostro spazio delle soluzioni ammissibili, senza dover stare ad esplorare tutto, vogliamo andare a concentrarci su una parte specifica di essa. Vogliamo utilizzare una struttura fondamentale per i problemi di programmazione lineare, che è quello con cui vogliamo andare a fare.</description>
    </item>
    <item>
      <title>Wireshark</title>
      <link>https://flecart.github.io/notes/wireshark/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/wireshark/</guid>
      <description>Ripasso Prox: 5 Ultima modifica: November 18, 2022 10:09 AM Primo Abbozzo: November 15, 2022 9:19 AM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso Wireshark Questo documento sono appunti riguardanti strumenti di sniffing di wireshark.
strumento passivo che ascolta ebbasta tutti i pacchetti che può (ovviamente può solo se riceve il segnale fisico…, quindi se uno switch non mi invia proprio il segnale, non c&amp;rsquo;è comunque modo per me di sniffare il pacchetto, ma se invece è un hub, allora sentirei tutto.</description>
    </item>
    <item>
      <title>Database exercises</title>
      <link>https://flecart.github.io/notes/database-exercises/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/database-exercises/</guid>
      <description>2016 Feb SELECT DISTINCT C.RV, C.Tonalità, C.Nome, C.Data FROM Concerto AS C JOIN Movimenti AS M ON C.RV=M.RV WHERE Tempo=&amp;#34;Largo&amp;#34; SELECT M.RV, M.Numero, M.Tempo, M.Durata FROM Concerto AS C JOIN Movimenti AS M ON C.RV=M.RV WHERE C.Data&amp;gt;1720 GROUP BY M.RV, M.Numero, M.Tempo, M.durata HAVING COUNT(M.Numero) &amp;gt; 3 Sbagliato il secondo perché il group by non grouppa bene, bisogna fare query innestata
$$ \pi_{RV, Numero,Tempo, Durata}(\sigma_{Durata &gt; 120}(Mov) \bowtie \sigma_{strumento=&#34;violino&#34;}Strumentazione) $$ $$ \pi_{RV, Numero, Tempo, Durata)}(\sigma_{Strumento=Cembalo}(Strumentazione) \bowtie Concerti \bowtie \sigma_{Numero=3}(mov)) - $$ $$ \pi_{RV, Numero, Tempo, Durata)}(\sigma_{Strumento=Cembalo}(Strumentazione) \bowtie Concerti \bowtie \sigma_{Numero&gt;3}(mov)) $$ Random exercises Relational algebra https://docs.</description>
    </item>
    <item>
      <title>Database logical design</title>
      <link>https://flecart.github.io/notes/database-logical-design/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/database-logical-design/</guid>
      <description>Introduzione al design logico Conoscenze sul carico dell&amp;rsquo;applicazione, ossia se ha più read rispetto a writes per esempio, sono dei priors in pratica Un design concettuale spiegato in precedenza. E si avrà in output un design logico con anche un po&amp;rsquo; di documentazione. bisogna in questa fase valutare la performance principalmente su indicatori, ossia una operazione quante istanze visiterà? Invece di garanzie sul numero di transazioni al secondo.
Indicatori visti (2) Costo di una operazione: viene valutato in termini di numero di occorrenze di entità e associazioni che mediamente vanno visitate per rispondere a una operazione sulla base dì dati; questa schematizzazione è molto forte e, pur nelle semplici valutazioni che svilupperemo, sarà talvolta necessario riferirci a un criterio più fine; Occupazione di memoria: viene valutato in termini dello spazio di memoria (misurato per esempio in numero di byte) necessario per memorizzare i dati descritti dallo schema.</description>
    </item>
    <item>
      <title>Deduzione naturale</title>
      <link>https://flecart.github.io/notes/deduzione-naturale/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/deduzione-naturale/</guid>
      <description>Ripasso Prox: 15 Ripasso: December 22, 2021 Ultima modifica: September 30, 2022 3:19 PM Primo Abbozzo: November 10, 2021 9:33 AM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
La deduzione naturale è un possibile sistema deduttivo che utilizza il linguaggio naturale per questo motivo più beginner friendly. Lo facciamo prima per la Logica Proposizionale che è molto facile
Il sistema deduttivo Poniamo l&amp;rsquo;esistenza di Assiomi (formule in una certa logica) e regole di inferenza definite sotto.</description>
    </item>
    <item>
      <title>Integrali multi-dimensionali</title>
      <link>https://flecart.github.io/notes/integrali-multi-dimensionali/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/integrali-multi-dimensionali/</guid>
      <description>Ripasso Prox: 2 Ultima modifica: October 8, 2022 12:08 PM Primo Abbozzo: April 28, 2022 4:19 PM Stato: 🌕🌕🌕🌑🌑 Studi Personali: No
Elementi di ripasso 12 Integrali multipli Andremo ad analizzare integrali di funzioni continue su insiemi semplici (domini normali) .
Introduzione Y-semplice e regolarità È un insieme semplice di punti, in pratica, se considero un intervallo limitato e due funzioni definite in questo intervallo tale che una è sempre minore dell’altra, l’insieme y-semplice sono i punti compresi fra queste</description>
    </item>
    <item>
      <title>Introduction to Convex Optimization</title>
      <link>https://flecart.github.io/notes/introduction-to-convex-optimization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduction-to-convex-optimization/</guid>
      <description>A brief history This field was quite developed in 1970 (started in 1920) when mathematicians had the same problem over and over again and needed a name. But this was only the theory. The practical applications came later. A modern use is in machine learning a statistics.
Form historical point of view
1947 simplex method popularized by Dantzig at Stanford Many people in soviet union in the ´60 worked on this (they already know about he applications!</description>
    </item>
    <item>
      <title>Sicurezza OS</title>
      <link>https://flecart.github.io/notes/sicurezza-os/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/sicurezza-os/</guid>
      <description>Ripasso Prox: 12 Ripasso: May 27, 2023 Ultima modifica: May 16, 2023 1:10 PM Primo Abbozzo: April 19, 2023 9:19 AM Stato: 🌕🌕🌕🌗🌑 Studi Personali: No
Elementi di ripasso Sicurezza OS Introduzione Note generali sulla sicurezza Su tre fronti
Hardware Software human-ware (lol). Una altra tendenza generale è che più è complessa più è insicura. e questo senso di insicurezza cresce in modo maggiore rispetto al lineare.
CIA properties Ne abbiamo parlato in modo leggermente inverso in Sicurezza delle reti.</description>
    </item>
    <item>
      <title>Uniform Resource Identifier</title>
      <link>https://flecart.github.io/notes/uniform-resource-identifier/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/uniform-resource-identifier/</guid>
      <description>Ripasso: May 14, 2023 Ultima modifica: June 17, 2023 11:54 PM Primo Abbozzo: February 24, 2023 1:33 PM Studi Personali: No
Elementi di ripasso URI Sono stata LA vera invenzione di Berners Lee accennati in Storia del web. Il problema è avere un modo per identificare una risorsa in modo univoco sull’internet.
Introduzione La risorsa 🟩 Una risorsa è qualunque struttura che sia oggetto di scambio tra applicazioni all’interno del World Wide Web.</description>
    </item>
    <item>
      <title>Appunti per l’orale</title>
      <link>https://flecart.github.io/notes/appunti-per-lorale/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/appunti-per-lorale/</guid>
      <description>Ultima modifica: October 19, 2022 5:02 PM Primo Abbozzo: June 3, 2022 11:34 AM Studi Personali: No
Argomenti da ripetere Ripassare proprietà e conseguenze per lo spazio vettoriale Capitolo 4 Dimostrazione teorema del completamento (2 tesi) Di conseguenza ripetere in modo più formale il capitolo 4 Capitolo 5 Bigezione fra spazio delle applicazioni lineari da n a m con le matrici n a m. Linearità per composizione lineare bigettiva sse invertibile Errore nella dimostrazione di iniettività per kernel F Dimensione sistema lineare omogeneo Capitolo 6 Teorema caratterizzazione della preimmagine igettiva sse invertibile Errore nella dimostrazione di iniettività per kernel F Dimensione sistema lineare omogeneo Capitolo 6 Teorema caratterizzazione della preimmagine </description>
    </item>
    <item>
      <title>Campo elettrico</title>
      <link>https://flecart.github.io/notes/campo-elettrico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/campo-elettrico/</guid>
      <description>Introduzione Intuizione del campo elettrostatico Elettrostatico vs elettrodinamico 🟩 Andiamo a chiamare elettrostatico perché nel nostro caso non si sta muovendo nessuna carica all&amp;rsquo;itnerno di questo campo.
Proprietà del campo elettrostatico (5) 🟨 Le linee di forza in ogni punto dello spazio sono tangenti e concorde al campo in quel punto; le linee di forza si addensano dove l&amp;rsquo;intensità del campo e maggiore; le linee di forza non si incrociano mai, in quanto in ogni punto il campo è definito univocamente e non può avere due direzioni distinte.</description>
    </item>
    <item>
      <title>Kolmogorov complexity</title>
      <link>https://flecart.github.io/notes/kolmogorov-complexity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/kolmogorov-complexity/</guid>
      <description>Gran parte di quanto scrivo ora è tratto da (Li &amp;amp; Vitányi 2019). Chaitin, Kolmogorov e Solomonoff hanno elaborato il tema in modo indipendente e allo stesso tempo verso gli anni &amp;lsquo;60!
Solomonoff lo ha trovato sul problema dell&amp;rsquo;induzione all&amp;rsquo;età di 38 anni, Kolmogorov invece era già tardi, ha già trovato gli assiomi della probabilità e poi nel 65 cerca randomness. Mentre Chaiten Information = Computation e non probabilità, nel 68 all&amp;rsquo;età di 19 anni.</description>
    </item>
    <item>
      <title>Macchine Astratte</title>
      <link>https://flecart.github.io/notes/macchine-astratte/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/macchine-astratte/</guid>
      <description>Ripasso Prox: 80 Ripasso: June 3, 2023 Ultima modifica: June 4, 2023 3:20 PM Primo Abbozzo: September 23, 2022 1:08 PM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso Domande
Interpreti
Quali sono i passi principali del ciclo FDE e cosa fa l’interprete (ciclo FDE)
Implementazione linguaggio via microprogrammazione o software
Realizzazione dell’interprete e del compilatore 🟥
Macchine Astratte Definizione ed esempi per macchine astratte 🟩 Una macchina astratta è un qualunque insieme di algoritmi e strutture di dati che permettono di memorizzare ed eseguire il linguaggio $L$, quindi una macchina astratta esiste per esguire il proprio linguaggio (inteso come insieme finito di istruzioni primitive che riesce ad comprendere e eseguire).</description>
    </item>
    <item>
      <title>Successioni</title>
      <link>https://flecart.github.io/notes/successioni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/successioni/</guid>
      <description>Ripasso Prox: 55.81 Ripasso: May 20, 2022 Ultima modifica: October 8, 2022 12:09 PM Primo Abbozzo: October 11, 2021 6:14 PM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso Vecchi dubbi Interrogare sé stessi se abbiamo capito con esattezza il significato di limite, vedere se lo abbiamo imparato a memoria oppure meno, chiedersi del perché lo si abbia definito in questo modo. 3 Successioni e Limiti 3.1 Successioni $$ \begin{cases} f: \mathbb{N} \to \mathbb{R} \\ n \to f(n) \\ \{a\}_{n \in \mathbb{N}} \vee a_n \end{cases} $$ È una funzione che mappa dai naturali ai Reali indicata spesso solamente come $$ \left\{ a \right\} _{n \in \mathbb{N}} $$ 3.</description>
    </item>
    <item>
      <title>Accessibilità</title>
      <link>https://flecart.github.io/notes/accessibilit%C3%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/accessibilit%C3%A0/</guid>
      <description>Ripasso: June 8, 2023 Ultima modifica: May 7, 2023 2:30 PM Primo Abbozzo: April 17, 2023 4:11 PM Studi Personali: No
Elementi di ripasso Accessibilità Ci chiediamo come facciamo a rendere sistemi informatici accessibili a persone attraverso certe tecnologie.
Slide esempi di disabilità
È meglio renderlo accessibile perché è illegale (nel senso che stai facendo una discriminazione verso un certo insieme di persone).
WGAC Queste sono alcuni principi di accessibilità, basati su 4 principi fondamentali</description>
    </item>
    <item>
      <title>Insiemi numerici</title>
      <link>https://flecart.github.io/notes/insiemi-numerici/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/insiemi-numerici/</guid>
      <description>Ripasso Prox: 100 Ripasso: June 1, 2022 Ultima modifica: December 25, 2022 9:29 PM Primo Abbozzo: September 21, 2021 7:04 PM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi da ripassare Notione di Campo ordinato, ciò che rendere (non importante) La dimostrazione che bigettività equivale a invertibilità 1 Insiemi Numerici 💡 Questa prima parte degli appunti è fortemente mancante 1.1 Insiemistica Tutta Questa prima roba di insiemistica è fatta molto meglio nel corso di logica, in particolare in questo documento</description>
    </item>
    <item>
      <title>Integrali</title>
      <link>https://flecart.github.io/notes/integrali/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/integrali/</guid>
      <description>Ripasso Prox: 40 Ripasso: June 21, 2022 Ultima modifica: October 8, 2022 12:08 PM Primo Abbozzo: February 21, 2022 1:20 PM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
8 Integrali 8.1 Introduzione 8.1.1 Il problema che risolve Vogliamo cercare di creare un metodo matematico che sia utile per calcolare area di qualunque curva.
L&amp;rsquo;idea principale per risolvere questo problema è approssimare l&amp;rsquo;area, lo facciamo utilizzando rettangoli, la formalizzazione sarà molto aiutata dal limite.</description>
    </item>
    <item>
      <title>Introduction to statistical learning</title>
      <link>https://flecart.github.io/notes/introduction-to-statistical-learning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduction-to-statistical-learning/</guid>
      <description>#statistics
Introduzione This is a short introduction to statistical learning, made with the help of the book ISLP (mi sento positivo ad affrontare la lettura di questo libro, ora che sta in python non lo vedo più come un libro solamente per statistici)
statistical learning refers to a set of approaches for estimating $f$ .
Utilizzi del statistical learning Solitamente sono due gli utilizzi Predizione e inferenza. Per predizione intendiamo il miglior modello che possa produrre le Y che ancora non conosciamo.</description>
    </item>
    <item>
      <title>Introduzione a programmazione</title>
      <link>https://flecart.github.io/notes/introduzione-a-programmazione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-a-programmazione/</guid>
      <description>Ripasso Prox: 30 Ripasso: December 19, 2021 Ultima modifica: December 14, 2021 3:43 PM Primo Abbozzo: September 22, 2021 11:25 AM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi da ripassare Processo che porta dal design alla creazione del programma 0 Basi 0.1 Struttura di un calcolatore Input: tastiera, mouse. Output: Schermo, suoni etc Memoria principale e secondaria CPU 0.2 Struttura della memoria Cerca di ricordare di come una informazione è messa in memoria e come è interpretata, come presentato in</description>
    </item>
    <item>
      <title>Object orientation</title>
      <link>https://flecart.github.io/notes/object-orientation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/object-orientation/</guid>
      <description>Ripasso Prox: 10 Ripasso: May 29, 2023 Ultima modifica: May 19, 2023 10:33 AM Primo Abbozzo: May 8, 2023 9:20 AM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
Elementi di ripasso Object orientation il tipo di dato astratto Introduzione Per questi tipi di dato non ci interessa di sapere cosa ci sia sotto (storato come bit? storato come sabbia boh), ci interessa solamente che abbia quei metodi, che possiamo in un certo senso identificare come la sua capsula, opaca in questo caso.</description>
    </item>
    <item>
      <title>Quizzes</title>
      <link>https://flecart.github.io/notes/quizzes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/quizzes/</guid>
      <description>Ultima modifica: February 25, 2023 2:07 PM Primo Abbozzo: December 29, 2021 12:42 PM Studi Personali: No
Rappresentazione delle informazioni Mini-quiz Cosa è una codifica posizionale? Darne degli esempi Codificare -189 in 9 bit utilizzando modulo o segno, complemento a 1 a 2 e in eccesso Cosa sono underflow e overflow per la codifica dei floating point? Perché i floating point hanno questa imprecisione mentre la codifica di interi no? Come sono codificati i caratteri nei calcolatori?</description>
    </item>
    <item>
      <title>Teorema di Rice</title>
      <link>https://flecart.github.io/notes/teorema-di-rice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/teorema-di-rice/</guid>
      <description>Introduction to the Rice Theorem Ci sono molti teoremi che non possono essere decisi, vedere Halting Theorem and Reducibility. Qui andiamo a chiederci quale sia l&amp;rsquo;insieme dei problemi decidibili.
Proprietà dei linguaggi TM 🟩 Data una macchina $\mathcal{M}$ definiamo il suo linguaggio come $$ L_{\mathcal{M}} = \left\{ x \in \Sigma^{*}: \mathcal{M} \text{ accetta } x \right\} $$ Allora con questa definizione di linguaggio possiamo dire che una proprietà, ossia una funzione da tutti i $TM$ possibili a $\left{ 0, 1 \right}$ tale per cui se il linguaggio riconosciuto è lo stesso, ossia $$ L_{\mathcal{M}} = L_{\mathcal{M}&#39;} \implies P(\mathcal{M}) = P(\mathcal{M}&#39;) $$ Definiamo questa non triviale se esiste una macchina per cui è 0, e una per cui è 1 (ossia non è costante).</description>
    </item>
    <item>
      <title>Unified Modeling Language</title>
      <link>https://flecart.github.io/notes/unified-modeling-language/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/unified-modeling-language/</guid>
      <description>Cosa è UML è un linguaggio di modelling (molto vecchio) ma ancora di continua evoluzione, da un punto di vista storico è nato insieme ai concetti di Object Oriented Programming che ora è molto presente all&amp;rsquo;interno dell&amp;rsquo;industria, descritto bene in Classi OOP, anche se in questa occasione sviluppata in maniera molto più intuitiva (grafica).
Perché serve 🟩 Per cercare di comunicare quanto necessario riguardo struttura e dinamicità dell&amp;rsquo;architettura.
Struttura di UML Structural Diagram 🟨++ These diagrams focus on representing the static structure of a system.</description>
    </item>
    <item>
      <title>Gestione delle risorse</title>
      <link>https://flecart.github.io/notes/gestione-delle-risorse/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gestione-delle-risorse/</guid>
      <description>Gestione delle risorse Introduzione Definizione classe, fungibilità Classe di risorse sono un insieme di risorse fra loro equivalenti (nel senso che uno può rimpiazzare l’uso dell&amp;rsquo;altro), anche detti fungibili.
Statico o dinamico Anche in economia ci sono tali definizioni! Queste risorse possono essere allocate staticamente o dinamicamente, in modo simile a quanto abbiamo detto in Gestione della memoria.
Statico quando già in fase di compilazione del processo, o di avviamento del processo gli dò la memoria, e quella sarà per tutti il tempo della sua vita.</description>
    </item>
    <item>
      <title>Introduzione a ottimizzazione Combinatoria</title>
      <link>https://flecart.github.io/notes/introduzione-a-ottimizzazione-combinatoria/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-a-ottimizzazione-combinatoria/</guid>
      <description>Ripasso Prox: 23 Ripasso: December 28, 2022 Ultima modifica: December 27, 2022 5:09 PM Primo Abbozzo: September 23, 2022 9:32 AM Stato: 🌕🌕🌕🌗🌑 Studi Personali: No
Elementi di ripasso Misa di dicembre, po’ tolgo perché è poco importante il modulo di introduzione
Introduzione (prolly non chiede niente di questo) L’ottimizzazione combinatoria è un altro nome per la ricerca operativa. È uno strumento utile a prendere le decisioni migliori, fatto sta che è anche molto utile al machine learning e si potrebbe dire che ne sia una base, questa è una cosa molto buona.</description>
    </item>
    <item>
      <title>Markov Chains</title>
      <link>https://flecart.github.io/notes/markov-chains/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/markov-chains/</guid>
      <description>Introduzione alle catene di Markov La proprietà di Markov Una sequenza di variabili aleatorie $X_{1}, X_{2}, X_{3}, \dots$ gode della proprietà di Markov se vale:
$$ P(X_{n}| X_{n - 1}, X_{n - 2}, \dots, X_{1}) = P(X_{n}|X_{n-1}) $$ Ossia posso scordarmi tutta la storia precedente, mi interessa solamente lo stato precedente per sapere la probabilità attuale.
Da un punto di vista filosofico/fisico, ha senso perché mi sta dicendo che posso predire lo stato successivo se ho una conoscenza (completa, (lo dico io completo, originariamente non esiste)) del presente.</description>
    </item>
    <item>
      <title>Massimi minimi multi-variabile</title>
      <link>https://flecart.github.io/notes/massimi-minimi-multi-variabile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/massimi-minimi-multi-variabile/</guid>
      <description>Ripasso Prox: 6 Ripasso: May 18, 2022 Ultima modifica: October 8, 2022 12:07 PM Primo Abbozzo: April 5, 2022 4:23 PM Stato: 🌕🌕🌕🌑🌑 Studi Personali: No
Elementi di ripasso 074179
gli utilizzi della matrice jacobiana Riguardarsi come la continuità finisce la dimostrazione di schwarz Rivedere i calcoli e l&amp;rsquo;idea principale per taylor al secondo ordine di coso. Massimi e Minimi multivariabile Matrice Jacobiana È un modo per scrivere il gradiente di una funzione quando è in una certa forma.</description>
    </item>
    <item>
      <title>Hello World</title>
      <link>https://flecart.github.io/hello-world/</link>
      <pubDate>Wed, 30 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/hello-world/</guid>
      <description>First blog post</description>
    </item>
    <item>
      <title>CSS</title>
      <link>https://flecart.github.io/notes/css/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/css/</guid>
      <description>Ripasso: May 19, 2023 Ultima modifica: June 19, 2023 9:32 PM Primo Abbozzo: March 6, 2023 3:14 PM Studi Personali: No
Elementi di ripasso Cascading Style Sheets Inizialmente HTML era per la presentazione, abbiamo ancora un pò di attributi storici e tag storici per questa parte di presentazione descritto in HTML e Markup.
Introduzione È un linguaggio indipendente per la descrizione della grafica. La cosa bella è iil fatto di essere indipendente, quindi è adatto a HTML, a XML e simili.</description>
    </item>
    <item>
      <title>Introduzione algoritmi</title>
      <link>https://flecart.github.io/notes/introduzione-algoritmi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-algoritmi/</guid>
      <description>Ripasso Prox: 50 Ripasso: May 27, 2022 Ultima modifica: April 25, 2022 9:17 PM Primo Abbozzo: February 21, 2022 4:24 PM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso 0 Introduzione 0.1 L’algoritmo Vogliamo cercare di creare algoritmi, ovvero soluzioni a problemi computazionali che non dipendono dal linguaggio di programmazione.
0.1.1 Definizione Procedura per risolvere un problema in un numero finito di passi (quindi un algoritmo deve finire)
0.1.2 Origine della parola Il nome &amp;ldquo;algoritmo&amp;rdquo; deriva da un nome di un matematico persiano dell 800 d.</description>
    </item>
    <item>
      <title>k-esimo priority-q DSU</title>
      <link>https://flecart.github.io/notes/k-esimo-priority-q-dsu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/k-esimo-priority-q-dsu/</guid>
      <description>Ripasso Prox: 12 Ultima modifica: May 12, 2022 10:55 AM Primo Abbozzo: April 7, 2022 9:25 AM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso 7 Problema k-esimo Questo documento è totalmente concentrato sull&amp;rsquo;analisi del problema della selezione del k-esimo elemento.
7.1 Introduzione al problema Dato un array di elementi vogliamo cercare di trovare un modo efficiente per selezionare il k-esimo elemento, ossia un elemento che sia maggiore di k-1 elementi</description>
    </item>
    <item>
      <title>Livello applicazione e socket</title>
      <link>https://flecart.github.io/notes/livello-applicazione-e-socket/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/livello-applicazione-e-socket/</guid>
      <description>Livello trasporto Protocolli classici Introduzione a TCP e UPD Il quarto livello dei protocolli dell’architettura di Internet è il livello trasporto (transport), ed è basato su due protocolli in particolare: il Transmission Control Protocol (TCP) e lo User Data Protocol (UDP), che possono essere usati in alternativa tra loro.
Questo è nel genere di *connession oriented e non, il primo, TCP è connection oriented, l&amp;rsquo;altro no, questa è l’unica differenza fra i due.</description>
    </item>
    <item>
      <title>LR(k) e YACC</title>
      <link>https://flecart.github.io/notes/lrk-e-yacc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/lrk-e-yacc/</guid>
      <description>Ripasso Prox: 70 Ripasso: May 26, 2023 Ultima modifica: June 9, 2023 3:22 PM Primo Abbozzo: November 29, 2022 12:35 PM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
Elementi di ripasso LR(k) e YACC LR(k) Grammatiche LR(k) 🟩 Anche in questo caso proviamo a generalizzare il concetto dei pirmi k caratteri, in modo da generalizzare in qualche senso il concetto di LR(k), quindi andiamo a modificare la closure considerando ora first k</description>
    </item>
    <item>
      <title>Onde elettromagnetiche</title>
      <link>https://flecart.github.io/notes/onde-elettromagnetiche/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/onde-elettromagnetiche/</guid>
      <description>Prendiamo La legge di Ampere-Maxwell $$ \vec{\nabla} \times \vec{B} = \mu_{0}\vec{J} + \mu_{0}\varepsilon_{0} \frac{\delta \vec{E}}{\delta t} $$ E la legge di Faraday neumann Lenz $$ \vec{\nabla} \times \vec{E} = - \frac{\delta \vec{B}}{\delta t} $$ Con questi abbiamo le onde elettromagnetiche.
Nel vuoto possiamo dire che non abbiamo densità di corrente, per questo posso andare nel vuoto, sono due cose che si autosostengono. Sono simmetriche a meno di costante.
Questo ci dice che</description>
    </item>
    <item>
      <title>Wifi 802-11</title>
      <link>https://flecart.github.io/notes/wifi-802-11/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/wifi-802-11/</guid>
      <description>Ripasso Prox: 5 Ripasso: May 25, 2023 Ultima modifica: May 19, 2023 10:13 AM Primo Abbozzo: May 12, 2023 10:32 AM Studi Personali: No
Elementi di ripasso Wifi 802.11 In questo documento andiamo a parlare dello standard effettivo wifi che possiamo andare a trovare nel mercato.
Prime slides sono delle liste enormi di tecnologie Wifi e dei loro utilizzi, come ad esempio della rete bluetooth, della rete wifi, del wifi ad ampio raggio e della rete 3G.</description>
    </item>
    <item>
      <title>Analysis of Neural Codes</title>
      <link>https://flecart.github.io/notes/analysis-of-neural-codes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/analysis-of-neural-codes/</guid>
      <description>Metodi di registrazione informazione Ci stiamo chiedendo in che modo possiamo registrare attività del cervello e quindi cercare di fare decoding delle informazioni presenti Prima parliamo di alcune tecniche non invasive che ci permettono di vedere alcune attività presenti nel cervello.
Metodi macroscopici Functional Magnetic Resonance Imaging Un metodo è fMRI. (ci sono cose ) TODO capire come funziona
Electro-Encephalo-Gram EEG che prende direttamente dai segnali Ma il drawback di entrambi è che non registrano attività del singolo array.</description>
    </item>
    <item>
      <title>Compression Algorithms</title>
      <link>https://flecart.github.io/notes/compression-algorithms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/compression-algorithms/</guid>
      <description>Lempel-Ziv-Welch Algorithm Introduzione sul funzionamento Primo scan con un dizionario indexato dei singoli caratteri Poi viene cercato di raggruppare caratteri a coppie. Se una coppia è già presente nel dizionario, allora aggiungo al dizionario una cosa più lunga e metto un code diverso Esempio di sopra. La cosa carina è che il dizionario si può ricostruire in fase di decoding.
Tutti gli altri, tipo zip, gzip, png si basano poi su questa idea.</description>
    </item>
    <item>
      <title>Gestione della memoria</title>
      <link>https://flecart.github.io/notes/gestione-della-memoria/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gestione-della-memoria/</guid>
      <description>Ripasso Prox: 60 Ripasso: June 1, 2023 Ultima modifica: May 29, 2023 3:34 PM Primo Abbozzo: February 27, 2023 9:07 AM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso Gestione della memoria Memoria statica Elementi in memoria statica (4) 🟩- Variabili globali Istruzioni macchina Costanti (Variabili locali, paramentri e ritorno di funzione?) Le primi tre elementi descritti di sopra sono sicuramente presenti dopo la fase di compilazione, infatti sono allocati dal compilatore in una zona presente nell’eseguibile (un esempio è il READONLY per le stringhe in C).</description>
    </item>
    <item>
      <title>Introduzione alla probabilita</title>
      <link>https://flecart.github.io/notes/introduzione-alla-probabilita/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-alla-probabilita/</guid>
      <description>Ripasso Prox: 3 Ultima modifica: September 16, 2022 9:37 AM Primo Abbozzo: September 13, 2022 2:53 PM Stato: 🌕🌕🌕🌕🌗 Studi Personali: Yes
Note: Questo corso è troppo astratto. Più che probabilità tratta di teoria della Misura. Quindi affossato…
Link della serie: https://www.youtube.com/watch?v=172m7qVy_FQ&amp;amp;list=PLrb6X_RiBI94b6dzCx-QwM-r0aZpJyPxS
Campo (di probabilità) Nota:
2 e 3 ⇒ 4
2 e 4 ⇒ 3
Quindi 3 e 4 sono interscambiabili, e si potrebbe eliminare uno dei due.
Anche il fatto che il vuoto sia presente in F si può omettere.</description>
    </item>
    <item>
      <title>Memory of the Brain</title>
      <link>https://flecart.github.io/notes/memory-of-the-brain/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/memory-of-the-brain/</guid>
      <description>La memoria e l&amp;rsquo;apprendimento Breve classificazione Basata sulla consapevolezza Basata sul tempo Basata sulla funzione Importanza della dimensione temporale Memoria a breve termine Memoria a lungo termine Anatomia della memoria nel cervello Il caso di H. M. </description>
    </item>
    <item>
      <title>Preparazione all’orale</title>
      <link>https://flecart.github.io/notes/preparazione-allorale/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/preparazione-allorale/</guid>
      <description>Ultima modifica: October 8, 2022 12:08 PM Primo Abbozzo: June 2, 2022 10:53 AM Studi Personali: No
Elementi di ripasso Preparazione Parte 1 introduzione ai reali Numerabilità di Q Relazione 5 postulato con th pitagora se ml = n gcd(m,n) = 1, allora n divide l, non ti ricordi proprio. (dimostrazione se n non è quadrato perfetto allora la sua radice non appartiene ai Q). (questo si può estendere anche n come numero razionale con ragionamento simile e non solo n come naturale, non te lo ricordavi al 100 per cento) Surplus: costruzione die numeri Reali con roba di Dedekind Non sapevi enunciare in modo completo la proprietà di completezza dei Reali Cose sbagliate in sta parte Non hai utilizzato il lemma per la dimostrazione della numerabilità, quindi la dimo è sbagliata Non ti ricordavi proprio la relazione Successioni e limiti Le successioni monotone hanno sempre un limite (o divergono o convergono, mentre potrebbe essere per certe successioni che né divergono né convergono) rifare la dimo di nepero convergenza, forse sbagli qualcosa funzioni varie Dimostrazione della formula della somma dei coseni e dei seni Dimostrazione limite noto del seno Continuità Definizione di funzione continua</description>
    </item>
    <item>
      <title>Semantica di un linguaggio</title>
      <link>https://flecart.github.io/notes/semantica-di-un-linguaggio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/semantica-di-un-linguaggio/</guid>
      <description>Ripasso Prox: 80 Ripasso: June 2, 2023 Ultima modifica: June 7, 2023 2:41 PM Primo Abbozzo: October 1, 2022 10:15 AM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
Elementi di ripasso Domande
Semantica di un linguaggio Vincoli sintattici contestuali Intro: dipendenze da contesto 🟩 I vincoli sintattici non sono esprimibili tramite BNF perché dipendono dal contesto, mentre le grammatiche libere sono per definizione libere da contesto, vogliamo quindi trovare una soluzione a questo problema.</description>
    </item>
    <item>
      <title>Algo from Youtube</title>
      <link>https://flecart.github.io/notes/algo-from-youtube/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algo-from-youtube/</guid>
      <description>Dai video di Abdul Bari
Ultima modifica: January 21, 2022 10:24 AM Primo Abbozzo: January 16, 2022 8:31 AM Studi Personali: No
0 Introduction Difference algo-prog Here we try to list and discuss the main differences between the algorithm and the program.
algo prog Design Implementation Any language program language Hardware/soft independent dependent Analysis Testing Domain knowledge Programming The algorithm step cares about the design of the program. It’s more of a abstract way of thinking (this is also the cause of the independency from the hardware software and OS), when on the other side the program is the implementation.</description>
    </item>
    <item>
      <title>Introduzione a Logica</title>
      <link>https://flecart.github.io/notes/introduzione-a-logica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-a-logica/</guid>
      <description>Ripasso Prox: 23 Ripasso: December 29, 2021 Ultima modifica: September 30, 2022 3:19 PM Primo Abbozzo: September 22, 2021 9:38 AM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Tutti i ripassi per scuola
logica0.pdf
0 Introduzione Lo scopo della logica è
Correttezza del ragionamento, anche verificata attraverso algoritmi predittivi. Si svilupperanno linguaggi logici I metodi per la veridicità di una sentenza. Possibilità e metodi del ragionamento logico Completezza e non-deducibilità di alcuni ragionamenti Necessità di completezza delle ipotesi: più ipotesi = ragionamento valido?</description>
    </item>
    <item>
      <title>Spazi vettoriali</title>
      <link>https://flecart.github.io/notes/spazi-vettoriali/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/spazi-vettoriali/</guid>
      <description>1 Spazi vettoriali 1.1 Piano cartesiano 1.1.1 Definizione Possiamo considerare il piano cartesiano come l&amp;rsquo;insieme $\R^2$ potremmo dire che esiste una corrispondenza fra una coordinata e un punto del piano, una volta che abbiamo definito un punto di origine. Si può vedere anche come corrispondenza biunivoca con vettori del piano per l&amp;rsquo;origine (parte dall&amp;rsquo;origine).
Questa cosa vale anche per uno spazio n-dimensionale, non soltanto due, ma per semplicità di introduzione di questo lo faccio con 2</description>
    </item>
    <item>
      <title>Variabili aleatorie</title>
      <link>https://flecart.github.io/notes/variabili-aleatorie/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/variabili-aleatorie/</guid>
      <description>Ripasso Prox: 5 Ultima modifica: May 6, 2023 5:51 PM Primo Abbozzo: March 14, 2023 10:50 AM Stato: 🌕🌕🌕🌗🌑 Studi Personali: No
Variabili aleatorie discrete Con le variabili aleatorie cominciamo ad entrare nel noccio della questione, finalmente possiamo in un certo senso legare l’outcome di un evento, alla probabilità dell’evento.
Introduzione Definizione VA 🟩 Si definisce variabile aleatoria $X$ una funzione da $\Omega \to E$, con Omega il nostro spazio campionario, e $E$ qualunque insieme (quando $E = \mathbb{R}$ si parla di variabile aleatoria reale</description>
    </item>
    <item>
      <title>Geometrie di spire</title>
      <link>https://flecart.github.io/notes/geometrie-di-spire/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/geometrie-di-spire/</guid>
      <description>Spire Spira quadrata Questo è descritto nell&amp;rsquo;esempio 8.1 del Mazzoldi. È stato descritto anche in un esercizio in classe (non è importante).
Spira circolare 🟩 Vedere pagina 245 Vogliamo cercare il valore del campo sull&amp;rsquo;asse della spira circolare. Questo è semplice, basta usare la prima di Laplace e trovare l&amp;rsquo;apporto del campo magnetico al centro. Si può anche pensare come momento magnetico, allora si utilizza sempre lo stesso discorso per la spira quadrata classica e il suo momento.</description>
    </item>
    <item>
      <title>Introduzione a blockchain</title>
      <link>https://flecart.github.io/notes/introduzione-a-blockchain/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-a-blockchain/</guid>
      <description>Ripasso Prox: 25 Ultima modifica: January 27, 2023 3:48 PM Primo Abbozzo: December 29, 2022 3:26 PM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso Introduzione Blockchain stack Vogliamo andare ora a descrivere la stack delle blockchain, in modo simile a quanto fatto con le internet, perché anche qui possiamo organizzarlo a stack!
Nota: le astrazioni fra questi layer non sono definiti bene come osi osint.
Layer - 0 Internet Internet (semi-reliable point-to-point communication) and cryptography (specifically, cryptographic hash functions and secure digital signatures).</description>
    </item>
    <item>
      <title>Condensatori con dielettrici</title>
      <link>https://flecart.github.io/notes/condensatori-con-dielettrici/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/condensatori-con-dielettrici/</guid>
      <description>introduzione ai dielettrici Esperimenti metalli e dielettrici 🟩 Verso gli anni del 1840 Faraday ha fatto molti sistematici esperimenti per scoprire come si comportava il potenziale e il campo elettrico di fronte a certi materiali. Sono stati principalmente posti delle sostanza (conduttrici o meno) in mezzo a lastre di condensatori, e hanno misurato come cambiava il potenziale elettrico fra le due lastre (che si può vedere attraverso il modo con cui cambiano sull&amp;rsquo;elettroscopio).</description>
    </item>
    <item>
      <title>Corrente Elettrica</title>
      <link>https://flecart.github.io/notes/corrente-elettrica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/corrente-elettrica/</guid>
      <description>Introduzione alla corrente elettrica Considerazioni generali Elettroni liberi nei materiali Ricorda che è un reticolo cristallino, con un elettrone nell&amp;rsquo;ultimo orbitale poco legato, quindi facilmente ionizzabile, in cui gli elettroni si possono muovere facilmente, e abbiamo che $n \approx 8.5 \times 10^{28} \frac{e^{-}}{m^{3}}$ nel rame Per l&amp;rsquo;argento abbiamo 5.9 con stesso ordine di grandezza.
Velocità media elettroni senza campo elettrico 🟩 Se è isotropo, gli elettroni si muovo in generale a caso e la velocità media dipendente dall&amp;rsquo;eccitazione termica (in teoria cinetica dei gas è studiata sta cosa).</description>
    </item>
    <item>
      <title>HTML e Markup</title>
      <link>https://flecart.github.io/notes/html-e-markup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/html-e-markup/</guid>
      <description>Ripasso Prox: 37 Ripasso: June 3, 2023 Ultima modifica: June 18, 2023 11:27 PM Primo Abbozzo: February 27, 2023 3:19 PM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso HTML Markup Introduzione alle funzioni del markup 🟩 La semantica di una parola è caratterizzata dalla mia scelta (design sul significato). Non mi dice molto, quindi proviamo a raccontare qualcosa in più.
Definiamo markup ogni mezzo per rendere esplicita una particolare interpretazione di un testo.</description>
    </item>
    <item>
      <title>Introduction to data-bases</title>
      <link>https://flecart.github.io/notes/introduction-to-data-bases/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduction-to-data-bases/</guid>
      <description>Basi di dati Cosa è un database? (2) 🟩 Si potrebbe intendere come un insieme di dati strutturato, utili per certi obiettivi di enterprise, aziende pubbliche o simili (uno delle necessità che la rivoluzione informatica ha più contribuito diciamo.)
Un altro significato più importante è
Un insieme di dati gestito da un Database Management System
Tristemente con questa definizione anche excel è un DBMS&amp;hellip;
Solitamente sono utilizzati per gestire grandi quantità di dati.</description>
    </item>
    <item>
      <title>Naïve Bayes</title>
      <link>https://flecart.github.io/notes/na%C3%AFve-bayes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/na%C3%AFve-bayes/</guid>
      <description>Introduzione a Naïve Bayes Bisognerebbe in primo momento avere benissimo in mente il significato di probabilità condizionata e la regola di naive Bayes in seguito.
Bayes ad alto livello 🟩 Da un punto di vista intuitivo non è altro che predire la cosa che abbiamo visto più spesso in quello spazio Assunzioni principali per naïve Bayes 🟩 I sample di input sono condizionalmente indipendenti uno con l&amp;rsquo;altro. Questo permette di utilizzare questa ipotesi $$ P(X_{1}\dots X_{n} | Y = y_{i}) = \prod_{i}^{n} P(X_{i} | Y) $$ E permette di rendere la parte di inferenza anche molto semplice perché per classificare un caso basta prendere label con la probabilità maggiore.</description>
    </item>
    <item>
      <title>Reti Preparazione Esami</title>
      <link>https://flecart.github.io/notes/reti-preparazione-esami/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/reti-preparazione-esami/</guid>
      <description>Ultima modifica: May 1, 2023 10:37 AM Primo Abbozzo: April 30, 2023 5:06 PM Studi Personali: No
Elementi di ripasso 2022-06-10 Es 3 (sicurezza) Testo [15] Alice spedisce a Bob un messaggio M1 molto grande con la sola garanzia di non ripudiabilità (ovvero Alice non potrà mai dimostrare di avere spedito un messaggio diverso da quello ricevuto da Bob), ma non serve privacy (tutti possono leggere M1). Bob in seguito risponde ad Alice con un messaggio m2 molto piccolo del quale deve essere però data garanzia di mittente (solo Bob può averlo spedito), di privacy (nessuno oltre ad Alice può leggerlo) e non Replay (ovvero Alice deve accettarlo una volta sola da Bob).</description>
    </item>
    <item>
      <title>Syncronous model</title>
      <link>https://flecart.github.io/notes/syncronous-model/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/syncronous-model/</guid>
      <description>Ripasso Prox: 20 Ultima modifica: February 1, 2023 4:21 PM Primo Abbozzo: December 30, 2022 9:40 AM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso Syncronous model Introduction Da ricordare il &amp;ldquo;The State Machine Replication (SMR) Problem&amp;rdquo; che è importantissimo per comprendere questa parte.
Storia locale Transazioni al singolo noto Problema del sync fra tutti questi nodi.
Goal of SMR solution in blockchains Andiamo a considerare alcune proprietà di safety e liveness Programmi Concorrenti</description>
    </item>
    <item>
      <title>System Design</title>
      <link>https://flecart.github.io/notes/system-design/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/system-design/</guid>
      <description>NOTA: tolgo dalle note perché non mi sembra importante.
Introduction to system design Packages vs diagrams 🟩- Packages fisica implementazione, perché è una cosa utile per lo sviluppo Diagrams logica visualizzazione perché aiuta solamente a comprendere meglio come funziona il sistema in toto. Components What is a component (3) 🟨 È una entità totalmente indipendente che funziona a sé, un esempio è il dll, dynamically loaded libraries presente nei sistemi di windows.</description>
    </item>
    <item>
      <title>Accept Reject algorithm</title>
      <link>https://flecart.github.io/notes/accept-reject-algorithm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/accept-reject-algorithm/</guid>
      <description>Some useful links Main results: https://jblevins.org/notes/accept-reject
Intuition: https://en.wikipedia.org/wiki/Rejection_sampling
La cosa è che faccio sampling fra due distribuzioni diverse e devo settare anche un parametro (e a seconda di certe cose diventa molto lento).
Introduzione al metodo Vorrei utilizzare una funzione $g$ per generarne una altra, questo è il fulcro del concetto. L&amp;rsquo;idea principale è:
Conosco la funzione densità della funzione $f$ che voglio andare a generare Riesco a generare seguendo una funzione semplice, la chiamo $g$, candidate density.</description>
    </item>
    <item>
      <title>Alberi BST e AVL</title>
      <link>https://flecart.github.io/notes/alberi-bst-e-avl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/alberi-bst-e-avl/</guid>
      <description>Alberi BST e AVL 4.1 Alberi binari di ricerca (BST) Queste sono delle varianti rispetto all&amp;rsquo;albero, descritto in modo molto sommario sopra (binario perché ogni nodo ha al massimo due figli, mentre l&amp;rsquo;albero può averne quanti se ne vuole).
4.1.1 Introduzione La caratteristica principale dell&amp;rsquo;albero di ricerca è una condizione sulle chiavi (che hanno i figli).
Infatti questo albero binario di ricerca si può vedere come una implementazione della struttura astratta del dizionario.</description>
    </item>
    <item>
      <title>Bias Variance Trade-off</title>
      <link>https://flecart.github.io/notes/bias-variance-trade-off/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bias-variance-trade-off/</guid>
      <description>Introduction È una cosa ormai risaputa che c&amp;rsquo;è una sorta di trade-off fra la varianza e il bias per una certo modello. Aumentare la varianza del modello certamente ci permetterà di avere un modello che abbia un errore di training molto basso, però appena vede dei dati nuovi non sarà in grado di generalizzare correttamente. Dall&amp;rsquo;altra parte avere un bias alto significa avere un modello eccessivamente semplice, poco flessibile, che comunque allenato non riesce ad avere una grande accuratezza né in fase di allenamento, né di in fase di validazione o di test.</description>
    </item>
    <item>
      <title>Effetti del linguaggio</title>
      <link>https://flecart.github.io/notes/effetti-del-linguaggio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/effetti-del-linguaggio/</guid>
      <description>In questa nota proviamo a cercare di descrivere bene l&amp;rsquo;analisi degli effetti del linguaggio che possono avere a che fare con theory of mind.
(Mahowald et al. 2023) Inizia a fare una bella analisi riguardante la differenza di conoscenza sintattica e funzionale del linguaggio. Molte references all&amp;rsquo;aspetto del cervello per quella roba.
References [1] Mahowald et al. “Dissociating Language and Thought in Large Language Models: A Cognitive Perspective” arXiv preprint arXiv:2301.</description>
    </item>
    <item>
      <title>Key Exchange protocols</title>
      <link>https://flecart.github.io/notes/key-exchange-protocols/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/key-exchange-protocols/</guid>
      <description>Metodi di key exchange
Trusted Key parties (sono come Certificate authorities studiati in Sicurezza delle reti) Merkle Puzzles DH protocol Trusted Third parties Squared Key problem Un problema abbastanza ovvio è che per storare le chiavi di tutti c&amp;rsquo;è una necessità $O(n^{2})$ on $O(n)$ users Se c&amp;rsquo;è un trusted key parties il numero delle chiavi si riduce di molto, ritorna ad essere lineare!
Protocols Toy Exchange protocol 🟩 TTP = Trusted Third party (simile a quanto poi si avrà in Asymmetric Cryptography) Questa è la base del servizio di Kerberos!</description>
    </item>
    <item>
      <title>Linguaggi liberi e PDA</title>
      <link>https://flecart.github.io/notes/linguaggi-liberi-e-pda/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/linguaggi-liberi-e-pda/</guid>
      <description>Ripasso Prox: 69 Ripasso: May 29, 2023 Ultima modifica: April 25, 2023 9:50 AM Primo Abbozzo: October 28, 2022 12:52 PM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso Domande
Linguaggi liberi e PDA Introduzione In questa parte del nostro percorso nei linguaggi di programmazione proviamo ad espandere NFA e DFA in modo che possano riconoscere linguaggi come $ww^r | w \in {a, b}^*$ , con r maggiore o uguale a zero (r per dire che è il contrario di w) (questo linguaggio per il pumping lemma).</description>
    </item>
    <item>
      <title>Metadati web e web semantico</title>
      <link>https://flecart.github.io/notes/metadati-web-e-web-semantico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/metadati-web-e-web-semantico/</guid>
      <description>Ripasso: May 19, 2023 Ultima modifica: May 11, 2023 8:38 PM Primo Abbozzo: May 5, 2023 2:21 PM Studi Personali: No
Metadati web https://csunibo.github.io/tecnologie-web/lucidi/teoria/23-metadati.pdf https://csunibo.github.io/tecnologie-web/lucidi/teoria/24-a-web-semantico-lod-rdf-json-ld.pdf
inconfrontabilità del sapere Stessa informazione in forme diverse Stessa parola per cose diversa. Serializzazione La semantica è relegata alle applicazioni che devono decidere in che modo interpretarli, oppure esseri umani.
PICS Platform for Internet Content Selection vuole cercare di tenere sotto controllo i materiali del film.</description>
    </item>
    <item>
      <title>N-Bandit Problem</title>
      <link>https://flecart.github.io/notes/n-bandit-problem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/n-bandit-problem/</guid>
      <description>Impostazione del problema Supponiamo di stare giocando a n slot machine contemporaneamente. Queste macchine hanno internamente un valore di reward che non conosciamo. Ad ogni step possiamo scegliere una singola macchina e andare a tirare la sua leva. Riceviamo il valore del reward nascosto con un pò di rumore. Vogliamo capire nel lungo quale sia la strategia che possa dare migliore reward medio possibile.
Questo è un semplice problema, ma lo possiamo considerare un fulcro molto importante per poter comprendere il problema del reinforcement learning.</description>
    </item>
    <item>
      <title>Recurrent Neural Networks</title>
      <link>https://flecart.github.io/notes/recurrent-neural-networks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/recurrent-neural-networks/</guid>
      <description>Ultima modifica: February 16, 2023 1:26 PM Primo Abbozzo: February 16, 2023 12:57 PM
Introduzione ai RNN Vorremmo costruire un modello che fosse in grado di predire delle cose che dipendono da vecchie sequenze (quindi un network che abbia in un qualche senso la memoria di un coso passato).
Riassunto in slide Formalizzazione del network Stato interno La differenza principale col percettrone è la presenza di uno stato interno nascosto, che continua a trasformarsi a seconda degli input, lo chiamiamo interno perché non è dato in output, ma viene se</description>
    </item>
    <item>
      <title>Requisiti e backlog del software</title>
      <link>https://flecart.github.io/notes/requisiti-e-backlog-del-software/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/requisiti-e-backlog-del-software/</guid>
      <description>Introduzione sui requisiti del software Note introduttive In linguaggio naturale (dizionario) 🟥+ Sono tutte le qualità necessarie per uno scopo ben determinato.
Secondo il prof. I requisiti sono dei desideri ossia ciò che idealmente vorresti riguardo qualcosa (nel nostro caso il software). Ma credo sia anche una tendenza italiana di fare le cose meglio possibile senza mai soddisfare tutto
Functional requirements 🟩 Sono ciò che permetterà di fare il sistema</description>
    </item>
    <item>
      <title>Teoria dei Tipi</title>
      <link>https://flecart.github.io/notes/teoria-dei-tipi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/teoria-dei-tipi/</guid>
      <description>Ripasso Prox: 30 Ripasso: June 6, 2023 Ultima modifica: May 14, 2023 6:13 PM Primo Abbozzo: March 13, 2023 9:20 AM Studi Personali: No
Elementi di ripasso Teoria dei Tipi Introduzione Definizione 🟩— Un metodo sintattico praticabile per dimostrare l&amp;rsquo;assenza di determinati comportamenti del programma, fatto classificando le unità sintattiche in base ai tipi di valore che assumono
Vogliamo che fosse praticabile nel senso che effettivamente lo possiamo implementare, cioè ci permettono di avere certe tipologie di garanzia.</description>
    </item>
    <item>
      <title>Training a NN</title>
      <link>https://flecart.github.io/notes/training-a-nn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/training-a-nn/</guid>
      <description>Ultima modifica: March 11, 2023 7:22 PM Primo Abbozzo: March 8, 2023 6:05 PM Studi Personali: No
Elementi di ripasso Training of NN How can we be sure that we can train well our function?
Dataset quality (this cannot be changed in training time) Models and parameters of our model, we can describe it as $L(x, \theta)$, and we try to minimize this function. Training approaches Random perturn weights, this is ispired by evolution, but it’s slow and not effective (and we can make things worse in many ways) Predict adjustments, usually we can analitically define what is the best way to minimize the loss, so we would like to follow that slope and go down!</description>
    </item>
    <item>
      <title>Descrizione linguaggio</title>
      <link>https://flecart.github.io/notes/descrizione-linguaggio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/descrizione-linguaggio/</guid>
      <description>Ripasso Prox: 79 Ripasso: June 10, 2023 Ultima modifica: June 4, 2023 3:33 PM Primo Abbozzo: September 27, 2022 12:18 PM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso Domande
Non sembra che abbia capito molto bene i concetti di pragmatica e linguaggio eseguibile per i linguaggi formali
Dimostrazione numerabilità delle grammatiche.
Questo insieme di appunti riassume gli appunti 1-2-3 del professor Gorrieri.
Descrizione di un linguaggio Introduzione Per questa parte c’è un sacco di roba in comune con Tecniche di definizione di semantica (4) 🟩</description>
    </item>
    <item>
      <title>Expressiveness of NN</title>
      <link>https://flecart.github.io/notes/expressiveness-of-nn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/expressiveness-of-nn/</guid>
      <description>Ripasso Prox: 40 Ripasso: June 10, 2023 Ultima modifica: April 22, 2023 11:38 AM Primo Abbozzo: March 2, 2023 9:19 AM Stato: 🌕🌕🌕🌗🌑 Studi Personali: No
Elementi di ripasso Expressiveness of NN The perceptron Slide summary of working of perceptron
Note on the bias: it is only useful to move the treshhold where to consider the output to be 1 and where to be 1.
Now we ask what can be predicted by a perceptron?</description>
    </item>
    <item>
      <title>HACK</title>
      <link>https://flecart.github.io/notes/hack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/hack/</guid>
      <description>Ultima modifica: February 25, 2023 2:07 PM Primo Abbozzo: October 26, 2021 1:53 PM Studi Personali: No
Elementi di ripasso Componenti di HACK Il nostro computer è diviso in tre parti fondamentali. (anche la memoria è divisa in tre parti fondamentali.
Memoria C&amp;rsquo;è una sezione per il RAM normale, una sezione per il ram dello schermo e un singolo byte per il keyboard.
Struttura generale Rom, e poi cose per input output come schermo e keyboard.</description>
    </item>
    <item>
      <title>Introduzione sistemi operativi</title>
      <link>https://flecart.github.io/notes/introduzione-sistemi-operativi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-sistemi-operativi/</guid>
      <description>Ultima modifica: March 1, 2023 9:52 AM Primo Abbozzo: October 16, 2021 6:09 PM Studi Personali: Yes
Elementi di ripasso 1 Introduzione In questa sezione andiamo ad indagare cosa fa il sistema operativo
Note Generali 4 Parti di un sistema di calcolo Struttura Memoria Vedi Memoria per il corso di Architettura
Tipologie di SO Bimodalità SO Utente e Kernel
Interrupt, Trap, System or Supervisor Call System call 🟩- per maggiori info sui modi di chiamata delle syscall</description>
    </item>
    <item>
      <title>Tiling problem</title>
      <link>https://flecart.github.io/notes/tiling-problem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/tiling-problem/</guid>
      <description>Formalizzazione del problema Definizione formale del tiling Consideriamo una tupla $\langle \mathcal{T}, t_{0}, H, V \rangle$
$\mathcal{T}$ è un insieme di piastrelle. $t_{0} \in \mathcal{T}$ è la piastrella d&amp;rsquo;origine. $H \subseteq \mathcal{T} \times \mathcal{T}$ le regole di adiacenza orizzontali. $V \subseteq \mathcal{T} \times \mathcal{T}$ le regole di adiacenza verticali. L&amp;rsquo;obiettivo è vedere se è possibile riempire tutto il piano con queste piastrelle, all&amp;rsquo;infinito. Sappiamo già che non è sempre possibile farlo.</description>
    </item>
    <item>
      <title>Valutazione Espressioni</title>
      <link>https://flecart.github.io/notes/valutazione-espressioni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/valutazione-espressioni/</guid>
      <description>Ripasso Prox: 40 Ripasso: May 31, 2023 Ultima modifica: May 29, 2023 3:58 PM Primo Abbozzo: March 6, 2023 9:19 AM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso Espressioni, Comandi, Ricorsione Espressioni Con espressione intendiamo una entità sintattica, che una volta valutata ritornerà un valore, oppure non termina, in questo caso si dice che la espressione è INDEFINITA.
Questa è una definizione è leggermente ambigua dato che non abbiamo una definizione precisa di valutazoine, che è fortemente dipendente dalla macchina astratta in cui viene eseguito.</description>
    </item>
    <item>
      <title>Asymptotic Equipartition Property</title>
      <link>https://flecart.github.io/notes/asymptotic-equipartition-property/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/asymptotic-equipartition-property/</guid>
      <description>Sembra essere molto simile a Central Limit Theorem and Law of Large Numbers però per Entropy.
Enunciato Data una serie di variabili aleatorie $X_{1}, X_{2}, \dots$ i.i.d. $\sim p(x)$ se vale che $$ -\frac{1}{n} \log p(X_{1}, X_{2}, \dots, X_{n}) \to H(X) $$ in probability (la definizione data in Central Limit Theorem and Law of Large Numbers#Convergence in probability).
Dimostrazione Principalmente sorvolata, ma utilizza cose simili a Central Limit Theorem and Law of Large Numbers, e una idea simile a Monte carlo integration per le probabilità.</description>
    </item>
    <item>
      <title>Introduzione algebra</title>
      <link>https://flecart.github.io/notes/introduzione-algebra/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-algebra/</guid>
      <description>Ripasso Prox: 36 Ripasso: June 1, 2022 Ultima modifica: October 19, 2022 5:05 PM Primo Abbozzo: December 12, 2021 11:58 AM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso significato di compatibilità Il vettore dei termini noti, non ti ricordavi la parola termini noti 😀 0 Introduzione Tutta sta parte si fa in modo formale in Sistemi Lineari e determinanti, quindi potresti saltarla totalmente
0.1 Equazioni lineari L&amp;rsquo;obiettivo dell&amp;rsquo;algebra lineare è risolvere n equazioni con n sconosciuti di primo grado.</description>
    </item>
    <item>
      <title>Logistic Regression</title>
      <link>https://flecart.github.io/notes/logistic-regression/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/logistic-regression/</guid>
      <description>Introduzione alla logistic regression Giustificazione del metodo Questo è uno dei modelli classici, creati da Minsky qualche decennio fa In questo caso andiamo direttamente a computare il valore di $P(Y|X)$ durante l&amp;rsquo;inferenza, quindi si parla di modello discriminativo, seguendo il modello presente in Introduction to machine learning
Introduzione al problema Supponiamo che
$Y$ siano variabili booleane $X_{i}$ siano variabili continue $X_{i}$ siano indipendenti uno dall&amp;rsquo;altro. $P(X_{i}| Y= k)$ sono modellate tramite distribuzioni gaussiane $\mathbb{N}(\mu_{ik}, \sigma_{i})$ NOTA!</description>
    </item>
    <item>
      <title>Semantica intuizionista</title>
      <link>https://flecart.github.io/notes/semantica-intuizionista/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/semantica-intuizionista/</guid>
      <description>Ripasso Prox: 6 Ripasso: December 23, 2021 Ultima modifica: September 30, 2022 3:20 PM Primo Abbozzo: November 26, 2021 9:35 AM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso Vecchi dubbi quali sono stati gli scopi della logica intuizionista? Gli effetti della compattezza 9 Semantica intuizionista Tutte le slides
slides10_202021.pdf
Molto importante questo documento per avere chiara la differenza fra la logica intuizionista e la Logica Proposizionale classica.
Questa logica intuizionista non si preoccupa del noumeno platonico, ma solo di una prova reale.</description>
    </item>
    <item>
      <title>VLAN</title>
      <link>https://flecart.github.io/notes/vlan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/vlan/</guid>
      <description>Ultima modifica: May 17, 2023 3:14 PM Primo Abbozzo: May 17, 2023 1:48 PM Studi Personali: No
Elementi di ripasso VLAN Introduzione Quando abbiamo una switch, ma vogliamo allo stesso momento andare a creare più LAN, allora abbiamo bisogno delle VLAN. Questi switch che hanno delle VLAN si chiamano managed switches
Queste vlan sono numerate (ricorda l’espericomento cn LUCA!).
Il problema Sono un protocollo livello 2 (Link-Layer, di collegamento), non vorremmo per esempio che un broadcast di una certa rete vada anche in altre reti che non centrino praticamente nulla, come possiamo vedere in figura.</description>
    </item>
    <item>
      <title>Agente Logico</title>
      <link>https://flecart.github.io/notes/agente-logico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/agente-logico/</guid>
      <description>Ripasso Prox: 5 Ultima modifica: December 29, 2022 3:24 PM Primo Abbozzo: July 30, 2022 4:16 PM Stato: 🌕🌕🌕🌑🌑 Studi Personali: No
Elementi di ripasso Agenti Logici Introduzione Nozioni base Questi sono le parole chiave di questo capitolo, ci permettono di parlare con chiarezza riguardo l’agente logico.
Sentence
Knowledge Base
Axiom
Inference
background knowledge
Knowledge representation language
Knowledge level
Implementation level
Esempio generale di agente logico
Logica proposizionale Sintassi del linguaggio Descrivere la BNF della logica proposizionale.</description>
    </item>
    <item>
      <title>Algebra lineare numerica</title>
      <link>https://flecart.github.io/notes/algebra-lineare-numerica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algebra-lineare-numerica/</guid>
      <description>Ripasso Prox: 24 Ripasso: December 23, 2022 Ultima modifica: January 2, 2023 9:50 AM Primo Abbozzo: September 22, 2022 12:03 PM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Algebra lineare numerica Immagini Lab 2 images
Metodo di gauss Vogliamo cercare un metodo per calcolare soluzioni a sistemi di equazione del genere:
$Ax = b$, classico. Supponiamo che questo sistema abbia una soluzione.
Il nostro obiettivo sarebbe scomporre la matrice $A = LU$ come prodotto di due matrici Lower triangular e Upper triangular.</description>
    </item>
    <item>
      <title>Antenne</title>
      <link>https://flecart.github.io/notes/antenne/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/antenne/</guid>
      <description>Ripasso Prox: 10 Ripasso: May 23, 2023 Ultima modifica: May 14, 2023 5:20 PM Primo Abbozzo: April 5, 2023 2:24 PM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
Elementi di ripasso Antenne Omnidirezionali Antenne omnidirezionali 🟩 Slides antenne omnidirezionali
Il senso di omnidirezionale è in tutte le direzioni dell&amp;rsquo;antenna (nota: non è isotropico, perché non è da un singolo punto).
in passato era importante andare a guardare la direzione per trovare la polarizzazione migliore.</description>
    </item>
    <item>
      <title>Asymmetric Cryptography</title>
      <link>https://flecart.github.io/notes/asymmetric-cryptography/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/asymmetric-cryptography/</guid>
      <description>Public Key Encryption We now define a formally what is a public key encryption
Formal definition of Public Key Encryption We define a 3-tuple formed as follows: $(G, E, D)$ where
$G$ is the generator for the private and public keys, from now on identified as $(pk, sk)$ (public key and secret key) $E$ the encryption algorithm, that takes the $pk$ and the message in input $D$ the decryption algorithm, that takes the $sk$ and the cyphertext in input.</description>
    </item>
    <item>
      <title>Garbage Collection</title>
      <link>https://flecart.github.io/notes/garbage-collection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/garbage-collection/</guid>
      <description>Ripasso Prox: 10 Ripasso: May 20, 2023 Ultima modifica: May 11, 2023 8:17 PM Primo Abbozzo: April 17, 2023 11:10 AM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
Elementi di ripasso Garbage Collection On dangling pointers Tombstones 🟩 Slides tombstones
Quando alloco, alloco anche una tombstone, e tutti i riferimenti passano per quella. (quindi ho due dereference per l’accesso) quando vado a deallocare segno la tombstone come RIP, NULL.
Dopo molto tempo ho il problema del cimitero che diventa molto grande.</description>
    </item>
    <item>
      <title>Legge di Coulomb</title>
      <link>https://flecart.github.io/notes/legge-di-coulomb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/legge-di-coulomb/</guid>
      <description>Introduzione elettromagnetismo Note storiche: triboelettricità Il concetto di campo è fondamentale per l&amp;rsquo;elettromagnetismo (vs forza in meccanica) da un punto di vista storico è nato tramite l&amp;rsquo;osservazione in fenomeni come lo strofinio fra vetro e pelle, dopo il quale hanno osservato ci fosse una forza nascosta (appunto ombra dal greco di electron). Il vetro si caricava poi abbastanza da poter attrarre carta per esempio. esempio dell&amp;rsquo;esperimento. Se viene fatto invece fra due lastre in vetro invece diventa repulsiva invece che attrattiva.</description>
    </item>
    <item>
      <title>Linguaggi Deterministici e DPDA</title>
      <link>https://flecart.github.io/notes/linguaggi-deterministici-e-dpda/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/linguaggi-deterministici-e-dpda/</guid>
      <description>Ripasso Prox: 55 Ripasso: July 2, 2023 Ultima modifica: June 9, 2023 12:26 PM Primo Abbozzo: November 5, 2022 10:55 AM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso Domande
Linguaggi Deterministici e DPDA DPDA Definizione (2) 🟩 La definizione di DPDA è molto simile a quella trattata in Linguaggi liberi e PDA, con solo costraints sulla deterministicità, che si traducono in due condizioni:
Al massimo posso avere un risultato per ogni coppia di lettura e simbolo su stack Se ho una transizione senza leggere, posso avere solo quella Slide</description>
    </item>
    <item>
      <title>Message Passing</title>
      <link>https://flecart.github.io/notes/message-passing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/message-passing/</guid>
      <description>Ripasso Prox: 70 Ripasso: July 22, 2023 Ultima modifica: May 19, 2023 9:25 AM Primo Abbozzo: November 23, 2022 1:32 PM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso Message passing ora abbiamo alcune primitive per passarci i messaggi, vogliamo creare metodo in modo che i processi si possano sincronizzare mandando messaggi.
la memoria è sempre privata.
Primitive Send e receive 🟩 Send
Spedizione del messaggio input deve avere un identificato al processo su cui spedire.</description>
    </item>
    <item>
      <title>Monitor</title>
      <link>https://flecart.github.io/notes/monitor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/monitor/</guid>
      <description>Ripasso Prox: 70 Ripasso: June 10, 2023 Ultima modifica: April 1, 2023 9:09 AM Primo Abbozzo: November 9, 2022 11:31 AM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
Elementi di ripasso Monitor Questo è un modo di più alto livello per creare programmazione concorrente.
Introduzione Questo costrutto per la programmazione concorrente, prende molto dalla programmazione agli oggetti, abbiamo delle variabili presenti al monitor, private solamente accessibili ad essa, tramite procedure che sono mutex automaticamente!</description>
    </item>
    <item>
      <title>Notazione Asintotica</title>
      <link>https://flecart.github.io/notes/notazione-asintotica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/notazione-asintotica/</guid>
      <description>Ripasso Prox: 31 Ripasso: May 28, 2022 Ultima modifica: April 28, 2022 5:07 PM Primo Abbozzo: February 24, 2022 9:19 AM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Notazione asintotica Introduzione alla notazione asintotica Cercare di definire il tempo impiegato da una funzione per essere eseguita in termini di DIMENSIONE dell&amp;rsquo;input. **(il numero di bit a livello basso basso)
Ma abbiamo il problema di misura, in quanto dobbiamo considerare delle variabili che siano indipendenti rispetto alla macchina.</description>
    </item>
    <item>
      <title>Funzioni</title>
      <link>https://flecart.github.io/notes/funzioni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/funzioni/</guid>
      <description>Ripasso Prox: 30 Ripasso: December 19, 2021 Ultima modifica: December 14, 2021 3:43 PM Primo Abbozzo: October 13, 2021 3:29 PM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso 2 Funzioni 2.1 Necessità Riutilizzare codice già scritto
Moduli disgiunti che possono essere scritti anche da persone diverse che lavorino assieme e simili
2.2 Scope Parentesi per gli scope
Doppia dichiarazione è sbagliata
2.2.1 Globali 2.2.2 Locale 2.2.3 Procedural Abstraction 2.3 Dichiarazione e chiamata 2.</description>
    </item>
    <item>
      <title>Gruppi Normali</title>
      <link>https://flecart.github.io/notes/gruppi-normali/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gruppi-normali/</guid>
      <description>Ripasso: April 29, 2022 Ultima modifica: June 29, 2022 9:42 AM Primo Abbozzo: March 26, 2022 11:00 AM Studi Personali: No
Elementi di ripasso Gruppi normali e quoziente Introduzione Definizione normalità Test del sottogruppo normale Dimostrazione
Il gruppo quoziente L’importanza del gruppo normale è che quando esso vale, possiamo avere il gurppo fattore
Dimostrazione
!</description>
    </item>
    <item>
      <title>Introduzione Calcolo numerico</title>
      <link>https://flecart.github.io/notes/introduzione-calcolo-numerico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-calcolo-numerico/</guid>
      <description>Ultima modifica: October 12, 2022 4:39 PM Primo Abbozzo: September 21, 2022 4:15 PM Studi Personali: No
Elementi di ripasso Introduzione Il corso verte su questi in slide:
Percorso standard per risoluzione problema di calcolo numerico Risoluzione del problema nel continuo (quindi vedere se esiste una soluzione dal punto di vista matematico Utilizzo di un algoritmo di metodi numerici Accuratezza Costo computazionale Condizionamento → Errore inerenti Commenti negativi La conversione in binario e decimale già fatto in architettura non ripetere!</description>
    </item>
    <item>
      <title>Legge di Gauss</title>
      <link>https://flecart.github.io/notes/legge-di-gauss/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/legge-di-gauss/</guid>
      <description>Introduzione alla legge di gauss Giustificazione con angoli solidi 🟨&amp;ndash; Pagina 69 del Mazzoldi. Vogliamo chiederci quanto sia il flusso in qualunque superficie Da un punto di vista infinitesimo abbiamo che (perché il flusso è, intuitivamente, la parte perpendicolare rispetto la superficie che abbiamo) $$ d\Phi = \vec{E}\cdot \vec{dS} = \lvert \vec{E} \rvert \lvert \vec{dS} \rvert \cos \theta = \frac{1}{4\pi\varepsilon_{0}}\frac{1}{r^{2}} ds = \frac{Q}{4\pi\varepsilon}d\Omega $$ Il secondo passaggio è giustificabile andando su coordinate polari considerando l&amp;rsquo;angolo solido di un oggetto quindi non dovrebbe essere un problema.</description>
    </item>
    <item>
      <title>Leggi di Ohm</title>
      <link>https://flecart.github.io/notes/leggi-di-ohm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/leggi-di-ohm/</guid>
      <description>Gli argomenti della lezione 31 Ottobre sono circa da pagina 164 fino a 185 del mazzoldi.
Leggi di Ohm Introduzione microscopica 🟩 Sappiamo che $$ \vec{J} = -n e \vec{v}_{d} ne^{2} t \frac{\vec{E}}{m} $$ Vedi analisi della velocità di deriva col modello del 1900 in Corrente Elettrica.
Dove abbiamo utilizzato la definizione di densità di corrente e la velocità fra collisioni ed altre Questo è una motivazione per considerare la densità di corrente come se fosse nello stesso verso.</description>
    </item>
    <item>
      <title>TLS-SSL protocol</title>
      <link>https://flecart.github.io/notes/tls-ssl-protocol/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/tls-ssl-protocol/</guid>
      <description>First time we talked about this was in Sicurezza delle reti#Protocollo SSL
SSL Secure socket Layer
Principles Session It&amp;rsquo;s an association (probably something similar to SA in Sicurezza delle reti). That connects the client to the server. Defines the cryptographic parameters to allow the communication.
Stuff for session:
Session identifier: generated by the server to identify an active or resumable session. Peer certificate: X 509v3 certificate. Compression method: algorithm used to compress the data before encryption.</description>
    </item>
    <item>
      <title>Algebra modulare</title>
      <link>https://flecart.github.io/notes/algebra-modulare/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algebra-modulare/</guid>
      <description>Algebra modulare Assunzioni Andiamo ora ad assumere l&amp;rsquo;esistenza e correttezza di alcune cose di base. (in teoria si possono dimostrare da cose più di base, ma non ho tempo).
Teorema fondamentale dell&amp;rsquo;algebra Ogni numero intero si fattorizza in modo unico.
Algoritmo di Euclide La conseguenza più importante di questo teorema, dovuto ad Euclide è che se ho $a, b \in \mathbb{Z}$ allora esistono resto e dividendo fra i due. Ossia $\exists q, p : a\mid b = qk + p$ per qualche $k$ intero</description>
    </item>
    <item>
      <title>Classi OOP</title>
      <link>https://flecart.github.io/notes/classi-oop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/classi-oop/</guid>
      <description>Ripasso Prox: 9 Ripasso: May 5, 2023 Ultima modifica: July 10, 2023 8:41 PM Primo Abbozzo: May 15, 2023 9:17 AM Stato: 🌕🌕🌕🌗🌑 Studi Personali: No
Elementi di ripasso Classi e OOP Introduzione Per la definizione di classe andare a guardare Object orientation, però lo ripeto in questa occasione, è solamente un modello su cui andare a costruire degli oggetti.
Capisaldi (!!) (4) 🟩 Incapsulazione Astrazione Ereditarietà Dispatch dinamico Costruttori 🟩- Slide costruttori</description>
    </item>
    <item>
      <title>Classical Cyphers</title>
      <link>https://flecart.github.io/notes/classical-cyphers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/classical-cyphers/</guid>
      <description>Ripasso Prox: 21 Ultima modifica: November 29, 2022 10:56 AM Primo Abbozzo: November 1, 2022 7:59 AM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Introduzione a Crittografia al corso di crittografia di Christof Paar su Youtube, con aggiunte del corso Unibo.
Classifications and definitions Classification nowadays as many many applications like, and it’s a increasing important field
Cryptology (2) 🟩 La branca comunemente riferita come crittografia è divisa principalmente in due campi crittografia e cryptanalysis in cui una cerca di creare nuovi metodi per cifrare i messaggi, e l’altro prova ad attaccare questi messaggi ritrovando il messaggio originale.</description>
    </item>
    <item>
      <title>Equazioni non lineari</title>
      <link>https://flecart.github.io/notes/equazioni-non-lineari/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/equazioni-non-lineari/</guid>
      <description>Ripasso Prox: 25 Ripasso: December 24, 2022 Ultima modifica: January 2, 2023 3:24 PM Primo Abbozzo: October 27, 2022 11:31 AM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Risoluzione di equazioni non lineari.pdf
Per trovare i zeri di una funzione continua non lineare non esistono alcuni metodi diretti che ci portano subito a una soluzione. Per questo motivo andremo ad analizzare molteplici pasis iterativi per trovare i zeri di una funzione.
La discussione di convergenza di ordine p è stata già discussa qui Note introduttive convergenza e iterazione , per quanto riguarda i metodi iterativi per risolvere sistemi di equazioni lineari</description>
    </item>
    <item>
      <title>Spettrometri di massa</title>
      <link>https://flecart.github.io/notes/spettrometri-di-massa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/spettrometri-di-massa/</guid>
      <description>Particelle in campi magnetici Moto in campo magnetico uniforme 🟩 Se abbiamo una particella carica con velocità uniforme in campo magnetico uniforme, come abbiamo detto in precedenza, una forza centripeta, questo farà curvare la carica, una cosa interessante sarebbe provare a capire raggio di curvatura della nostra carica. Sotto in immagine abbiamo l&amp;rsquo;esempio di curvatura. $$ F = qvB= ma = \frac{mv^{2}}{r} \implies r = \frac{mv^{2}}{qvB} = \frac{mv}{qB} = \frac{p}{qB} $$ Dove $p$ è la quantità di moto, quantità che credo sia relazionata al lavoro ed inerzia, parte di fisica 1 che non ho studiato da più di due anni.</description>
    </item>
    <item>
      <title>Design patterns</title>
      <link>https://flecart.github.io/notes/design-patterns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/design-patterns/</guid>
      <description>Introduction to design patterns Introduzione personale 🟩 I design patterns sono simili a dei plug and play, ossia delle soluzioni che hanno funzionato bene in passato e che sono ora riutilizzati. Solitamente dovrebbe essere una abilità implicita, cioè un buon programmatore è in grado di fare senza pensarci, dovrebbe essere automatico. Infatti quando uno fa il design non lo fa esplitamente seguendo un certo modello, ma farlo solitamente risulta utile per guidare il processo.</description>
    </item>
    <item>
      <title>Divergenza e Circuitazione</title>
      <link>https://flecart.github.io/notes/divergenza-e-circuitazione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/divergenza-e-circuitazione/</guid>
      <description>Scalare Scalare e gradiente 🟩 Un campo scalare assegna a ogni punto dello spazio un valore reale, quindi è naturalmente rappresentabile tramite una funzione $$ \varphi(x, y, z) : \mathbb{R}^{3} \to \mathbb{R} $$ Un esempio abbastanza naturale è il gradiente del valore scalare che si indica con $$\vec{\nabla}\varphi = ( \frac{\delta\varphi}{\delta x}, \frac{\delta\varphi}{\delta y}, \frac{\delta\varphi}{\delta z}) = \frac{\delta\varphi}{\delta x} \hat{i} + \frac{\delta\varphi}{\delta y} \hat{j} + \frac{\delta\varphi}{\delta z} \hat{k}$$ Se consideriamo il gradiente da solo è un campo vettoriale (dice la direzione della derivata multidimensionale).</description>
    </item>
    <item>
      <title>Inferential Social Learning</title>
      <link>https://flecart.github.io/notes/inferential-social-learning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/inferential-social-learning/</guid>
      <description>This is a theory from developmental psychology. It concerns about how a child is learning from a teacher. I discovered this field with (Gweon et al. 2023). But it is quite difficult to know how this could be useful for machines (not enough technical details about how).
The main idea is that
Childrens need to infer about teacher&amp;rsquo;s mental states to learn (I don&amp;rsquo;t know if this is true, but personally I don&amp;rsquo;t think is always true, you can learn with just a book, inferring mental states is not a necessity) Teacher&amp;rsquo;s need to choose the best example.</description>
    </item>
    <item>
      <title>La macchina di Turing</title>
      <link>https://flecart.github.io/notes/la-macchina-di-turing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/la-macchina-di-turing/</guid>
      <description>Introduzione Note filosofiche (non impo) Bisogna in primo momento cercare di definire cosa è la computazione e cosa è un computer. Aristotele faceva la distinzione fra proprietà essenziali e accidentali. Quelle essenziali sono proprie dell&amp;rsquo;oggetto.
Una sedia può essere fatta di legno o di metallo, ma questa proprietà è accidentale, ovvero, essa rimane una sedia indipendentemente dal materiale di cui è fatta.
Solitamente in matematica si prova ad astrarre (vedi Astrazione sul controllo per nota generale sull&amp;rsquo;astrazione).</description>
    </item>
    <item>
      <title>Logica meta-linguistica</title>
      <link>https://flecart.github.io/notes/logica-meta-linguistica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/logica-meta-linguistica/</guid>
      <description>Ripasso Prox: 30 Ripasso: January 1, 2022 Ultima modifica: September 30, 2022 3:19 PM Primo Abbozzo: September 24, 2021 10:13 AM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso Dubbi vecchi Sulle premesse di antinomi e paradossi. Capire cantor per l&amp;rsquo;ultimo paradosso Se ti va approfondisci la prima teoria degli insiemi e la storia del dibattito matematico iniziale. Funzioni non totali 1 Paradossi Metalinguistici 1.1 Antinomie e Paradossi 1.1.1 Antinomia Definizione di antinomia è un ragionamento corretto da cui deriva una conclusione errata, probabilmente è l&amp;rsquo;insieme o campo in cui stiamo operando ad essere errato e bisogna cercare di ridefinirlo in modo più corretto, in quanto le premesse erano accettabili</description>
    </item>
    <item>
      <title>Measure Theory</title>
      <link>https://flecart.github.io/notes/measure-theory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/measure-theory/</guid>
      <description>Ultima modifica: September 18, 2022 9:43 AM Primo Abbozzo: September 16, 2022 9:52 AM Studi Personali: Yes
Elementi di ripasso Measure Theory Introduzione Requirements of the measure function Vorremmo cercare di estendere il concetto di misurabilità a gruppi molto più ampi di un singolo intervallo, vorrei creare una funzione che sia in grado di misurare degli insiemi. *su vedrà che sono impossibili).
Impossibilità di questi requirements (assurdo) Costruzione dell’insieme di interesse</description>
    </item>
    <item>
      <title>Object Detection</title>
      <link>https://flecart.github.io/notes/object-detection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/object-detection/</guid>
      <description>Ultima modifica: April 16, 2023 4:23 PM Primo Abbozzo: April 8, 2023 9:34 AM Studi Personali: No
Elementi di ripasso Object Detection Introduction Semantic segmentation Vorremo trovare regioni che corrispondano a categorie diverse. E dividere in questo modo l’immagine secondo zone di informazione.
Object detection Vogliamo trovare il più piccolo box che vada a contenere l’oggetto. Questo è fatto con il bounding box.
In questo caso la funzione di loss è un pò più difficile da definire, si utilizza la funzione intersection over union con le aree, in pratica la percentuale di immagine comune diciamo.</description>
    </item>
    <item>
      <title>Porte Logiche</title>
      <link>https://flecart.github.io/notes/porte-logiche/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/porte-logiche/</guid>
      <description>Ripasso Prox: 40 Ripasso: December 22, 2021 Ultima modifica: October 27, 2022 12:16 PM Primo Abbozzo: September 27, 2021 3:02 PM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso Exercise
As it is mentioned in the question that there are two motorcycle gang in the area and one of them always tells truth and the other always tell lies. The missionary also does not know which gang tells the truth and which do not.</description>
    </item>
    <item>
      <title>Problemi di accoppiamento</title>
      <link>https://flecart.github.io/notes/problemi-di-accoppiamento/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/problemi-di-accoppiamento/</guid>
      <description>Ripasso Prox: 12 Ripasso: January 4, 2023 Ultima modifica: December 30, 2022 12:31 PM Primo Abbozzo: November 23, 2022 4:26 PM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
Elementi di ripasso Problemi di accoppiamento Introduzione (defs) Grafo bipartito 🟩 Un grafo bipartito è un insieme $(O \cup D), (A)$ di nodi e di archi. Tutti i nodi sono o fra i nodi di origine oppure fra i nodi di destinazione, e gli archi sono solamente collegati fra nodi di origine e nodi di destinazione.</description>
    </item>
    <item>
      <title>Teoria assiomatica degli insiemi</title>
      <link>https://flecart.github.io/notes/teoria-assiomatica-degli-insiemi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/teoria-assiomatica-degli-insiemi/</guid>
      <description>Ripasso Prox: 60 Ripasso: January 5, 2022 Ultima modifica: September 30, 2022 3:19 PM Primo Abbozzo: September 29, 2021 9:42 AM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso Vecchi Dubbi Assioma di rimpiazzamento e regolarità, capirli meglio 2 Teoria degli insiemi 2.1 Elementi di base 2.1.1 Definizione e caratteristiche Tutto è un insieme (su questo si basa la maggior parte della matematica) Efficace nella descrizione degli oggetti (infiniti è ez), ma non è efficiente nel calcolo in quanto non dà nessun indizio sul&amp;rsquo;implementazione in memoria o sul modo per calcolarlo, c&amp;rsquo;è solo una associazione Si può concludere che per l&amp;rsquo;informatico non serve a molto questa teoria, ma è la base per la matematica.</description>
    </item>
    <item>
      <title>Circuiti Sequenziali</title>
      <link>https://flecart.github.io/notes/circuiti-sequenziali/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/circuiti-sequenziali/</guid>
      <description>Ripasso Prox: 45 Ripasso: December 22, 2021 Ultima modifica: October 27, 2022 12:17 PM Primo Abbozzo: October 15, 2021 12:53 PM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso la caratteristica che contraddistingue DFF e Latch D Se hai voglia approfondisci la costruzione di una memoria (reale) December 14, 2021 3:43 PM 7 Circuiti sequenziali 7.1 Introduzione 7.1.1 Perché usarli Sono utili per mantenere delle informazioni nel tempo
7.1.2 Caratteristiche Hanno feedback cioè ci sono degli output che tornano dentro al circuito, quindi è molto difficile senza sapere niente cosa succede dentro</description>
    </item>
    <item>
      <title>Scrum Method</title>
      <link>https://flecart.github.io/notes/scrum-method/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/scrum-method/</guid>
      <description>Introduzione (idea principale) In breve: essence card 🟩- Giallo = Prodotto. Metafora staffetta-rugby 🟩 Con altri metodi si fanno produzioni stile staffetta, ossia un membro sta fermo, finché non ha il testimone e poi si uccide correndo&amp;hellip; Il metodo più utile ispirato a scrum è rugby, che tutti si muovo insieme collaborando. Un po&amp;rsquo; di tutto è fatto durante lo sprint
Cicli di base (3) 🟩 Planning: in cui vengono scelti i task da eseguire durante questo sprint, solitamente questo viene preso da un subset dei task descritti dal product owner.</description>
    </item>
    <item>
      <title>Secury Principles and Tor</title>
      <link>https://flecart.github.io/notes/secury-principles-and-tor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/secury-principles-and-tor/</guid>
      <description>Security principles We have already outlined these principles in Sicurezza delle reti and talked about the concepts of authentication and integrity. Here we try to deepen these concepts and delve a little bit more on the attack vectors These are acronyms, usually called CIA and AAA for infrastructure
Confidentiality This is one concerns about the secrecy of the sent message. We do not want others to be able to access and read what we are doing.</description>
    </item>
    <item>
      <title>Analisi multi-variabile</title>
      <link>https://flecart.github.io/notes/analisi-multi-variabile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/analisi-multi-variabile/</guid>
      <description>Ripasso Prox: 20 Ripasso: June 4, 2022 Ultima modifica: 11 Marzo, 2024 12:08 PM Primo Abbozzo: March 7, 2022 1:34 PM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Analisi multi-variabile In questo capitolo cerchiamo di andare oltre alla singola dimensione per l&amp;rsquo;analisi.
Introduzione
Lo spazio R^n Possiamo definire uno spazio Rn come il prodotto cartesiano fra l&amp;rsquo;insieme R un numero di volte uguale a n $\mathbb{R} \times \mathbb{R} \times &amp;hellip; \times\mathbb{R} = \mathbb{R}^n$</description>
    </item>
    <item>
      <title>Cicli iterativi</title>
      <link>https://flecart.github.io/notes/cicli-iterativi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cicli-iterativi/</guid>
      <description>Ripasso Prox: 30 Ripasso: December 19, 2021 Ultima modifica: December 14, 2021 3:43 PM Primo Abbozzo: October 5, 2021 11:42 AM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso 2 Iteratori 2.1 While 2.1.1 Guardia 2.1.1 Corpo del ciclo 2.1.3 Variabile di controllo 2.2 While, for, do bruh i Personali: No
Elementi di ripasso 2 Iteratori 2.1 While 2.1.1 Guardia 2.1.1 Corpo del ciclo 2.1.3 Variabile di controllo 2.2 While, for, do bruh</description>
    </item>
    <item>
      <title>Clustering Algorithms</title>
      <link>https://flecart.github.io/notes/clustering-algorithms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/clustering-algorithms/</guid>
      <description>K-Means Neural Gas Esempi in azione: https://www.youtube.com/embed/XtC1M7nrDk0</description>
    </item>
    <item>
      <title>Fisica del Wireless</title>
      <link>https://flecart.github.io/notes/fisica-del-wireless/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/fisica-del-wireless/</guid>
      <description>Ripasso Prox: 18 Ripasso: May 17, 2023 Ultima modifica: May 5, 2023 5:39 PM Primo Abbozzo: March 24, 2023 10:16 AM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso Reti wireless Introduzione Radio 🟩 Slide radio
Antenna: converte corrente in segnali radiorequenza e viceversa. le segnali radiofrequenza sono onde radio con frequenza diversa per rappresentare 1 o 0. Un altro modo per mandare 1 o 0 sarebbe semplicemente cambiare l’intensità della onda, mantenendo la stessa frequenza.</description>
    </item>
    <item>
      <title>General SWE principles</title>
      <link>https://flecart.github.io/notes/general-swe-principles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/general-swe-principles/</guid>
      <description>This small note sections tries to fix 5 important concepts in software engineering
Sub-system and modules 🟩 We need to differentiate from sub-system, which is a part of a system that tries to achieve some objective, and a module, which is more language specific way of saying imported file, or set of functions or classes.
Information hiding 🟩 This is a very important principle present in object oriented programming. Within this philosophy we should be able to access only public methods or data, this allows the construction of abstractions that allow us to think at a higher level.</description>
    </item>
    <item>
      <title>Introduzione SO</title>
      <link>https://flecart.github.io/notes/introduzione-so/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-so/</guid>
      <description>Ripasso Prox: 40 Ultima modifica: April 9, 2023 9:36 AM Primo Abbozzo: September 21, 2022 11:15 AM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso Introduzione a SO Intro Scopi del sistema operativo 🟩 Un sistema operativo è una astrazione sul HW che permette di
Gestire l’esecuzione di più programmi assieme (concorrenza), tramite virtualizzazione CPU e Memoria Gestire le risorse (Quindi I/O, RAM, Memoria, Networking) Fornisce una interfaccia di programmazione (API) molto più generale e potente, in grado di astrarre da dettagli di livello basso, vicini all’Hardware (come device drivers).</description>
    </item>
    <item>
      <title>Monte carlo integration</title>
      <link>https://flecart.github.io/notes/monte-carlo-integration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/monte-carlo-integration/</guid>
      <description>DI Law of Large Numbers e Central limit theorem ne parliamo in Central Limit Theorem and Law of Large Numbers.
Law of large numbers Data una sequenza di variabili aleatorie, $X_{1}, X_{2}, \dots, X_{n}\dots$, tali che siano i.i.d tali per cui $E(X_{1}) = E(X_{2}) = \dots = E(X_{n}) =\dots = \mu$ tale che sia finito. Consideriamo $$ S_{n} = \sum^n_{i=1} x_{i} ,:, \bar{x}_{n} = \frac{S_{n}}{n} $$ Allora questo teorema afferma che: $$ \bar{x}_{n} \to \mu $$ Ossia il limite converge sul valore atteso di tutte le variabili aleatorie.</description>
    </item>
    <item>
      <title>Sezioni Critiche</title>
      <link>https://flecart.github.io/notes/sezioni-critiche/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/sezioni-critiche/</guid>
      <description>Ripasso Prox: 80 Ripasso: May 21, 2023 Ultima modifica: March 12, 2023 10:00 AM Primo Abbozzo: October 8, 2022 11:30 AM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
Elementi di ripasso 2 Sezioni Critiche Introduzione La parte di un programma che utilizza una o più risorse condivise viene detta sezione critica (critical section, o CS)
Andiamo in questa altra parte a valutare certe soluzioni:
Programma d’esempio 🟩 Vorremmo garantire che a = b invariante.</description>
    </item>
    <item>
      <title>Automi e Regexp</title>
      <link>https://flecart.github.io/notes/automi-e-regexp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/automi-e-regexp/</guid>
      <description>Ripasso Prox: 70 Ripasso: June 7, 2023 Ultima modifica: June 4, 2023 4:06 PM Primo Abbozzo: October 14, 2022 2:19 PM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso Domande
Automi e Regexp Per l’analisi lessicale vogliamo cercare di ricordare le parole legali all&amp;rsquo;interno di questo linguaggio e questo è fatto con i linguaggi regolari.
Introduzione a analizzatori lessicali Token 🟩 Struttura del token è fatto da due parti
Identificatore della classe del token Identificatore del valore del token Pattern e lessema ci sono direi boh Pattern e Lessema 🟩 I pattern sono una descrizione generale della forma dei valori di una classe di token.</description>
    </item>
    <item>
      <title>Basi</title>
      <link>https://flecart.github.io/notes/basi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/basi/</guid>
      <description>Ripasso Prox: 60 Ripasso: December 19, 2021 Ultima modifica: December 14, 2021 3:43 PM Primo Abbozzo: October 3, 2021 10:19 AM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso 1 Variabili ed espressioni 1.1 Identificatori e dichiarazioni 1.1.1 Il nome simbolico/simbolico e fisico Nome simbolico: nome leggibile da esseri umani diverso dal nome numerico con cui se lo ricorda il computer
💡 Fai attenzione alle possibili variabili per il nome simbolico!</description>
    </item>
    <item>
      <title>Relational Algebra</title>
      <link>https://flecart.github.io/notes/relational-algebra/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/relational-algebra/</guid>
      <description>Introduzione all&amp;rsquo;algebra relazionale Confronto con relazioni matematiche Le relazioni come le intendiamo in database sono leggermente diverse rispetto a quelle presenti per le relazioni matematiche:
Non conta l&amp;rsquo;ordine Ci sono gli attributi Per il resto se introduciamo questo sistema per tenere conto delle astrazioni, possiamo analizzarle matematicamente, e questo ci fornisce qualche sicurezza in più diciamo.
Definition of tuples 🟩 Le relazioni sono esattamente quelle definite in matematica, però noi aggiungiamo anche gli attributi, in modo da poter considerare l&amp;rsquo;ordine delle colonne non importante.</description>
    </item>
    <item>
      <title>Algoritmi per il progetto</title>
      <link>https://flecart.github.io/notes/algoritmi-per-il-progetto/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algoritmi-per-il-progetto/</guid>
      <description>Ultima modifica: September 10, 2022 12:24 PM Primo Abbozzo: August 8, 2022 12:52 PM Studi Personali: No
Euristiche, capitolo 3.6 del libro intelligenza artificiale Database degli algoritmi Algoritmi da provare
Algoritmi da provare
Cose da guardare Null move In chess sembra che una null move heuristics (in pratica fai fare 2 mosse all&amp;rsquo;avversario) sia utile per stabilire il valore di una posizione, si potrebbe fare qualcosa di simile?
Libri Norvigs</description>
    </item>
    <item>
      <title>Central Limit Theorem and Law of Large Numbers</title>
      <link>https://flecart.github.io/notes/central-limit-theorem-and-law-of-large-numbers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/central-limit-theorem-and-law-of-large-numbers/</guid>
      <description>Bounds Markov Bound Questo bound è abbastanza banale se fatto da un punto di vista grafico, comunque afferma che $$ P(X \geq y) \leq \frac{E[X]}{y} $$ Il motivo è che $$ yP(X \geq y) = y\int _{x =y}^{+\infty} f(x) \, dx \leq \int _{x=y}^{+\infty} x f(x) \, d \leq \int _{-\infty}^{+\infty}xf(x) \, d = E[X] $$ Il che finisce la dimostrazione.
Chebychev Bound Questa è una conseguenza abbastanza diretta sul bound precedente: Afferma che $$ P(\mid x - E[X] \mid \geq y) \leq \frac{\sigma^{2}}{y^{2}} $$ E in pratica dice che all&amp;rsquo;infinito viene tutto compattata sul valore atteso La dimostrazione è abbastanza semplice, si sostituisce $(x - E[X])^{2}$ su $X$ di Markov e $\varepsilon^{2}$ a $y$ e poi si dovrebbe già avere il risultato</description>
    </item>
    <item>
      <title>Convolutional NN</title>
      <link>https://flecart.github.io/notes/convolutional-nn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/convolutional-nn/</guid>
      <description>Ultima modifica: May 6, 2023 5:55 PM Primo Abbozzo: March 18, 2023 9:48 PM Stato: 🌕🌕🌑🌑🌑 Studi Personali: No
Elementi di ripasso Convolutional NN Introduction The convolution operator 🟩- Il prodotto di convoluzione è matematicamente molto contorto, anche se nella pratica è una cosa molto molto semplice. In pratica voglio calcolare il valore di un pixel in funzione di certi suoi vicini, moltiplicati per un filter che in pratica è una matrice di pesi, che definisce un pattern lineare a cui sarei interessato di cercare nell’immagine.</description>
    </item>
    <item>
      <title>Design del database</title>
      <link>https://flecart.github.io/notes/design-del-database/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/design-del-database/</guid>
      <description>Processo design del database Il design Some design steps (3) (non impo) How to gather requirements? 🟨+ Come si può raccogliere i dati degli utilizzatori?
parlare col il personale che dovrà utilizzare questi sistemi Documentazione esistente Interview di persone che dovrà utilizzare queste risorse O Moduli per fare sampling Top-down approach La cosa brutta è che questi requisiti non possono essere standardizzati, ci sono molte necessità, molto diverse fra i loro, quindi è utile andare a parlare con gli esperti e capire cosa abbiano bisogno per i dati.</description>
    </item>
    <item>
      <title>Dipolo elettrico</title>
      <link>https://flecart.github.io/notes/dipolo-elettrico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/dipolo-elettrico/</guid>
      <description>Questo problema è stato trattato in modo un po&amp;rsquo; più semplificato (nel caso in cui la carica era esattamente a metà in Campo elettrico#Dipolo elettrico). Questo problema è stato storico, utilizzato per analizzare l&amp;rsquo;atomo.
Potenziale del dipolo elettrico 🟩&amp;ndash; Per il principio di sovrapposizione possiamo affermare che $$ V(P) = V_{r^{+}} + V_{r^{-}} = \frac{q}{4\pi\varepsilon_{0}}\left( \frac{1}{r^{+}} - \frac{1}{r^{-}} \right) $$ Ora possiamo fare certe approssimazioni, supponendo che $r \gg a$ con $r$ la congiungente fra il centro del dipolo e il nostro punto e $a$ la distanza fra le cariche, possiamo affermare che $$ r^{+} - r^{-} = -a \cos \theta $$ Sappiamo che l&amp;rsquo;angolo è lo stesso (più o meno), perché sappiamo che i due reggi sono ora paralleli (come assunsione di semplificazione) Inoltre abbiamo che $r^{+}r^{-} = r^{2}$ perché il punto è molto lontano allora possiamo affermare che $$ \left( \frac{1}{r^{+}} - \frac{1}{r^{-}} \right) = \frac{a\cos \theta}{r^{2}} $$ a $$ V(P) = \frac{1}{4\pi\varepsilon_{0}}\frac{qa\cos \theta}{r^{2}} = \frac{1}{4\pi\varepsilon_{0}}\frac{P\cos \theta}{r^{2}} = \frac{1}{4\pi\varepsilon_{0}} \frac{\vec{P}\cdot \hat{r}}{r^{2}} $$ Direttamente proporzionale al momento di tipolo Inversamente proporzionale al quadrato del raggio.</description>
    </item>
    <item>
      <title>Minimi quadrati</title>
      <link>https://flecart.github.io/notes/minimi-quadrati/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/minimi-quadrati/</guid>
      <description>Ripasso Prox: 20 Ripasso: February 9, 2023 Ultima modifica: January 2, 2023 10:14 AM Primo Abbozzo: October 19, 2022 4:17 PM Stato: 🌕🌕🌕🌑🌑 Studi Personali: No
Elementi di ripasso Minimi Quadrati Note matematiche introduttive Vettori ortonormali 🟩 Due vettori si dicono ortonormali se $vv^T = ||v|| = 1$ e sono ortogonali, ossia $v_i v^T_j = 0$ con i e j diversi fra di loro
Matrici ortogonale (4) 🟩- Matrici si dicono ortonomali se le sue colonne sono vettori sono ortonormali</description>
    </item>
    <item>
      <title>Block Ciphers</title>
      <link>https://flecart.github.io/notes/block-ciphers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/block-ciphers/</guid>
      <description>Utilizzano blocchi per cifra invece che stream generators.
DES 56 bit 3DES 56*3 bit di chiave AES che può andare a 128, 196 o 256 Solitamente i stream ciphers studiati in OTP and Stream Ciphers sono più veloci. Data Encryption Standard 1974 da IBM su commissione di NSA in quel periodo era solamente fatta dalla intelligence, non c’era bisogno di comunicazioni per il pubblico in quel periodo.
1977 - 1998 questo era lo standard per gli stati uniti.</description>
    </item>
    <item>
      <title>Modulazione wireless</title>
      <link>https://flecart.github.io/notes/modulazione-wireless/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/modulazione-wireless/</guid>
      <description>Ripasso Prox: 7 Ripasso: May 28, 2023 Ultima modifica: May 19, 2023 1:57 PM Primo Abbozzo: April 19, 2023 1:43 PM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso Modulazione del segnale Introduzione Digital modulation 🟨 Slide introduzione
Modulazione digitale: prendiamo un dato digitale e trasmesso con un segnale analogico, come le RF.
ASK: amplitude shift keying
FSK: frequency shift
PSK: phase shift
Questi sono i tre metodi principali, che dipendono dalle caratteristiche dell’onda descritte in Fisica del Wireless.</description>
    </item>
    <item>
      <title>Filesystem</title>
      <link>https://flecart.github.io/notes/filesystem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/filesystem/</guid>
      <description>Ripasso Prox: 12 Ripasso: May 19, 2023 Ultima modifica: May 11, 2023 9:12 PM Primo Abbozzo: April 11, 2023 6:54 PM Stato: 🌕🌕🌕🌗🌑 Studi Personali: No
Elementi di ripasso Filesystem Introduzione Perché filesystem? 🟨++ Questa è l&amp;rsquo;idea presa dall&amp;rsquo;archivio, come se fosse un ufficio che deve tenere delle pratiche ordinate in cartelle e cartelloni.
L’utilizzo principale è dare un interfaccia comune di accesso ai dispotitivi. perché dispositivi diversi hanno sotto modi di accedere diversi, questa interfaccia facilizza molto l&amp;rsquo;accesso.</description>
    </item>
    <item>
      <title>Function approximation</title>
      <link>https://flecart.github.io/notes/function-approximation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/function-approximation/</guid>
      <description>We have enormous state functions, having a generic approssimation could really help! We want to use a differentiable value function so that we can use gradient descent to optimize it, for example a good way of loss would be $$ J(w) = \mathbb{E}_\pi[(V^\pi(s) - \hat{V}^\pi(s;w))^2] $$ The second one is parametrized with $w$. There are two ways (recuperali!) MC policy or Time differential (that is boostrapped, instead the Monte carlo uses a full simulation in order to know what to use).</description>
    </item>
    <item>
      <title>Livello di Rete</title>
      <link>https://flecart.github.io/notes/livello-di-rete/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/livello-di-rete/</guid>
      <description>Ripasso Prox: 50 Ripasso: June 14, 2023 Ultima modifica: May 13, 2023 11:59 PM Primo Abbozzo: October 12, 2022 9:50 AM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Reti di Reti Le parti importanti per questo sono Data Plane e Control Plane (che ha saltato quasi tutto, ma almeno dijkstra lo dovresti fare bene)
Introduzione (puoi skippare 🟩) La puoi skipppare perché tratta in modo molto generare parti che saranno trattati in modo più approfondito in seguito.</description>
    </item>
    <item>
      <title>Replication and consistency</title>
      <link>https://flecart.github.io/notes/replication-and-consistency/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/replication-and-consistency/</guid>
      <description>Ultima modifica: January 5, 2023 9:59 AM Primo Abbozzo: January 4, 2023 10:02 AM Studi Personali: No
Replication and consistency Introduzione Ci sono due vantaggi principali nella replicazione dei dati
Velocità Vicinanza geografica (quindi meno tempo ad andare a tornare) Maggiore computazione, quindi avere molti più processori che cercano di offrire lo stesso servizio. Affidabilità Così se una sede diventa corrotta, posso avere abbondanza, avere una copia da una altra parte, così non perdo le informazioni!</description>
    </item>
    <item>
      <title>Tokenization</title>
      <link>https://flecart.github.io/notes/tokenization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/tokenization/</guid>
      <description>Introduction to tokenization Tokenization is the process of converting normal strings into small little pieces that could be fed into one of our models. It usually comes from a tradition in programming languages, as we can see in Automi e Regexp where we define a specific token to have a known pattern, usually recognized by regular expressions.
There have been historically been many approaches to tokenization, let&amp;rsquo;s see a few:</description>
    </item>
    <item>
      <title>Algorithmic Probability</title>
      <link>https://flecart.github.io/notes/algorithmic-probability/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algorithmic-probability/</guid>
      <description>&amp;ldquo;Information theory must precede probability theory, and not be based on it. By the very essence of this discipline, the foundations of information theory have a finite combinatorial character.&amp;rdquo; Kolmogorov, A. N. (1983). Combinatorial foundations of information theory and the calculus of probabilities.
Russian mathematical surveys, 38 (4), 29-40.
&amp;ldquo;it is clear that elements requiring an extremely large number of words for their definition should be considered as having an extremely low probability.</description>
    </item>
    <item>
      <title>Ambienti di sviluppo</title>
      <link>https://flecart.github.io/notes/ambienti-di-sviluppo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/ambienti-di-sviluppo/</guid>
      <description>Ultima modifica: March 24, 2023 7:35 PM Primo Abbozzo: March 24, 2023 2:23 PM Studi Personali: No
Ambienti di sviluppo Ambiente di sviluppo è diverso rispetto all’ambiente di deploy! bisognare fare delle differenze, sono dell macchine diverse, in questa sezione di documenti andiamo a parlare di norme e modi di lavorare per facilitare il metodo di sviluppo.
Note di compatibilità Front-end Le compatibilità, soprattutto per cose browser (quindi front-end) cambiano molto spesso, come fare a trackare queste cose?</description>
    </item>
    <item>
      <title>Architettura e livelli 1, 2</title>
      <link>https://flecart.github.io/notes/architettura-e-livelli-1-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/architettura-e-livelli-1-2/</guid>
      <description>Ripasso Prox: 140 Ripasso: June 1, 2023 Ultima modifica: March 15, 2023 3:01 PM Primo Abbozzo: October 14, 2022 5:49 PM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso 1 Architettura e primi due livelli 0.4 Architettura di rete 0.4.1 Perché a stack 🟩- Capire l’architettura significa capire la struttura (l’organizzazione) del nostro app e comprenderne i motivi (i sottoproblemi risolti) che ogni livello prova a risolvere
La soluzione che è stata individuata, e ha rappresentato uno dei principali cardini del successo delle reti e della nascita di Internet, è data dalla separazione delle classi di protocolli in livelli.</description>
    </item>
    <item>
      <title>Bayesian Networks</title>
      <link>https://flecart.github.io/notes/bayesian-networks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bayesian-networks/</guid>
      <description>Ripasso Prox: 3 Ultima modifica: December 29, 2022 3:24 PM Primo Abbozzo: August 20, 2022 1:31 PM Stato: 🌕🌕🌑🌑🌑 Studi Personali: No
Elementi di ripasso Networks Bayesiani Questi network bayesiani sono proprio dei grafi, che permettono una migliore comprensione delle relazioni causali o diagnostici fra le probabilità
Esempio rete bayesiana
Note generali Introduzione alla rete classica Una rete bayesiana ci permette di semplificare di molto il calcolo della full disjoint probability table, rendendola in questo modo</description>
    </item>
    <item>
      <title>Javascript</title>
      <link>https://flecart.github.io/notes/javascript/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/javascript/</guid>
      <description>Ripasso: May 14, 2023 Ultima modifica: May 6, 2023 6:25 PM Primo Abbozzo: March 20, 2023 3:16 PM Studi Personali: No
Elementi di ripasso Javascript Obiettivo principale è esegurie codice clientside
Un pò di storia nato all’inizio della prima guerra dei browser (da netscape, explorer è in visual basic comunque non compatibile con JS) come il fratellino di java nel senso che runnava ovunque, attualmente è ECMAScript, ed è la versione migliore.</description>
    </item>
    <item>
      <title>Normalizzazione dei database</title>
      <link>https://flecart.github.io/notes/normalizzazione-dei-database/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/normalizzazione-dei-database/</guid>
      <description>Introduzione alla normalizzazione Perché si normalizza? 🟩 Cercare di aumentare la qualità del nostro database, perché praticamente andiamo a risolvere delle anomalie possibili al nostro interno, e questo aiuta per la qualità.
Tipologie di anomalie (!) (4) 🟨+ Ridondanze, non vorrei avere la stessa informazione espressa più volte in troppi punti. Update non consistente, quando per aggiornare un singolo valore devo aggiornare moltissime altre tuple dipendenti da essa. Deletion non consistente, la presenza di certe entità è strettamente dipendente da presenza di altri, nell&amp;rsquo;esempio in questione sulle slides, se elimino tutti gli utenti, elimino anche i progetti su cui hanno partecipato, mentre invece dovrebbero essere separati.</description>
    </item>
    <item>
      <title>R e Intervalli</title>
      <link>https://flecart.github.io/notes/r-e-intervalli/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/r-e-intervalli/</guid>
      <description>Ripasso Prox: 50.31 Ripasso: May 18, 2022 Ultima modifica: October 8, 2022 12:09 PM Primo Abbozzo: October 11, 2021 6:08 PM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
Elementi di ripasso dimostrazione esistenza e unicità della radice, qui un pò di difficoltà (ti sei totalmente dimenticato del vincolo di voler avere cose maggiore di 0) Ho messo .31 ho fatto 50 l&amp;rsquo;ultima volta anche però l&amp;rsquo;esame è vicino e non avrebbe molto senso rifare dopo&amp;hellip; 2 R e Intervalli 2.</description>
    </item>
    <item>
      <title>Calcolo differenziale</title>
      <link>https://flecart.github.io/notes/calcolo-differenziale/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/calcolo-differenziale/</guid>
      <description>Ripasso Prox: 24 Ripasso: June 2, 2022 Ultima modifica: October 8, 2022 12:08 PM Primo Abbozzo: March 14, 2022 2:11 PM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
Elementi di ripasso DImostrare per benino la condizione sufficiente di differenziabilità perché probabile che alcuni passaggi non li fai per filo e per segno. 10 Calcolo differenziale 10.1 Derivata parziale La derivata vuole descrivere quanto varia una funzione al variare dell&amp;rsquo;input. Ma ora siamo in più dimensioni, quindi vogliamo descrivere il variare dell&amp;rsquo;input come il variare della distanza euclidea</description>
    </item>
    <item>
      <title>Conduttori elettrici</title>
      <link>https://flecart.github.io/notes/conduttori-elettrici/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/conduttori-elettrici/</guid>
      <description>Campo elettrico nei materiali Se prendiamo un conduttore, gli elettroni in questi materiali sono liberi, significa che sono liberi di muoversi come vogliono, si può dire che &amp;ldquo;vadano in giro&amp;rdquo; (per esempio questo vale per il rame).
il reticolo cristallino è al struttura regolare che è comune nei materiali, in cui gli atomi sono sempre a distanza costante (o comunque a pattern regolari) uno dall&amp;rsquo;altro $r$ per esempio.
Campo e materiali (6) Schermatura del campo (!</description>
    </item>
    <item>
      <title>Derivate</title>
      <link>https://flecart.github.io/notes/derivate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/derivate/</guid>
      <description>Ripasso Prox: 75 Ripasso: June 16, 2022 Ultima modifica: October 8, 2022 12:08 PM Primo Abbozzo: November 4, 2021 3:59 PM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso Vecchi dubbi Invertibilità e derivata dell&amp;rsquo;inversa Fare esercizi e provare derivate particolari. Dimostrazione della formula di mul e div per derivate 5 Derivate 5.1 Geometria introduttiva 5.1.1 Tangente e pendenza Si può trovare la relazione fra la pendenza della retta e la tangente.</description>
    </item>
    <item>
      <title>Grafi</title>
      <link>https://flecart.github.io/notes/grafi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/grafi/</guid>
      <description>Ripasso Prox: 3 Ripasso: May 20, 2022 Ultima modifica: May 19, 2022 12:48 PM Primo Abbozzo: May 3, 2022 11:31 AM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Rappresentazione e terminologia Operazioni importanti
Definizione di grafo È un insieme di nodi e di archi. (prendili da insiemi corretti)
Metodi di rappresentazione Liste di incidenza (In pratica numero tutti gli archi e storo il valore dell&amp;rsquo;arco incidente per ogni nodo)
Liste di adiacenza Classico usato per cp, si storano direttamente pointer a nodi di interesse</description>
    </item>
    <item>
      <title>Mac Wifi</title>
      <link>https://flecart.github.io/notes/mac-wifi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/mac-wifi/</guid>
      <description>Ripasso Prox: 5 Ripasso: May 17, 2023 Ultima modifica: May 12, 2023 12:21 PM Primo Abbozzo: May 3, 2023 1:48 PM Stato: 🌕🌕🌕🌑🌑 Studi Personali: No
Elementi di ripasso Mac Wifi Introduzione Ricordiamo che vogliamo cercare di arbitrare l’accesso al canale fisico sottostante. In questo momento andiamo ad assumere di avere già tutto l’impianto di trasmissione fisica che abbiamo in Tecnologia Wireless, Modulazione wireless Fisica del Wireless.
Obiettivi: 🟨— Arbitraggio del singolo canale fisico (la tesi di dottorato del prof era su collision avoidance di wifi).</description>
    </item>
    <item>
      <title>Tabelle di hash</title>
      <link>https://flecart.github.io/notes/tabelle-di-hash/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/tabelle-di-hash/</guid>
      <description>Ripasso Prox: 20 Ripasso: May 19, 2022 Ultima modifica: April 30, 2022 10:54 AM Primo Abbozzo: March 22, 2022 11:41 AM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
5 Tabelle di Hash 5.1 Introduzione 5.1.1 Prototipo Vogliamo implementare le operazioni del prototipo dizionario presentato in Strutture di dati elementari, e vogliamo fare solo queste 3 ma molto bene.
Insert O(1) Delete O(1) Search in O(1) La struttura dati di hash riesce a fare bene queste singole operazioni</description>
    </item>
    <item>
      <title>Tarjan e MCMF</title>
      <link>https://flecart.github.io/notes/tarjan-e-mcmf/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/tarjan-e-mcmf/</guid>
      <description>Ripasso Prox: 12 Ripasso: January 5, 2023 Ultima modifica: December 27, 2022 4:55 PM Primo Abbozzo: November 14, 2022 9:19 AM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
Elementi di ripasso Algo di grafi Questa sezione la tengo separata rispetto agli altri per favorire lo studio, così questa roba nuova la ripasso più spesso, in seguito si può accorpare.
Goldberg Tarjan/Push-relabel Questo algoritmo è importante perché introduce ragionamenti sul minimo locale che possa alla fine essere ricomposto come soluzione globale.</description>
    </item>
    <item>
      <title>Teorema di Lagrange</title>
      <link>https://flecart.github.io/notes/teorema-di-lagrange/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/teorema-di-lagrange/</guid>
      <description>Ripasso Prox: 2 Ripasso: April 30, 2022 Ultima modifica: June 29, 2022 9:42 AM Primo Abbozzo: March 23, 2022 10:33 AM Stato: 🌕🌕🌑🌑🌑 Studi Personali: No
Classi laterali Dimostrazione dei lemmi sopra. La cosa interessante di questa parte è possiamo usare una classe laterale per partizionare il gruppo iniziale!
Il teorema di Lagrange Dividere significa che **partiziona** l&#39;insieme iniziale in alcuni insiemi distinti. L&#39;insieme $G:H$ è l&#39;insieme che contiene tutti i cosets, credo.</description>
    </item>
    <item>
      <title>The RLHF pipeline</title>
      <link>https://flecart.github.io/notes/the-rlhf-pipeline/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/the-rlhf-pipeline/</guid>
      <description>https://huyenchip.com/2023/05/02/rlhf.html è un blog post che lo descrive in modo abbastanza dettagliato e buono.
Introduzione a RLHF Questo è il processo che è quasi la migliore per la produzione di LLM moderni (maggior parte si basano su questo per dire).
Struttura generale Si può dire che RLHF si divida in 3 parti fondamentali
Completion il modello viene allenato a completare parole dal web,solitamente è molto inutile Fine tuning per le singole task, per esempio riassumere, rispondere in certo modo etc.</description>
    </item>
    <item>
      <title>Vettore potenziale</title>
      <link>https://flecart.github.io/notes/vettore-potenziale/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/vettore-potenziale/</guid>
      <description>Introduzione al vettore potenziale Definizione vettore potenziale 🟩 Possiamo sempre scrivere il campo $\vec{B}$ come $$ \vec{B} = \vec{\nabla} \times \vec{A} $$ Con un campo vettoriale a caso $\vec{A}$, vedremo che questo campo avrà qualche utilità per fare i calcoli.
Possiamo notare che soddisfa la proprietà dell campo solenoidale citato in Magnetismo, infatti
$$ \vec{\nabla} \cdot \vec{B} = \vec{\nabla} \cdot (\vec{\nabla} \times \vec{A}) = 0 $$ Perché sappiamo che la divergenza del rotore (questo operatore dico) è sempre nullo per ragioni di Cauchy, se ne parla in Divergenza e Circuitazione.</description>
    </item>
    <item>
      <title>Algebra astratta</title>
      <link>https://flecart.github.io/notes/algebra-astratta/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algebra-astratta/</guid>
      <description>Ultima modifica: October 19, 2022 5:05 PM Primo Abbozzo: February 2, 2022 4:31 PM Studi Personali: No
Cerco di riassumere i concetti principali nei video di Benedict Gross presenti sul web (in particolare youtube)
Argomento Spazi vettoriali Th: generatori di spazi - linearmente indipendenti Dati due insiemi di vettori S e L, con S che spanna nello spazio V e L di vettori in V che siano tutte linearmente indimendenti, allora $|S| \geq |L|$</description>
    </item>
    <item>
      <title>Autoencoders</title>
      <link>https://flecart.github.io/notes/autoencoders/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/autoencoders/</guid>
      <description>In questa serie di appunti proviamo a descrivere tutto quello che sappiamo al meglio riguardanti gli autoencoders Blog di riferimento Blog secondario che sembra buono
Introduzione agli autoencoders L&amp;rsquo;idea degli autoencoders è rappresentare la stessa cosa attraverso uno spazio minore, in un certo senso è la compressione con loss. Per cosa intendiamo qualunque tipologia di dato, che può spaziare fra immagini, video, testi, musica e simili. Qualunque cosa che noi possiamo rappresentare in modo digitale possiamo costruirci un autoencoder.</description>
    </item>
    <item>
      <title>Autovettori e determinanti</title>
      <link>https://flecart.github.io/notes/autovettori-e-determinanti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/autovettori-e-determinanti/</guid>
      <description>Ultima modifica: January 4, 2023 9:56 AM Primo Abbozzo: December 26, 2021 11:42 AM Studi Personali: No
Elementi di ripasso 2 Autovalori e Determinanti Determinanti I determinanti sono un numero associato alle matrici quadrate. Più o meno ne sono il riassunto.
Proprietà Le prime 3 sono quelle fondamentali per calcolare il tutto, i numeri dopo il 3 sono alcune conseguenze.
det I = 1
Cambiare righe → cambiare il segno della determinante.</description>
    </item>
    <item>
      <title>L’ algoritmo di Google</title>
      <link>https://flecart.github.io/notes/l-algoritmo-di-google/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/l-algoritmo-di-google/</guid>
      <description>Ultima modifica: October 19, 2022 5:01 PM Primo Abbozzo: April 25, 2022 12:27 PM Stato: 🌕🌕🌕🌑🌑 Studi Personali: No
Elementi di ripasso È una cos extra
20 Pagerank È un algoritmo molto utile (base) per il motore di ricerca di Google.
Quanto è importante la pagina Quante frecce partono da una pagina (che ha valore più concentrato con meno voti) Cerchiamo di definire quindi una fuinzione che sia definita con le caratteristiche precedenti:</description>
    </item>
    <item>
      <title>Log degli esercizi</title>
      <link>https://flecart.github.io/notes/log-degli-esercizi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/log-degli-esercizi/</guid>
      <description>Ultima modifica: May 13, 2023 4:44 PM Primo Abbozzo: January 14, 2023 11:55 AM Studi Personali: No
Log esercizi fatti Data, compito, C1 fatto? c2 fatto?
2022.09.06 [http://www.cs.unibo.it/~renzo/so/compiti/2022.09.06.tot.pdf] (36 KB) X X 2022.07.20 [http://www.cs.unibo.it/~renzo/so/compiti/2022.07.20.tot.pdf] (36 KB) X X (non me lo ricordo) 2022.06.21 [http://www.cs.unibo.it/~renzo/so/compiti/2022.06.21.tot.pdf] (40 KB) X X X 2022.06.01 [http://www.cs.unibo.it/~renzo/so/compiti/2022.06.01.tot.pdf] (36 KB) X X 2022.02.14 [http://www.cs.unibo.it/~renzo/so/compiti/2022.02.14.tot.pdf] (40 KB) X X 2022.01.17 [http://www.cs.unibo.it/~renzo/so/compiti/2022.01.17.tot.pdf] (36 KB) X X X X 2021.09.15 [http://www.</description>
    </item>
    <item>
      <title>Pre-esame</title>
      <link>https://flecart.github.io/notes/pre-esame/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/pre-esame/</guid>
      <description>Ultima modifica: January 10, 2023 3:09 PM Primo Abbozzo: January 2, 2023 10:36 AM Studi Personali: No
Elementi di ripasso Pre-esame Per la struttura di questo esame, tristemente ci sono un sacco di cose da imparare a memoria, senza averne capito il motivo.
Per questa ragione metto qui alcune cose importanti per l’esame, che sono probabilmente da imparare a memoria
Numeri finiti Standard IEEE per 32 e 64 floating point, il formato a 4, dire a memoria i numeri Formula per precisione macchina Norme e condizionamento Definizione del numero di condizionamento per una matrice Norma 1, p-adica, infinito Norma di frobenius Norma indotta (1 e infinito) Norma spettrale Metodi diretti Cholesky, che composizione ha?</description>
    </item>
    <item>
      <title>Verita, Teorie, modelli, connotazione, denotazione</title>
      <link>https://flecart.github.io/notes/verita-teorie-modelli-connotazione-denotazione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/verita-teorie-modelli-connotazione-denotazione/</guid>
      <description>Ripasso Prox: 17 Ripasso: December 22, 2021 Ultima modifica: September 30, 2022 3:19 PM Primo Abbozzo: November 3, 2021 9:14 AM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso Vecchi dubbi
ripassare da inconsistenza in poi. Modello è una funzione semantica?
5 Verità e conseguenza Logica Questa è una necessità per stabilire il significato di una sintassi definiti.
5.1 Verità e Realtà La verità ha solamente senso quando lo si relaziona con un mondo sensibile, ossia il mondo che si può percepire con i nostri sensi.</description>
    </item>
    <item>
      <title>Adversarial Search</title>
      <link>https://flecart.github.io/notes/adversarial-search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/adversarial-search/</guid>
      <description>Ripasso Prox: 7 Ultima modifica: December 29, 2022 3:24 PM Primo Abbozzo: July 18, 2022 3:29 PM Studi Personali: No
Elementi di ripasso Adversarial Search Questi algoritmi trattano principalmente di giochi e di modi</description>
    </item>
    <item>
      <title>Entropy</title>
      <link>https://flecart.github.io/notes/entropy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/entropy/</guid>
      <description>Entropy Questo è stato creato da 1948 Shannon in (Shannon 1948). Questa nozione è basata sulla nozione di probabilità, perché le cose rare sono più informative rispetto a qualcosa che accade spesso. Kolmogorov complexity è un modo diverso per definire la complessità. Legato è Neural Networks#Kullback-Leibler Divergence.
We can model the classical view of entropy as the from [^1]
Expected value of Surprisal which is the uncertainty of a random variable $X$ taking a certain value which is $p(X = x) = P(x)$, but we want to measure it using log-likelihood.</description>
    </item>
    <item>
      <title>Network Address Translation</title>
      <link>https://flecart.github.io/notes/network-address-translation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/network-address-translation/</guid>
      <description>Ripasso Prox: 60 Ripasso: July 12, 2023 Ultima modifica: May 13, 2023 11:33 PM Primo Abbozzo: December 13, 2022 10:36 AM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso NAT Network address translation Introduzione Col il NAT possiamo avere tutto lo spazio degli IP di cui abbiamo bisogno, che però non sono esposti. All&amp;rsquo;esterno vengono esposte solamente l’IP del NAT.
Schema classico NAT
Quindi in breve
All&amp;rsquo;esterno è esposto solamente l&amp;rsquo;indirizzo del router, il router, a seconda della porta giusta, dà in risposta al computer giusto, quindi all&amp;rsquo;interno della nostra rete conosciamo tutti gli indirizzi IP giusti.</description>
    </item>
    <item>
      <title>Object detection and Segmentation</title>
      <link>https://flecart.github.io/notes/object-detection-and-segmentation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/object-detection-and-segmentation/</guid>
      <description>Definition of problems Object detection Bisogna trovare all&amp;rsquo;interno dell&amp;rsquo;immagine quali siano gli oggetti presenti, e in più vogliamo sapere dove siano quindi utilizzare una bounding box per caratterizzarli sarebbe buono.
Object segmentation È riuscire a caratterizzare categoria per categoria per singoli pixelsm e per questo motivo potrei riuscire a fare delle image map in cui colorare singoli oggetti in una categoria.
Datasets Example datasets Pascal VOC 2012 Coco datasets Cityscapes dataset Autogenerated datasets But I don&amp;rsquo;t know much about these datasets Applications Auto drive Campo medico (per segmentazione medica o riconoscimento immagini).</description>
    </item>
    <item>
      <title>Proximal Policy Optimization</title>
      <link>https://flecart.github.io/notes/proximal-policy-optimization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/proximal-policy-optimization/</guid>
      <description>(Schulman et al. 2017) è uno degli articoli principali che praticamente hanno dato via al campo. Anche questo è buono per Policy gradients:
https://lilianweng.github.io/posts/2018-04-08-policy-gradient/
Introduzione a PPO References [1] Schulman et al. “Proximal Policy Optimization Algorithms” arXiv preprint arXiv:1707.06347 2017</description>
    </item>
    <item>
      <title>Top-down Parser</title>
      <link>https://flecart.github.io/notes/top-down-parser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/top-down-parser/</guid>
      <description>Ripasso Prox: 60 Ripasso: May 23, 2023 Ultima modifica: June 11, 2023 3:00 PM Primo Abbozzo: November 11, 2022 3:47 PM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso Domande
Top-down Parser Top-down Algoritmo di parsing 🟩 Slide
Questo si potrebbe considerare come algoritmo classico di parsing con non determinismo. (vado avanti, ed esploro tutto, senza look ahead).
Esempio di esecuzione
Commenti efficienza di sopra 🟩 È molto inefficiente, in particolare si potrebbe trovare una compessità esponenziale del tipo</description>
    </item>
    <item>
      <title>Estensioni di Turing e altre macchine</title>
      <link>https://flecart.github.io/notes/estensioni-di-turing-e-altre-macchine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/estensioni-di-turing-e-altre-macchine/</guid>
      <description>Sono variazioni possibili equivalenti: • Nastri addizionali • Testine addizionali • Nastri infiniti su entrambi i lati • Non-determinismo • Scelta probabilistica • Scelta quantistica
Turing con nastri addizionali Questo è presente in modo abbastanza facile sul Sipser.
La computazione comincia con l’input sul primo nastro, e tutti gli altri nastri vuoti. Macchine di Turing con nastri addizionali In ciascun passo di computazione, ogni testina é nello stesso stato, ma può essere in una posizione diversa, leggere un simbolo differente, e compiere un’azione diversa.</description>
    </item>
    <item>
      <title>Map of Mind Theories</title>
      <link>https://flecart.github.io/notes/map-of-mind-theories/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/map-of-mind-theories/</guid>
      <description>This note is just useful to classify some classical views of mind theories
Mentalism Si basa sull&amp;rsquo;idealismo Hegeliano Questo lo citiamo ma non ne parliamo proprio
Attribute theory In cui sì è materialista, ma c&amp;rsquo;è qualcosina in più che non ho ben capito.
Dualism In cui si pensa che esistono due componenti indipendenti (nel senso che uno può vivere senza l&amp;rsquo;altro).
Cartesian dualism Quello di Cartesio e della ghiandola pineale</description>
    </item>
    <item>
      <title>Problemi di ricerca</title>
      <link>https://flecart.github.io/notes/problemi-di-ricerca/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/problemi-di-ricerca/</guid>
      <description>Ripasso Prox: 36 Ultima modifica: December 29, 2022 3:24 PM Primo Abbozzo: June 30, 2022 2:38 PM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso September 10, 2022
Mi sono scordato gli stati possibili. Quasi niente sulla ricerca per algoritmi non deterministici e non osservabili. 2 Problemi di ricerca In questa prima parte si tratta di ricerca semplice, ossia si utilizza un modello basato su obiettivi, di struttura atomica, in un ambiente che risulti singolo-agente, episodico, totalmente osservabile, deterministico, statico, discreto, conosciuto.</description>
    </item>
    <item>
      <title>Project Management</title>
      <link>https://flecart.github.io/notes/project-management/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/project-management/</guid>
      <description>Project, product management, project management Bisogna capire queste definizioni. Vedere https://dynamik.vercel.app/ingegneria-del-software/lucidi/13-gestione-del-progetto.pdf?from=informatica, slide 5 per definizione
Progetto: inizia e finisce in tempo preciso. È importante comunque ricordare gli steps principali per il progetto ossia ideazione, creazione, mantenimento, rilascio, e poi morte, questo in genere è per qualunque progetto.
Project Manager Compiti principali (costi e risorse) Vedere se il progetto è fattibile Allocare risorse Monitorare come sta andando. (preventivo e consuntivo). Work Breakdown structure Descrizione WBS È una suddivisione del progetto in piccoli sottoparti che si possono gestire in modo autonomo.</description>
    </item>
    <item>
      <title>Relazional Model</title>
      <link>https://flecart.github.io/notes/relazional-model/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/relazional-model/</guid>
      <description>This is the classical format that we encounter, it is the format used for relational databases introduced in databases course introduction, introduced in (Codd 1970).
Introduzione, i modelli di dati Lista modelli di dati (4) Nel tempo sono stati sviluppati molti modelli di dati:
Relational Data Model: This is the most common data model and uses tables to represent data. It organizes data into rows and columns, where each row represents a record, and each column represents an attribute of that record.</description>
    </item>
    <item>
      <title>Serie</title>
      <link>https://flecart.github.io/notes/serie/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/serie/</guid>
      <description>Questo è un tentativo di aggiungere un argomento che non era presente quando abbiamo fatto il corso due anni fa. Inizio la scrittura il 2024-03-03. Questo non è stato trattano nel corso, ma è importante per molte cose. Quindi introduco questo appunto.
Introduzione alle serie Le serie infinite sono dei mostri strani perché non si comportano spesso come dovrebbero.
Limit Comparison Test Siano date due Successioni $a_{n}$ e $b_{n}$ sempre positive.</description>
    </item>
    <item>
      <title>Ampere e Faraday</title>
      <link>https://flecart.github.io/notes/ampere-e-faraday/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/ampere-e-faraday/</guid>
      <description>Relazioni con fili - Ampere Legge di Biot-Savart/Formalizzazione esperienza di Ampere 🟩 Poniamo che ho due fili in cui scorra della corrente, voglia capire la forza per unità di lunghezza del filo uno su due e viceversa.
So che entrambi generano campo magnetico So che il campo magnetico induce forza su correnti in movimento. Supponiamo che la loro distanza sia $D$, allora avremo che: Per la prima legge so: $$ d\vec{B} = \mu_{0}i d\vec{l} \times \frac{\hat{r}}{4\pi r^{2}} $$ da questo posso calcolare il campo magnetico totale, in un modo simile a quanto fatto in precedenza per il campo elettrico (solo che in questo caso abbiamo il prodotto seno, quindi l&amp;rsquo;angolo che conviene scegliere è un po&amp;rsquo; diverso), e una volta che ho questo posso usare la seconda legge per avere la forza, questo è il piano.</description>
    </item>
    <item>
      <title>Deblur di immagini</title>
      <link>https://flecart.github.io/notes/deblur-di-immagini/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/deblur-di-immagini/</guid>
      <description>Ripasso Prox: 4 Ripasso: December 23, 2022 Ultima modifica: January 3, 2023 11:54 AM Primo Abbozzo: November 17, 2022 11:22 AM Stato: 🌕🌑🌑🌑🌑 Studi Personali: No
Elementi di ripasso Immagini Introduzioni Origini di sfocatura Slide
Rumore causata da problemi fisici che sono errori di lettura del segnale analogico Questo si indica anche come errore gaussiano bianco e si può considerare additivo. Rumore causato dalla digitalizzazione, quindi dalla discretizzazione di essa. Slide formalizzazione errori per sfocatura</description>
    </item>
    <item>
      <title>Algebra Logica</title>
      <link>https://flecart.github.io/notes/algebra-logica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algebra-logica/</guid>
      <description>Ripasso Prox: 3 Ripasso: December 15, 2021 Ultima modifica: September 30, 2022 3:20 PM Primo Abbozzo: December 15, 2021 9:18 AM Stato: 🌕🌕🌑🌑🌑 Studi Personali: No
Strutture algebriche Differenza matematica e informatica Una osservazione per quanto riguarda la logica intuizionista è che sta a metà fra matematica e informatica perché la dimostrazione intuizionista possiede in sé un algoritmo e una struttura di dati.
Infatti di solito l&amp;rsquo;informatico scrive senza fare la dimostrazione dell&amp;rsquo;algoritmo mentre il matematico scrive la dimostrazione senza fare l&amp;rsquo;algoritmo (inoltre può definire degli enti ed oggetti che non siano rappresentabili come dati in quanto possono essere infiniti.</description>
    </item>
    <item>
      <title>Index, B-trees and hashes</title>
      <link>https://flecart.github.io/notes/index-b-trees-and-hashes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/index-b-trees-and-hashes/</guid>
      <description>Indexes Trattiamo qui di alcuni metodi che sono utilizzati per costruire indici
Introduction to indexes Gli indici sono una struttura di dati aggiuntiva che ci permette di ricercare più in fretta alcuni valori per le queries. In questa sezione proviamo ad approfondire in che modo possono essere costruite e gestite.
Search keys 🟩 Sono in breve la cosa che vogliamo andare a cercare. Solitamente sono nella forma &amp;lt;key, label&amp;gt;, che ci permette di trovare in fretta il label, che si potrebbe intendere come il valore che noi stiamo provando a cercare.</description>
    </item>
    <item>
      <title>Modelli AGILE</title>
      <link>https://flecart.github.io/notes/modelli-agile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/modelli-agile/</guid>
      <description>Socialità dello sviluppo del software (3) 🟨- Si assume che
È difficile assegnarsi i compiti, bisogni di utenti, tempi di consegna (+ persone difficile) È facile scrivere software (almeno software classico, e non computazione scientifica) La gente sia brava tecnicamente che socialmente è una cosa rara VS Waterfall (3) 🟨++ Pianificare tutto come viene descritto nel modello del waterfall non è possibile. Per i seguenti motivi
Non è chiaro cosa vuole l&amp;rsquo;utente finale (quindi sarebbe meglio avere feedback continuo).</description>
    </item>
    <item>
      <title>Tecnologia Wireless</title>
      <link>https://flecart.github.io/notes/tecnologia-wireless/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/tecnologia-wireless/</guid>
      <description>Ripasso Prox: 10 Ripasso: May 21, 2023 Ultima modifica: May 14, 2023 5:18 PM Primo Abbozzo: April 12, 2023 3:02 PM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
Elementi di ripasso Tecnologia Wireless Introduzione Spettro del wireless networks (skip) Slide spettro Wirelesss networks
Questo solamente la classica differenziazione fra radio, visibile, raggi x raggi gamma etcetera.
Se andiamo a guardare le onde radio, quelle che ci interessano, se ho frequenza alta ho densità di frequenza alta, se ho frequenza bassa ho alta capacità di suparamento di ostacoli.</description>
    </item>
    <item>
      <title>Bag of words</title>
      <link>https://flecart.github.io/notes/bag-of-words/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bag-of-words/</guid>
      <description>Introduzione a bag of words Faremo una introduzione di applicazione di Naïve Bayes applicato alla classificazione di documenti.
Setting del problema 🟨+ Questo è una parte che è importante nel caso volessimo fare document classification. e simili, In questa brevissima introduzione cerchiamo di calcolare $$ \theta_{i, \text{word}, l} = P(X_{i} = \text{word} | Y = l) $$ Ossia quanto è probabile che una parola sia word, che appaia alla posizione i, data la categoria $l$ del documento Assumendo che non dipenda dalla posizione posso solamente contare le parole per documento fregandomene della posizione, questa è l&amp;rsquo;idea che ha portato ai primi approcci in questo campo.</description>
    </item>
    <item>
      <title>Codifica dei caratteri</title>
      <link>https://flecart.github.io/notes/codifica-dei-caratteri/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/codifica-dei-caratteri/</guid>
      <description>Ripasso Prox: 40 Ripasso: May 14, 2023 Ultima modifica: May 14, 2023 5:18 PM Primo Abbozzo: March 2, 2023 4:19 PM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Codifica dei caratteri Sull&amp;rsquo;encoding Introduzione 🟩 Ossia trattiamo metodi per codificare caratteri dei linguaggi umani, come ASCII, UCS e UTF.
Digitalizzare significa encodarlo in un sistema che possa essere memorizzato su un dispositivo di memorizzazione elettronico. Ovviamente non possiamo mantenere l&amp;rsquo;informazione così come è, ma vogliamo memorizzarne una forma equivalente, ma più facile da manipolare dal punto di vista del computer.</description>
    </item>
    <item>
      <title>Control Plane</title>
      <link>https://flecart.github.io/notes/control-plane/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/control-plane/</guid>
      <description>Tipologie di control plane La control plane è la parte al livello di rete che si occupa di riempire le tabelle di istradamento dei router. In questo caso si possono in generare dividere gli algoritmi in due grandi famiglie
Centralizzati, anche chiamati algoritmi LS( Link state) perché devono conoscere in che modo sono collegati i router fra di loro. Solitamente le SDN ossia software defined networking di cui abbiamo parlato in Data Plane utilizzano questi metodi, c&amp;rsquo;è un server centralizzato (che per ragioni di tolleranza può anche essere distribuito, però diciamo che è esterno al router la decisione) Distribuiti in cui nessuno ha informazioni complete sulla rete, ma è possibile scambiarsi informazioni sui vicini e congiungere così al percorso più breve.</description>
    </item>
    <item>
      <title>Data Plane</title>
      <link>https://flecart.github.io/notes/data-plane/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/data-plane/</guid>
      <description>Ripasso Prox: 30 Ripasso: May 20, 2023 Ultima modifica: May 14, 2023 5:18 PM Primo Abbozzo: March 10, 2023 12:10 PM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Introduzione Data or Control plane come fanno i router a fare forwarding dei pacchetti? e decidere come mandare? Come fanno a passare. Sono le tabelle di instradamento. Si può dire di end-to-end perché solamente il sender e receiver andranno a livello applicazione, e leggeranno le cose (se criptato veramente solo loro riescono a fare questo).</description>
    </item>
    <item>
      <title>Rappresentazione della conoscenza</title>
      <link>https://flecart.github.io/notes/rappresentazione-della-conoscenza/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/rappresentazione-della-conoscenza/</guid>
      <description>Ripasso Prox: 7 Ultima modifica: December 29, 2022 3:24 PM Primo Abbozzo: August 13, 2022 5:03 PM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
Elementi di ripasso August 25, 2022
Rappresentazione della conoscenza Questo è stato un capitolo molto vasto, che andava in certi punti a toccare la filosofia, la fisica. Un aspetto, quello di codifica delle informazioni reali in un ambiente logico (che per quanto i miei pregiudizi siano, ritengo una cosa molto impossibile, molto limitata e altrettanto impossibile).</description>
    </item>
    <item>
      <title>Sicurezza delle reti</title>
      <link>https://flecart.github.io/notes/sicurezza-delle-reti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/sicurezza-delle-reti/</guid>
      <description>Ripasso Prox: 23 Ripasso: May 17, 2023 Ultima modifica: May 1, 2023 10:58 AM Primo Abbozzo: March 1, 2023 1:10 PM Stato: 🌕🌕🌕🌗🌑 Studi Personali: No
Elementi di ripasso Sicurezza delle reti Introduzione Obiettivi della sicurezza (!!!) 🟩 Vogliamo creare delle reti che abbiamo certe garanzie di sicurezza, soprattutto:
Confidenzialità, non vorremmo che il nostro messaggio sia intercettabile e leggibili da persone intermedie Integrità: non vogliamo che messaggi possano essere cambiati senza intervento del sender Autenticazione: vorremmo sapere con chi stiamo parlando, e vorremmo essere sicuri che non stiano mentendo sull’identità.</description>
    </item>
    <item>
      <title>Structured Query Language</title>
      <link>https://flecart.github.io/notes/structured-query-language/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/structured-query-language/</guid>
      <description>Data types Default data types 🟩 I tipi di dati sono
Carattere numero data tempo intervallo di tempo booleano blob (binario) clob (carattere) Setting custom data types 🟩 Ma possono essere definiti anche tipi di dati custom, la sintassi è simile
CREATE DOMAIN Grade AS SMALLINT DEFAULT NULL CHECK (value &amp;gt;= 18 AND value &amp;lt;= 30) Altering existing domains 🟩 In cui posso mettere anche dei check custom.
DROP DOMAIN Per cancellare il domain lì presente</description>
    </item>
    <item>
      <title>Strutture</title>
      <link>https://flecart.github.io/notes/strutture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/strutture/</guid>
      <description>Ultima modifica: November 2, 2021 10:50 AM Primo Abbozzo: November 2, 2021 9:22 AM Studi Personali: No
Elementi di ripasso Strutture Caratteristiche La caratteristica principale è che le strutture permettono di avere valori eterogenei mentre prima avevamo solo array, ossia valori omogenei, uguali fra di loro.
Questo è anche il modo solito con cui fare dei database! Teneere roba ordinata
Sintassi Accesso Blablabla
Copia Si può copiare un array in modo molto semplice, basta un uguale, mentre invece con gli array non si poteva semplicemente copiare (perché copiava il pointer) ora a quanto pare copia in automatico.</description>
    </item>
    <item>
      <title>The Neuron</title>
      <link>https://flecart.github.io/notes/the-neuron/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/the-neuron/</guid>
      <description>La struttura del neurone #### Parti strutturali principali (2) 🟩 Possiamo identificare tre parti principali per quanto riguarda la struttura di un singolo neurone
Assoni che si occupano di mandare activation potential signal all&amp;rsquo;esterno, a comunicare con altre cellule. Il segnale che parte dall&amp;rsquo;assone inizia da una sezione che viene chiamato segmento iniziale. Dentriti che si occupano di ricevere segnali da altri neuroni. Gli assoni e dentriti non sono connessi, ma c&amp;rsquo;è un piccolo spazio in mezzo a questi che si chiama Synaptic cleft, (la scoperta di questo è stato di stupore, in passato pensavano che fosse una cosa continua il cervello, invece abbiamo qualche piccola unità discreta, scoperto con la colorazione d&amp;rsquo;argento metodi di Golgi) l&amp;rsquo;informazione in questo spazio pre e post sinaptico è gestito da neurotrasmettitori.</description>
    </item>
    <item>
      <title>Costo computazionale</title>
      <link>https://flecart.github.io/notes/costo-computazionale/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/costo-computazionale/</guid>
      <description>Ultima modifica: November 3, 2021 11:27 AM Primo Abbozzo: November 3, 2021 11:24 AM Studi Personali: No
Costo computazionale In modo intuitivo il costo in tempo è il numero di cicli di clock che il computer deve avere per forza per finire l&amp;rsquo;esecuzione di un codice.
Si cerca di avere un costo massimo quindi possiamo fare per casi:
Costo condizionale Costo guardia più max guardia
costo_della_guardia + max(costo_ramo_then, costo_ramo_else)
Costo iterativo numero_iterazioni*(costo_della_guardia+costo_del_corpo) + costo della guardia dia più max guardia</description>
    </item>
    <item>
      <title>Decision Theory Intro</title>
      <link>https://flecart.github.io/notes/decision-theory-intro/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/decision-theory-intro/</guid>
      <description>Ultima modifica: January 22, 2023 12:26 PM Primo Abbozzo: August 23, 2022 2:06 PM Studi Personali: No
Elementi di ripasso Decision theory Introduzione Cosa rappresenta
Assiomi 6 assiomi principali di questo
Funzioni di utilità Cosa è una funzione di utilità, cosa rappresenta
Multiattriute
Cosa sono le funzioni utilità multi attributo
In che modo vengono rankate, in che modo si dice che un modello domina sull’altra.
Mutual preference indipendence.
Reti decisionali La differenza con le Bayesian Networks, e perché le amplia, cosa sono le cose nuove che sono introdotte con queste nuove reti decisionali.</description>
    </item>
    <item>
      <title>Partially synchronous model</title>
      <link>https://flecart.github.io/notes/partially-synchronous-model/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/partially-synchronous-model/</guid>
      <description>Ultima modifica: January 3, 2023 3:59 PM Primo Abbozzo: January 3, 2023 3:58 PM Studi Personali: No
Elementi di ripasso Argomento https://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf</description>
    </item>
    <item>
      <title>Preparazione Esame</title>
      <link>https://flecart.github.io/notes/preparazione-esame/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/preparazione-esame/</guid>
      <description>Ultima modifica: June 21, 2023 9:07 PM Primo Abbozzo: June 17, 2023 11:59 PM Studi Personali: No
URI Cosa sono? Per cosa vengono utilizzati? Che differenza c&amp;rsquo;è fra URL e URN? sintassi dell’URI Alcuni esempi di schema (e relativo utilizzo e sintassi per l’URI) IRI e IDN, cosa sono? Cosa sono i CURIE? Cosa è URL Ref e come viene risolto Cosa è uri resolution, e cosa uri dereference? Cosa è LOD?</description>
    </item>
    <item>
      <title>Randomness</title>
      <link>https://flecart.github.io/notes/randomness/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/randomness/</guid>
      <description>Introduzione alla Randomicità Questo è principalmente basato su (Li &amp;amp; Vitányi 2019) Capito 1.9 Sembra che la nozione di random sia alla fine una cosa molto profonda. Per esempio, un caso lampante che le definizioni non funzionano nel caso di numeri trascendenti è che catalogano i numeri di $\pi$ come se fossero casuali, mentre in realtà possono essere trovati mediante procedimenti precisi. È una distinzione filosoficamente molto interessante.
Alla fine sembra ci sia un link molto diretto con la crittografia, si può vedere (Stinson 2005).</description>
    </item>
    <item>
      <title>Relazioni di Ricorrenza</title>
      <link>https://flecart.github.io/notes/relazioni-di-ricorrenza/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/relazioni-di-ricorrenza/</guid>
      <description>Ripasso Prox: 40 Ripasso: June 24, 2022 Ultima modifica: May 19, 2022 12:48 PM Primo Abbozzo: February 28, 2022 5:02 PM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso 2 Relazioni di ricorrenza Iterazione Questo metodo semplicemente consiste di calcolare tutte le operazioni e scriverlo con una notazione asintotica.
slide
Sostituzione (induzione) slide
Analisi della relazione di ricorrenza di fibonacci
Si può dimostrare utilizzando l&amp;rsquo;induzione che una relazione di questo tipo</description>
    </item>
    <item>
      <title>Sintassi e RI strutturali</title>
      <link>https://flecart.github.io/notes/sintassi-e-ri-strutturali/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/sintassi-e-ri-strutturali/</guid>
      <description>Ripasso Prox: 27 Ultima modifica: October 7, 2022 1:25 PM Primo Abbozzo: October 15, 2021 10:35 AM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso Vecchi dubbi Cosa è la sintassi I costituenti della BNF (ripassarreeee le tre soluzioi per l&amp;rsquo;ambibuità definizione di linguaggio Differenza funzioni matematiche ed informatiche Context-free-grammar per AST Cosa significa espandere un non terminale? 4 Sintassi Programmare e dimostrare sono sostanzialmente la stessa attività ~Coen
Ma non secondo l&amp;rsquo;industria&amp;hellip;</description>
    </item>
    <item>
      <title>Advanced SQL</title>
      <link>https://flecart.github.io/notes/advanced-sql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/advanced-sql/</guid>
      <description>Check function A volte può essere molto pesante, perché
What does check do? Viene utilizzato per introdurre un constraint check per avere sicurezza su un range. Check e innestamenti 🟩- Può essere che certe implementazioni non permettano il check innestato, questo è una cosa molto pesante, perché ogni modifica deve andare a rifare la modifica ai subalterni, quindi questo è pesante pesante.
Assertions 🟩&amp;ndash; Sono dei check fatti al livello dello schema, quindi valgono sempre, e possono essere riutilizzati in table diversi credo.</description>
    </item>
    <item>
      <title>Algebra dei tipi</title>
      <link>https://flecart.github.io/notes/algebra-dei-tipi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algebra-dei-tipi/</guid>
      <description>Ripasso Prox: 19 Ripasso: May 22, 2023 Ultima modifica: May 6, 2023 5:58 PM Primo Abbozzo: April 3, 2023 1:22 PM Stato: 🌕🌕🌕🌗🌑 Studi Personali: No
Elementi di ripasso Algebra dei tipi Slide introduzione algebra dei tipi
Equivalenza dei tipi (2) 🟩 Quando possiamo dire che due tipi siano uguali? Solitamente vengono utilizzati due metodi:
EQUIVALENZA NOMINALE
Quando un nuono tipo introduce un nuovo nome diverso fra tutti i presenti. Credo così vada golang.</description>
    </item>
    <item>
      <title>Asynchronous model</title>
      <link>https://flecart.github.io/notes/asynchronous-model/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/asynchronous-model/</guid>
      <description>Ultima modifica: December 30, 2022 9:42 AM Primo Abbozzo: December 30, 2022 9:42 AM Studi Personali: No
Elementi di ripasso Asynchronous model Introduction Praticamente non assumo niente… Se riesco a dire qualcosa sarebbe molto interessante
FLP impossibility TODO: continuare</description>
    </item>
    <item>
      <title>Consensus protocols</title>
      <link>https://flecart.github.io/notes/consensus-protocols/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/consensus-protocols/</guid>
      <description>Ripasso Prox: 7 Ultima modifica: January 27, 2023 2:29 PM Primo Abbozzo: December 29, 2022 3:49 PM Studi Personali: No
Elementi di ripasso Consensus protocols Introduzione Vogliamo tenere in modo sincronizzato alcune macchine, questo è il nostro obiettivo. Questo è un problema abbastanza difficile… Come tenere in sinc se ci sono alcuni nodi maligni o la rete che non è bona?
Assunzioni principali (2) Esiste internet Esiste Crittografia Queste sono le assunzioni che non saranno mai rilassate per l’intero corso, diciamo che sono la nostra base su cui possiamo andare a costruire la base per il nostro studio.</description>
    </item>
    <item>
      <title>Limiti</title>
      <link>https://flecart.github.io/notes/limiti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/limiti/</guid>
      <description>Ripasso Prox: 80 Ripasso: June 30, 2022 Ultima modifica: October 8, 2022 12:08 PM Primo Abbozzo: October 28, 2021 4:56 PM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
4 Limiti Riguardare Successioni per avere primo attacco sui limiti
4.1 Limiti finiti al finito 4.1.1 Intorno sferico Dato l&amp;rsquo;insieme $\R$ si definisce l&amp;rsquo;intorno sferico aperto di $x \in \R$ di raggio $r \in \R$ l&amp;rsquo;insieme $I_r(x) = (x -r, x + r)$ questa nozione è molto importante per definire il limite.</description>
    </item>
    <item>
      <title>Alberi di decisione</title>
      <link>https://flecart.github.io/notes/alberi-di-decisione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/alberi-di-decisione/</guid>
      <description>Introduzione agli alberi di decisione Setting del problema 🟩- Spazio delle ipotesi Definizione spazio ipotesi 🟩&amp;mdash; Per spazio delle ipotesi andiamo a considerare l&amp;rsquo;insieme delle funzioni rappresentabili dal nostro modello. Questo implica che l&amp;rsquo;allenamento ricerca l&amp;rsquo;ipotesi ossia la parametrizzazione ottimale del nostro modello, ottimale in quanto minimizza l&amp;rsquo;errore che viene compiuto nel training set.
L&amp;rsquo;insieme iniziale si può anche considerare come inductive bias ossia il restringimento solamente a certe ipotesi e non tutte.</description>
    </item>
    <item>
      <title>Bottom-up Parser LR(1)</title>
      <link>https://flecart.github.io/notes/bottom-up-parser-lr1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bottom-up-parser-lr1/</guid>
      <description>Ripasso Prox: 40 Ripasso: May 27, 2023 Ultima modifica: April 17, 2023 12:52 PM Primo Abbozzo: November 22, 2022 1:22 PM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso Domande
Bottom-up Parser -LR(1) Si può osservare che per il parser costruito in Bottom-up Parser LR(0), non riesce a riconoscere di linguaggi semplici come $L = {a, ab}$.
Esempio di quanto detto Parser SLR(1) Questi parser qui utilizzano l’idea del look ahead ampiamente utilizzata in Top-down Parser, per escludere molte produzioni.</description>
    </item>
    <item>
      <title>Memoria virtuale</title>
      <link>https://flecart.github.io/notes/memoria-virtuale/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/memoria-virtuale/</guid>
      <description>Ripasso Prox: 20 Ripasso: May 17, 2023 Ultima modifica: May 16, 2023 12:49 PM Primo Abbozzo: March 29, 2023 9:50 AM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso Memoria virtuale e Algo rimpiazzamento Memoria virtuale Perché è utile la MV? 🟨- I programmi non usano tutta la memoria, ma pensano di averla tutta disponibile dal suo punto di vista. L&amp;rsquo;idea principale è che molte zone di memoria sono inutili per lungo tempo, possono essere utilizzati per altro.</description>
    </item>
    <item>
      <title>OTP and Stream Ciphers</title>
      <link>https://flecart.github.io/notes/otp-and-stream-ciphers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/otp-and-stream-ciphers/</guid>
      <description>XOR operation È una operazione binaria abbastanza semplice però ci sarà importante per andare ad analizzare dei cifrari di un certo genere. Come il ONE TIME PAD che faremo fra poco in OTP and Stream Ciphers.
Teorema cifratura con XOR Prendiamo $X$ una variabile aleatoria in $\left{ 0,1 \right}^{n}$ uniforme, sia $Y$ una variabile aleatoria su uno stesso dominio come vogliamo. Tali per cui $X, Y$ siano indipendenti Allora avremo che $C = X \oplus Y$ è una variabile aleatoria uniforme.</description>
    </item>
    <item>
      <title>Poisson processes</title>
      <link>https://flecart.github.io/notes/poisson-processes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/poisson-processes/</guid>
      <description>Introduzione ai processi di Poisson Arrival processes Sia una sequenza di variabili aleatorie $0 &amp;lt; S_{1} &amp;lt; S_{2} &amp;lt; \dots$ (il fatto che sia positivo significa che per ogni elemento del dominio vale che quell&amp;rsquo;elemento è &amp;lt;, non so se mi sono spiegato.) Il fatto che siano crescenti ci permette di metterli in linea, perché siamo sicuri che $S_{2}$ produrrà un valore maggiore di $S_{1}$.
Incline a questo c&amp;rsquo;è anche il arrival counting process che semplicemente va a contare il numero di arrivi (indicati dagli $S_{i}$).</description>
    </item>
    <item>
      <title>Reti di flusso</title>
      <link>https://flecart.github.io/notes/reti-di-flusso/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/reti-di-flusso/</guid>
      <description>Ripasso Prox: 23 Ripasso: January 3, 2023 Ultima modifica: December 25, 2022 10:21 AM Primo Abbozzo: October 21, 2022 10:04 AM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso Reti di flusso Questi problemi sono una sottoclasse della programamzione lineare con variabili reali. (Alcuni riescono a riconoscere se un problema è in questa forma, e lo risolvono in modo istantaneo se questo succede).
Un problema dei router è un classico problema di flusso, che si risolvono con questi algoritmi polinomiali</description>
    </item>
    <item>
      <title>Time Complexity</title>
      <link>https://flecart.github.io/notes/time-complexity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/time-complexity/</guid>
      <description>Introduction to Time Complexity This note will build upon know techniques of algorithms analysis explained in Notazione Asintotica. We will need big-$O$ notation and $o$ notation. L&amp;rsquo;idea è che il problema di decisione è decidibile se limito la lunghezza del teorema. Simile al numero di Chaitin, che non è computabile, ma è approssimabile quanto si vuole. In un certo senso è computabile. The general idea is to ask how the function $\varphi$ that maps the longest $n$ proof to the number of steps of computation behaves.</description>
    </item>
    <item>
      <title>Algoritmi di ordinamento</title>
      <link>https://flecart.github.io/notes/algoritmi-di-ordinamento/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algoritmi-di-ordinamento/</guid>
      <description>Ripasso Prox: 23 Ripasso: May 15, 2022 Ultima modifica: April 30, 2022 10:35 AM Primo Abbozzo: March 25, 2022 9:34 AM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso 6 Algoritmi di Ordinamento 6.1 Introduzione 6.1.1 L’importanza del topic Gli algoritmi di ordinamento sono molto di base per la comprensione dell&amp;rsquo;ampio raggio degli algoritmi. Utilizzano l&amp;rsquo;analisi, introducono tecniche di risoluzione dei problemi computazionali come greedy, divide et impera e simile. Permettono un primo uso di astrazioni e l&amp;rsquo;analisi di sottoproblemi.</description>
    </item>
    <item>
      <title>Interpolazione</title>
      <link>https://flecart.github.io/notes/interpolazione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/interpolazione/</guid>
      <description>Ripasso Prox: 21 Ripasso: January 1, 2023 Ultima modifica: January 2, 2023 10:49 AM Primo Abbozzo: October 26, 2022 4:45 PM Stato: 🌕🌑🌑🌑🌑 Studi Personali: No
Elementi di ripasso Interpolazione Vogliamo in questa sezione andare ad indagare la costruzione di funzioni che passano in tutti i punti che vogliamo, appunto interpolare. La funzione è molto simile alla regressione trattata in Minimi quadrati (con il metodo della regressione, chiamato anche approssimazione ai minimi quadrati).</description>
    </item>
    <item>
      <title>Introduction to Algorithmic Information and Complexity</title>
      <link>https://flecart.github.io/notes/introduction-to-algorithmic-information-and-complexity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduction-to-algorithmic-information-and-complexity/</guid>
      <description>Quick introduction Si assume che la descrizione più intelligente di un qualcosa è la stringa più corta che descrive quella, un po&amp;rsquo; forse è arbitrario, perché minore complessità, non è detto che sia direttamente relazionata con la difficoltà di descriverla.
Nel caso di AIT, diciamo che una cosa random non è compressibile, altrimenti posso scriverla in modo più compatto. È importante stabilire che l&amp;rsquo;alfabeto che abbiamo per rappresentare qualcosa è fissato a priori.</description>
    </item>
    <item>
      <title>Planning automatico</title>
      <link>https://flecart.github.io/notes/planning-automatico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/planning-automatico/</guid>
      <description>Ultima modifica: December 29, 2022 3:24 PM Primo Abbozzo: August 14, 2022 4:14 PM Stato: 🌑🌑🌑🌑🌑 Studi Personali: No
Elementi di ripasso Planning Automatico Vogliamo andare a creare un programma che sia in grado di creare un piano per fare una azione, andiamo in questo capitolo gli algoritmi storicamente migliori adatti a risolvere questo problema
Il problema di pianificazione Andiamo a rappresentare il nostro problema di pianificazione con un linguaggio molto simile alla Logica del Primo ordine.</description>
    </item>
    <item>
      <title>Teoremi Base Analisi</title>
      <link>https://flecart.github.io/notes/teoremi-base-analisi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/teoremi-base-analisi/</guid>
      <description>Ripasso Prox: 75 Ripasso: June 22, 2022 Ultima modifica: October 8, 2022 12:08 PM Primo Abbozzo: November 11, 2021 5:41 PM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso Fare attenzione alla dimostrazione di monotonia (stretta o lasca) nei casi in cui si può usare lagrange o meno (RIPETO IL FARE ATTENZIONE A STA COSA) Fare attenzione all&amp;rsquo;enunciato di fermat, lo ho invertito Vecchi dubbi Teorema di permanenza del segno (enunciato) DImostrazione del corollario di Lagrange Ripetere le ipotesi del teorema di Fermat Vedere se si ricorda come dimostrare tutti i teoremi Monotonia funzioni!</description>
    </item>
    <item>
      <title>Base e dimensione</title>
      <link>https://flecart.github.io/notes/base-e-dimensione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/base-e-dimensione/</guid>
      <description>Ripasso Prox: 30 Ripasso: May 30, 2022 Ultima modifica: October 19, 2022 5:02 PM Primo Abbozzo: March 12, 2022 11:51 AM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso Tutte le proprietà della basi, caratterizzazione delle dimensioni. 2 Basi e Dimensione 2.1 Basi 2.1.1 Definizione Un insieme di vettori $v_1,&amp;hellip;,v_n$ sono basi di uno spazio vettoriale $V$ se sono soddisfatte queste proprietà
$V = \langle v_1,&amp;hellip;,v_n\rangle$ $v_1,&amp;hellip;,v_n$ sono linearmente indipendenti Dalla proprietà 2 potremmo anche dire che è il minimo insieme di vettori necessario per avere questa base.</description>
    </item>
    <item>
      <title>Explainability of CNN</title>
      <link>https://flecart.github.io/notes/explainability-of-cnn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/explainability-of-cnn/</guid>
      <description>Ultima modifica: April 4, 2023 6:19 PM Primo Abbozzo: April 1, 2023 11:11 AM Studi Personali: No
Elementi di ripasso Explainability of CNN Introduction Capire in che modo una rete convoluzionale ci può dare insight migliori su come funzionano questi networks.
Visualizzazione dei hidden layers Slide visualization
Potremmo fissare una immagine anche a caso, e modificare la x in modo che sia più simile a quanto vuole computare il neurone. In questo modo genero una immagine che generi una activation forte nel neuron trainato, e si potrebbe dire che sia il genere di immagine che viene generata da essa.</description>
    </item>
    <item>
      <title>Gestione delle eccezioni</title>
      <link>https://flecart.github.io/notes/gestione-delle-eccezioni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gestione-delle-eccezioni/</guid>
      <description>Ripasso Prox: 17 Ripasso: May 27, 2023 Ultima modifica: May 16, 2023 9:53 AM Primo Abbozzo: March 27, 2023 10:58 AM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso Gestione delle eccezioni Introduzione Metodi alternativi di gestione degli errori (3) 🟩 A volte le computazioni falliscono. Potremmo gestirle con i result come accennato in Polimorfismo, però diventa molto macchinoso fare tutte le funzioni che debbano inoltrare solamente delle results. bisogna trovare un modo più naturale.</description>
    </item>
    <item>
      <title>Hopital, Taylor, Peano</title>
      <link>https://flecart.github.io/notes/hopital-taylor-peano/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/hopital-taylor-peano/</guid>
      <description>Ripasso Prox: 40 Ripasso: May 17, 2022 Ultima modifica: March 7, 2023 1:41 PM Primo Abbozzo: November 25, 2021 12:17 PM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
7 Hopital , Taylor e Peano 7.1 De Hopital 7.1.1 Lemmi preliminari Questo lemma preliminare era già presente per la prova del teorema degli zeri
Questo lemma è molto interessante perché mette in relazione il finito (le successioni) con l&amp;rsquo;infinito (i reali) In molte dimostrazioni si dà per scontato questo lemma, ma è una sottigliezza importante che giustifica l&amp;rsquo;utilizzo di successioni per limiti reali.</description>
    </item>
    <item>
      <title>Neural Networks</title>
      <link>https://flecart.github.io/notes/neural-networks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/neural-networks/</guid>
      <description>Ripasso Prox: 10 Ultima modifica: May 6, 2023 5:55 PM Primo Abbozzo: February 16, 2023 3:04 PM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso Introduction: a neuron Questi sono cosettini ispirati dalla struttura dei neuroni nel nostro cervello, ma mi sembra di aver sentito che alla fine non c’entrino proprio niente.
Structure Linear + activation In pratica possiamo dire che un neurone in questa parte di AI è una funzione lineare (quindi che non fa altro che $w^Tx + b$ di solito indicata con $z$) ossia moltiplicazione lineare, e poi una funzione non lineare tra 0 e 1 che mi indica o meno se la cosa è attivata o meno.</description>
    </item>
    <item>
      <title>Note sull’architettura</title>
      <link>https://flecart.github.io/notes/note-sullarchitettura/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/note-sullarchitettura/</guid>
      <description>Ripasso Prox: 30 Ripasso: June 1, 2023 Ultima modifica: April 16, 2023 12:33 PM Primo Abbozzo: February 23, 2023 5:13 PM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso Chiedi chiarimenti sul perché è necessario avere stack separati per la gestione di interrupt multipli annidati. Non basterebbe aggiungere sulla stack che ho già? Poi quando finisco l’interrupt elimino quanto mi ha aggiunto l’ultimo interrupt, e la roba vecchia c’è ancora. Note sull’architettura Interrupt Descrizione iniziale 🟩 Di interrupt e trap se n’è parlato un pò in Livello ISA di architettura, ora andiamo ad approfondire come viene gestito a livello SO.</description>
    </item>
    <item>
      <title>Cambio di Base e Autovalori</title>
      <link>https://flecart.github.io/notes/cambio-di-base-e-autovalori/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cambio-di-base-e-autovalori/</guid>
      <description>Ripasso Prox: 7 Ripasso: June 1, 2022 Ultima modifica: October 19, 2022 4:59 PM Primo Abbozzo: April 5, 2022 10:40 AM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
Elementi di ripasso 5 Cambio di base 5.1 Nozioni da avere prima di Cambio di Base Applicazioni lineari La definizione di applicazione lineare La matrice associata L&amp;rsquo;esistenza e unicità di una applicazione lineare rispetto a una base Le coordinate di un punto rispetto a una base.</description>
    </item>
    <item>
      <title>Magnetismo nella materia</title>
      <link>https://flecart.github.io/notes/magnetismo-nella-materia/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/magnetismo-nella-materia/</guid>
      <description>Analisi macroscopica Setting dell&amp;rsquo;esperimento 🟩 Provare a guardare 269 del Mazzoldi. (227 per la defivazione della forza.) Si può dimostrare che $$ \vec{F} = -\vec{\nabla} \cdot U \implies F = -\vec{\nabla}(\vec{m} \cdot \vec{B}) = \pm m \frac{dB}{dx} $$ La prima relazione si deriva da definizione di lavoro e forza. (esteso al caso di una forza applicata su spira che non è banale, facciamola brevemente).
Sappiamo che $U = - m \cdot B$, quindi è vero che $dW = -dU = i d \Phi (B)$ e poi utilizzando una proprietà del gradiente in Divergenza e Circuitazione abbiamo $$ Fds = dW = -dU = i \nabla \Phi(B) ds \implies F = i\nabla \Phi(B) = m \cdot \nabla B = -\nabla U $$ La cosa da notare è che per campi uniformi abbiamo che si può definire il lavoro.</description>
    </item>
    <item>
      <title>Optimization methods</title>
      <link>https://flecart.github.io/notes/optimization-methods/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/optimization-methods/</guid>
      <description>Metodi altri sono trovare una approssimazione facile da calcolare (simile all&amp;rsquo;approccio del modello surrogato credo). Ma nel nostro caso proviamo a trovare metodi di esplorare lo spazio dei parametri in modo intelligente.
Deterministic methods Sono utilizzabili quando ci sono delle proprietà come convessità, limitatezza, continuità.
Newton Raphson method Molte implementazioni in R usano questo metodo, è
Perfetto quando $h$ è quadratico, e in statistica molti problemi sono quadratici e funziona in modo perfetto Ma in cose non lineari si ha meno performance (perché l&amp;rsquo;hessiana è molto instabile per l&amp;rsquo;inversione, si dice che è mal condizionata, e si fa con attenzione.</description>
    </item>
    <item>
      <title>Spazi vettoriali (vecchio)</title>
      <link>https://flecart.github.io/notes/spazi-vettoriali-vecchio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/spazi-vettoriali-vecchio/</guid>
      <description>Ultima modifica: October 19, 2022 5:05 PM Primo Abbozzo: December 14, 2021 4:36 PM Studi Personali: No
Elementi di ripasso 0 pezzo di introduzione 0.1 Modi di vedere (3) Ci sono principalmente 3 modi di vedere l&amp;rsquo;algebra lineare.
Visione Colonna, visione riga e visione matriciale
(La seguente è una visione riga)
$$ 2x - y = 0 \\ -x + 2y = 3 $$ Questa cosa si può rappresentare in forma matriciale in questo modo:</description>
    </item>
    <item>
      <title>The Database Management System</title>
      <link>https://flecart.github.io/notes/the-database-management-system/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/the-database-management-system/</guid>
      <description>Struttura del DBMS Introduzione ai DBMS Schema riassuntivo #### Operazioni classiche Ci stiamo chiedendo, come facciamo a descrivere i processi che portano alla comprensione della query e della retrieval degli elementi utili? Questo deve fare il DBMS, ossia capace di - Aggiornare tuple - Trovare tuple - Gestire gli accessi - Gestire accessi concorrenti? ### Query processor #### Query compiler (3) 🟩 - Parsing (crea l&#39;albero di derivazione per la nostra query) - Pre-processing (fa check semantici sulla query) - Optimization, si occupa lui di migliorare L&#39;ottimizzazione #### Execution engine 🟩 Esegue l&#39;effettiva computazione per la query, ed è il punto d&#39;incontro col resto (indexes, e logging per dire) Esegue il piano di esecuzione che probabilmente un livello superiore ha calcolato Interagisce con tutti gli altri componenti del db (ad esempio Log per transazioni e durabilità, buffer e scheduler delle operazioni prolly).</description>
    </item>
    <item>
      <title>Condensatori nel vuoto</title>
      <link>https://flecart.github.io/notes/condensatori-nel-vuoto/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/condensatori-nel-vuoto/</guid>
      <description>Introduzione ai condensatori Analisi introduttiva condensatori: tubi di flusso 🟩 Consideriamo un **tubo di flusso infinitesimo** come in immagine. abbiamo che $dQ$ è la carica totale dentro al cubo. Tale che segua le linee di campo. Il flusso totale sarebbe $$ \oint_{\Sigma} \vec{E} \cdot d\vec{s} = \frac{Q_{T}}{\varepsilon_{0}} $$ Sappiamo anche che $$ \vec{E}_{1}d\vec{s}_{1} + \vec{E}_{2}d\vec{s}_{2} = \frac{dQ_{T}}{\varepsilon_{0}} $$ Ma scegliamo il cubo di flusso in modo che le superfici siano **perpendicolari al nostro campo**, e così posso considerare il problema da un puro punto di vista **scalare**.</description>
    </item>
    <item>
      <title>Cookie e autenticazione</title>
      <link>https://flecart.github.io/notes/cookie-e-autenticazione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cookie-e-autenticazione/</guid>
      <description>Ripasso: May 14, 2023 Ultima modifica: May 6, 2023 6:25 PM Primo Abbozzo: March 30, 2023 4:20 PM Studi Personali: No
Cookies Gli utilizzi più soliti sono per Autenticazione e per Autorizzazione, perché sono delle informazioni che il server genera e mette al client, come se fossero dei segreti cifrati.
Cookie Questi sono una estensione di netscape, che si appoggiano al protocollo HTTP per implementare certe funzionalità (soprattutto il fatto di essere stateless, quindi è utile per avere informazioni sugli stati su qualcosa.</description>
    </item>
    <item>
      <title>HTTP e REST</title>
      <link>https://flecart.github.io/notes/http-e-rest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/http-e-rest/</guid>
      <description>Ripasso Prox: 40 Ripasso: May 25, 2023 Ultima modifica: April 15, 2023 10:21 PM Primo Abbozzo: March 10, 2023 2:16 PM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso HTTP e REST HTTP HYPERTEXT-TRANSFER-PROTOCOL
Caratteristiche principali (3) 🟨 Slide caratteristiche
Comunicazioni fra client e server, e quanto sono comunicate le cose si chiude la connessione e ci sono politiche di caching molto bone (tipo con i proxy) Generico: perché è un protocollo utilizzato per caricare moltissime tipologie di risorse!</description>
    </item>
    <item>
      <title>Livello ISA</title>
      <link>https://flecart.github.io/notes/livello-isa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/livello-isa/</guid>
      <description>Ripasso Prox: 37 Ripasso: December 31, 2021 Ultima modifica: October 20, 2022 5:12 PM Primo Abbozzo: October 29, 2021 1:21 PM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso Vecchi dubbi Activation record Busy waiting e polling, priorita&amp;rsquo; interrupt 8 ISA livello il livello isa è il livallo delle istruzioni
8.1 Struttura Solitamente le istruzioni sono divise in due parti:
8.1.1 Opcode e indirizzamento Opcode
Questo opcode indica la tipologia di istruzione.</description>
    </item>
    <item>
      <title>Semplificazione grammatiche</title>
      <link>https://flecart.github.io/notes/semplificazione-grammatiche/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/semplificazione-grammatiche/</guid>
      <description>Ripasso Prox: 65 Ripasso: June 21, 2023 Ultima modifica: June 9, 2023 12:53 PM Primo Abbozzo: November 8, 2022 1:48 PM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso Domande
Semplificazione grammatiche Gestione del non determinismo Il modo più facile per gestire il non determinsmo è semplificare le grammatiche quindi andiamo a vedere metodi per fare ciò.
Semplificazione grammatiche (5) Slide
No produzioni del tipo $A \to \varepsilon$ per bottom up (altrimenti va all’infinito!</description>
    </item>
    <item>
      <title>Tecniche algoritmiche</title>
      <link>https://flecart.github.io/notes/tecniche-algoritmiche/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/tecniche-algoritmiche/</guid>
      <description>Ripasso Prox: 3 Ultima modifica: May 8, 2022 11:57 AM Primo Abbozzo: April 12, 2022 12:50 PM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
Elementi di ripasso 10 Tecniche Algoritmiche 13-DivideEtImpera.pdf
10.1 Divide et impera 10.1.1 Introduzione Abbiamo già visto L&amp;rsquo;utilizzo di questa tecnica per quick e merge sort in Algoritmi di ordinamento
Questa tecnica si focalizza in tre passi fondamentali:
Dividere il problema in sotto-problemi Risolvere il sotto-problema Mergiare le soluzioni di questi sotto-problemi.</description>
    </item>
    <item>
      <title>Architettura software dell’OS</title>
      <link>https://flecart.github.io/notes/architettura-software-dellos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/architettura-software-dellos/</guid>
      <description>Ripasso Prox: 22 Ripasso: June 6, 2023 Ultima modifica: May 23, 2023 10:19 PM Primo Abbozzo: March 1, 2023 10:07 AM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
Elementi di ripasso In teoria il ripasso era 28 maggio
Architettura software dell’OS A seconda dell&amp;rsquo;utilizzatore l’OS può essere molte cose, come solamente l’interfaccia se sei un programmatore, servizi (se sei un utente, ma gran parte dei servizi sono astratti e l&amp;rsquo;utente ne può anche essere a non-conoscenza).</description>
    </item>
    <item>
      <title>Gruppi</title>
      <link>https://flecart.github.io/notes/gruppi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gruppi/</guid>
      <description>Ripasso Prox: 15 Ripasso: July 1, 2022 Ultima modifica: July 7, 2022 4:00 PM Primo Abbozzo: March 20, 2022 3:44 PM Stato: 🌕🌕🌕🌑🌑 Studi Personali: No
Definizione gruppo Qualunque insieme più operazione tale per cui:
Esistenza dell&amp;rsquo;inverso per ogni elemento Esistenza di un elemento neutro Associatività. Unicità dell’elemento neutro Supponiamo di avere un gruppo $G$ e due elementi neutri $e, f$ Allora abbiamo che $ae = a = af$ però se moltiplichiamo per l&amp;rsquo;inversa abbiamo che $a^{-1}ae = a^{-1}af \implies e = f$</description>
    </item>
    <item>
      <title>Magnetismo</title>
      <link>https://flecart.github.io/notes/magnetismo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/magnetismo/</guid>
      <description>Introduzione ai campi magnetici Introduzione storica (non impo) 🟩 Il magnetismo è stato in primi osservato e documentato da Greci, che hanno osservato che materiali metallici come ferro, questo è successo in magnesia, una penisola dell&amp;rsquo;Asia minore, mentre elettro era più sull&amp;rsquo;ambra, che credo fosse il nome dato a quel materiale.
Una cosa nota era che se vicino a un materiale magnetico, venivano create linee con materiale ferroso all&amp;rsquo;estremità (limatura magnetica).</description>
    </item>
    <item>
      <title>Paginazione e segmentazione</title>
      <link>https://flecart.github.io/notes/paginazione-e-segmentazione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/paginazione-e-segmentazione/</guid>
      <description>Ripasso Prox: 36 Ripasso: June 6, 2023 Ultima modifica: May 9, 2023 10:02 PM Primo Abbozzo: March 23, 2023 1:29 PM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso Memoria sistema Operativo Guradare Memoria virtuale Per vedere come vengono rimpiazzate le pagine
In quest sezione andiamo a parlare di come fanno molti processi a venire eseguiti insieme, anche se lo spazio di memoria fisico è lo stesso. Andiamo quindi a parlare di spazio di indirizzi, risoluzione di questi indirizzi logici, segmentazione e paginazione.</description>
    </item>
    <item>
      <title>Applicazioni lineari</title>
      <link>https://flecart.github.io/notes/applicazioni-lineari/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/applicazioni-lineari/</guid>
      <description>Ripasso Prox: 27 Ripasso: June 2, 2022 Ultima modifica: January 4, 2023 9:54 AM Primo Abbozzo: March 22, 2022 9:19 AM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso 3 Applicazioni lineari 3.1 Introduzione e definizione Si definisce applicazione lineare una funzione (omomorfica) che preserva la struttura dello spazio vettoriale, ossia vale che
$$ f:V \to W, tale che \\ f(u + v) = f(u) +f(v)\\ f(\lambda v) = \lambda f(v) $$ 3.</description>
    </item>
    <item>
      <title>Bottom-up Parser LR(0)</title>
      <link>https://flecart.github.io/notes/bottom-up-parser-lr0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bottom-up-parser-lr0/</guid>
      <description>Ripasso Prox: 70 Ripasso: June 25, 2023 Ultima modifica: June 9, 2023 2:56 PM Primo Abbozzo: November 18, 2022 2:52 PM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
Elementi di ripasso Domande
Bottom up parser Descrivo ora alcune domande utili per ripasso:
Quali sono schematicmente quali sono le operazioni migliori per un parser top-down? Cosa è un prefisso viabile? Quali sono i conflitti possibli, e come risolverli… Non sai nemmeno definire inmodo formale cosa sia un item Bottom up Intro shift-reduce e LR 🟩 Slide</description>
    </item>
    <item>
      <title>CSP problems</title>
      <link>https://flecart.github.io/notes/csp-problems/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/csp-problems/</guid>
      <description>Ripasso Prox: 5 Ultima modifica: December 29, 2022 3:24 PM Primo Abbozzo: July 11, 2022 11:15 AM Stato: 🌕🌕🌑🌑🌑 Studi Personali: No
Elementi di ripasso Non ti ricordi le tecniche di backtracking belle per avere un buon CSP. 3 CSP Problems Costraint Satisfaction Problems.
Definizione Caratteristiche Variabili Dominio per ogni variabile Costraints per ogni variabile Queste tre sono elementi che definiscono un problema di soddisfazione delle restrizioni, una soluzione è un assegnamento di variabili che soddisfi ogni restrizioone e sia all’interno del dominio</description>
    </item>
    <item>
      <title>Fn Ordine superiore</title>
      <link>https://flecart.github.io/notes/fn-ordine-superiore/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/fn-ordine-superiore/</guid>
      <description>Ripasso Prox: 30 Ripasso: May 18, 2023 Ultima modifica: April 22, 2023 11:23 AM Primo Abbozzo: March 25, 2023 11:49 AM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso Fn Ordine superiore Questa parte è strettamente collegata conl a parte di Astrazione sul controllo.
Si parla di passare le funzioni come dati. e quindi possono essere passati come se fossero dei parametri.
un linguaggio di programmazione è di ordine superiore qualora ammetta funzioni sia come parametro che come risultato di altre funzioni.</description>
    </item>
    <item>
      <title>Nomi e Scope</title>
      <link>https://flecart.github.io/notes/nomi-e-scope/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/nomi-e-scope/</guid>
      <description>Ripasso Prox: 70 Ripasso: June 1, 2023 Ultima modifica: April 25, 2023 9:22 AM Primo Abbozzo: February 20, 2023 8:45 AM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso Nomi e Scope I Nomi e oggetti Oggetti denotati e identificatori🟩 I nomi sono sequenze di caratteri o numeri aka: token alfanumerico (anche IDENTIFICATORE (per token guardare Grammatiche Regolari) utilizzate principalmente come Astrazione sul controllo e sui dati (quindi sono cose molto più facili da ricordare rispetto il suo encoding binario o a indirizzi).</description>
    </item>
    <item>
      <title>Debugging</title>
      <link>https://flecart.github.io/notes/debugging/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/debugging/</guid>
      <description>Ultima modifica: February 25, 2023 2:07 PM Primo Abbozzo: November 9, 2021 3:00 PM Studi Personali: No
Il debugging è un ambito che interessa molto a Lanese perché è molto affine al suo ambito di ricerca.
Condizioni di correttezza Un programma di si dice corretto quando restituisce il valore voluto per ogni condizione di input
Esempi di programmi sbagliati Un programma che a volte si pianta e non va più. Un programma con cicli infiniti.</description>
    </item>
    <item>
      <title>Isomorfismi</title>
      <link>https://flecart.github.io/notes/isomorfismi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/isomorfismi/</guid>
      <description>Ripasso Prox: 4 Ripasso: April 30, 2022 Ultima modifica: June 29, 2022 9:42 AM Primo Abbozzo: March 22, 2022 9:19 AM Stato: 🌕🌕🌕🌑🌑 Studi Personali: No
Elementi di ripasso 3 Isomorfismi Gli isomorfismi sono delle proprietà fondamentali per stabilire una sorta di equivalenza fra i gruppi. Utilizziamo questi isomorfismi per parlare della stessa cosa ma in modi diversi.
3.1 Introduzione 3.1.1 Definizione Un gruppo si dice isomorfo rispetto ad un altro gruppo se, in paroloni semplici, esiste una funzione bigettiva tale che preservi l&amp;rsquo;operazione del gruppo.</description>
    </item>
    <item>
      <title>l’intelligenza</title>
      <link>https://flecart.github.io/notes/lintelligenza/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/lintelligenza/</guid>
      <description>Ripasso Prox: 30 Ultima modifica: January 26, 2023 10:03 PM Primo Abbozzo: June 28, 2022 8:53 AM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso August 22, 2022
1 Introduzione L’intelligenza artificiale è un campo in velocissima espansione, con già un mercato enorme di un trillion dollars.
Inoltre il suo campo di studi spazia da moltissimi campi, è per questo che quasi potresti considerarla universale.
1.1 L’intelligenza artificiale 1.1.1 Cosa è (2) Nel tempo si è cercato di definire con esattessa cosa sia l’intelligenza artificiale.</description>
    </item>
    <item>
      <title>Livello OS</title>
      <link>https://flecart.github.io/notes/livello-os/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/livello-os/</guid>
      <description>Ripasso Prox: 12 Ripasso: December 23, 2021 Ultima modifica: March 23, 2023 2:12 PM Primo Abbozzo: November 15, 2021 2:16 PM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso Vecchi dubbi Come funzionano esattamente gli algoritmi di paginazione? Quali sono i problemi principali della paginazione? Come funziona la MMU (ossia come faccio a trovare un indirizzo reale per ogni indirizzo virtuale?) 9 Livello sistema operativo 9.1 Caratteristiche Il sistema operativo non ha sempre avuto una interfaccia grafica.</description>
    </item>
    <item>
      <title>Logica Proposizionale</title>
      <link>https://flecart.github.io/notes/logica-proposizionale/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/logica-proposizionale/</guid>
      <description>Ripasso Prox: 20 Ripasso: December 14, 2021 Ultima modifica: September 30, 2022 3:19 PM Primo Abbozzo: November 5, 2021 9:19 AM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso Vecchi dubbi La funzione semantica vs funzione di interpretazione definizione di conseguenza logica ed equivalenza logica Le 3 caratteristiche della deduzione naturale Perché un sistema deduttivo è sintattico? 6 Logica proposizionale Con la logica proposizionale studiamo le denotazioni che hanno un valore di verità, ovvero deve essere una sentenza assertiva.</description>
    </item>
    <item>
      <title>Programmi Concorrenti</title>
      <link>https://flecart.github.io/notes/programmi-concorrenti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/programmi-concorrenti/</guid>
      <description>Ripasso Prox: 120 Ripasso: July 1, 2023 Ultima modifica: April 1, 2023 9:03 AM Primo Abbozzo: September 28, 2022 11:20 AM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
1 Programmazione concorrente Vorremmo cercare di stabilire una teoria riguardante programmi che vengono eseguiti appunto concorrentemente, senza una esecuzione classica uno dpo l’altro
Esempio mini-programma rallentamento
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;pthread.h&amp;gt; void test(void *s) { for (int i = 0; i &amp;lt; 10; i++) { printf(&amp;#34;%s\n&amp;#34;, s); for (int j = 0; j &amp;lt; 100000000; j++); } } int main(int argc, char *argv[]) { pthread_t t1, t2; pthread_create(&amp;amp;t1, NULL, (void *)test, &amp;#34;Uno&amp;#34;); pthread_create(&amp;amp;t2, NULL, (void *)test, &amp;#34;Due&amp;#34;); pthread_join(t1, NULL); pthread_join(t2, NULL); } Example output:</description>
    </item>
    <item>
      <title>Reti convoluzionali</title>
      <link>https://flecart.github.io/notes/reti-convoluzionali/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/reti-convoluzionali/</guid>
      <description>Abbiamo trattato i modelli classici in Convolutional NN. Con i vecchi files di notion
Il Kernel I punti interessanti delle immagini sono solamente i punti di cambio solo che attualmente siamo in stato discreto, quindi ci è difficile usare una derivata, si usano kernel del tipo: $\left[ 1, 0, -1 \right]$, che sarà positivo se cresce verso sinistra, negativo se scende. feature map Sono delle mappe che rappresentano alcune informazioni interessanti della nostra immagine.</description>
    </item>
    <item>
      <title>Metodi di Discesa</title>
      <link>https://flecart.github.io/notes/metodi-di-discesa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/metodi-di-discesa/</guid>
      <description>Ripasso Prox: 13 Ripasso: December 23, 2022 Ultima modifica: January 3, 2023 11:12 AM Primo Abbozzo: November 3, 2022 11:53 AM Stato: 🌕🌕🌕🌑🌑 Studi Personali: No
Elementi di ripasso Metodi di discesa Intro Generali sui metodi di discesa Vogliamo creare algoritmi che riescano a trovare i punti di minimo delle funzioni non vincolate.
In generale si trova un punto stazionario (condizioni necessarie) ma non è garantito lo stato ottimo.
Condizioni di arresto classiche (2) 🟩- Slide</description>
    </item>
    <item>
      <title>Model of Analogies</title>
      <link>https://flecart.github.io/notes/model-of-analogies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/model-of-analogies/</guid>
      <description>The human ability of making analogies proceeds in such a way as to keep complexity minimal.
Perché facciamo questo? Perché è la cosa più semplice da fare! Anche su Vapnik&amp;rsquo;s dimensions è simile questa idea!
Occam razor, Epicuro, con Solomonoff che ha risolto problema dell&amp;rsquo;induzione che Hume pensava di fare con abitudini. Attualmente IQ tests provano a misurare la capacità di estendere questo.
Analogia Studiamo l&amp;rsquo;analogia come oggetto matematico perché sembra essere una capacità molto difficile da generalizzare e utilizzare nelle macchine.</description>
    </item>
    <item>
      <title>Norme e Condizionamento</title>
      <link>https://flecart.github.io/notes/norme-e-condizionamento/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/norme-e-condizionamento/</guid>
      <description>Ripasso Prox: 30 Ripasso: December 24, 2022 Ultima modifica: January 9, 2023 3:28 PM Primo Abbozzo: September 28, 2022 4:34 PM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
Errore inerente Bisogna cercare di generalizzare il concetto di errore e lo si fa con la norma
Norma vettoriale È una funzione da $f: \mathbb{R}^n \to \mathbb{R}$ indicata con due barrette, questa funzione mi dà un concetto di distanza.
Proprietà della norma Si definisce una norma una funzione che soddisfa queste proprietà</description>
    </item>
    <item>
      <title>Sistem programming</title>
      <link>https://flecart.github.io/notes/sistem-programming/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/sistem-programming/</guid>
      <description>Ultima modifica: March 1, 2023 9:51 AM Primo Abbozzo: November 10, 2022 3:23 PM Studi Personali: No
Elementi di ripasso Argomento Execs execve runna e sostituisce
l è per list (credo variabili p adiche, invece che array terminato
Memoria Brk mappo gli indirizzi fisici con gli indirizzi logici.
data ci stanno sopra un pochettino alla fine.
heap sta in basso, mentre stack cresce a ritroso!!!
Ci stanno cose tipo la variabile globale.</description>
    </item>
    <item>
      <title>Spazi di probabilita</title>
      <link>https://flecart.github.io/notes/spazi-di-probabilita/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/spazi-di-probabilita/</guid>
      <description>Ripasso Prox: 40 Ripasso: May 29, 2023 Ultima modifica: April 29, 2023 10:09 AM Primo Abbozzo: June 5, 2022 3:43 PM Stato: 🌕🌕🌕🌕🌕 Studi Personali: Yes
Questi sono appunti che mi faccio durante lo studio individuale estivo per probabilità e statistica.
Introduzione La probabilità Termini Esito ed esperimenti aleatorio L’evento è quello che accade, mentre un esperimento aleatorio qualcosa di cui vogliamo andare a misurare la probabilità diciamo. Esperimento aleatorio: esperimento di cui non conosciamo il risultato con certezza.</description>
    </item>
    <item>
      <title>Goals of Distributed systems</title>
      <link>https://flecart.github.io/notes/goals-of-distributed-systems/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/goals-of-distributed-systems/</guid>
      <description>Ultima modifica: January 10, 2023 10:49 AM Primo Abbozzo: January 5, 2023 9:38 AM Studi Personali: No
Elementi di ripasso Dependable systems Introduzione Possiamo individuare alcune proprietà dei sistemi distribuiti. Però non siamo riusciti a renderli logicamente validi. Sono ancora un pò misti di linguaggio naturale e della sua ambiguità! Comunque possiamo ridurci per guardare quanto un sistema sia affidabile a guardare poche sue caratteristiche precise.
Caratteristiche fondamentali (4) Queste proprietà sono pensate naturalmente caratterizzanti dei sistemi.</description>
    </item>
    <item>
      <title>Introduzione a reti</title>
      <link>https://flecart.github.io/notes/introduzione-a-reti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-a-reti/</guid>
      <description>Ripasso Prox: 60 Ripasso: May 18, 2023 Ultima modifica: May 12, 2023 7:59 PM Primo Abbozzo: September 19, 2022 11:11 AM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso Vecchi ripassi Esempi di rete di calcolatori e non Metodi di valutazione della qualità della rete Il connettore di rete 0 Introduzione 0.1 Introduzione 0.1.1 Definizione di rete di calcolatori (2) 🟩- Slide
I requisiti sono principalmente 2
Essere autonomi nel calcolo (capacità di eseguire dei programmi) Essere interconnessi (capacità di ricevere ed inviare dei segnali) Gli scopi sono principalmente per la comunicazione fra utenti o calcolatori.</description>
    </item>
    <item>
      <title>Modelli Lineari di sviluppo</title>
      <link>https://flecart.github.io/notes/modelli-lineari-di-sviluppo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/modelli-lineari-di-sviluppo/</guid>
      <description>Introduzione ai modelli lineari Processi di sviluppo Definizione L’insieme strutturato di attività, eventi, documenti e procedure necessari per la costruzione di un sistema software
Cosa viene descritto (4) 🟩 Questo è proprio quanto vuole studiare l&amp;rsquo;ingegneria del software -&amp;gt; metodi di sviluppo, in modo da portare i migliori risultati possibile.
Nella formazione classica va a definire 4 concetti (soprattutto utili nel lavoro di gruppo, al fine di comunicare nella maniera più efficace):</description>
    </item>
    <item>
      <title>Polimorfismo</title>
      <link>https://flecart.github.io/notes/polimorfismo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/polimorfismo/</guid>
      <description>Ripasso Prox: 20 Ripasso: May 31, 2023 Ultima modifica: May 14, 2023 4:31 PM Primo Abbozzo: April 4, 2023 10:15 AM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
Elementi di ripasso Polimorfismo Introduzione Monoforfo 🟩 Quando non posso utilizzare un tipo come parametro. Ossia non possiamo definire una funzione generica.
Slide monomorfismo
Polimorfismo Polimorfismo, come dice il nome, significa avere tante forme, in questo caso tanti tipi. Ma avere tanti tipi non è una cosa ambigua?</description>
    </item>
    <item>
      <title>Preparazione esame logica</title>
      <link>https://flecart.github.io/notes/preparazione-esame-logica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/preparazione-esame-logica/</guid>
      <description>Ultima modifica: September 30, 2022 3:20 PM Primo Abbozzo: December 23, 2021 4:43 PM Studi Personali: No
Elementi di ripasso Perché la riduzione all’assurdo crea così tanti problemi alla logica intuizionista? Esercizi per induzione strutturale Concetti da ripassare Fare un esercizio di dimostrazione teoria degli insiemi con relazioni e funzioni in Relazioni fra insiemi Concetti da NON fare se NON fai l’orale Paradossi presentati in Logica meta-linguistica assiomi di regolarità o fondazione e rimpiazzamento in Teoria assiomatica degli insiemi Studiare le relazioni con l’infinito in Relazioni fra insiemi come Hilbert, diagonalizzazione, aleph, Cantor Costruzione di R.</description>
    </item>
    <item>
      <title>Probabilita condizionata e indipendenza</title>
      <link>https://flecart.github.io/notes/probabilita-condizionata-e-indipendenza/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/probabilita-condizionata-e-indipendenza/</guid>
      <description>Ripasso Prox: 40 Ripasso: May 31, 2023 Ultima modifica: May 3, 2023 8:04 AM Primo Abbozzo: February 28, 2023 12:24 PM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
Elementi di ripasso Probabilità condizionata e indipendente Condizionata Definizione 🟩 Andiamo a definire una probabilità di un evento $A$, condizionata a un evento non nullo $B$, come
$$ P(A|B) = \dfrac{P(A\cap B)}{P(B)} $$ Questo è la cosa fondamentale per poter considerare cose come bayes perché in questo modo abbiamo una certa relazione fra causa ed effetto e anche il contrario!</description>
    </item>
    <item>
      <title>Scheduler</title>
      <link>https://flecart.github.io/notes/scheduler/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/scheduler/</guid>
      <description>Ripasso Prox: 33 Ripasso: June 9, 2023 Ultima modifica: May 10, 2023 9:41 AM Primo Abbozzo: March 8, 2023 10:18 AM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso Scheduler Il suo scopo principale è gestire l&amp;rsquo;avvicendamento dei processi. Ad esempio sospendere il processo che chiede I/O. O un sistema time sharing, quando arriva un interrupt sul time.
Solitamente il nome scheduler è solamente un gestore dell&amp;rsquo;avvicendamento, si può quindi utilizzare per indicare scheduler di altro tipo.</description>
    </item>
    <item>
      <title>Storia del web</title>
      <link>https://flecart.github.io/notes/storia-del-web/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/storia-del-web/</guid>
      <description>Ultima modifica: February 24, 2023 2:04 PM Primo Abbozzo: February 24, 2023 1:33 PM Studi Personali: No
Un pò di storia Guerre dei browser Prima guerra ~1995
Fra netscape, una forma di rete (?) che poi viene ripresa da firefox da Mozilla, dopo che è stato mandato in bancarotta da Microsoft (che ha ancora con IE una grandissima fetta del mercato in questo primo periodo).
Secondo periodo di guerra ~2010</description>
    </item>
    <item>
      <title>Strutture di dati elementari</title>
      <link>https://flecart.github.io/notes/strutture-di-dati-elementari/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/strutture-di-dati-elementari/</guid>
      <description>Ripasso Prox: 45 Ripasso: June 3, 2022 Ultima modifica: April 30, 2022 10:30 AM Primo Abbozzo: March 7, 2022 4:15 PM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso Nella ricerca nella linked list non hai considerato il caso in cui l&amp;rsquo;input è NIL, così come anche nell&amp;rsquo;inserimento. Nella deletion non hai considerato il singolo elemento in lista. Anche in questo caso l&amp;rsquo;eliminazione in Testa ha dei problemi, non li hai considerati.</description>
    </item>
    <item>
      <title>Halting Theorem and Reducibility</title>
      <link>https://flecart.github.io/notes/halting-theorem-and-reducibility/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/halting-theorem-and-reducibility/</guid>
      <description>Halting theorem Questo è un problema fondamentale, che abbiamo trattato anche in Fondamenti teorica#Halting problem, ma qui lo ritrattiamo, perché così lo rifacciamo per bene. In parte è stato trattato anche al corso di Logica.
Enunciato Halting theorem Questo è molto simile a quanto presente sul (Sipser 2012). Ossia consideriamo il linguaggio $$ HALT = \left\{ \langle x, y \rangle : y = code(M),M \text{ si ferma su } x\right\} $$ Dimostrazione Halting theorem La parte del sì è facile perché basta eseguirlo e vedere che si ferma (quindi abbiamo una La macchina di Turing#La macchina di Turing universale.</description>
    </item>
    <item>
      <title>Inverse Transform</title>
      <link>https://flecart.github.io/notes/inverse-transform/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/inverse-transform/</guid>
      <description>How can we transform a uniform into a random variable? It is true that we have $$ F(x) = \int _{-\infty}^{x} f(t) \, dt $$ A volte la densità non è definita, mentre la funzione cumulativa lo è , per questo spesso cominciamo a definire partendo dalla definizione.
Suppose we have a $x \sim F_{X}(x)$ where $F$ is a cumulative distribution function, same thing, we just need to take the set, normal cumulative distribution function that we saw a lot in other courses.</description>
    </item>
    <item>
      <title>Livello di trasporto</title>
      <link>https://flecart.github.io/notes/livello-di-trasporto/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/livello-di-trasporto/</guid>
      <description>Ripasso Prox: 21 Ripasso: June 3, 2023 Ultima modifica: May 14, 2023 6:13 PM Primo Abbozzo: March 18, 2023 9:23 AM Stato: 🌕🌕🌕🌑🌑 Studi Personali: No
Elementi di ripasso Guardare la parte equivalente in Note Esame che è simile.
Livello di trasporto Si parla di livello logico di trasporto, ma gran parte ne abbiamo già parlato in Livello applicazione e socket di UDP, TCP e Socket. trasporto end-to-end, nel senso che livello traporto viene visto solamente ad inizio e alla fine, in tutti i nodi intermedi non è visto sto pacchetto.</description>
    </item>
    <item>
      <title>Memoria</title>
      <link>https://flecart.github.io/notes/memoria/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/memoria/</guid>
      <description>Ripasso Prox: 40 Ultima modifica: March 30, 2023 3:39 PM Primo Abbozzo: September 21, 2021 7:10 PM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi da ripassare Vecchi dubbi Principio di località e temporalità Le tipologie di raid November 29, 2021 9:22 PM 4 Memoria 4.1 Caratteristiche della Memoria La gerarchia della memoria, più si va giù più spazio si ha, più è lento il caricamento delle informazioni
4.1.1 Catalogazione della memoria Le tipologie di memoria sono presenti a fianco.</description>
    </item>
    <item>
      <title>Logica del Primo ordine</title>
      <link>https://flecart.github.io/notes/logica-del-primo-ordine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/logica-del-primo-ordine/</guid>
      <description>Logica del primo ordine Questa è la logica più utilizzata dai matematici
Limitatezza della logica proposizionale La logica proposizionale classica non è in grado di ragionare sull&amp;rsquo;infinito Fino ad ora abbiamo utilizzato una metalogica per giustificare il per ogni e l&amp;rsquo;esiste nelle dimostrazioni fin&amp;rsquo;ora.
Dobbiamo quindi dare una definizione più formale dei quantificatori.
Obiettivo della logica del primo ordine Si può quindi identificare come l&amp;rsquo;obiettivo della logica di primo ordine l&amp;rsquo;introduzione dei quantificatori dell&amp;rsquo;universale e dell&amp;rsquo;esiste</description>
    </item>
    <item>
      <title>Simplesso e B&amp;B</title>
      <link>https://flecart.github.io/notes/simplesso-e-bb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/simplesso-e-bb/</guid>
      <description>Ripasso Prox: 3 Ripasso: December 28, 2022 Ultima modifica: December 27, 2022 5:07 PM Primo Abbozzo: December 5, 2022 10:02 AM Stato: 🌕🌕🌑🌑🌑 Studi Personali: No
Elementi di ripasso Simplesso e branch n bound Algoritmo del simplesso Ricerca della direzione migliore Ricerca dello step Pseudocodice Slide
B sono gli indici di partenza, poi questi vengono aggiornati
In riga 5 vado a checkare se ho direzioni di crescita possibili, se è tutto positivo non ne ho.</description>
    </item>
    <item>
      <title>Sistemi Lineari e determinanti</title>
      <link>https://flecart.github.io/notes/sistemi-lineari-e-determinanti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/sistemi-lineari-e-determinanti/</guid>
      <description>Ripasso Prox: 20 Ripasso: June 3, 2022 Ultima modifica: October 19, 2022 5:00 PM Primo Abbozzo: March 31, 2022 11:17 AM Stato: 🌕🌕🌕🌕🌕 Studi Personali: No
Elementi di ripasso 4 Sistemi lineari e determinanti 4.1 Sistemi lineari La cosa buona è che possiamo analizzare il sistema lineare utilizzando tutti i teoremi che abbiamo sviluppato finora, quindi siamo molto più potenti per attaccare questo problema.
Definiamo un sistema lineare così
$Ax = b$ con A la matrice associata.</description>
    </item>
  </channel>
</rss>
