<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>X. Angelo Huang&#39;s Blog</title>
    <link>https://flecart.github.io/</link>
    <description>Recent content on X. Angelo Huang&#39;s Blog</description>
    <image>
      <title>X. Angelo Huang&#39;s Blog</title>
      <url>https://flecart.github.io/images/papermod-cover.png</url>
      <link>https://flecart.github.io/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <atom:link href="https://flecart.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Devices OS</title>
      <link>https://flecart.github.io/notes/devices-os/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/devices-os/</guid>
      <description>Devices Categorizzazione (6)🟨- Trasferimento dei dati Accesso al device sinfonia del trasferimento condivisone fra processi Velocità del trasferimento I/O direction (scrittura o lettura) Vediamo che molte caratteristiche sono riguardo il trasferimento
Slide categorizzazione I/O
Blocchi o caratteri 🟩- Slide devices blocchi o caratteri
Tecniche di gestione devices (4) 🟨- Buffering Possiamo mettere un buffer per favorire la comunicazione fra i devices. la cos amigliore che fa è creare maggiore efficienza. Un altro motivo è la velocità diversa di consumo.</description>
    </item>
    <item>
      <title>Javascript</title>
      <link>https://flecart.github.io/notes/javascript/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/javascript/</guid>
      <description>Javascript Obiettivo principale è esegurie codice clientside
Un pò di storia nato all’inizio della prima guerra dei browser (da netscape, explorer è in visual basic comunque non compatibile con JS) come il fratellino di java nel senso che runnava ovunque, attualmente è ECMAScript, ed è la versione migliore. (era pensato per fare microscript!)
ECMAScript quando è nato è il nucleo a tutte le implementazioni JS eseistenti fino a quel momento (che è stato molto caotico!</description>
    </item>
    <item>
      <title>Classical Cyphers</title>
      <link>https://flecart.github.io/notes/classical-cyphers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/classical-cyphers/</guid>
      <description>Introduzione a Crittografia al corso di crittografia di Christof Paar su Youtube, con aggiunte del corso Unibo.
Classifications and definitions Classification nowadays as many many applications like, and it’s a increasing important field
Cryptology (2) 🟩 La branca comunemente riferita come crittografia è divisa principalmente in due campi crittografia e cryptanalysis in cui una cerca di creare nuovi metodi per cifrare i messaggi, e l’altro prova ad attaccare questi messaggi ritrovando il messaggio originale.</description>
    </item>
    <item>
      <title>Dipolo elettrico</title>
      <link>https://flecart.github.io/notes/dipolo-elettrico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/dipolo-elettrico/</guid>
      <description>Questo problema è stato trattato in modo un po&amp;rsquo; più semplificato (nel caso in cui la carica era esattamente a metà in Campo elettrico#Dipolo elettrico). Questo problema è stato storico, utilizzato per analizzare l&amp;rsquo;atomo.
Potenziale del dipolo elettrico 🟩&amp;ndash; Per il principio di sovrapposizione possiamo affermare che $$ V(P) = V_{r^{+}} + V_{r^{-}} = \frac{q}{4\pi\varepsilon_{0}}\left( \frac{1}{r^{+}} - \frac{1}{r^{-}} \right) $$ Ora possiamo fare certe approssimazioni, supponendo che $r \gg a$ con $r$ la congiungente fra il centro del dipolo e il nostro punto e $a$ la distanza fra le cariche, possiamo affermare che $$ r^{+} - r^{-} = -a \cos \theta $$ Sappiamo che l&amp;rsquo;angolo è lo stesso (più o meno), perché sappiamo che i due reggi sono ora paralleli (come assunsione di semplificazione) Inoltre abbiamo che $r^{+}r^{-} = r^{2}$ perché il punto è molto lontano allora possiamo affermare che $$ \left( \frac{1}{r^{+}} - \frac{1}{r^{-}} \right) = \frac{a\cos \theta}{r^{2}} $$ a $$ V(P) = \frac{1}{4\pi\varepsilon_{0}}\frac{qa\cos \theta}{r^{2}} = \frac{1}{4\pi\varepsilon_{0}}\frac{P\cos \theta}{r^{2}} = \frac{1}{4\pi\varepsilon_{0}} \frac{\vec{P}\cdot \hat{r}}{r^{2}} $$ Direttamente proporzionale al momento di tipolo Inversamente proporzionale al quadrato del raggio.</description>
    </item>
    <item>
      <title>Introduction to Natural Language Processing</title>
      <link>https://flecart.github.io/notes/introduction-to-natural-language-processing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduction-to-natural-language-processing/</guid>
      <description>The landscape of NLP was very different in the beginning of the field.
&amp;ldquo;But it must be recognized that the notion &amp;lsquo;probability of a sentence&amp;rsquo; is an entirely useless one, under any known interpretation of this term 1968 p 53. Noam Chomsky.
Probability was not seen very well (Chomsky has said many wrong things indeed), and linguists were considered useless. Recently deep learning and computational papers are ubiquitous in major conferences in linguistics, e.</description>
    </item>
    <item>
      <title>Logistic Regression</title>
      <link>https://flecart.github.io/notes/logistic-regression/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/logistic-regression/</guid>
      <description>Queste note sono molto di base. Per cose leggermente più avanzate bisogna guardare Bayesian Linear Regression, Linear Regression methods.
Introduzione alla logistic regression Giustificazione del metodo Questo è uno dei modelli classici, creati da Minsky qualche decennio fa In questo caso andiamo direttamente a computare il valore di $P(Y|X)$ durante l&amp;rsquo;inferenza, quindi si parla di modello discriminativo.
Introduzione al problema Supponiamo che
$Y$ siano variabili booleane $X_{i}$ siano variabili continue $X_{i}$ siano indipendenti uno dall&amp;rsquo;altro.</description>
    </item>
    <item>
      <title>Measure Theory</title>
      <link>https://flecart.github.io/notes/measure-theory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/measure-theory/</guid>
      <description>Ultima modifica: September 18, 2022 9:43 AM Primo Abbozzo: September 16, 2022 9:52 AM Studi Personali: Yes
Elementi di ripasso Measure Theory Introduzione Requirements of the measure function Vorremmo cercare di estendere il concetto di misurabilità a gruppi molto più ampi di un singolo intervallo, vorrei creare una funzione che sia in grado di misurare degli insiemi. *su vedrà che sono impossibili).
Impossibilità di questi requirements (assurdo) Costruzione dell’insieme di interesse</description>
    </item>
    <item>
      <title>Neural Networks</title>
      <link>https://flecart.github.io/notes/neural-networks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/neural-networks/</guid>
      <description>Introduction: a neuron I am lazy, so I&amp;rsquo;m skipping the introduction for this set of notes. Look at Andrew Ng&amp;rsquo;s Coursera course for this part. Historical notes are (Rosenblatt 1958). One can view a perceptron to be a Log Linear Models with the temperature of the softmax that goes to 0 (so that it is an argmax). Trained with a stochastic gradient descent with a batch of 1 (this is called the perceptron update rule).</description>
    </item>
    <item>
      <title>Simplesso e B&amp;B</title>
      <link>https://flecart.github.io/notes/simplesso-e-bb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/simplesso-e-bb/</guid>
      <description>Algoritmo del simplesso Ricerca della direzione migliore Ricerca dello step Pseudocodice Slide
B sono gli indici di partenza, poi questi vengono aggiornati
In riga 5 vado a checkare se ho direzioni di crescita possibili, se è tutto positivo non ne ho.
in riga 6, si sceglie il più piccol per evitare loop.
L&amp;rsquo;idea in generale va in questo modo
Cerco di trovare il duale e confrontarlo con la x attuale Se sono uguali, allora ho trovato l’ottimo ed esco Altrimenti cerco una direzione di crescita che sia anche ammissibile Continuo fino a trovare un vertice, se ho il vertice allora mi muovo lì e riapplico, altrimenti è illimitata, se non esiste un vertice.</description>
    </item>
    <item>
      <title>Uniform Resource Identifier</title>
      <link>https://flecart.github.io/notes/uniform-resource-identifier/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/uniform-resource-identifier/</guid>
      <description>URI Sono stata LA vera invenzione di Berners Lee accennati in Storia del web. Il problema è avere un modo per identificare una risorsa in modo univoco sull’internet.
Introduzione La risorsa 🟩 Una risorsa è qualunque struttura che sia oggetto di scambio tra applicazioni all’interno del World Wide Web.
Ora una risorsa può essere qualunque cosa, non solamente solo un file! Quindi è agnostico rispetto a contenuto oppure metodo di memorizzazione del dato, appare anche in questo ambiente importante vedere quanto siano importanti standard che permettano una comunicazione</description>
    </item>
    <item>
      <title>Calcolo differenziale</title>
      <link>https://flecart.github.io/notes/calcolo-differenziale/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/calcolo-differenziale/</guid>
      <description>10.1 Derivata parziale La derivata vuole descrivere quanto varia una funzione al variare dell&amp;rsquo;input. Ma ora siamo in più dimensioni, quindi vogliamo descrivere il variare dell&amp;rsquo;input come il variare della distanza euclidea
$\dfrac{\delta f}{\delta x}(x,y) = \lim _{h \to 0} \dfrac{f(x + h, y) - f(x, y)}{h}$ ovvero sto facendo variare solamente una variabile (la y in questo caso è come se fosse una costante!?) Questo è un rapporto incrementale su una direzione.</description>
    </item>
    <item>
      <title>Deblur di immagini</title>
      <link>https://flecart.github.io/notes/deblur-di-immagini/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/deblur-di-immagini/</guid>
      <description>Origini di sfocatura &amp;lt;img src=&amp;quot;/images/notes/image/universita/ex-notion/Immagini/Untitled.png&amp;quot; alt=&amp;quot;image/universita/ex-notion/Immagini/Untitled&amp;quot;&amp;gt; Rumore causata da problemi fisici che sono errori di lettura del segnale analogico Questo si indica anche come errore gaussiano bianco e si può considerare additivo. Rumore causato dalla digitalizzazione, quindi dalla discretizzazione di essa. Slide formalizzazione errori per sfocatura
Point spread function Un unico pixel bianco sembra influenzare il suo ambiente nero, come in immagine
Vorremmo utilizzare delle funzioni ce siano in grado di approssimare questa funzione.</description>
    </item>
    <item>
      <title>Minimi quadrati</title>
      <link>https://flecart.github.io/notes/minimi-quadrati/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/minimi-quadrati/</guid>
      <description>Note matematiche introduttive Vettori ortonormali 🟩 Questa parte è fatto molto meglio in Inner product spaces.
Due vettori si dicono ortonormali se $vv^T = ||v|| = 1$ e sono ortogonali, ossia $v_i v^T_j = 0$ con i e j diversi fra di loro
Matrici ortogonale (4) 🟩- Matrici si dicono ortonomali se le sue colonne sono vettori sono ortonormali
Matrici ortonormali sono isometrie, cioè mantengono le distanze. Queste matrici sono tutte non singolari e quadrate per definizione La sua inversa è ortogonale La sua inversa è uguale alla trasposta slide Proprietà matrice ortonormale</description>
    </item>
    <item>
      <title>Paginazione e segmentazione</title>
      <link>https://flecart.github.io/notes/paginazione-e-segmentazione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/paginazione-e-segmentazione/</guid>
      <description>Memoria sistema Operativo Guradare Memoria virtuale Per vedere come vengono rimpiazzate le pagine
In quest sezione andiamo a parlare di come fanno molti processi a venire eseguiti insieme, anche se lo spazio di memoria fisico è lo stesso. Andiamo quindi a parlare di spazio di indirizzi, risoluzione di questi indirizzi logici, segmentazione e paginazione. (e molto di più!)
MMU Controlla se l’accesso di memoria è bono o meno. (traduzione fra indirizzo logico e fisico)</description>
    </item>
    <item>
      <title>Teoremi Base Analisi</title>
      <link>https://flecart.github.io/notes/teoremi-base-analisi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/teoremi-base-analisi/</guid>
      <description>Def: Massimo minimo relativo (locale) Sia $x_{0} \in \mathcal{A}$ si dice punto di massimo relativo (o locale) se: $$ \exists r &gt; 0 : f(x) \leq f(x_{0}), \, \forall x \in \mathcal{A} \cap I_{r}(x_{0}) $$ Dove $I_{r}(x_{0}) = \left[ x_{0} -r, x_{0} + r \right]$, è un intorno
Def: Massimo minimo assoluto Sia $x_{0} \in \mathcal{A}$ si dice punto di massimo assoluto se vale $$ f(x) \leq f(x_{0}), \, \forall x \in \mathcal{A} $$ Fermat 6.</description>
    </item>
    <item>
      <title>Classi OOP</title>
      <link>https://flecart.github.io/notes/classi-oop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/classi-oop/</guid>
      <description>Introduzione a OOP Per la definizione di classe andare a guardare Object orientation, però lo ripeto in questa occasione, è solamente un modello su cui andare a costruire degli oggetti.
Capisaldi🟩 Incapsulazione Astrazione Ereditarietà Dispatch dinamico Costruttori 🟩- Il costruttore è un codice utilizzato per inizializzare correttamente lo stato interno. Le regole sono le stesse dei metodi sovraccaricati (dinamica per la chiamata, statica per il numero dei parametri che prende in input).</description>
    </item>
    <item>
      <title>Design patterns</title>
      <link>https://flecart.github.io/notes/design-patterns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/design-patterns/</guid>
      <description>Introduction to design patterns Introduzione personale 🟩 I design patterns sono simili a dei plug and play, ossia delle soluzioni che hanno funzionato bene in passato e che sono ora riutilizzati. Solitamente dovrebbe essere una abilità implicita, cioè un buon programmatore è in grado di fare senza pensarci, dovrebbe essere automatico. Infatti quando uno fa il design non lo fa esplitamente seguendo un certo modello, ma farlo solitamente risulta utile per guidare il processo.</description>
    </item>
    <item>
      <title>Tabular Reinforcement Learning</title>
      <link>https://flecart.github.io/notes/tabular-reinforcement-learning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/tabular-reinforcement-learning/</guid>
      <description>This note extends the content Markov Processes in this specific context.
A Classical Dilemma We have seen something similar also in Active Learning when we tried to model if we wanted to look elsewhere or go for the maximum value we have found. The dilemma under analysis is the explore-exploit dilemma: whether if we should just go for the best solution we have found at the moment, or look for a better one.</description>
    </item>
    <item>
      <title>Data Plane</title>
      <link>https://flecart.github.io/notes/data-plane/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/data-plane/</guid>
      <description>Introduzione Data or Control plane come fanno i router a fare forwarding dei pacchetti? e decidere come mandare? Come fanno a passare. Sono le tabelle di instradamento. Si può dire di end-to-end perché solamente il sender e receiver andranno a livello applicazione, e leggeranno le cose (se criptato veramente solo loro riescono a fare questo).
Funzioni principali Forwarding che in pratica è passare il pacchetto al successivo, è parte del data plane.</description>
    </item>
    <item>
      <title>Teoria assiomatica degli insiemi</title>
      <link>https://flecart.github.io/notes/teoria-assiomatica-degli-insiemi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/teoria-assiomatica-degli-insiemi/</guid>
      <description>2.1 Elementi di base 2.1.1 Definizione e caratteristiche Tutto è un insieme (su questo si basa la maggior parte della matematica) Efficace nella descrizione degli oggetti (infiniti è ez), ma non è efficiente nel calcolo in quanto non dà nessun indizio sul&amp;rsquo;implementazione in memoria o sul modo per calcolarlo, c&amp;rsquo;è solo una associazione Si può concludere che per l&amp;rsquo;informatico non serve a molto questa teoria, ma è la base per la matematica.</description>
    </item>
    <item>
      <title>Cammini</title>
      <link>https://flecart.github.io/notes/cammini/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cammini/</guid>
      <description>1.1 Il cammino minimo 1.1.1 Definizione e caratteristiche 1.1.2 Costi negativi Sono cose molto brutte
1.1.3 Cammino minimo semplice Costruzione di cammini minimi 1.2 Vertici 1.2.1 definizione distanza fra due vertici Costo del cammino minimo che li connette
Condizione di bellman Albero dei cammini minimi Rilassamento Definizione Si va a vedere dove non funziona la disuguaglianza triangolare, se localmente non funziona ovvero se per esempio succede $D_{xu} + \omega(u,y) &lt; D_{xy}$ per qualche vertice all&amp;rsquo;interno del grafo, so di per certo che la distanza $D_{xy}$ non è una distanza, quindi possiamo riassegnarla in modo che verifichi la disuguaglianza</description>
    </item>
    <item>
      <title>Condensatori con dielettrici</title>
      <link>https://flecart.github.io/notes/condensatori-con-dielettrici/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/condensatori-con-dielettrici/</guid>
      <description>introduzione ai dielettrici Esperimenti metalli e dielettrici 🟩 Verso gli anni del 1840 Faraday ha fatto molti sistematici esperimenti per scoprire come si comportava il potenziale e il campo elettrico di fronte a certi materiali. Sono stati principalmente posti delle sostanza (conduttrici o meno) in mezzo a lastre di condensatori, e hanno misurato come cambiava il potenziale elettrico fra le due lastre (che si può vedere attraverso il modo con cui cambiano sull&amp;rsquo;elettroscopio).</description>
    </item>
    <item>
      <title>Fisher&#39;s Linear Discriminant</title>
      <link>https://flecart.github.io/notes/fishers-linear-discriminant/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/fishers-linear-discriminant/</guid>
      <description>Fisher&amp;rsquo;s Linear Discriminant is a simple idea used to linearly classify our data. The image above, taken from (Bishop 2006), is the summary of the idea. We want to maximize the distance from the centers, while minimizing the interclass variance. Let&amp;rsquo;s consider these two classes of points and let&amp;rsquo;s set $$ m_{j} = \frac{1}{N_{j}}\sum_{i : y_{i} = j} x_{i} $$ Which is just the mean of our cluster. Then if we consider a linear projection with $w$ the projected mean would be $w^{T}m_{j}$ over every class $j$.</description>
    </item>
    <item>
      <title>Fondamenti teorica</title>
      <link>https://flecart.github.io/notes/fondamenti-teorica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/fondamenti-teorica/</guid>
      <description>https://virtuale.unibo.it/pluginfile.php/1295166/mod_resource/content/0/Lez18-Gorrieri.pdf
Halting problem Questo asserisce che non esiste nessun programma che sia in grado di decidere la terminazione di un altro programma
Questo è un problema che ci è interessante perché vorremmo costruire un compilatore che sia in grado di osservare tutti gli errori possibili del programma. Come vedremo tra poco la risposta sarà negativa.
Dimostrazione tesi 🟨++ Supponiamo che questo programma esista, lo chiamiamo check(P) che restituisce 0 se termina 1 se non termina, allora devo poter essere in grado di scrivere un programma di questo genere</description>
    </item>
    <item>
      <title>Introduzione a reti</title>
      <link>https://flecart.github.io/notes/introduzione-a-reti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-a-reti/</guid>
      <description>Questa nota raccoglie note introduttive al corso di reti dei calcolatori fatto all&amp;rsquo;università di Bologna.
0.1.1 Definizione di rete di calcolatori (2) 🟩- I requisiti sono principalmente 2
Essere autonomi nel calcolo (capacità di eseguire dei programmi) Essere interconnessi (capacità di ricevere ed inviare dei segnali) Gli scopi sono principalmente per la comunicazione fra utenti o calcolatori.
Non-esempi
Rete telefonica, non sono autonomi Rete televisiva Esempi
Smartphones con wi-fi WWW E-mail Una rete di calcolatori è un insieme di dispositivi autonomi, cioè in grado di eseguire e svolgere autonomamente i compiti programmati di calcolo e di comunicazione, interconnessi tra loro da supporti fisici alla trasmissione di segnali.</description>
    </item>
    <item>
      <title>Introduzione ad architettura</title>
      <link>https://flecart.github.io/notes/introduzione-ad-architettura/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-ad-architettura/</guid>
      <description>1.1 Il principio di astrazione/implementazione Astrazione per macchine livello n con linguaggi n.
1.2 I livelli principali di astrazione Livelli in breve
1.2.1 Livello 0 Qua è utile indagare la
Porte Logiche in cui si indagano in un modo molto alto il funzionamento di porte
È il livello fisico delle porte logiche e dell&amp;rsquo;ingegneria elettrica.
1.2.2 Livello 1 Link utili potrebbero essere la CPU e storia degli elaboratori
Circuiti Sequenziali Ossia la Memoria</description>
    </item>
    <item>
      <title>Livello di trasporto</title>
      <link>https://flecart.github.io/notes/livello-di-trasporto/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/livello-di-trasporto/</guid>
      <description>Livello di trasporto Si parla di livello logico di trasporto, ma gran parte ne abbiamo già parlato in Livello applicazione e socket di UDP, TCP e Socket. trasporto end-to-end, nel senso che livello traporto viene visto solamente ad inizio e alla fine, in tutti i nodi intermedi non è visto sto pacchetto.
UDP (3) 🟩- Slide UDP
Classico inizio e fine porta del socket. Lunghezza, si può vedere che massimo è 2 alla 16, e poi il checksum per vedere se è comunicato bene.</description>
    </item>
    <item>
      <title>Modelli AGILE</title>
      <link>https://flecart.github.io/notes/modelli-agile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/modelli-agile/</guid>
      <description>Socialità dello sviluppo del software (3) 🟨- Si assume che
È difficile assegnarsi i compiti, bisogni di utenti, tempi di consegna (+ persone difficile) È facile scrivere software (almeno software classico, e non computazione scientifica) La gente sia brava tecnicamente che socialmente è una cosa rara VS Waterfall (3) 🟨++ Pianificare tutto come viene descritto nel modello del waterfall non è possibile. Per i seguenti motivi
Non è chiaro cosa vuole l&amp;rsquo;utente finale (quindi sarebbe meglio avere feedback continuo).</description>
    </item>
    <item>
      <title>Spettrometri di massa</title>
      <link>https://flecart.github.io/notes/spettrometri-di-massa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/spettrometri-di-massa/</guid>
      <description>Particelle in campi magnetici Moto in campo magnetico uniforme 🟩 Se abbiamo una particella carica con velocità uniforme in campo magnetico uniforme, come abbiamo detto in precedenza, una forza centripeta, questo farà curvare la carica, una cosa interessante sarebbe provare a capire raggio di curvatura della nostra carica. Sotto in immagine abbiamo l&amp;rsquo;esempio di curvatura. $$ F = qvB= ma = \frac{mv^{2}}{r} \implies r = \frac{mv^{2}}{qvB} = \frac{mv}{qB} = \frac{p}{qB} $$ Dove $p$ è la quantità di moto, quantità che credo sia relazionata al lavoro ed inerzia, parte di fisica 1 che non ho studiato da più di due anni.</description>
    </item>
    <item>
      <title>Wide Column Storage</title>
      <link>https://flecart.github.io/notes/wide-column-storage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/wide-column-storage/</guid>
      <description>We now start with data modelling after having dealt with the syntax in HTML e Markup and data storage methods in Cloud Storage and Distributed file systems. In this case we want the data to be denormalized (see Normalizzazione dei database) but still looking like tables.
Usage of Wide Column Storages Wide column stores were invented to provide more control over performance and in particular, in order to achieve high-throughput and low latency for objects ranging from a few bytes to about 10 MB, which are too big and numerous to be efficiently stored as so-called clobs (character large objects) or blobs (binary large objects) in a relational database system, but also too small and numerous to be efficiently accessed in a distributed file system.</description>
    </item>
    <item>
      <title>Astrazione sul controllo</title>
      <link>https://flecart.github.io/notes/astrazione-sul-controllo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/astrazione-sul-controllo/</guid>
      <description>Significato di astrazione L&amp;rsquo;astrazione è una cosa fondamentale nell&amp;rsquo;informatica, l’abbiamo visto anche nella prima lezione in assoluto per architettura, il sistema a strati di Architettura e livelli 1, 2 reti e simili.
Il principali metodi sono astrazioni sul controllo e sui dati sui dati stiamo cominciando a parlarne in Teoria dei Tipi.
Le astrazioni sono utili a nascondere dettagli per qualche fenomeno o simile (ricorda l&amp;rsquo;esempio della mappa, che non è il territorio è una astrazione su essa, che contiene ancora informazioni utili).</description>
    </item>
    <item>
      <title>Divergenza e Circuitazione</title>
      <link>https://flecart.github.io/notes/divergenza-e-circuitazione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/divergenza-e-circuitazione/</guid>
      <description>Scalare Scalare e gradiente 🟩 Un campo scalare assegna a ogni punto dello spazio un valore reale, quindi è naturalmente rappresentabile tramite una funzione $$ \varphi(x, y, z) : \mathbb{R}^{3} \to \mathbb{R} $$ Un esempio abbastanza naturale è il gradiente del valore scalare che si indica con $$\vec{\nabla}\varphi = ( \frac{\delta\varphi}{\delta x}, \frac{\delta\varphi}{\delta y}, \frac{\delta\varphi}{\delta z}) = \frac{\delta\varphi}{\delta x} \hat{i} + \frac{\delta\varphi}{\delta y} \hat{j} + \frac{\delta\varphi}{\delta z} \hat{k}$$ Se consideriamo il gradiente da solo è un campo vettoriale (dice la direzione della derivata multidimensionale).</description>
    </item>
    <item>
      <title>k-esimo priority-q DSU</title>
      <link>https://flecart.github.io/notes/k-esimo-priority-q-dsu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/k-esimo-priority-q-dsu/</guid>
      <description>Questo documento è totalmente concentrato sull&amp;rsquo;analisi del problema della selezione del k-esimo elemento.
7.1 Introduzione al problema Dato un array di elementi vogliamo cercare di trovare un modo efficiente per selezionare il k-esimo elemento, ossia un elemento che sia maggiore di k-1 elementi
7.1.1 Note sull&amp;rsquo;utilizzo Questo algoritmo è utile per esempio per sapere cosa displayare in una pagina di ricerca, perché per esempio posso avere blocchi di tanta roba 140k, mentre ovviamente posso selezionare solamente un blocco ristretto.</description>
    </item>
    <item>
      <title>Leggi di Ohm</title>
      <link>https://flecart.github.io/notes/leggi-di-ohm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/leggi-di-ohm/</guid>
      <description>Gli argomenti della lezione 31 Ottobre sono circa da pagina 164 fino a 185 del mazzoldi.
Leggi di Ohm Introduzione microscopica 🟩 Sappiamo che $$ \vec{J} = -n e \vec{v}_{d} ne^{2} t \frac{\vec{E}}{m} $$ Vedi analisi della velocità di deriva col modello del 1900 in Corrente Elettrica.
Dove abbiamo utilizzato la definizione di densità di corrente e la velocità fra collisioni ed altre Questo è una motivazione per considerare la densità di corrente come se fosse nello stesso verso.</description>
    </item>
    <item>
      <title>Semirings</title>
      <link>https://flecart.github.io/notes/semirings/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/semirings/</guid>
      <description>Semirings allow us to generalize many many common operations. One of the most powerful usages is the algebraic view of dynamic programming.
Definition of a semiring A semiring is a 5-tuple $R = (A, \oplus, \otimes, \bar{0}, \bar{1})$ such that.
$(A, \oplus, \bar{0})$ is a commutative monoid $(A, \otimes, \bar{1})$ is a monoid $\otimes$ distributes over $\oplus$. $\bar{0}$ is annihilator for $\otimes$. Monoid Let $K, \oplus$ be a set and a operation, then:</description>
    </item>
    <item>
      <title>Sentiment Analysis</title>
      <link>https://flecart.github.io/notes/sentiment-analysis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/sentiment-analysis/</guid>
      <description>Sentiment analysis is one of the oldest tasks in natural language processing. In this note we will introduce some examples and terminology, some key problems in the field and a simple model that we can understand by just knowing Backpropagation Log Linear Models and the Softmax Function.
We say:
Polarity: the orientation of the sentiment. Subjectivity: if it expresses personal feelings. See demo
Some applications: Businesses use sentiment analysis to understand if users are happy or not with their product.</description>
    </item>
    <item>
      <title>Analisi multi-variabile</title>
      <link>https://flecart.github.io/notes/analisi-multi-variabile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/analisi-multi-variabile/</guid>
      <description>In questo capitolo cerchiamo di andare oltre alla singola dimensione per l&amp;rsquo;analisi.
Lo spazio $\mathbb{R}^{n}$ Possiamo definire uno spazio Rn come il prodotto cartesiano fra l&amp;rsquo;insieme R un numero di volte uguale a n $\mathbb{R} \times \mathbb{R} \times ... \times\mathbb{R} = \mathbb{R}^n$
Allora un tipico elemento in Rn è nella forma $(x_1,...,x_n)$, questo elemento si chiama punto, mentre gli elelmenti in R che costituiscono questo elemento si chiamano componenti.
Osservazione La maggior parte dei risultati che dimostro nello spazio ordinario (R3) si può dimostrare per Rn, non andiamo più nel dettaglio perché i problemi che ho in spazi maggiori sono parte di materiale per analisi 2</description>
    </item>
    <item>
      <title>Cambio di Base</title>
      <link>https://flecart.github.io/notes/cambio-di-base/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cambio-di-base/</guid>
      <description>Nozioni da avere prima di Cambio di Base Applicazioni lineari La definizione di applicazione lineare La matrice associata L&amp;rsquo;esistenza e unicità di una applicazione lineare rispetto a una base Le coordinate di un punto rispetto a una base. Matrice del Cambio di Base Se ho due spazi vettoriali
Intuizione in $R$ Le coordinate dei punti in $R$ sono uguali a $V$ per le basi canoniche, ma questo vale solamente per $R$, ora vogliamo andare a dire una cosa più forte, il cambio di base Poi sarà importantissimo questa nozione, applicazione di base in ML è Principal Component Analysis.</description>
    </item>
    <item>
      <title>LR(k) e YACC</title>
      <link>https://flecart.github.io/notes/lrk-e-yacc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/lrk-e-yacc/</guid>
      <description>LR(k) Grammatiche LR(k) 🟩 Anche in questo caso proviamo a generalizzare il concetto dei pirmi k caratteri, in modo da generalizzare in qualche senso il concetto di LR(k), quindi andiamo a modificare la closure considerando ora first k
Per ricordarti come si calcolava first k, andare a guardare Top-down Parser
il problema che poi diventa pratico riguardo questo è l&amp;rsquo;impossibilità di gestire stringhe lunghezza k che sono una assurdità (esponenziale per la lunghezza)</description>
    </item>
    <item>
      <title>Markov Processes</title>
      <link>https://flecart.github.io/notes/markov-processes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/markov-processes/</guid>
      <description>Andiamo a parlare di processi Markoviani. Dobbiamo avere bene a mente il contenuto di Markov Chains prima di approcciare questo capitolo.
Markov property 🟩 Uno stato si può dire di godere della proprietà di Markov se, intuitivamente parlando, possiede già tutte le informazioni necessarie per predire lo stato successivo, ossia, supponiamo di avere la sequenza di stati $(S_n)_{n \in \mathbb{N}}$, allora si ha che $P(S_k | S_{k-1}) = P(S_k|S_0S_1...S_{k - 1})$, ossia lo stato attuale in $S_{k}$ dipende solamente dallo stato precedente.</description>
    </item>
    <item>
      <title>Softmax Function</title>
      <link>https://flecart.github.io/notes/softmax-function/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/softmax-function/</guid>
      <description>Softmax is one of the most important functions for neural networks. It also has some interesting properties that we list here. This function is part of The Exponential Family, one can also see that the sigmoid function is a particular case of this softmax, just two variables. Sometimes this could be seen as a relaxation of the action potential inspired by neuroscience (See The Neuron for a little bit more about neurons).</description>
    </item>
    <item>
      <title>Applicazioni lineari</title>
      <link>https://flecart.github.io/notes/applicazioni-lineari/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/applicazioni-lineari/</guid>
      <description>3.1 Introduzione e definizione Si definisce applicazione lineare una funzione (omomorfica) che preserva la struttura dello spazio vettoriale, ossia vale che
$$ f:V \to W, \text{ tale che } \\ f(u + v) = f(u) +f(v)\\, f(\lambda v) = \lambda f(v) $$ Vengono mantenute alcune caratteristiche principali. In modo simile si possono definire omomorfismi per tutte le altre strutture algebriche, la cosa importante è che lo spazio d&amp;rsquo;arrivo possieda ancora tutte le stesse operazioni.</description>
    </item>
    <item>
      <title>Clustering</title>
      <link>https://flecart.github.io/notes/clustering/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/clustering/</guid>
      <description>Gaussian Mixture Models This set takes inspiration from chapter 9.2 of (Bishop 2006). We assume that the reader already knows quite well what is a Gaussian mixture model and we will just restate the models here. We will discuss the problem of estimating the best possible parameters (so, this is a density estimation problem) when the data is generated by a mixture of Gaussians.
Remember that the standard multivariate Gaussian has this format: $$ \mathcal{N}(x \mid \mu, \Sigma) = \frac{1}{\sqrt{ 2\pi }} \frac{1}{\lvert \Sigma \rvert^{1/2} } \exp \left( -\frac{1}{2} (x - \mu)^{T} \Sigma^{-1}(x - \mu) \right) $$ Problem statement Given a set of data points $x_{1}, \dots, x_{n}$ in $\mathbb{R}^{d}$ sampled by $k$ Gaussian each with responsibility $\pi_{k}$ the objective of this problem is to estimate the best $\pi_{k}$ for each Gaussian and the relative mean and covariance matrix.</description>
    </item>
    <item>
      <title>Connettivi Logici, correttezza, variabili</title>
      <link>https://flecart.github.io/notes/connettivi-logici-correttezza-variabili/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/connettivi-logici-correttezza-variabili/</guid>
      <description>8.1 Dimostrazione teorema invarianza 8.1.1 Introduzione Basi: Due proposizioni sono equivalenti quando valgono sugli stessi mondi.
quindi $\forall v, \llbracket F \rrbracket ^v \equiv \llbracket G \rrbracket ^ v$.
Vogliamo dire che dati un buco presente in una proposizione, queste valgono sempre, sono in effetti equivalenti. Il buco la prendo come una variabile proposizionale. (riempire = rimpiazzare il buco)
8.1.2 Operazione di sostituzione Si può notare che ci sono 4 casi base, mentre le altre 4 sono per ricorsione strutturale.</description>
    </item>
    <item>
      <title>Explainability of CNN</title>
      <link>https://flecart.github.io/notes/explainability-of-cnn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/explainability-of-cnn/</guid>
      <description>Introduction Capire in che modo una rete convoluzionale ci può dare insight migliori su come funzionano questi networks.
Visualizzazione dei hidden layers Slide visualization
Potremmo fissare una immagine anche a caso, e modificare la x in modo che sia più simile a quanto vuole computare il neurone. In questo modo genero una immagine che generi una activation forte nel neuron trainato, e si potrebbe dire che sia il genere di immagine che viene generata da essa.</description>
    </item>
    <item>
      <title>Garbage Collection</title>
      <link>https://flecart.github.io/notes/garbage-collection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/garbage-collection/</guid>
      <description>On dangling pointers Tombstones 🟩 Slides tombstones
Quando alloco, alloco anche una tombstone, e tutti i riferimenti passano per quella. (quindi ho due dereference per l’accesso) quando vado a deallocare segno la tombstone come RIP, NULL.
Dopo molto tempo ho il problema del cimitero che diventa molto grande. Anche se non punta più a niente, il cimitero.
Keys and locks 🟩 Un pò di overhead in più dal punto di vista della memoria, che è doppio</description>
    </item>
    <item>
      <title>Hello World</title>
      <link>https://flecart.github.io/hello-world/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/hello-world/</guid>
      <description>First blog post</description>
    </item>
    <item>
      <title>HTTP e REST</title>
      <link>https://flecart.github.io/notes/http-e-rest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/http-e-rest/</guid>
      <description>HTTP is the acronym for HyperText Transfer Protocol.
Caratteristiche principali (3) 🟨 Comunicazioni fra client e server, e quanto sono comunicate le cose si chiude la connessione e ci sono politiche di caching molto bone (tipo con i proxy) Generico: perché è un protocollo utilizzato per caricare moltissime tipologie di risorse! Stateless, ossia non vengono mantenute informazioni su scambi vecchi, in un certo modo ne abbiamo parlato in Sicurezza delle reti quando abbiamo parlato di firewall stateless.</description>
    </item>
    <item>
      <title>Tecniche algoritmiche</title>
      <link>https://flecart.github.io/notes/tecniche-algoritmiche/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/tecniche-algoritmiche/</guid>
      <description>In questa nota andiamo a parlare in modo sommario (si impara probabilmente molto meglio con la pratica) di generali tipologie di approcci che esistono per affrontare problemi di tipo algoritmico.
Divide et impera Introduzione Abbiamo già visto L&amp;rsquo;utilizzo di questa tecnica per quick e merge sort in Algoritmi di ordinamento
Questa tecnica si focalizza in tre passi fondamentali:
Dividere il problema in sotto-problemi Risolvere il sotto-problema Mergiare le soluzioni di questi sotto-problemi.</description>
    </item>
    <item>
      <title>Autoencoders</title>
      <link>https://flecart.github.io/notes/autoencoders/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/autoencoders/</guid>
      <description>In questa serie di appunti proviamo a descrivere tutto quello che sappiamo al meglio riguardanti gli autoencoders Blog di riferimento Blog secondario che sembra buono
Introduzione agli autoencoders L&amp;rsquo;idea degli autoencoders è rappresentare la stessa cosa attraverso uno spazio minore, in un certo senso è la compressione con loss. Per cosa intendiamo qualunque tipologia di dato, che può spaziare fra immagini, video, testi, musica e simili. Qualunque cosa che noi possiamo rappresentare in modo digitale possiamo costruirci un autoencoder.</description>
    </item>
    <item>
      <title>Derivate</title>
      <link>https://flecart.github.io/notes/derivate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/derivate/</guid>
      <description>5.1 Geometria introduttiva 5.1.1 Tangente e pendenza Si può trovare la relazione fra la pendenza della retta e la tangente.
Possiamo analizzare la retta dal punto di vista analitico, della formula e si può dimostrare che data una retta nella forma $y = mx + q$ $m$ è la pendenza della retta.
5.1.2 Formula generale delle rette Dati qualunque due punti .$(x_1, y_1), (x_2, y_2)$ possiamo dire che la pendenza è esprimibile come</description>
    </item>
    <item>
      <title>Graph Databases</title>
      <link>https://flecart.github.io/notes/graph-databases/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/graph-databases/</guid>
      <description>We have first cited the graph data model in the Introduction to Big Data note. Until now, we have explored many aspects of relational data bases, but now we are changing the data model completely. The main reason driving this discussion are the limitations of classical relational databases: queries like traversal of a high number of relationships, reverse traversal requiring also indexing foreign keys (need double index! Index only work in one direction for relationship traversal, i.</description>
    </item>
    <item>
      <title>Introduzione alla probabilita</title>
      <link>https://flecart.github.io/notes/introduzione-alla-probabilita/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-alla-probabilita/</guid>
      <description>Note: Questo corso è troppo astratto. Più che probabilità tratta di teoria della Misura. Quindi affossato…
Link della serie: https://www.youtube.com/watch?v=172m7qVy_FQ&amp;amp;list=PLrb6X_RiBI94b6dzCx-QwM-r0aZpJyPxS
Campo (di probabilità) Nota:
2 e 3 ⇒ 4
2 e 4 ⇒ 3
Quindi 3 e 4 sono interscambiabili, e si potrebbe eliminare uno dei due.
Anche il fatto che il vuoto sia presente in F si può omettere. combinando 1 e 2 ottengo il vuoto (complementare dell’insieme che prenda tutto).</description>
    </item>
    <item>
      <title>Linguaggi Deterministici e DPDA</title>
      <link>https://flecart.github.io/notes/linguaggi-deterministici-e-dpda/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/linguaggi-deterministici-e-dpda/</guid>
      <description>DPDA Definizione (2)🟩 La definizione di DPDA è molto simile a quella trattata in Linguaggi liberi e PDA, con solo costraints sulla deterministicità, che si traducono in due condizioni:
Al massimo posso avere un risultato per ogni coppia di lettura e simbolo su stack Se ho una transizione senza leggere, posso avere solo quella Slide
Linguaggio libero deterministico Un linguaggio è libero deterministico se esiste un PDA che lo riconosce per stato finale.</description>
    </item>
    <item>
      <title>The Neuron</title>
      <link>https://flecart.github.io/notes/the-neuron/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/the-neuron/</guid>
      <description>La struttura del neurone Parti strutturali principali (2) 🟩 Possiamo identificare tre parti principali per quanto riguarda la struttura di un singolo neurone
Assoni che si occupano di mandare activation potential signal all&amp;rsquo;esterno, a comunicare con altre cellule. Il segnale che parte dall&amp;rsquo;assone inizia da una sezione che viene chiamato segmento iniziale. Dentriti che si occupano di ricevere segnali da altri neuroni. Gli assoni e dentriti non sono connessi, ma c&amp;rsquo;è un piccolo spazio in mezzo a questi che si chiama Synaptic cleft, (la scoperta di questo è stato di stupore, in passato pensavano che fosse una cosa continua il cervello, invece abbiamo qualche piccola unità discreta, scoperto con la colorazione d&amp;rsquo;argento metodi di Golgi) l&amp;rsquo;informazione in questo spazio pre e post sinaptico è gestito da neurotrasmettitori.</description>
    </item>
    <item>
      <title>Algorithmic Probability</title>
      <link>https://flecart.github.io/notes/algorithmic-probability/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algorithmic-probability/</guid>
      <description>&amp;ldquo;Information theory must precede probability theory, and not be based on it. By the very essence of this discipline, the foundations of information theory have a finite combinatorial character.&amp;rdquo; Kolmogorov, A. N. (1983). Combinatorial foundations of information theory and the calculus of probabilities.
Russian mathematical surveys, 38 (4), 29-40.
&amp;ldquo;it is clear that elements requiring an extremely large number of words for their definition should be considered as having an extremely low probability.</description>
    </item>
    <item>
      <title>Control Plane</title>
      <link>https://flecart.github.io/notes/control-plane/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/control-plane/</guid>
      <description>Tipologie di control plane La control plane è la parte al livello di rete che si occupa di riempire le tabelle di istradamento dei router. In questo caso si possono in generare dividere gli algoritmi in due grandi famiglie
Centralizzati, anche chiamati algoritmi LS( Link state) perché devono conoscere in che modo sono collegati i router fra di loro. Solitamente le SDN ossia software defined networking di cui abbiamo parlato in Data Plane utilizzano questi metodi, c&amp;rsquo;è un server centralizzato (che per ragioni di tolleranza può anche essere distribuito, però diciamo che è esterno al router la decisione) Distribuiti in cui nessuno ha informazioni complete sulla rete, ma è possibile scambiarsi informazioni sui vicini e congiungere così al percorso più breve.</description>
    </item>
    <item>
      <title>Corrente Elettrica</title>
      <link>https://flecart.github.io/notes/corrente-elettrica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/corrente-elettrica/</guid>
      <description>Introduzione alla corrente elettrica Considerazioni generali Elettroni liberi nei materiali Ricorda che è un reticolo cristallino, con un elettrone nell&amp;rsquo;ultimo orbitale poco legato, quindi facilmente ionizzabile, in cui gli elettroni si possono muovere facilmente, e abbiamo che $n \approx 8.5 \times 10^{28} \frac{e^{-}}{m^{3}}$ nel rame Per l&amp;rsquo;argento abbiamo 5.9 con stesso ordine di grandezza.
Velocità media elettroni senza campo elettrico 🟩 Se è isotropo, gli elettroni si muovo in generale a caso e la velocità media dipendente dall&amp;rsquo;eccitazione termica (in teoria cinetica dei gas è studiata sta cosa).</description>
    </item>
    <item>
      <title>Gruppi Normali</title>
      <link>https://flecart.github.io/notes/gruppi-normali/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gruppi-normali/</guid>
      <description>Introduzione Definizione normalità Test del sottogruppo normale Dimostrazione
Il gruppo quoziente L’importanza del gruppo normale è che quando esso vale, possiamo avere il gurppo fattore
Dimostrazione
!</description>
    </item>
    <item>
      <title>La macchina di Turing</title>
      <link>https://flecart.github.io/notes/la-macchina-di-turing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/la-macchina-di-turing/</guid>
      <description>Introduzione Note filosofiche (non impo) Bisogna in primo momento cercare di definire cosa è la computazione e cosa è un computer. Aristotele faceva la distinzione fra proprietà essenziali e accidentali. Quelle essenziali sono proprie dell&amp;rsquo;oggetto.
Una sedia può essere fatta di legno o di metallo, ma questa proprietà è accidentale, ovvero, essa rimane una sedia indipendentemente dal materiale di cui è fatta.
Solitamente in matematica si prova ad astrarre (vedi Astrazione sul controllo per nota generale sull&amp;rsquo;astrazione).</description>
    </item>
    <item>
      <title>Metodi di Discesa</title>
      <link>https://flecart.github.io/notes/metodi-di-discesa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/metodi-di-discesa/</guid>
      <description>Introduzione ai metodi di discesa. Generali sui metodi di discesa Vogliamo creare algoritmi che riescano a trovare i punti di minimo delle funzioni non vincolate.
In generale si trova un punto stazionario (condizioni necessarie) ma non è garantito lo stato ottimo.
Solitamente sono divisi in first order methods in cui viene considerata solamente la derivata prima della funzione. E cose di metodi superiori.
Condizioni di arresto classiche (2) 🟩- Slide</description>
    </item>
    <item>
      <title>Relazioni fra insiemi</title>
      <link>https://flecart.github.io/notes/relazioni-fra-insiemi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/relazioni-fra-insiemi/</guid>
      <description>Coppia ordinata Definizione di Kuratowsky Una coppia ordinata è definita dall&amp;rsquo;insieme
$$ \langle X, Y \rangle = \{X, \{X, Y\}\} $$ È quindi chiaro che due coppie ordinate sono uguali fra di loro nel caso in cui gli elementi sono uguali ma anche la loro posizione sono uguali
Teorema caratterizzazione delle coppie
Definizione di Wiener $$ (X,Y) := \{\{\{X\}, \varnothing\}, \{\{Y\}\}\} $$ Definizione di Hausdorff $$ (X,Y) := \{\{X, 1\}, \{X,2\}\} $$ Proprietà fondamentale coppie ordinate Due coppie ordinate si dicono uguali se e solo se il primo elemento dei due sono uguali e la stessa cosa per il secondo</description>
    </item>
    <item>
      <title>Apache Spark</title>
      <link>https://flecart.github.io/notes/apache-spark/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/apache-spark/</guid>
      <description>Apache Spark This is a new framework that is faster than MapReduce. It is written in Scala and has a more functional approach to programming. Spark extends the previous MapReduce framework to a generic distributed dataflow, properly modeled as a DAG.
Resilient distributed datasets&amp;rsquo; Lifecycle Resilient distributed datasets (RDD) are the unit data blocks of Apache Spark. These blocks are created, transformed and written back into the disk.
Resilient means that they remain in memory or on disk on a “best effort” basis, and can be recomputed if need be.</description>
    </item>
    <item>
      <title>Automi e Regexp</title>
      <link>https://flecart.github.io/notes/automi-e-regexp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/automi-e-regexp/</guid>
      <description>Per l’analisi lessicale vogliamo cercare di ricordare le parole legali all&amp;rsquo;interno di questo linguaggio e questo è fatto con i linguaggi regolari.
Introduzione a analizzatori lessicali Token 🟩 Struttura del token è fatto da due parti
Identificatore della classe del token Identificatore del valore del token Pattern e lessema ci sono direi boh Pattern e Lessema 🟩 I pattern sono una descrizione generale della forma dei valori di una classe di token.</description>
    </item>
    <item>
      <title>Calcolo di numeri finiti</title>
      <link>https://flecart.github.io/notes/calcolo-di-numeri-finiti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/calcolo-di-numeri-finiti/</guid>
      <description>1 Calcolo dei numeri finiti Il calcolo è numerico perché si differenzia rispetto a un calcolo normale perché è finito.
1.1 Errore nei calcoli 1.1.1 Tipologie di errore (5) 🟩 Errore di misura, dovuto alle imperfezioni dello strumento di misura dei dati del problema. Errore di troncamento, quando un procedimento infinito viene realizzato come procedimento finito. (esempio: calcolo del valore di una funzione tramite sviluppo in serie, perché dato che l’algoritmo deve essere finito, devo prima o poi interrompere il calcolo, ecco qui l’errore).</description>
    </item>
    <item>
      <title>Diffusion Models</title>
      <link>https://flecart.github.io/notes/diffusion-models/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/diffusion-models/</guid>
      <description>Diffusion is a physical process that models random motion, first analyzed by Brown when studying pollen grains in water. In this section, we will first analyze a simplified 1-dimensional version, and then delve into diffusion models for images, the ones closest to (Ho et al. 2020).
The Diffusion Process This note follows original Einstein&amp;rsquo;s presentation, here we have a simplifyed version.
Let&amp;rsquo;s suppose we have a particle at $t = 0$ at some position $i$.</description>
    </item>
    <item>
      <title>Grafi</title>
      <link>https://flecart.github.io/notes/grafi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/grafi/</guid>
      <description>Rappresentazione e terminologia Operazioni importanti
Definizione di grafo È un insieme di nodi e di archi. (prendili da insiemi corretti)
Metodi di rappresentazione Liste di incidenza In pratica numero tutti gli archi e storo il valore dell&amp;rsquo;arco incidente per ogni nodo. Diventa una tabella con una parte i nodi e l&amp;rsquo;altra gli archi. Avrò dei valori -1 e 1 che marcano partenza e arrivo. La cosa carina di questo metodo è che può essere generalizzata anche per Ipergrafi, in cui gli archi possono avere più di una partenza o arrivo.</description>
    </item>
    <item>
      <title>Hopital, Taylor, Peano</title>
      <link>https://flecart.github.io/notes/hopital-taylor-peano/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/hopital-taylor-peano/</guid>
      <description>7.1 De Hopital 7.1.1 Lemmi preliminari Questo lemma preliminare era già presente per la prova del teorema degli zeri
Questo lemma è molto interessante perché mette in relazione il finito (le successioni) con l&amp;rsquo;infinito (i reali) In molte dimostrazioni si dà per scontato questo lemma, ma è una sottigliezza importante che giustifica l&amp;rsquo;utilizzo di successioni per limiti reali. Ci permette di semplificare molto le dimostrazioni perché riusciamo a trattare le successioni molto meglio.</description>
    </item>
    <item>
      <title>Kalman Filters</title>
      <link>https://flecart.github.io/notes/kalman-filters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/kalman-filters/</guid>
      <description>Kalman Filters are defined as follows:
We start with a variable $X_{0} \sim \mathcal{N}(\mu, \Sigma)$, then we have a motion model and a sensor model:
$$ \begin{cases} X_{t + 1} = FX_{t} + \varepsilon_{t} &amp; F \in \mathbb{R}^{d\times d}, \varepsilon_{t} \sim \mathcal{N}(0, \Sigma_{x})\\ Y_{t} = HX_{t} + \eta_{t} &amp; H \in \mathbb{R}^{m \times d}, \eta_{t} \sim \mathcal{N}(0, \Sigma_{y}) \end{cases} $$ Inference is just doing things with the Gaussians. One can interpret the $Y$ to be the observations and $X$ to be the underlying beliefs about a certain state.</description>
    </item>
    <item>
      <title>Key Exchange protocols</title>
      <link>https://flecart.github.io/notes/key-exchange-protocols/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/key-exchange-protocols/</guid>
      <description>Metodi di key exchange
Trusted Key parties (sono come Certificate authorities studiati in Sicurezza delle reti) Merkle Puzzles DH protocol Trusted Third parties Squared Key problem Un problema abbastanza ovvio è che per storare le chiavi di tutti c&amp;rsquo;è una necessità $O(n^{2})$ on $O(n)$ users Se c&amp;rsquo;è un trusted key parties il numero delle chiavi si riduce di molto, ritorna ad essere lineare!
Protocols Toy Exchange protocol🟩 TTP = Trusted Third party (simile a quanto poi si avrà in Asymmetric Cryptography) Questa è la base del servizio di Kerberos!</description>
    </item>
    <item>
      <title>Limiti</title>
      <link>https://flecart.github.io/notes/limiti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/limiti/</guid>
      <description>Riguardare Successioni per avere primo attacco sui limiti
4.1 Limiti finiti al finito 4.1.1 Intorno sferico Dato l&amp;rsquo;insieme $\mathbb{R}$ si definisce l&amp;rsquo;intorno sferico aperto di $x \in \mathbb{R}$ di raggio $r \in \mathbb{R}$ l&amp;rsquo;insieme $I_r(x) = (x -r, x + r)$ questa nozione è molto importante per definire il limite. Lo useremo subito su un punto di accumulazione
4.1.2 Punto di accumulazione Un punto di accumulazione $x$ di un insieme $A \subseteq \mathbb{R}$ è un punto tale per cui mi posso avvicinare in modo indefinito in quel punto.</description>
    </item>
    <item>
      <title>Model-free Reinforcement Learning</title>
      <link>https://flecart.github.io/notes/model-free-reinforcement-learning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/model-free-reinforcement-learning/</guid>
      <description></description>
    </item>
    <item>
      <title>Monte Carlo Methods</title>
      <link>https://flecart.github.io/notes/monte-carlo-methods/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/monte-carlo-methods/</guid>
      <description>DI Law of Large Numbers e Central limit theorem ne parliamo in Central Limit Theorem and Law of Large Numbers. Usually these methods are useful when you need to calculate following something similar to Bayes rule, but don&amp;rsquo;t know how to calculate the denominator, often infeasible integral. We estimate this value without explicitly calculating that.
Interested in $\mathbb{P}(x) = \frac{1}{z} \mathbb{P}^{*}(x) = \frac{1}{Z} e^{-E(x)}$ Can evaluate E(x) at any x.</description>
    </item>
    <item>
      <title>Norme e Condizionamento</title>
      <link>https://flecart.github.io/notes/norme-e-condizionamento/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/norme-e-condizionamento/</guid>
      <description>Errore inerente Bisogna cercare di generalizzare il concetto di errore e lo si fa con la norma
Norma vettoriale È una funzione da $f: \mathbb{R}^n \to \mathbb{R}$ indicata con due barrette, questa funzione mi dà un concetto di distanza.
Proprietà della norma Si definisce una norma una funzione che soddisfa queste proprietà
$\lVert x \rVert \geq 0$ per ogni $x \in \mathbb{R}^{n}$ $\lVert x \rVert = 0 \iff x = 0$ $\lVert \alpha x \rVert = \lvert \alpha \rvert \lVert x \rVert$ per ogni $x \in \mathbb{R}^{n}$ e $\alpha \in \mathbb{R}$ Vale la disuguaglianza triangolare, ossia $\forall x, y \in \mathbb{R}^{n}, \lVert x + y \rVert \leq \lVert x \rVert + \lVert y \rVert$.</description>
    </item>
    <item>
      <title>Proximal Polixy Optimization</title>
      <link>https://flecart.github.io/notes/proximal-polixy-optimization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/proximal-polixy-optimization/</guid>
      <description>This documents attempts to briefly present the algorithm and some experiments found online about it. The following repo seems to be a good resource: here.
Usually, PPO is explained as an actor critic framework. This means there is an agent that acts on the environment, and then there is a critic that collects the feedback from the environment. The main idea about this framework is to select a policy that is similar, so that it is less probable that a bad policy, a very different policy from the original is selected.</description>
    </item>
    <item>
      <title>Requisiti e backlog del software</title>
      <link>https://flecart.github.io/notes/requisiti-e-backlog-del-software/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/requisiti-e-backlog-del-software/</guid>
      <description>Introduzione sui requisiti del software Note introduttive In linguaggio naturale (dizionario) 🟥+ Sono tutte le qualità necessarie per uno scopo ben determinato.
Secondo il prof. I requisiti sono dei desideri ossia ciò che idealmente vorresti riguardo qualcosa (nel nostro caso il software). Ma credo sia anche una tendenza italiana di fare le cose meglio possibile senza mai soddisfare tutto
Functional requirements 🟩 Sono ciò che permetterà di fare il sistema</description>
    </item>
    <item>
      <title>TLS-SSL protocol</title>
      <link>https://flecart.github.io/notes/tls-ssl-protocol/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/tls-ssl-protocol/</guid>
      <description>First time we talked about this was in Sicurezza delle reti#Protocollo SSL But that was a simple toy model.
Secure Socket Layer Secure socket Layer and TLS add security (see security principles in Theoretical Notions of Security) on the transport layers, whereas IPSec protocol adds it to the network level. So this works on a higher level of abstraction following the ISO OSI framework Architettura e livelli 1, 2#Livelli ISO/OSI.</description>
    </item>
    <item>
      <title>Anomaly Detection</title>
      <link>https://flecart.github.io/notes/anomaly-detection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/anomaly-detection/</guid>
      <description>Anomaly detection is a problem in machine learning that is of a big interest in industry. For example a bank needs to identify problems in transactions, doctors need it to see illness, or suspicious behaviors for law (no Orwell here). The main difference between this and classification is that here we have no classes.
Setting of the problem Let&amp;rsquo;s say we have a set $X = \left\{ x_{1}, \dots, x_{n} \right\} \subseteq \mathcal{N} \subseteq \mathcal{X} = \mathbb{R}^{d}$ We say this set is the normal set, and $X$ are our samples but it&amp;rsquo;s quite complex, so we need an approximation to say whether if a set is normal or not.</description>
    </item>
    <item>
      <title>Architettura e livelli 1, 2</title>
      <link>https://flecart.github.io/notes/architettura-e-livelli-1-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/architettura-e-livelli-1-2/</guid>
      <description>Perché a stack 🟩- Capire l’architettura significa capire la struttura (l’organizzazione) del nostro app e comprenderne i motivi (i sottoproblemi risolti) che ogni livello prova a risolvere
La soluzione che è stata individuata, e ha rappresentato uno dei principali cardini del successo delle reti e della nascita di Internet, è data dalla separazione delle classi di protocolli in livelli. La struttura dei livelli dei protocolli di rete prende il nome di architettura dei protocolli di rete.</description>
    </item>
    <item>
      <title>Cross Validation and Model Selection</title>
      <link>https://flecart.github.io/notes/cross-validation-and-model-selection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cross-validation-and-model-selection/</guid>
      <description>There is a big difference between the empirical score and the expected score; in the beginning, we had said something about this in Introduction to Advanced Machine Learning. We will develop more methods to better comprehend this fundamental principles.
How can we estimate the expected risk of a particular estimator or algorithm? We can use the cross-validation method. This method is used to estimate the expected risk of a model, and it is a fundamental method in machine learning.</description>
    </item>
    <item>
      <title>Gruppi ciclici e permutazioni</title>
      <link>https://flecart.github.io/notes/gruppi-ciclici-e-permutazioni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gruppi-ciclici-e-permutazioni/</guid>
      <description>Gruppi ciclici e permutazioni Il gruppo ciclico Definizione gruppo ciclico Abbiamo definito in Gruppi per la prima volta il significato di gruppo ciclico generato da un elemento del gruppo, questo insieme si è poi dimostrato essere un sottogruppo del gruppo
Un gruppo $G$ è chiamato ciclico se esiste un $a \in G$ tel per cui $$ G = \left\{ a^{n} \mid n \in \mathbb{Z} \right\} $$ Dove a è chiamato elemento generatore.</description>
    </item>
    <item>
      <title>Livello OS</title>
      <link>https://flecart.github.io/notes/livello-os/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/livello-os/</guid>
      <description>9.1 Caratteristiche Il sistema operativo non ha sempre avuto una interfaccia grafica.
9.1.1 In generale Principalmente è un gestore delle risorse come il disco, la CPU, l&amp;rsquo;output e l&amp;rsquo;input.
È qualcosa che si infrappone come interfaccia fra le applicazioni e quello che è presente sotto.
9.1.2 Ambiti principali 9.2 Paginazione Al programma non interessa se effettivamente è presente in memoria fisica questa quantità di memoria, si di solito basta sempre.</description>
    </item>
    <item>
      <title>Modulazione wireless</title>
      <link>https://flecart.github.io/notes/modulazione-wireless/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/modulazione-wireless/</guid>
      <description>Introduzione Digital modulation 🟨 Slide introduzione
Modulazione digitale: prendiamo un dato digitale e trasmesso con un segnale analogico, come le RF.
ASK: amplitude shift keying
FSK: frequency shift
PSK: phase shift
Questi sono i tre metodi principali, che dipendono dalle caratteristiche dell’onda descritte in Fisica del Wireless.
TRE CARATTERISTICHE
Power
Resistenza interferenze. (robustezza)
ANALOG MODULATION
Per modulare un segnale analogico si utilizzano principalemente AM o FM, amplitude o frequency modulation, raramente si utilizza PM.</description>
    </item>
    <item>
      <title>Network Address Translation</title>
      <link>https://flecart.github.io/notes/network-address-translation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/network-address-translation/</guid>
      <description>NAT Network address translation Introduzione Col il NAT possiamo avere tutto lo spazio degli IP di cui abbiamo bisogno, che però non sono esposti. All&amp;rsquo;esterno vengono esposte solamente l’IP del NAT.
Schema classico NAT
Quindi in breve
All&amp;rsquo;esterno è esposto solamente l&amp;rsquo;indirizzo del router, il router, a seconda della porta giusta, dà in risposta al computer giusto, quindi all&amp;rsquo;interno della nostra rete conosciamo tutti gli indirizzi IP giusti.
Addr translation table 🟩 Sembra che ad ogni richiesta ci sia una table di transizione all&amp;rsquo;interno del router che matcha porta → indirizzo locale corretto!</description>
    </item>
    <item>
      <title>On intuitive notions of probability</title>
      <link>https://flecart.github.io/notes/on-intuitive-notions-of-probability/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/on-intuitive-notions-of-probability/</guid>
      <description>This note will mainly attempt to summarize the introduction of some intuitive notions of probability used in common sense human reasoning. Most of what is said here is available here (Jaynes 2003).
Three intuitive notions of probability Jaynes presents some forms of inference that are not possible in classical first order or propositional logic, yet they are frequent in human common sense reasoning. Let&amp;rsquo;s present some rules and some examples along them:</description>
    </item>
    <item>
      <title>Randomness</title>
      <link>https://flecart.github.io/notes/randomness/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/randomness/</guid>
      <description>Introduzione alla Randomicità Questo è principalmente basato su (Li &amp;amp; Vitányi 2019) Capito 1.9 Sembra che la nozione di random sia alla fine una cosa molto profonda. Per esempio, un caso lampante che le definizioni non funzionano nel caso di numeri trascendenti è che catalogano i numeri di $\pi$ come se fossero casuali, mentre in realtà possono essere trovati mediante procedimenti precisi. È una distinzione filosoficamente molto interessante.
Alla fine sembra ci sia un link molto diretto con la crittografia, si può vedere (Stinson 2005).</description>
    </item>
    <item>
      <title>Rappresentazione della conoscenza</title>
      <link>https://flecart.github.io/notes/rappresentazione-della-conoscenza/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/rappresentazione-della-conoscenza/</guid>
      <description>Questo è stato un capitolo molto vasto, che andava in certi punti a toccare la filosofia, la fisica. Un aspetto, quello di codifica delle informazioni reali in un ambiente logico (che per quanto i miei pregiudizi siano, ritengo una cosa molto impossibile, molto limitata e altrettanto impossibile). Si tratta dello studio della logica per rappresentazione di conoscenza.
Fatto sta che mi sembra assurdamente teorico tanto da non aver nessun utilizzo (probabilmente mi sbaglio di grosso), e che sia roba da filosofi.</description>
    </item>
    <item>
      <title>Algebra Logica</title>
      <link>https://flecart.github.io/notes/algebra-logica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algebra-logica/</guid>
      <description>Strutture algebriche Differenza matematica e informatica Una osservazione per quanto riguarda la logica intuizionista è che sta a metà fra matematica e informatica perché la dimostrazione intuizionista possiede in sé un algoritmo e una struttura di dati.
Infatti di solito l&amp;rsquo;informatico scrive senza fare la dimostrazione dell&amp;rsquo;algoritmo mentre il matematico scrive la dimostrazione senza fare l&amp;rsquo;algoritmo (inoltre può definire degli enti ed oggetti che non siano rappresentabili come dati in quanto possono essere infiniti.</description>
    </item>
    <item>
      <title>Circuit Motifs</title>
      <link>https://flecart.github.io/notes/circuit-motifs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/circuit-motifs/</guid>
      <description>Work like (Luo 2021) show that our brain has naturally some types of circuits, which can be classified mainly as 4 types as described in (Wang et al.):
References [1] Luo “Architectures of Neuronal Circuits” Science Vol. 373(6559), pp. eabg7285 2021
[2] Wang et al. “CircuitNet: A Generic Neural Network to Realize Universal Circuit Motif Modeling”</description>
    </item>
    <item>
      <title>CPU e storia degli elaboratori</title>
      <link>https://flecart.github.io/notes/cpu-e-storia-degli-elaboratori/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cpu-e-storia-degli-elaboratori/</guid>
      <description>2 Storia 2.1 0: Computer Meccanici dal 1600 a oggi
2.2 1: Computer a Valvole Principalmente i computer della seconda guerra mondiale
2.3 2: Computer a Transistor Abbattere i costi
2.4 3: Circuiti stampati Computazione parallela Multiprogrammazione (Caricamento di più programmi) 2.5 4: VLSI Possibilità di creare tansissimi transistor
2.6 5: Computer moderni 2.6.1 Computer Ubiqui 2.6.2 Computer invisibili 2.7 Velocità di calcolo 2.7.1 Flops and MIPS 3 CPU La struttura moderna degli elaboratori sono basati principalmente sull&amp;rsquo;architettura di Von Neuman, l&amp;rsquo;unica differenza è che gli elementi di questa architettura.</description>
    </item>
    <item>
      <title>Ensemble Methods</title>
      <link>https://flecart.github.io/notes/ensemble-methods/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/ensemble-methods/</guid>
      <description>The idea of ensemble methods goes back to Sir Francis Galton. In 787, he noted that although not every single person got the right value, the average estimate of a crowd of people predicted quite well.
The main idea of ensemble methods is to combine relatively weak classifiers into a highly accurate predictor.
The motivation for boosting was a procedure that combines the outputs of many “weak” classifiers to produce a powerful “committee.</description>
    </item>
    <item>
      <title>Filesystem</title>
      <link>https://flecart.github.io/notes/filesystem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/filesystem/</guid>
      <description>Perché filesystem? Questa è l&amp;rsquo;idea presa dall&amp;rsquo;archivio, come se fosse un ufficio che deve tenere delle pratiche ordinate in cartelle e cartelloni.
L’utilizzo principale è dare un interfaccia comune di accesso ai dispositivi. perché dispositivi diversi hanno sotto modi di accedere diversi, questa interfaccia facilita molto l&amp;rsquo;accesso.
Informazioni dei files (5+) 🟨 Il file è l’unità logica di memorizzazione. il formato che c&amp;rsquo;è dentro è gestito dall&amp;rsquo;applicazione, non dal file system!</description>
    </item>
    <item>
      <title>Introduction to Information Theory</title>
      <link>https://flecart.github.io/notes/introduction-to-information-theory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduction-to-information-theory/</guid>
      <description>The course will be more about the the quantization, talking about lossless and lossy compression (how many bits will be needed to describe something? This is not a CS course so it will not be so much algorithmically focused course), then we will talk about channel and capacity and DMC things. Most of the things explained in the Lapidoth course will be theoretical there will be some heavy maths.
The professor starts with some mathy definitions (not very important, just that the $\mathbb{E}[ \cdot]$ needs a domain to be defined, so notations like $\mathbb{E}[x]$ do not make sense, while $\mathbb{E}[g(x)]$ do make sense because $g(x) : \mathcal{X} \to \mathbb{R}$).</description>
    </item>
    <item>
      <title>Naïve Bayes</title>
      <link>https://flecart.github.io/notes/na%C3%AFve-bayes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/na%C3%AFve-bayes/</guid>
      <description>Introduzione a Naïve Bayes NOTE: this note should be reviewed after the course I took in NLP. This is a very old note, not even well written.
Bisognerebbe in primo momento avere benissimo in mente il significato di probabilità condizionata e la regola di naive Bayes in seguito.
Bayes ad alto livello 🟩 Da un punto di vista intuitivo non è altro che predire la cosa che abbiamo visto più spesso in quello spazio Assunzioni principali per naïve Bayes 🟩 I sample di input sono condizionalmente indipendenti uno con l&amp;rsquo;altro.</description>
    </item>
    <item>
      <title>Onde elettromagnetiche</title>
      <link>https://flecart.github.io/notes/onde-elettromagnetiche/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/onde-elettromagnetiche/</guid>
      <description>Prendiamo La legge di Ampere-Maxwell $$ \vec{\nabla} \times \vec{B} = \mu_{0}\vec{J} + \mu_{0}\varepsilon_{0} \frac{\delta \vec{E}}{\delta t} $$ E la legge di Faraday neumann Lenz $$ \vec{\nabla} \times \vec{E} = - \frac{\delta \vec{B}}{\delta t} $$ Con questi abbiamo le onde elettromagnetiche.
Nel vuoto possiamo dire che non abbiamo densità di corrente, per questo posso andare nel vuoto, sono due cose che si autosostengono. Sono simmetriche a meno di costante.
Questo ci dice che</description>
    </item>
    <item>
      <title>Poisson processes</title>
      <link>https://flecart.github.io/notes/poisson-processes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/poisson-processes/</guid>
      <description>I processi di Poisson sono dei processi stocastici, interpretabili come collezione indicizzata dal tempo di variabili aleatorie. Esempi semplici sono una uniforme, altri più complessi potrebbe essere una catena di Markov (see Markov Chains) (utile per modellare cammini randomici) o quella di Poisson spiegata qui.
Introduzione ai processi di Poisson Arrival processes Sia una sequenza di variabili aleatorie $0 &lt; S_{1} &lt; S_{2} &lt; \dots$ (il fatto che sia positivo significa che per ogni elemento del dominio vale che quell&amp;rsquo;elemento è &amp;lt;, non so se mi sono spiegato.</description>
    </item>
    <item>
      <title>Costraint Satisfaction Problems</title>
      <link>https://flecart.github.io/notes/costraint-satisfaction-problems/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/costraint-satisfaction-problems/</guid>
      <description>Definizione Caratteristiche Variabili Dominio per ogni variabile Costraints per ogni variabile Queste tre sono elementi che definiscono un problema di soddisfazione delle restrizioni, una soluzione è un assegnamento di variabili che soddisfi ogni restrizioone e sia all’interno del dominio
Consistenza Vogliamo andare a limitare il dominio valutando le consistenze possibili
Consistenza del punto Si può dire che un punto sia consistente se le sue variabili possibili non viola nessuna restrizione unaria: eg.</description>
    </item>
    <item>
      <title>Entropy</title>
      <link>https://flecart.github.io/notes/entropy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/entropy/</guid>
      <description>Questo è stato creato da 1948 Shannon in (Shannon 1948). Questa nozione è basata sulla nozione di probabilità, perché le cose rare sono più informative rispetto a qualcosa che accade spesso.
Introduction to Entropy The Shannon Information Content This is dependent on the notion of the Shannon information content defined as $$ h(x = a_{i}) = \log_{2}\frac{1}{P(x = a_{i})} $$ We will see that the entropy is a weighted average of the information, so the expected information content in a distribution.</description>
    </item>
    <item>
      <title>Halting Theorem and Reducibility</title>
      <link>https://flecart.github.io/notes/halting-theorem-and-reducibility/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/halting-theorem-and-reducibility/</guid>
      <description>Halting theorem Questo è un problema fondamentale, che abbiamo trattato anche in Fondamenti teorica#Halting problem, ma qui lo ritrattiamo, perché così lo rifacciamo per bene. In parte è stato trattato anche al corso di Logica.
Enunciato Halting theorem🟩 Questo è molto simile a quanto presente sul (Sipser 2012). Ossia consideriamo il linguaggio $$ HALT = \left\{ \langle x, y \rangle \in \Sigma^{*} \times \Sigma^{*}: x = code(M),M \text{ si ferma su } x\right\} $$ Dimostrazione Halting theorem🟩 La parte del sì è facile perché basta eseguirlo e vedere che si ferma (quindi abbiamo una La macchina di Turing#La macchina di Turing universale.</description>
    </item>
    <item>
      <title>Kernel Methods</title>
      <link>https://flecart.github.io/notes/kernel-methods/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/kernel-methods/</guid>
      <description>As we will briefly see, Kernels will have an important role in many machine learning applications. In this note we will get to know what are Kernels and why are they useful. Intuitively they measure the similarity between two input points. So if they are close the kernel should be big, else it should be small.
We briefly state the requirements of a Kernel, then we will argue with a simple example why they are useful.</description>
    </item>
    <item>
      <title>Legge di Coulomb</title>
      <link>https://flecart.github.io/notes/legge-di-coulomb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/legge-di-coulomb/</guid>
      <description>Introduzione elettromagnetismo Note storiche: triboelettricità Il concetto di campo è fondamentale per l&amp;rsquo;elettromagnetismo (vs forza in meccanica) da un punto di vista storico è nato tramite l&amp;rsquo;osservazione in fenomeni come lo strofinio fra vetro e pelle, dopo il quale hanno osservato ci fosse una forza nascosta (appunto ombra dal greco di electron). Il vetro si caricava poi abbastanza da poter attrarre carta per esempio. esempio dell&amp;rsquo;esperimento. Se viene fatto invece fra due lastre in vetro invece diventa repulsiva invece che attrattiva.</description>
    </item>
    <item>
      <title>Logica meta-linguistica</title>
      <link>https://flecart.github.io/notes/logica-meta-linguistica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/logica-meta-linguistica/</guid>
      <description>Con questo documento iniziamo a parlare di logica, alcuni paradossi famosi all&amp;rsquo;interno di questo mondo.
Paradossi Metalinguistici Antinomie e Paradossi Antinomia Definizione di antinomia è un ragionamento corretto da cui deriva una conclusione errata, probabilmente è l&amp;rsquo;insieme o campo in cui stiamo operando ad essere errato e bisogna cercare di ridefinirlo in modo più corretto, in quanto le premesse erano accettabili
Paradosso Paradosso quando il ragionamento corretto va contro l&amp;rsquo;intuizione, come il paradosso dei gemelli in fisica e simili.</description>
    </item>
    <item>
      <title>Relational Algebra</title>
      <link>https://flecart.github.io/notes/relational-algebra/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/relational-algebra/</guid>
      <description>Introduzione all&amp;rsquo;algebra relazionale Confronto con relazioni matematiche Le relazioni come le intendiamo in database sono leggermente diverse rispetto a quelle presenti per le relazioni matematiche:
Non conta l&amp;rsquo;ordine Ci sono gli attributi Per il resto se introduciamo questo sistema per tenere conto delle astrazioni, possiamo analizzarle matematicamente, e questo ci fornisce qualche sicurezza in più diciamo.
Definition of tuples 🟩 Le relazioni sono esattamente quelle definite in matematica, però noi aggiungiamo anche gli attributi, in modo da poter considerare l&amp;rsquo;ordine delle colonne non importante.</description>
    </item>
    <item>
      <title>Serie</title>
      <link>https://flecart.github.io/notes/serie/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/serie/</guid>
      <description>Questo è un tentativo di aggiungere un argomento che non era presente quando abbiamo fatto il corso due anni fa. Inizio la scrittura il 2024-03-03. Questo non è stato trattano nel corso, ma è importante per molte cose. Quindi introduco questo appunto.
Introduzione alle serie Le serie infinite sono dei mostri strani perché non si comportano spesso come dovrebbero.
Definizione di convergenza Sia data una funzione $(a_{n})_{n=0}^{\infty}$ una funzione da $\mathbb{N} \to \mathbb{R}$, possiamo dire che questa serie è convergente se la somma cumulativa $f_{n} = \sum_{n = 0}^{n} a_{n}$ ha un limite finito, ossia $$ \lim_{ n \to \infty } f_{n} = c $$ con $c$ un numero reale.</description>
    </item>
    <item>
      <title>Spazi vettoriali</title>
      <link>https://flecart.github.io/notes/spazi-vettoriali/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/spazi-vettoriali/</guid>
      <description>Spazi vettoriali 1.1 Piano cartesiano 1.1.1 Definizione Possiamo considerare il piano cartesiano come l&amp;rsquo;insieme $\R^2$ potremmo dire che esiste una corrispondenza fra una coordinata e un punto del piano, una volta che abbiamo definito un punto di origine. Si può vedere anche come corrispondenza biunivoca con vettori del piano per l&amp;rsquo;origine (parte dall&amp;rsquo;origine).
Questa cosa vale anche per uno spazio n-dimensionale, non soltanto due, ma per semplicità di introduzione di questo lo faccio con 2</description>
    </item>
    <item>
      <title>Unified Modeling Language</title>
      <link>https://flecart.github.io/notes/unified-modeling-language/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/unified-modeling-language/</guid>
      <description>Cosa è UML è un linguaggio di modelling (molto vecchio) ma ancora di continua evoluzione, da un punto di vista storico è nato insieme ai concetti di Object Oriented Programming che ora è molto presente all&amp;rsquo;interno dell&amp;rsquo;industria, descritto bene in Classi OOP, anche se in questa occasione sviluppata in maniera molto più intuitiva (grafica).
Perché serve 🟩 Per cercare di comunicare quanto necessario riguardo struttura e dinamicità dell&amp;rsquo;architettura.
Struttura di UML Structural Diagram 🟨++ These diagrams focus on representing the static structure of a system.</description>
    </item>
    <item>
      <title>Bottom-up Parser LR(0)</title>
      <link>https://flecart.github.io/notes/bottom-up-parser-lr0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bottom-up-parser-lr0/</guid>
      <description>Descrivo ora alcune domande utili per ripasso:
Quali sono schematicmente quali sono le operazioni migliori per un parser top-down? Cosa è un prefisso viabile? Quali sono i conflitti possibli, e come risolverli… Non sai nemmeno definire inmodo formale cosa sia un item Bottom up Intro shift-reduce e LR 🟩 Slide
In breve:
Shift = simbolo terminale messo nella stack Riduzione utilizzando una produzione LR = dettura da Sinistra, creazione della stringa da destra (derivazione rightmost) Algoritmo classico 🟨+ Quello che credo che intendevo per questo algoritmo classico è quello non deterministico, nel senso che prova a fare backtracking, finché non ha finito tutte le possibilità, oppure trova la derivazione giusta.</description>
    </item>
    <item>
      <title>Document Stores</title>
      <link>https://flecart.github.io/notes/document-stores/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/document-stores/</guid>
      <description>Document stores provide a native database management system for semi-structured data. Document stores also scale to Gigabytes or Ter- abytes of data, and typically millions or billions of records (a record being a JSON object or an XML document).
Introduction to Document Stores a document store, unlike a data lake, manages the data directly and the users do not see the physical layout.
Unlike data lakes, using document stores prevent us from breaking data independence and reading the data file directly: it offers an automatic manager service for semi-structured data that we need to throw and read quickly.</description>
    </item>
    <item>
      <title>Introduzione algebra</title>
      <link>https://flecart.github.io/notes/introduzione-algebra/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-algebra/</guid>
      <description>Tutta sta parte si fa in modo formale in Sistemi Lineari e determinanti, quindi potresti saltarla totalmente
Equazioni lineari L&amp;rsquo;obiettivo dell&amp;rsquo;algebra lineare è risolvere n equazioni con n sconosciuti di primo grado. Cosa che ci riesce con grandissimo successo! Andiamo ora a definire meglio cosa è una equazione lineare
Definizione Una equazione lineare è una equazione a coefficienti appartenenti a un certo campo (che può essere R) e incognite il cui grado è 1 e che siano indipendenti:</description>
    </item>
    <item>
      <title>Logica del Primo ordine</title>
      <link>https://flecart.github.io/notes/logica-del-primo-ordine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/logica-del-primo-ordine/</guid>
      <description>Logica del primo ordine Questa è la logica più utilizzata dai matematici
Limitatezza della logica proposizionale La logica proposizionale classica non è in grado di ragionare sull&amp;rsquo;infinito Fino ad ora abbiamo utilizzato una metalogica per giustificare il per ogni e l&amp;rsquo;esiste nelle dimostrazioni fin&amp;rsquo;ora.
Dobbiamo quindi dare una definizione più formale dei quantificatori.
Obiettivo della logica del primo ordine Si può quindi identificare come l&amp;rsquo;obiettivo della logica di primo ordine l&amp;rsquo;introduzione dei quantificatori dell&amp;rsquo;universale e dell&amp;rsquo;esiste</description>
    </item>
    <item>
      <title>Magnetismo</title>
      <link>https://flecart.github.io/notes/magnetismo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/magnetismo/</guid>
      <description>Introduzione ai campi magnetici Introduzione storica (non impo) 🟩 Il magnetismo è stato in primi osservato e documentato da Greci, che hanno osservato che materiali metallici come ferro, questo è successo in magnesia, una penisola dell&amp;rsquo;Asia minore, mentre elettro era più sull&amp;rsquo;ambra, che credo fosse il nome dato a quel materiale.
Una cosa nota era che se vicino a un materiale magnetico, venivano create linee con materiale ferroso all&amp;rsquo;estremità (limatura magnetica).</description>
    </item>
    <item>
      <title>Modelizzazione</title>
      <link>https://flecart.github.io/notes/modelizzazione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/modelizzazione/</guid>
      <description>Programmazione lineare Programmazione lineare contiene alcuni algoritmi utili per risolvere certi problemi di ottimizzazione.
Introduzione Andiamo in questa sezione a definire un problema di programmazione lineare
Definizione 🟩- Variabili reali che saranno le variabili del nostro problema, sono in numero finito (eg. tutti in Rn) Funzione obiettivo che ci definisce il costo $f: \R^n \to \R$ Vincoli lineari che limitano il dominio delle variabili reali e li mettono in relazione fra di loro Se le variabili appartengono agli interi andiamo a parlare di programmazione lineare intera.</description>
    </item>
    <item>
      <title>Principal Component Analysis</title>
      <link>https://flecart.github.io/notes/principal-component-analysis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/principal-component-analysis/</guid>
      <description>See https://peterbloem.nl/blog/pca series. The main idea is to find the directions with the most variance in a dataset. Those will be principal components.
There is a very easy derivation present in (Bishop &amp;amp; Bishop 2024). It is also known as the Kosambi-Karhunen-Loève transform (you will probably like this name more if you are from physics). Another good resource is the Wilkinson.
Technique setting Le&amp;rsquo;t say we have $\left\{ \boldsymbol{x}_{n} \right\}$ observations of dimension $D$ and $n \in \left\{ 1, \dots, N \right\}$.</description>
    </item>
    <item>
      <title>Scelta del PO</title>
      <link>https://flecart.github.io/notes/scelta-del-po/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/scelta-del-po/</guid>
      <description>La cosa che rende il PO diverso rispetto agli sviluppatori è la conoscenza delle necessità del cliente. Questo permette di prioritizzare del task e capire in che modo dovrebbe essere il prodotto finale. In questo modo si crea una vision del prodotto. Pensiamo che il PO debba condividere questa informazione e prendere decisioni di gruppo.
Domande da fare: La user interface, come sembra il wireframe? Pensavamo di utilizzare i social solamente per i login, pensavate di utilizzare anche per altro durante il gioco?</description>
    </item>
    <item>
      <title>Scheduler</title>
      <link>https://flecart.github.io/notes/scheduler/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/scheduler/</guid>
      <description>Il suo scopo principale è gestire l&amp;rsquo;avvicendamento dei processi. Ad esempio sospendere il processo che chiede I/O. O un sistema time sharing, quando arriva un interrupt sul time.
Solitamente il nome scheduler è solamente un gestore dell&amp;rsquo;avvicendamento, si può quindi utilizzare per indicare scheduler di altro tipo.
Note introduttive Diagramma di Gantt Questo è il diagramma per presentare lo scheduling, ossia da quando a quando è eseguito cosa
Esempio gantt</description>
    </item>
    <item>
      <title>Successioni</title>
      <link>https://flecart.github.io/notes/successioni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/successioni/</guid>
      <description>3.1 Successioni $$ \begin{cases} f: \mathbb{N} \to \mathbb{R} \\ n \to f(n) \\ \{a\}_{n \in \mathbb{N}} \vee a_n \end{cases} $$ È una funzione che mappa dai naturali ai Reali indicata spesso solamente come $$ \left\{ a \right\} _{n \in \mathbb{N}} $$ 3.1.1 Immagine e successione L&amp;rsquo;immagine di una successione (l&amp;rsquo;insieme dei suoi elementi) non è una successione! la successione è anche ordinata.
3.1.2 Limitazioni della successione Come per gli insiemi si può definire se l&amp;rsquo;insieme è limitato superiormente, inferiormente o entrambi, a seconda di come lo definiamo in questo modo possiamo poi farci altri ragionamenti</description>
    </item>
    <item>
      <title>The Database Management System</title>
      <link>https://flecart.github.io/notes/the-database-management-system/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/the-database-management-system/</guid>
      <description>Struttura del DBMS Introduzione ai DBMS Schema riassuntivo #### Operazioni classiche Ci stiamo chiedendo, come facciamo a descrivere i processi che portano alla comprensione della query e della retrieval degli elementi utili? Questo deve fare il DBMS, ossia capace di - Aggiornare tuple - Trovare tuple - Gestire gli accessi - Gestire accessi concorrenti? ### Query processor #### Query compiler (3) 🟩 - Parsing (crea l&#39;albero di derivazione per la nostra query) - Pre-processing (fa check semantici sulla query) - Optimization, si occupa lui di migliorare L&#39;ottimizzazione #### Execution engine 🟩 Esegue l&#39;effettiva computazione per la query, ed è il punto d&#39;incontro col resto (indexes, e logging per dire) Esegue il piano di esecuzione che probabilmente un livello superiore ha calcolato Interagisce con tutti gli altri componenti del db (ad esempio Log per transazioni e durabilità, buffer e scheduler delle operazioni prolly).</description>
    </item>
    <item>
      <title>Wireless attack vectors</title>
      <link>https://flecart.github.io/notes/wireless-attack-vectors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/wireless-attack-vectors/</guid>
      <description>In this note we will talk about some common ways to attack wireless based devices.
Attacking an automated door Usually these doors are opened by radio frequency keys, and can be opened easily (e.g. replay attacks, Jam the frequency)
Jamming This is the easiest way to attack. Just send many signals to make a certain frequency un-usable in our space. But with Frequency hopping this attack is solved. See Tecnologia Wireless#Frequency Hopping But this method could be easily known and observed (enables eavesdropping, against confidentiality, a principle in Theoretical Notions of Security#CIAA principles of security.</description>
    </item>
    <item>
      <title>Algebra dei tipi</title>
      <link>https://flecart.github.io/notes/algebra-dei-tipi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algebra-dei-tipi/</guid>
      <description>Equivalenza dei tipi (2) 🟩 Quando possiamo dire che due tipi siano uguali? Solitamente vengono utilizzati due metodi:
Equivalenza Nominale Quando un nuono tipo introduce un nuovo nome diverso fra tutti i presenti. Credo così vada golang. Quindi in questo caso si può dire che un tipo è equivalente solamente a sé stesso.
Vogliamo fare in questo modo perché se definiamo un nuovo tipo solitamente dovrebbe avere funzioni diverse, quindi è giusto che sia diverso da uqello iniziale.</description>
    </item>
    <item>
      <title>Analisi di Convessità</title>
      <link>https://flecart.github.io/notes/analisi-di-convessit%C3%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/analisi-di-convessit%C3%A0/</guid>
      <description>Questo argomento è stato trattato durante dopo la discussione dei Massimi minimi multi-variabile, però è stato ripreso anche nella forma R to R, quindi credo necessiti di un foglio a parte.
Affine set Lines Let&amp;rsquo;s take two points in $\mathbb{R}$ $x_{1}, x_{2}$, if we consider the parametrization $$ x = \theta x_{1} + (1 - \theta)x_{2} $$ This is a parametrization of the line Example:
Def: affine set A combination where the coefficients add up to 1.</description>
    </item>
    <item>
      <title>l’intelligenza</title>
      <link>https://flecart.github.io/notes/lintelligenza/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/lintelligenza/</guid>
      <description>Questi appunti sono stati scritti leggendo il (Russell &amp;amp; Norvig 2009).
1 Introduzione L’intelligenza artificiale è un campo in velocissima espansione, con già un mercato enorme di un trillion dollars.
Inoltre il suo campo di studi spazia da moltissimi campi, è per questo che quasi potresti considerarla universale.
1.1 L’intelligenza artificiale 1.1.1 Cosa è (2) Nel tempo si è cercato di definire con esattezza cosa sia l’intelligenza artificiale. In generare si è basato su alcuni parametri cardine ossia:</description>
    </item>
    <item>
      <title>La qualità del software</title>
      <link>https://flecart.github.io/notes/la-qualit%C3%A0-del-software/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/la-qualit%C3%A0-del-software/</guid>
      <description>Dato che il software sta diventando sempre più diffuso, diventa sempre più importante andare a definire delle metriche che possano garantirne la qualità, ossia la non frequenza di errori o bug che possono in qualche modo limitarne la qualità.
Error, Fault and Failure Secondo la definizione esatta data da IEEE, questi tre termini hanno un significato ben specifico, molto diverso.
Error, sono comportamenti non previsti da un comportamento dell&amp;rsquo;utente, oppure il programmatore capisce male le specifiche.</description>
    </item>
    <item>
      <title>Massimi minimi multi-variabile</title>
      <link>https://flecart.github.io/notes/massimi-minimi-multi-variabile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/massimi-minimi-multi-variabile/</guid>
      <description>Matrice Jacobiana È un modo per scrivere il gradiente di una funzione quando è in una certa forma.
Data una funzione $f: \mathbb{R}^n \to \mathbb{R}^p$ ossia per esempio $x=(x_1,...,x_n) \to(f_1(x),...,f_p(x))$ Se le p funzioni di arrivo sono differenziabili, allora la matrice Jacobiana è definita in questo modo:
$$J_f(x) = \begin{pmatrix} \delta_{x_1} f_1(x) &amp;amp; &amp;hellip; &amp;amp; \delta_{x_n} f_1(x)\ . &amp;amp; . &amp;amp; . \ \delta_{x_1} f_p(x) &amp;amp; &amp;hellip; &amp;amp; \delta_{x_n} f_p(x)</description>
    </item>
    <item>
      <title>Notazione Asintotica</title>
      <link>https://flecart.github.io/notes/notazione-asintotica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/notazione-asintotica/</guid>
      <description>Introduzione alla notazione asintotica Cercare di definire il tempo impiegato da una funzione per essere eseguita in termini di DIMENSIONE dell&amp;rsquo;input. **(il numero di bit a livello basso basso)
Ma abbiamo il problema di misura, in quanto dobbiamo considerare delle variabili che siano indipendenti rispetto alla macchina.
Caratteristiche della notazione Vogliamo considerare una notazione asintotica (che guarda quanto fa il comportamento verso l&amp;rsquo;infinito)
Funzione di costo Modelli asintotici Abbiamo trattato di o-piccolo e ogrande in Analisi.</description>
    </item>
    <item>
      <title>Querying Denormalized Data</title>
      <link>https://flecart.github.io/notes/querying-denormalized-data/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/querying-denormalized-data/</guid>
      <description>TODO: write the introduction to the note.
JSONiq purports as an easy query language that could run everywhere. It attempts to solve common problems in SQL i.e. the lack of support for nested data structures and also the lack of support for JSON data types. A nice thing about JSONiq is that it is functional, which makes its queries quite powerful and flexible. It is also declarative and set-based. These are some commonalities with SQL.</description>
    </item>
    <item>
      <title>Reti convoluzionali</title>
      <link>https://flecart.github.io/notes/reti-convoluzionali/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/reti-convoluzionali/</guid>
      <description>Abbiamo trattato i modelli classici in Convolutional NN. Con i vecchi files di notion
Il Kernel I punti interessanti delle immagini sono solamente i punti di cambio solo che attualmente siamo in stato discreto, quindi ci è difficile usare una derivata, si usano kernel del tipo: $\left[ 1, 0, -1 \right]$, che sarà positivo se cresce verso sinistra, negativo se scende. feature map Sono delle mappe che rappresentano alcune informazioni interessanti della nostra immagine.</description>
    </item>
    <item>
      <title>Tecnologia Wireless</title>
      <link>https://flecart.github.io/notes/tecnologia-wireless/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/tecnologia-wireless/</guid>
      <description>Introduzione Spettro del wireless networks (skip) Slide spettro Wirelesss networks
Questo solamente la classica differenziazione fra radio, visibile, raggi x raggi gamma etcetera.
Se andiamo a guardare le onde radio, quelle che ci interessano, se ho frequenza alta ho densità di frequenza alta, se ho frequenza bassa ho alta capacità di suparamento di ostacoli.
ISM è una banda da 2 a 5.0 GHz e c&amp;rsquo;è tutto il WiFi, bluetooth. (anche wifi a 5 ghz.</description>
    </item>
    <item>
      <title>Algebra modulare</title>
      <link>https://flecart.github.io/notes/algebra-modulare/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algebra-modulare/</guid>
      <description>Algebra modulare Assunzioni Andiamo ora ad assumere l&amp;rsquo;esistenza e correttezza di alcune cose di base. (in teoria si possono dimostrare da cose più di base, ma non ho tempo).
Teorema fondamentale dell&amp;rsquo;algebra Ogni numero intero si fattorizza in modo unico.
Algoritmo di Euclide La conseguenza più importante di questo teorema, dovuto ad Euclide è che se ho $a, b \in \mathbb{Z}$ allora esistono resto e dividendo fra i due. Ossia $\exists q, p : a\mid b = qk + p$ per qualche $k$ intero</description>
    </item>
    <item>
      <title>Bayesian neural networks</title>
      <link>https://flecart.github.io/notes/bayesian-neural-networks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bayesian-neural-networks/</guid>
      <description>TODO
Robbins-Moro Algorithm TODO: the algorithm is very simple we do Set some learning rates $\alpha_{0} &gt; \alpha_{1} &gt; \dots &gt; \alpha_{n} \dots$ choose a $w_{0}$ then update in the following way: $$ w_{n+1} = w_{n} - \alpha_{n} \Delta w_{n} $$ Bayesian Neural Networks The Idea TODO
We want to predict the weights of a given model with some bounds on certainty about them. One thing is that we have always used linear models for this, but we can also use neural networks or more complex models.</description>
    </item>
    <item>
      <title>Circuiti Sequenziali</title>
      <link>https://flecart.github.io/notes/circuiti-sequenziali/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/circuiti-sequenziali/</guid>
      <description>7.1 Introduzione 7.1.1 Perché usarli Sono utili per mantenere delle informazioni nel tempo
7.1.2 Caratteristiche Hanno feedback cioè ci sono degli output che tornano dentro al circuito, quindi è molto difficile senza sapere niente cosa succede dentro
Questo circuito non è combinatorio, che è formalizzabile in modo deterministico con l&amp;rsquo;lgebra booleana.
7.1.3 Il Bit di memoria Questo bit ha due input, un load e un input, se il load è attivo comincia a storare, altrimenti l&amp;rsquo;output è sempre il bit che ha memoriazzato.</description>
    </item>
    <item>
      <title>Conduttori elettrici</title>
      <link>https://flecart.github.io/notes/conduttori-elettrici/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/conduttori-elettrici/</guid>
      <description>Campo elettrico nei materiali Se prendiamo un conduttore, gli elettroni in questi materiali sono liberi, significa che sono liberi di muoversi come vogliono, si può dire che &amp;ldquo;vadano in giro&amp;rdquo; (per esempio questo vale per il rame).
il reticolo cristallino è al struttura regolare che è comune nei materiali, in cui gli atomi sono sempre a distanza costante (o comunque a pattern regolari) uno dall&amp;rsquo;altro $r$ per esempio.
Campo e materiali (6) Schermatura del campo (!</description>
    </item>
    <item>
      <title>Cookie e autenticazione</title>
      <link>https://flecart.github.io/notes/cookie-e-autenticazione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cookie-e-autenticazione/</guid>
      <description>Cookies Gli utilizzi più soliti sono per Autenticazione e per Autorizzazione, perché sono delle informazioni che il server genera e mette al client, come se fossero dei segreti cifrati.
Cookie Questi sono una estensione di netscape, che si appoggiano al protocollo HTTP per implementare certe funzionalità (soprattutto il fatto di essere stateless, quindi è utile per avere informazioni sugli stati su qualcosa.)
Slide cookie
Vengon utilizzati header specifici per settare il cookie.</description>
    </item>
    <item>
      <title>Duality Theory</title>
      <link>https://flecart.github.io/notes/duality-theory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/duality-theory/</guid>
      <description>È una branca dell&amp;rsquo;algebra lineare che ci permette di semplificare tutti i concetti.
Intro dualità🟩 &amp;lt;img src=&amp;quot;/images/notes/image/universita/ex-notion/Programmazione lineare/Untitled 8.png&amp;quot; alt=&amp;quot;image/universita/ex-notion/Programmazione lineare/Untitled 8&amp;quot;&amp;gt; Si fa una sorta di trasposta alla matrice di A. y è pari al numero di righe di A La trasformazione al duale è molto facile, ed è abbastanza intuitiva una volta che capiamo che vogliamo andare a fare l’upper bound.
Dualità asimmetrica 🟥+ Teorema debole di dualità 🟩 Slide</description>
    </item>
    <item>
      <title>Interpolazione</title>
      <link>https://flecart.github.io/notes/interpolazione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/interpolazione/</guid>
      <description>Vogliamo in questa sezione andare ad indagare la costruzione di funzioni che passano in tutti i punti che vogliamo, appunto interpolare. La funzione è molto simile alla regressione trattata in Minimi quadrati (con il metodo della regressione, chiamato anche approssimazione ai minimi quadrati).
Quindi mentre la precedente voleva andare a minimizzare l&amp;rsquo;errore, questo attuale va a creare proprio da 0 la funzione che ci passa sempre.
Introduzione Andremo a creare una funzione f tale che per ogni x in input si abbia esattamente la y in output</description>
    </item>
    <item>
      <title>Scrum Method</title>
      <link>https://flecart.github.io/notes/scrum-method/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/scrum-method/</guid>
      <description>Introduzione (idea principale) In breve: essence card 🟩- Giallo = Prodotto. Metafora staffetta-rugby 🟩 Con altri metodi si fanno produzioni stile staffetta, ossia un membro sta fermo, finché non ha il testimone e poi si uccide correndo&amp;hellip; Il metodo più utile ispirato a scrum è rugby, che tutti si muovo insieme collaborando. Un po&amp;rsquo; di tutto è fatto durante lo sprint
Cicli di base (3) 🟩 Planning: in cui vengono scelti i task da eseguire durante questo sprint, solitamente questo viene preso da un subset dei task descritti dal product owner.</description>
    </item>
    <item>
      <title>Semantica di un linguaggio</title>
      <link>https://flecart.github.io/notes/semantica-di-un-linguaggio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/semantica-di-un-linguaggio/</guid>
      <description>Vincoli sintattici contestuali Intro: dipendenze da contesto 🟩 I vincoli sintattici non sono esprimibili tramite BNF perché dipendono dal contesto, mentre le grammatiche libere sono per definizione libere da contesto, vogliamo quindi trovare una soluzione a questo problema. Vengono usati metodi Ad-Hoc nella fase di analisi semantica del programma.
Grammatiche dipendenti dal contesto
Queste grammatiche sono molto più complicate (e lente) rispetto a quelle libere da contesto, quindi è poco pratico e non utilizzabile (tempo esponenziale, quindi non finisce mai).</description>
    </item>
    <item>
      <title>Introduzione algoritmi</title>
      <link>https://flecart.github.io/notes/introduzione-algoritmi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-algoritmi/</guid>
      <description>0 Introduzione 0.1 L’algoritmo Vogliamo cercare di creare algoritmi, ovvero soluzioni a problemi computazionali che non dipendono dal linguaggio di programmazione.
0.1.1 Definizione Procedura per risolvere un problema in un numero finito di passi (quindi un algoritmo deve finire)
0.1.2 Origine della parola Il nome &amp;ldquo;algoritmo&amp;rdquo; deriva da un nome di un matematico persiano dell 800 d.c. Muhammad ibn Musa al-Khwarizmi, che latinizzato diventa algorithmi, quindi i latini hanno creato la parola!</description>
    </item>
    <item>
      <title>Linear Regression methods</title>
      <link>https://flecart.github.io/notes/linear-regression-methods/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/linear-regression-methods/</guid>
      <description>We will present some methods related to regression methods for data analysis. Some of the work here is from (Hastie et al. 2009). This note does not treat the bayesian case, you should see Bayesian Linear Regression for that.
Problem setting In usual regression problems we want to reach the $\arg \min \mathbb{E}_{Y \mid X} \left[ (Y - f(X))^{2} \right]$ and the solution is given by the conditional mean: $f^{*} = \mathbb{E}(Y \mid X = x)$.</description>
    </item>
    <item>
      <title>Metric Spaces</title>
      <link>https://flecart.github.io/notes/metric-spaces/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/metric-spaces/</guid>
      <description>There is a close relationship between topologies and metric spaces. We will see that every metric space directly induces a topology based on its metric. (from a CS point of view, this means topologies are more general than metric spaces).
Definition of Metric Space 🟩 We say that $(\mathcal{X}, d)$ is a metric space if $\mathcal{X}$ is a set and $d$ a function $\mathcal{X} \times \mathcal{X} \to \mathbb{R}$ such that:</description>
    </item>
    <item>
      <title>Processi e thread</title>
      <link>https://flecart.github.io/notes/processi-e-thread/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/processi-e-thread/</guid>
      <description>Il processo e la gestione dell&amp;rsquo;esecuzione è uno dei compiti principali dei sistemi operativi. Lo vuole fare in maniera efficace ed efficiente, come descritto in Note sull’architettura.
Slide schema generale tabelle
Processi Il process control block è la struttura di dati principali da comprendere.
Ha una tabella dei file aperti, che sono dei file descriptor (all&amp;rsquo;interno della propria struttura di dati), riferiti a una tabella dell&amp;rsquo;interno sistema credo, e questi puntano a un VNode che permette di localizzarlo nella memoria secondaria.</description>
    </item>
    <item>
      <title>Analysis of Neural Codes</title>
      <link>https://flecart.github.io/notes/analysis-of-neural-codes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/analysis-of-neural-codes/</guid>
      <description>Metodi di registrazione informazione Ci stiamo chiedendo in che modo possiamo registrare attività del cervello e quindi cercare di fare decoding delle informazioni presenti Prima parliamo di alcune tecniche non invasive che ci permettono di vedere alcune attività presenti nel cervello.
Metodi macroscopici Functional Magnetic Resonance Imaging Un metodo è fMRI. (ci sono cose ) TODO capire come funziona
Electro-Encephalo-Gram EEG che prende direttamente dai segnali Ma il drawback di entrambi è che non registrano attività del singolo array.</description>
    </item>
    <item>
      <title>Cook-Levin and Savitch</title>
      <link>https://flecart.github.io/notes/cook-levin-and-savitch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cook-levin-and-savitch/</guid>
      <description>Cook Levin theorem is important because says that in 1971 if $SAT \in P$ then $NP = P$. We will start with this idea to define the concept of NP-completeness. Let&amp;rsquo;s start with the basics.
Poly-reduction Def: poly-reduction🟩 We say that two languages $L$ and $L&#39;$ defines over alphabet $\Sigma$. We say that $L´$ is poly (mapping)-reducible in $L$, $L&#39; \leq_{p} L$ when a $TM$ that computes polynomial time a function $f: \Sigma^{*} \to \Sigma^{*}$ such that $$ x \in L&#39; \iff f(x) \in L $$ This is very similar to the Halting Theorem and Reducibility#Mapping reducibility.</description>
    </item>
    <item>
      <title>Introduction to databases</title>
      <link>https://flecart.github.io/notes/introduction-to-databases/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduction-to-databases/</guid>
      <description>Basi di dati Cosa è un database? (2) 🟩 Si potrebbe intendere come un insieme di dati strutturato, utili per certi obiettivi di enterprise, aziende pubbliche o simili (uno delle necessità che la rivoluzione informatica ha più contribuito diciamo.)
Un altro significato più importante è
Un insieme di dati gestito da un Database Management System
Tristemente con questa definizione anche excel è un DBMS&amp;hellip;
Solitamente sono utilizzati per gestire grandi quantità di dati.</description>
    </item>
    <item>
      <title>Problemi di accoppiamento</title>
      <link>https://flecart.github.io/notes/problemi-di-accoppiamento/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/problemi-di-accoppiamento/</guid>
      <description>I problem idi accoppiamento sono abbastanza comuni per ottimizzazione a grafi. In questa serie di note andiamo a trattare brevemente i problemi principali, con un accenno veloce ad alcuni algoritmi di soluzione per esse.
Grafo bipartito🟩 Un grafo bipartito è un insieme $(O \cup D), (A)$ di nodi e di archi. Tutti i nodi sono o fra i nodi di origine oppure fra i nodi di destinazione, e gli archi sono solamente collegati fra nodi di origine e nodi di destinazione.</description>
    </item>
    <item>
      <title>Variational Inference</title>
      <link>https://flecart.github.io/notes/variational-inference/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/variational-inference/</guid>
      <description>With variational inference we want to find a good approximation of the posterior distribution from which it is easy to sample. The objective is to approximate the posterior with a simpler one, because sometimes the prior or likelihood are difficult to compute. $$ p(\theta \mid x_{1:n}, y_{1:n}) = \frac{1}{z} p(y_{1:n} \mid \theta, x_{1:n}) p(\theta \mid x_{1:n}) \approx q(\theta \mid \lambda) $$ For Bayesian Linear Regression we had high dimensional Gaussians which made the inference closed form, in general this is not true, so we need some kinds of approximation.</description>
    </item>
    <item>
      <title>Agente Logico</title>
      <link>https://flecart.github.io/notes/agente-logico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/agente-logico/</guid>
      <description>Introduzione Nozioni base Questi sono le parole chiave di questo capitolo, ci permettono di parlare con chiarezza riguardo l’agente logico.
Sentence
Knowledge Base
Axiom
Inference
background knowledge
Knowledge representation language
Knowledge level
Implementation level
Esempio generale di agente logico
Logica proposizionale Sintassi del linguaggio Descrivere la BNF della logica proposizionale.
per sapere cosa sia la BNF di questo è molto più facile rifarsi agli appunti di logica presi durante l’anno di corso 2021/2022 Logica Proposizionale.</description>
    </item>
    <item>
      <title>Data Models and Validation</title>
      <link>https://flecart.github.io/notes/data-models-and-validation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/data-models-and-validation/</guid>
      <description>A data model is an abstract view over the data that hides the way it is stored physically.
The same idea from (Codd 1970) This is why we should not modify data directly, but pass though some abstraction that maintain the properties of that specific data model.
Data Models Tree view We can view all JSON and XML data, as presented in HTML and Markup, as trees. This structure is usually quite evident, as it is inherent in their design.</description>
    </item>
    <item>
      <title>Introduzione a ottimizzazione Combinatoria</title>
      <link>https://flecart.github.io/notes/introduzione-a-ottimizzazione-combinatoria/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-a-ottimizzazione-combinatoria/</guid>
      <description>L’ottimizzazione combinatoria è un altro nome per la ricerca operativa. È uno strumento utile a prendere le decisioni migliori, fatto sta che è anche molto utile al machine learning e si potrebbe dire che ne sia una base, questa è una cosa molto buona.
Ricerca operativa Questo è un campo a forte impatto economico perché prova a minimizzare i costi e massimizzare i profitti.
Steps 🟩, 🟨 Individuazione del problema (almeno riconoscere che ci sia un problema) Raccoglimento dei dati Modellizzazione del problema Ricerca di una soluzione Analisi dei risultati della soluzione La ricerca operativa si interessa principalmente degli step 3 e 4, nonostante gli steps non sempre vengono eseguiti in maniera lineare, ma c’è un ciclo di feedback a riguardo.</description>
    </item>
    <item>
      <title>Memoria</title>
      <link>https://flecart.github.io/notes/memoria/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/memoria/</guid>
      <description>4.1 Caratteristiche della Memoria La gerarchia della memoria, più si va giù più spazio si ha, più è lento il caricamento delle informazioni
4.1.1 Catalogazione della memoria Le tipologie di memoria sono presenti a fianco.
In generale più la memoria è veloce da riprendere, più è costosa da memorizzare (c&amp;rsquo;è poco spazio)
4.1.2 Byte e Word Il libro a pagina 74 parte con la discussione del perché si è preferito evitare la BCD (Binary coded decimal, in cui i numeri da 0 a 9 erano codificato da 4 bit), per questioni di efficienza.</description>
    </item>
    <item>
      <title>N-Bandit Problem</title>
      <link>https://flecart.github.io/notes/n-bandit-problem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/n-bandit-problem/</guid>
      <description>Impostazione del problema Supponiamo di stare giocando a n slot machine contemporaneamente. Queste macchine hanno internamente un valore di reward che non conosciamo. Ad ogni step possiamo scegliere una singola macchina e andare a tirare la sua leva. Riceviamo il valore del reward nascosto con un pò di rumore. Vogliamo capire nel lungo quale sia la strategia che possa dare migliore reward medio possibile.
Questo è un semplice problema, ma lo possiamo considerare un fulcro molto importante per poter comprendere meglio reinforcement learning.</description>
    </item>
    <item>
      <title>Planning automatico</title>
      <link>https://flecart.github.io/notes/planning-automatico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/planning-automatico/</guid>
      <description>Planning Automatico Vogliamo andare a creare un programma che sia in grado di creare un piano per fare una azione, andiamo in questo capitolo gli algoritmi storicamente migliori adatti a risolvere questo problema
Il problema di pianificazione Andiamo a rappresentare il nostro problema di pianificazione con un linguaggio molto simile alla Logica del Primo ordine.
È il PDDL ossia il Planning domain definition language
PDDL Questo linguaggio è definito da</description>
    </item>
    <item>
      <title>Replication and consistency</title>
      <link>https://flecart.github.io/notes/replication-and-consistency/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/replication-and-consistency/</guid>
      <description>Replication and consistency Introduzione Ci sono due vantaggi principali nella replicazione dei dati
Velocità Vicinanza geografica (quindi meno tempo ad andare a tornare) Maggiore computazione, quindi avere molti più processori che cercano di offrire lo stesso servizio. Affidabilità Così se una sede diventa corrotta, posso avere abbondanza, avere una copia da una altra parte, così non perdo le informazioni! Se una macchina cade in errore, ho altre macchine che lo sostituiscono!</description>
    </item>
    <item>
      <title>RL Function Approximation</title>
      <link>https://flecart.github.io/notes/rl-function-approximation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/rl-function-approximation/</guid>
      <description>These algorithms are good for scaling state spaces, but not actions spaces.
The Gradient Idea Recall Temporal difference learning and Q-Learning, two model free policy evaluation techniques explored in Tabular Reinforcement Learning.
A simple parametrization The idea here is to parametrize the value estimation function so that similar inputs gets similar values akin to Parametric Modeling estimation we have done in the other courses. In this manner, we don&amp;rsquo;t need to explicitly explore every single state in the state space.</description>
    </item>
    <item>
      <title>The Tor protocol</title>
      <link>https://flecart.github.io/notes/the-tor-protocol/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/the-tor-protocol/</guid>
      <description>Some notes Mix-based systems🟨 Created in 1981 by David Chaum. Very similar to the previous one, in practice, in the end, it acts as a proxy but not only does it take and receive, but it also mixes together the packets it has received from the sources, applying its key.
Disadvantage: The public-private mixing system is very slow. For this reason, a network of nodes is established, each having a symmetric key, making it much faster.</description>
    </item>
    <item>
      <title>Transformers</title>
      <link>https://flecart.github.io/notes/transformers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/transformers/</guid>
      <description>Introduction to the structure Transformers are just repeated blocks of attention layers, norms, MLP, followed by a final softmax on the final MLP layer, and preceded by a encoding layer. The first encoding layer has to embed some information about the original structure:
Semantic information about the input Positional information about the input. Then we use the transformer blocks to process the input and get the final embedding layer. Positional encoding We need to keep positional information about the contents.</description>
    </item>
    <item>
      <title>CSS</title>
      <link>https://flecart.github.io/notes/css/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/css/</guid>
      <description>Cascading Style Sheets Inizialmente HTML era per la presentazione, abbiamo ancora un pò di attributi storici e tag storici per questa parte di presentazione descritto in HTML e Markup.
Introduzione È un linguaggio indipendente per la descrizione della grafica. La cosa bella è iil fatto di essere indipendente, quindi è adatto a HTML, a XML e simili.
Una cosa particolare è il cascading quindi il fatto che dichiarazioni più nuove sovrascrivano o espandino dichiarazione vecchie.</description>
    </item>
    <item>
      <title>Goals of Distributed systems</title>
      <link>https://flecart.github.io/notes/goals-of-distributed-systems/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/goals-of-distributed-systems/</guid>
      <description>Dependable systems Introduzione Possiamo individuare alcune proprietà dei sistemi distribuiti. Però non siamo riusciti a renderli logicamente validi. Sono ancora un pò misti di linguaggio naturale e della sua ambiguità! Comunque possiamo ridurci per guardare quanto un sistema sia affidabile a guardare poche sue caratteristiche precise.
Caratteristiche fondamentali (4) Queste proprietà sono pensate naturalmente caratterizzanti dei sistemi. In particolare dovrebbero essere tutti misurabili.
Availability
Che risponde nell’istante in cui fai una richiesta.</description>
    </item>
    <item>
      <title>Introduzione a Logica</title>
      <link>https://flecart.github.io/notes/introduzione-a-logica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-a-logica/</guid>
      <description>Lo scopo della logica è
Correttezza del ragionamento, anche verificata attraverso algoritmi predittivi. Si svilupperanno linguaggi logici I metodi per la veridicità di una sentenza. Possibilità e metodi del ragionamento logico Completezza e non-deducibilità di alcuni ragionamenti Necessità di completezza delle ipotesi: più ipotesi = ragionamento valido? Completezza delle tesi, impossibile. Una necessità della logica è Meta-logica:
La logica si deve cercare di basare su certe basi, spesso queste non sono certe, però danno un certo grado di sicurezza → Se la base è solida allora tutto il ragionamento di una parte è giusta</description>
    </item>
    <item>
      <title>Legge di Gauss</title>
      <link>https://flecart.github.io/notes/legge-di-gauss/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/legge-di-gauss/</guid>
      <description>Introduzione alla legge di gauss Giustificazione con angoli solidi 🟨&amp;ndash; Pagina 69 del Mazzoldi. Vogliamo chiederci quanto sia il flusso in qualunque superficie Da un punto di vista infinitesimo abbiamo che (perché il flusso è, intuitivamente, la parte perpendicolare rispetto la superficie che abbiamo) $$ d\Phi = \vec{E}\cdot \vec{dS} = \lvert \vec{E} \rvert \lvert \vec{dS} \rvert \cos \theta = \frac{1}{4\pi\varepsilon_{0}}\frac{1}{r^{2}} ds = \frac{Q}{4\pi\varepsilon}d\Omega $$ Il secondo passaggio è giustificabile andando su coordinate polari considerando l&amp;rsquo;angolo solido di un oggetto quindi non dovrebbe essere un problema.</description>
    </item>
    <item>
      <title>Nomi e Scope</title>
      <link>https://flecart.github.io/notes/nomi-e-scope/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/nomi-e-scope/</guid>
      <description>I Nomi e oggetti Oggetti denotati e identificatori🟩 I nomi sono sequenze di caratteri o numeri aka: token alfanumerico (anche IDENTIFICATORE (per token guardare Grammatiche Regolari) utilizzate principalmente come Astrazione sul controllo e sui dati (quindi sono cose molto più facili da ricordare rispetto il suo encoding binario o a indirizzi). Infatti utilizziamo i nomi per evitare di interessarci di informazioni come l’indirizzo di memoria del nostro dato o per creare una interfaccia con visibili solo nome della procedura e parametri.</description>
    </item>
    <item>
      <title>Normalizzazione dei database</title>
      <link>https://flecart.github.io/notes/normalizzazione-dei-database/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/normalizzazione-dei-database/</guid>
      <description>Introduzione alla normalizzazione Perché si normalizza? 🟩 Cercare di aumentare la qualità del nostro database, perché praticamente andiamo a risolvere delle anomalie possibili al nostro interno, e questo aiuta per la qualità.
Tipologie di anomalie (!) (4) 🟨++ Ridondanze, non vorrei avere la stessa informazione espressa più volte in troppi punti. Update non consistente, quando per aggiornare un singolo valore devo aggiornare moltissime altre tuple dipendenti da essa. Deletion non consistente, la presenza di certe entità è strettamente dipendente da presenza di altri, nell&amp;rsquo;esempio in questione sulle slides, se elimino tutti gli utenti, elimino anche i progetti su cui hanno partecipato, mentre invece dovrebbero essere separati.</description>
    </item>
    <item>
      <title>Top-down Parser</title>
      <link>https://flecart.github.io/notes/top-down-parser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/top-down-parser/</guid>
      <description>Top-down Algoritmo di parsing 🟩 Slide
Questo si potrebbe considerare come algoritmo classico di parsing con non determinismo. (vado avanti, ed esploro tutto, senza look ahead).
Esempio di esecuzione
Commenti efficienza di sopra 🟩 È molto inefficiente, in particolare si potrebbe trovare una compessità esponenziale del tipo
$O(b^{|w|})$, con b il massimo numero di produzioni. (la produzione maggiore la espando sempre!)
Slide
Si può rendere molto più efficiente con un valore di lookahead.</description>
    </item>
    <item>
      <title>Antenne</title>
      <link>https://flecart.github.io/notes/antenne/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/antenne/</guid>
      <description>Omnidirezionali Antenne omnidirezionali 🟩 Slides antenne omnidirezionali
Il senso di omnidirezionale è in tutte le direzioni dell&amp;rsquo;antenna (nota: non è isotropico, perché non è da un singolo punto).
in passato era importante andare a guardare la direzione per trovare la polarizzazione migliore. Praticamente irradia a 360 gradi sul piano permedicolare all’antenna.
Esempio pattern di radiazione
Questo genere di antenne sono irrealizzabili la più simile è la antenna dipolo dipolo, ma comunque non rispetta le antenne in questo verso diciamo.</description>
    </item>
    <item>
      <title>Base e dimensione</title>
      <link>https://flecart.github.io/notes/base-e-dimensione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/base-e-dimensione/</guid>
      <description>2.1 Basi 2.1.1 Definizione Un insieme di vettori $v_1,...,v_n$ sono basi di uno spazio vettoriale $V$ se sono soddisfatte queste proprietà
$V = \langle v_1,...,v_n\rangle$ $v_1,...,v_n$ sono linearmente indipendenti Dalla proprietà 2 potremmo anche dire che è il minimo insieme di vettori necessario per avere questa base.
Finitamente generato
Se l&amp;rsquo;insieme dei vettori nella base è finito allora posso dire che è finitamente generato
Ma possiamo trovare anche spazi che non sono finitamente generati come $\R[x]$ che non hanno un numero finito di basi (perché dipende dal grado dei polinomi che può essere infinito).</description>
    </item>
    <item>
      <title>Common problems in Theoretical CS</title>
      <link>https://flecart.github.io/notes/common-problems-in-theoretical-cs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/common-problems-in-theoretical-cs/</guid>
      <description>This note is useful to gather in a single place the description of some common problems in CS and their theoretical implications explained in other notes.
The Clique problem Description of the problem This problem is in NP, find all sub-graphs where all nodes are connected (this set of nodes forms a complete graph).
We can prove that the problem is in NP because there is an easy non-deterministic algorithm that computes it.</description>
    </item>
    <item>
      <title>Compression Algorithms</title>
      <link>https://flecart.github.io/notes/compression-algorithms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/compression-algorithms/</guid>
      <description>Lempel-Ziv-Welch Algorithm Introduzione sul funzionamento Primo scan con un dizionario indexato dei singoli caratteri Poi viene cercato di raggruppare caratteri a coppie. Se una coppia è già presente nel dizionario, allora aggiungo al dizionario una cosa più lunga e metto un code diverso Esempio di sopra. La cosa carina è che il dizionario si può ricostruire in fase di decoding.
Tutti gli altri, tipo zip, gzip, png si basano poi su questa idea.</description>
    </item>
    <item>
      <title>Consensus protocols</title>
      <link>https://flecart.github.io/notes/consensus-protocols/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/consensus-protocols/</guid>
      <description>Introduzione Vogliamo tenere in modo sincronizzato alcune macchine, questo è il nostro obiettivo. Questo è un problema abbastanza difficile… Come tenere in sync se ci sono alcuni nodi maligni o la rete che non è bona?
Assunzioni principali (2) Esiste internet Esiste Crittografia Queste sono le assunzioni che non saranno mai rilassate per l’intero corso, diciamo che sono la nostra base su cui possiamo andare a costruire la base per il nostro studio.</description>
    </item>
    <item>
      <title>OTP and Stream Ciphers</title>
      <link>https://flecart.github.io/notes/otp-and-stream-ciphers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/otp-and-stream-ciphers/</guid>
      <description>XOR operation È una operazione binaria abbastanza semplice però ci sarà importante per andare ad analizzare dei cifrari di un certo genere. Come il ONE TIME PAD che faremo fra poco in OTP and Stream Ciphers.
Teorema cifratura con XOR Prendiamo $X$ una variabile aleatoria in $\left\{ 0,1 \right\}^{n}$ uniforme, sia $Y$ una variabile aleatoria su uno stesso dominio come vogliamo. Tali per cui $X, Y$ siano indipendenti Allora avremo che $C = X \oplus Y$ è una variabile aleatoria uniforme.</description>
    </item>
    <item>
      <title>Spazi di probabilita</title>
      <link>https://flecart.github.io/notes/spazi-di-probabilita/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/spazi-di-probabilita/</guid>
      <description>In order to define the concept of probability formally, we need first to introduce some mathematical concepts.
La probabilità Termini Esito ed esperimenti aleatorio L’evento è quello che accade, mentre un esperimento aleatorio qualcosa di cui vogliamo andare a misurare la probabilità diciamo. Esperimento aleatorio: esperimento di cui non conosciamo il risultato con certezza. Esito: risultato dell’esperimento aleatorio
Spazio campionario ed evento Spazio campionatorio Lo spazio campionatorio è l&amp;rsquo;insieme di tutti gli stati possibili per una certa cosa da misurare (ossia di un esperimento aleatorio), gli stati sono talvolta anche chiamati sample points oppure outcomes in modo più semplice.</description>
    </item>
    <item>
      <title>Algebra lineare numerica</title>
      <link>https://flecart.github.io/notes/algebra-lineare-numerica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algebra-lineare-numerica/</guid>
      <description>In questa sezione andiamo ad indagare metodi di scomposizione, iterativi e non. Ci sono molte matrici importanti per questa parte che dovremmo prendere confidenza.
Immagini Lab 2 images
Metodo di gauss Vogliamo cercare un metodo per calcolare soluzioni a sistemi di equazione del genere:
$Ax = b$, classico. Supponiamo che questo sistema abbia una soluzione.
Il nostro obiettivo sarebbe scomporre la matrice $A = LU$ come prodotto di due matrici Lower triangular e Upper triangular.</description>
    </item>
    <item>
      <title>Introduction to statistical learning</title>
      <link>https://flecart.github.io/notes/introduction-to-statistical-learning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduction-to-statistical-learning/</guid>
      <description>Introduzione This is a short introduction to statistical learning, made with the help of the book (James et al. 2023).
statistical learning refers to a set of approaches for estimating $f$ .
Utilizzi del statistical learning Solitamente sono due gli utilizzi Predizione e inferenza. Per predizione intendiamo il miglior modello che possa produrre le Y che ancora non conosciamo. Per inferenza significa il miglior modello f per predire Y che conosciamo.</description>
    </item>
    <item>
      <title>Livello applicazione e socket</title>
      <link>https://flecart.github.io/notes/livello-applicazione-e-socket/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/livello-applicazione-e-socket/</guid>
      <description>Livello trasporto Protocolli classici Introduzione a TCP e UPD Il quarto livello dei protocolli dell’architettura di Internet è il livello trasporto (transport), ed è basato su due protocolli in particolare: il Transmission Control Protocol (TCP) e lo User Data Protocol (UDP), che possono essere usati in alternativa tra loro.
Questo è nel genere di *connession oriented e non, il primo, TCP è connection oriented, l&amp;rsquo;altro no, questa è l’unica differenza fra i due.</description>
    </item>
    <item>
      <title>Memory Corruption</title>
      <link>https://flecart.github.io/notes/memory-corruption/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/memory-corruption/</guid>
      <description>First of all, we need to have a strong understanding of how a program allocates memory during its execution. See Memoria, Memoria virtuale and other notes about Nomi e Scope, Gestione della memoria. The thing you have to remember is that
Every new function call allocates a new block, with his local variables. How the calling parameters are stored in the stack How the heap is allocated (common heap algos are in Gestione della memoria) How the stack grows (and how it can overflow it, and overwriting important data).</description>
    </item>
    <item>
      <title>Object detection and Segmentation</title>
      <link>https://flecart.github.io/notes/object-detection-and-segmentation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/object-detection-and-segmentation/</guid>
      <description>Definition of problems Object detection Bisogna trovare all&amp;rsquo;interno dell&amp;rsquo;immagine quali siano gli oggetti presenti, e in più vogliamo sapere dove siano quindi utilizzare una bounding box per caratterizzarli sarebbe buono.
Object segmentation È riuscire a caratterizzare categoria per categoria per singoli pixelsm e per questo motivo potrei riuscire a fare delle image map in cui colorare singoli oggetti in una categoria.
Datasets Example datasets Pascal VOC 2012 Coco datasets Cityscapes dataset Autogenerated datasets But I don&amp;rsquo;t know much about these datasets Applications Auto drive Campo medico (per segmentazione medica o riconoscimento immagini).</description>
    </item>
    <item>
      <title>Programmazione lineare</title>
      <link>https://flecart.github.io/notes/programmazione-lineare/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/programmazione-lineare/</guid>
      <description>Vogliamo cercare di restare nel nostro spazio delle soluzioni ammissibili, senza dover stare ad esplorare tutto, vogliamo andare a concentrarci su una parte specifica di essa. Vogliamo utilizzare una struttura fondamentale per i problemi di programmazione lineare, che è quello con cui vogliamo andare a fare. Il fatto è che spostandoci leggermente da un punto tra le soluzioni, possiamo gestire in modo molto semplice il modo con cui si sposta la retta dei valori.</description>
    </item>
    <item>
      <title>Syncronous model</title>
      <link>https://flecart.github.io/notes/syncronous-model/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/syncronous-model/</guid>
      <description>Introduction Da ricordare il &amp;ldquo;The State Machine Replication (SMR) Problem&amp;rdquo; in Consensus protocols che è importantissimo per comprendere questa parte.
Storia locale Transazioni al singolo noto Problema del sync fra tutti questi nodi.
Goal of SMR solution in blockchains Andiamo a considerare alcune proprietà di safety e liveness Programmi Concorrenti
Consistenza i nodi devono essere daccordo su quale transazione mettere prima e dopo → stessa storia per tutte le transazioni. (con la possibilità di alcuni nodi che siano indietro, ma solo prefisso!</description>
    </item>
    <item>
      <title>Tarjan e MCMF</title>
      <link>https://flecart.github.io/notes/tarjan-e-mcmf/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/tarjan-e-mcmf/</guid>
      <description>Questa sezione la tengo separata rispetto agli altri per favorire lo studio, così questa roba nuova la ripasso più spesso, in seguito si può accorpare.
Goldberg Tarjan/Push-relabel Questo algoritmo è importante perché introduce ragionamenti sul minimo locale che possa alla fine essere ricomposto come soluzione globale.
Questa lezione youtube lo spiega da Dio
Preflusso 🟩 Slide
La parte nuova di questa cosa è che i vincoli di bilanciamento possono diventare una disuguaglianza.</description>
    </item>
    <item>
      <title>The Exponential Family</title>
      <link>https://flecart.github.io/notes/the-exponential-family/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/the-exponential-family/</guid>
      <description>This is the generalization of the family of function where Softmax Function belongs. Many many functions are part of this family, most of the distributions that are used in science are part of the exponential family, e.g. beta, Gaussian, Bernoulli, Categorical distribution, Gamma, Beta, Poisson, are all part of the exponential family. The useful thing is the generalization power of this set of functions: if you prove something about this family, you prove it for every distribution that is part of this family.</description>
    </item>
    <item>
      <title>Backpropagation</title>
      <link>https://flecart.github.io/notes/backpropagation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/backpropagation/</guid>
      <description>Backpropagation is perhaps the most important algorithm of the 21st century. It is used everywhere in machine learning and is also connected to computing marginal distributions. This is why all machine learning scientists and data scientists should understand this algorithm very well. An important observation is that this algorithm is linear: the time complexity is the same as the forward pass. Derivatives are unexpectedly cheap to calculate. This took a lot of time to discover.</description>
    </item>
    <item>
      <title>Fn Ordine superiore</title>
      <link>https://flecart.github.io/notes/fn-ordine-superiore/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/fn-ordine-superiore/</guid>
      <description>Questa parte è strettamente collegata conl a parte di Astrazione sul controllo.
Si parla di passare le funzioni come dati. e quindi possono essere passati come se fossero dei parametri.
un linguaggio di programmazione è di ordine superiore qualora ammetta funzioni sia come parametro che come risultato di altre funzioni.
La parte molto simile alla precedente è il fatto di valutare la funzione nell&amp;rsquo;ambiente iniziale, quindi bisogna utilizzare un sistema simile a quello del passaggio per nome.</description>
    </item>
    <item>
      <title>Maximum Entropy Principle</title>
      <link>https://flecart.github.io/notes/maximum-entropy-principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/maximum-entropy-principle/</guid>
      <description>The maximum entropy principle is one of the most important guiding motives in artificial artificial intelligence. Its roots emerge from a long tradition of probabilistic inference that goes back to Laplace and Occam&amp;rsquo;s Razor, i.e. the principle of parsimony.
Let&amp;rsquo;s start with a simple example taken from Andreas Kraus&amp;rsquo;s Lecture notes in the ETH course of Probabilistic Artificial Intelligence:
Consider a criminal trial with three suspects, A, B, and C. The collected evidence shows that suspect C can not have committed the crime, however it does not yield any information about sus- pects A and B.</description>
    </item>
    <item>
      <title>Model of Analogies</title>
      <link>https://flecart.github.io/notes/model-of-analogies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/model-of-analogies/</guid>
      <description>The human ability of making analogies proceeds in such a way as to keep complexity minimal.
Perché facciamo questo? Perché è la cosa più semplice da fare! Anche su Vapnik&amp;rsquo;s dimensions è simile questa idea!
Occam razor, Epicuro, con Solomonoff che ha risolto problema dell&amp;rsquo;induzione che Hume pensava di fare con abitudini. Attualmente IQ tests provano a misurare la capacità di estendere questo.
Analogia Studiamo l&amp;rsquo;analogia come oggetto matematico perché sembra essere una capacità molto difficile da generalizzare e utilizzare nelle macchine.</description>
    </item>
    <item>
      <title>Parametric Modeling</title>
      <link>https://flecart.github.io/notes/parametric-modeling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/parametric-modeling/</guid>
      <description>In this note we will first talk about briefly some of the main differences of the three main approaches regarding statistics: the bayesian, the frequentist and the statistical learning methods and then present the concept of the estimator, compare how the approaches differ from method to method, we will explain maximum likelihood estimator and the Rao Cramer Bound.
Short introduction to the statistical methods Bayesian With bayesian methods we often assume a prior on the parameters, often human picked, that allows to give a regularizer term over the possible distribution that we are trying to model.</description>
    </item>
    <item>
      <title>Reinforcement Learning, a introduction</title>
      <link>https://flecart.github.io/notes/reinforcement-learning-a-introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/reinforcement-learning-a-introduction/</guid>
      <description>The main difference between reinforcement learning and other machine learning, pattern inference methods is that reinforcement learning takes the concept of actions into its core: models developed in this field can be actively developed to have an effect in its environment, while other methods are mainly used to summarize interesting data or generating sort of reports.
Reinforcement learning (RL) is an interdisciplinary area of machine learning and optimal control concerned with how an intelligent agent ought to take actions in a dynamic environment in order to maximize the cumulative reward.</description>
    </item>
    <item>
      <title>Cloud Storage</title>
      <link>https://flecart.github.io/notes/cloud-storage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cloud-storage/</guid>
      <description>Paradigms of data storage ETL framework 🟩 This is the classical database approach: We load the data in the database and let the underlying system handle it. We won&amp;rsquo;t talk much about this but this is the general concept!
Data Lakes 🟩 We typically store data in the filesystem, where it is viewed simply as files. This approach works well when we only need to read the data. It&amp;rsquo;s often referred to as in situ storage because there is no need to extract the data first.</description>
    </item>
    <item>
      <title>IPSec protocol</title>
      <link>https://flecart.github.io/notes/ipsec-protocol/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/ipsec-protocol/</guid>
      <description>Questo è un protocollo di sicurezza a livello Rete e non più a livello socket!
Perché vorremmo avere sicurezza a questo livello? È una cosa troppo comune da dover mettere a livello superiore (ma solitamente viene messa a questo livello per la sicurezza, quindi non è implementata ovunque per dire), quindi IPsec vuole facilitare l&amp;rsquo;implementazione dei principi CIA a un livello più basso, in modo che sia flessibile e customizzabile.</description>
    </item>
    <item>
      <title>Polimorfismo</title>
      <link>https://flecart.github.io/notes/polimorfismo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/polimorfismo/</guid>
      <description>Introduzione Monoforfo 🟩 Quando non posso utilizzare un tipo come parametro. Ossia non possiamo definire una funzione generica.
Slide monomorfismo
Polimorfismo Polimorfismo, come dice il nome, significa avere tante forme, in questo caso tanti tipi. Ma avere tanti tipi non è una cosa ambigua? Questa cosa si risolve solitamente a compile time (facendo checks di sottotipo, oppure dispatch della funzione corretta).
Tipologie di Polimorfismo (3) 🟩 Slide tipologie di monomorfismo</description>
    </item>
    <item>
      <title>R e Intervalli</title>
      <link>https://flecart.github.io/notes/r-e-intervalli/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/r-e-intervalli/</guid>
      <description>2.1 Necessità e caratteristiche di R 2.1.1 Radici di N non perfetti e Q $\sqrt{n} \in \mathbb{Q} \implies n \text{ è quadrato perfetto}$
Fai lemma della divisibilità fra due numeri
Lemma: Dati $m,n,l$ tali che $MCD(m,l)=1$ e $l | m n$ allora allora $l | n$ Questo si risolve con ragionamenti sui fattori di m e n. Per dimostrare che è razionale la radice di solamente una radice perfetta parto da un numero razionale, faccio certi ragionamenti e scoprirò alla fine che il numero deve essere una radice perfetta.</description>
    </item>
    <item>
      <title>Rappresentazione delle informazioni</title>
      <link>https://flecart.github.io/notes/rappresentazione-delle-informazioni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/rappresentazione-delle-informazioni/</guid>
      <description>6.1 Codifiche Si utilizzano codifiche, che sono delle convenzioni, qualcosa che un gruppo di umani ha deciso fosse utile darci un significato.
6.1.1 Codifica posizionale Dove $d_i$ è il valore in posizione $i$ e $b$ è la base
$$ \sum_{i=0}^k d_ib $$ 6.1.2 Ottale, esadecimale e binario Queste sono le codifiche principali per i computer in quanto sono comodi da visualizzare. Inoltre Ottale e esadecimale in particolare sono riassunti dei binari, cioè sono dei sottoinsiemi che possiedono ancora tutte le caratteristiche e quindi sono comodi</description>
    </item>
    <item>
      <title>Teorema di Rice</title>
      <link>https://flecart.github.io/notes/teorema-di-rice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/teorema-di-rice/</guid>
      <description>Introduction to the Rice Theorem Ci sono molti teoremi che non possono essere decisi, vedere Halting Theorem and Reducibility. Qui andiamo a chiederci quale sia l&amp;rsquo;insieme dei problemi decidibili.
Proprietà dei linguaggi TM🟩 Data una macchina $\mathcal{M}$ definiamo il suo linguaggio come $$ L_{\mathcal{M}} = \left\{ x \in \Sigma^{*}: \mathcal{M} \text{ accetta } x \right\} $$ Allora con questa definizione di linguaggio possiamo dire che una proprietà, ossia una funzione da tutti i $TM$ possibili a $\left\{ 0, 1 \right\}$ tale per cui se il linguaggio riconosciuto è lo stesso, ossia $$ L_{\mathcal{M}} = L_{\mathcal{M}&#39;} \implies P(\mathcal{M}) = P(\mathcal{M}&#39;) $$ Definiamo questa non triviale se esiste una macchina per cui è 0, e una per cui è 1 (ossia non è costante).</description>
    </item>
    <item>
      <title>Architettura software del OS</title>
      <link>https://flecart.github.io/notes/architettura-software-del-os/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/architettura-software-del-os/</guid>
      <description>A seconda dell&amp;rsquo;utilizzatore l’OS può essere molte cose, come solamente l’interfaccia se sei un programmatore, servizi (se sei un utente, ma gran parte dei servizi sono astratti e l&amp;rsquo;utente ne può anche essere a non-conoscenza).
Ma se sei un programmatore OS ti interessa capire le componenti principali dell’OS
Slide componenti OS alto livello Introduzione sui componenti (salto) Questa parte la salto perché è una descrizione molto generale di cosa si occupa L’os verso drivers, processi, filesystem I/O, quindi non è molto importante</description>
    </item>
    <item>
      <title>Expressiveness of NN</title>
      <link>https://flecart.github.io/notes/expressiveness-of-nn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/expressiveness-of-nn/</guid>
      <description>The perceptron Slide summary of working of perceptron
Note on the bias: it is only useful to move the treshhold where to consider the output to be 1 and where to be 1.
Now we ask what can be predicted by a perceptron?
We can see the update rule of the perceptron:
$$ \begin{cases} w = w + \alpha x \\ b = b + \alpha \end{cases} $$ Where $$ \alpha = \begin{cases} 0 &amp; \Theta(x \theta + b) = y \\ -1 &amp; \Theta(x \theta + b) &gt; y \\ 1 &amp; \Theta(x \theta + b) &lt; y \end{cases} $$ Linearly separability necessity Hyperplanes, because that equation is an hyperplane, so we are sure that we can predict an hyperplane, and that it, and it’s only it.</description>
    </item>
    <item>
      <title>Magnetismo nella materia</title>
      <link>https://flecart.github.io/notes/magnetismo-nella-materia/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/magnetismo-nella-materia/</guid>
      <description>Analisi macroscopica Setting dell&amp;rsquo;esperimento 🟩 Provare a guardare 269 del Mazzoldi. (227 per la defivazione della forza.) Si può dimostrare che $$ \vec{F} = -\vec{\nabla} \cdot U \implies F = -\vec{\nabla}(\vec{m} \cdot \vec{B}) = \pm m \frac{dB}{dx} $$ La prima relazione si deriva da definizione di lavoro e forza. (esteso al caso di una forza applicata su spira che non è banale, facciamola brevemente).
Sappiamo che $U = - m \cdot B$, quindi è vero che $dW = -dU = i d \Phi (B)$ e poi utilizzando una proprietà del gradiente in Divergenza e Circuitazione abbiamo $$ Fds = dW = -dU = i \nabla \Phi(B) ds \implies F = i\nabla \Phi(B) = m \cdot \nabla B = -\nabla U $$ La cosa da notare è che per campi uniformi abbiamo che si può definire il lavoro.</description>
    </item>
    <item>
      <title>Metadati web e web semantico</title>
      <link>https://flecart.github.io/notes/metadati-web-e-web-semantico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/metadati-web-e-web-semantico/</guid>
      <description>Metadati web https://csunibo.github.io/tecnologie-web/lucidi/teoria/23-metadati.pdf https://csunibo.github.io/tecnologie-web/lucidi/teoria/24-a-web-semantico-lod-rdf-json-ld.pdf
inconfrontabilità del sapere Stessa informazione in forme diverse Stessa parola per cose diversa. Serializzazione La semantica è relegata alle applicazioni che devono decidere in che modo interpretarli, oppure esseri umani.
PICS Platform for Internet Content Selection vuole cercare di tenere sotto controllo i materiali del film. È un sistema di rating. → tanti criteri di classificazione a seconda dei criteri ideologici su cui voglio andare a basarmi.</description>
    </item>
    <item>
      <title>Object orientation</title>
      <link>https://flecart.github.io/notes/object-orientation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/object-orientation/</guid>
      <description>Ripasso Prox: 10 Ripasso: May 29, 2023 Ultima modifica: May 19, 2023 10:33 AM Primo Abbozzo: May 8, 2023 9:20 AM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
Elementi di ripasso Object orientation il tipo di dato astratto Introduzione Per questi tipi di dato non ci interessa di sapere cosa ci sia sotto (storato come bit? storato come sabbia boh), ci interessa solamente che abbia quei metodi, che possiamo in un certo senso identificare come la sua capsula, opaca in questo caso.</description>
    </item>
    <item>
      <title>Geometrie di spire</title>
      <link>https://flecart.github.io/notes/geometrie-di-spire/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/geometrie-di-spire/</guid>
      <description>Spire Spira quadrata Questo è descritto nell&amp;rsquo;esempio 8.1 del Mazzoldi. È stato descritto anche in un esercizio in classe (non è importante).
Spira circolare 🟩 Vedere pagina 245 Vogliamo cercare il valore del campo sull&amp;rsquo;asse della spira circolare. Questo è semplice, basta usare la prima di Laplace e trovare l&amp;rsquo;apporto del campo magnetico al centro. Si può anche pensare come momento magnetico, allora si utilizza sempre lo stesso discorso per la spira quadrata classica e il suo momento.</description>
    </item>
    <item>
      <title>Gruppi</title>
      <link>https://flecart.github.io/notes/gruppi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gruppi/</guid>
      <description>Definizione gruppo Qualunque insieme più operazione tale per cui:
Esistenza dell&amp;rsquo;inverso per ogni elemento $\forall g \in G, \exists g^{-1} \in G : gg^{-1} = e$ Esistenza di un elemento neutro $\exists e \in G: \forall g \in G, eg = g$ Associatività: $(gh)f = g(hf)$ Closure: $\forall g, h \in G \implies gh \in G$ Unicità dell’elemento neutro Supponiamo di avere un gruppo $G$ e due elementi neutri $e, f$ Allora abbiamo che $ae = a = af$ però se moltiplichiamo per l&amp;rsquo;inversa abbiamo che $a^{-1}ae = a^{-1}af \implies e = f$</description>
    </item>
    <item>
      <title>Introduzione a blockchain</title>
      <link>https://flecart.github.io/notes/introduzione-a-blockchain/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-a-blockchain/</guid>
      <description>Blockchain stack Vogliamo andare ora a descrivere la stack delle blockchain, in modo simile a quanto fatto con le internet, perché anche qui possiamo organizzarlo a stack!
Nota: le astrazioni fra questi layer non sono definiti bene come osi osint.
Layer - 0 Internet Internet (semi-reliable point-to-point communication) and cryptography (specifically, cryptographic hash functions and secure digital signatures).
Layer - 1 Consensus Ci concentreremo sui protocolli di questo per la maggior parte di quanto faremo!</description>
    </item>
    <item>
      <title>Inverse Transform</title>
      <link>https://flecart.github.io/notes/inverse-transform/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/inverse-transform/</guid>
      <description>NOTE: this is an old set of note, and it is of quite bad quality, it should be completely rewritten.
How can we transform a uniform into a random variable? It is true that we have $$ F(x) = \int _{-\infty}^{x} f(t) \, dt $$ A volte la densità non è definita, mentre la funzione cumulativa lo è , per questo spesso cominciamo a definire partendo dalla definizione.
Suppose we have a $x \sim F_{X}(x)$ where $F$ is a cumulative distribution function, same thing, we just need to take the set, normal cumulative distribution function that we saw a lot in other courses.</description>
    </item>
    <item>
      <title>Sintassi e RI strutturali</title>
      <link>https://flecart.github.io/notes/sintassi-e-ri-strutturali/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/sintassi-e-ri-strutturali/</guid>
      <description>Programmare e dimostrare sono sostanzialmente la stessa attività ~Coen
Ma non secondo l&amp;rsquo;industria&amp;hellip;
4.1.1 Definizione e necessità Branca della linguistica, studia creazione di proposizione e il loro collegamento per la creazione di un periodo
In seguito la semantica dà un metodo a queste proposizioni in modo che abbiano un senso.
Utile o necessario per la definizione del linguaggio artificiale 4.1.2 Alfabeto, stringa, linguaggio e grammatica Alfabeto: Insieme non vuoto di simboli (che spesso sono diversi fra di loro) Stringa seguenza finita (vuoto è possibile) di simboli $\epsilon = \varnothing$ Linguaggio: insieme di stringhe (di qualunque tipo, finito o infinito).</description>
    </item>
    <item>
      <title>Time and Space Complexity</title>
      <link>https://flecart.github.io/notes/time-and-space-complexity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/time-and-space-complexity/</guid>
      <description>In this note we explore a theme of time and space complexity. Those are cardinal themes in Theoretical CS. Time -&amp;gt; execution step bounds on algorithms Space -&amp;gt; the cells visited by a Turing Machine when executed.
Introduction to Time Complexity This note will build upon know techniques of algorithms analysis explained in Notazione Asintotica. We will need big-$O$ notation and $o$ notation. L&amp;rsquo;idea è che il problema di decisione è decidibile se limito la lunghezza del teorema.</description>
    </item>
    <item>
      <title>Variabili aleatorie</title>
      <link>https://flecart.github.io/notes/variabili-aleatorie/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/variabili-aleatorie/</guid>
      <description>Le variabili aleatorie ci permettono di dire qualcosa sullo spazio di probabilità senza andare troppo nei dettagli a considerare singoli eventi e cose simili.
Variabili aleatorie discrete Con le variabili aleatorie cominciamo ad entrare nel noccio della questione, finalmente possiamo in un certo senso legare l’outcome di un evento, alla probabilità dell’evento.
Definizione Variabili aleatorie 🟩 Si definisce variabile aleatoria $X$ una funzione da $\Omega \to E$, con $\Omega$ il nostro spazio campionario, e $E$ qualunque insieme (quando $E = \mathbb{R}$ si parla di variabile aleatoria reale</description>
    </item>
    <item>
      <title>Ampere e Faraday</title>
      <link>https://flecart.github.io/notes/ampere-e-faraday/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/ampere-e-faraday/</guid>
      <description>Relazioni con fili - Ampere Legge di Biot-Savart/Formalizzazione esperienza di Ampere 🟩 Poniamo che ho due fili in cui scorra della corrente, voglia capire la forza per unità di lunghezza del filo uno su due e viceversa.
So che entrambi generano campo magnetico So che il campo magnetico induce forza su correnti in movimento. Supponiamo che la loro distanza sia $D$, allora avremo che: Per la prima legge so: $$ d\vec{B} = \mu_{0}i d\vec{l} \times \frac{\hat{r}}{4\pi r^{2}} $$ da questo posso calcolare il campo magnetico totale, in un modo simile a quanto fatto in precedenza per il campo elettrico (solo che in questo caso abbiamo il prodotto seno, quindi l&amp;rsquo;angolo che conviene scegliere è un po&amp;rsquo; diverso), e una volta che ho questo posso usare la seconda legge per avere la forza, questo è il piano.</description>
    </item>
    <item>
      <title>Asymptotic Equipartition Property</title>
      <link>https://flecart.github.io/notes/asymptotic-equipartition-property/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/asymptotic-equipartition-property/</guid>
      <description>Sembra essere molto simile a Central Limit Theorem and Law of Large Numbers però per Entropy. This is also called Shannon&amp;rsquo;s source coding theorem see here
Enunciato AEP Data una serie di variabili aleatorie $X_{1}, X_{2}, \dots$ i.i.d. $\sim p(x)$ se vale che $$ -\frac{1}{n} \log p(X_{1}, X_{2}, \dots, X_{n}) \to H(X) $$ in probability (la definizione data in Central Limit Theorem and Law of Large Numbers#Convergence in probability).
Un modo alternativo per enunciarla è così, segue il metodo in (MacKay 2003).</description>
    </item>
    <item>
      <title>Deduzione naturale</title>
      <link>https://flecart.github.io/notes/deduzione-naturale/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/deduzione-naturale/</guid>
      <description>La deduzione naturale è un possibile sistema deduttivo che utilizza il linguaggio naturale per questo motivo più beginner friendly. Lo facciamo prima per la Logica Proposizionale che è molto facile
Il sistema deduttivo Poniamo l&amp;rsquo;esistenza di Assiomi (formule in una certa logica) e regole di inferenza definite sotto. Esempi sono $P \vdash \varphi$ se $\varphi$ è un assioma. O altre cose simili con $\land$ e simili&amp;hellip;
Una dimostrazione allora è una sequenza di $\varphi_{1}, \dots, \varphi_{n}$ dove $\varphi_{i}$ è derivata con le regole di inferenza e $\varphi_{1}, \dots, \varphi_{i - 1}$.</description>
    </item>
    <item>
      <title>Gestione delle eccezioni</title>
      <link>https://flecart.github.io/notes/gestione-delle-eccezioni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gestione-delle-eccezioni/</guid>
      <description>Introduzione Metodi alternativi di gestione degli errori (3) 🟩 A volte le computazioni falliscono. Potremmo gestirle con i result come accennato in Polimorfismo, però diventa molto macchinoso fare tutte le funzioni che debbano inoltrare solamente delle results. bisogna trovare un modo più naturale. Ecco che arriva una gestione delle eccezioni direttamente nel linguaggio. Si tratta un sistema di comunicazione degli errori.
ALTRI METODI
Results, stile monadico, vedi sopra. definire dei valori eccezionali (questo si va spesso in C) Il chiamato dice al chiamante una cosa da chiamare quando fallisce.</description>
    </item>
    <item>
      <title>HTML e Markup</title>
      <link>https://flecart.github.io/notes/html-e-markup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/html-e-markup/</guid>
      <description>Markup Introduzione alle funzioni del markup 🟩 La semantica di una parola è caratterizzata dalla mia scelta (design sul significato). Non mi dice molto, quindi proviamo a raccontare qualcosa in più.
Definiamo markup ogni mezzo per rendere esplicita una particolare interpretazione di un testo.
In particolare è un modo per esplicitare qualche significato. (un pò come la punteggiatura, che da qualche altra informazione oltre le singole parole, rende più chiaro l&amp;rsquo;uso del testo).</description>
    </item>
    <item>
      <title>Porte Logiche</title>
      <link>https://flecart.github.io/notes/porte-logiche/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/porte-logiche/</guid>
      <description>In questa nota andiamo a trattare argomenti come tabelle di verità. Mappe di Karnaugh. E piccolissima introduzione ai circuiti integrati.
Boole Un signor Boole ha creato le basi dell&amp;rsquo;algebra booleana su cui si basano le porte logiche dei computer moderni.
Tabelle di verità Le tabelle di verità sono sufficienti per descrivere il funzionamento di una porta logica.
Questa cosa è possibile grazie alla limitatezza delle funzioni all&amp;rsquo;interno dell&amp;rsquo;insieme $\{0,1\}$ dominio di partenza e fine dell&amp;rsquo;algebra booleana.</description>
    </item>
    <item>
      <title>Strutture di dati elementari</title>
      <link>https://flecart.github.io/notes/strutture-di-dati-elementari/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/strutture-di-dati-elementari/</guid>
      <description>3.1 Introduzione 3.1.1 Cosa sono Le strutture di dati si interessano solamente di come memorizzare i dati, non necessariamente va a memorizzare un tipo di dato concreto.
Quindi + sul come - sul cosa.
3.1.2 Prototipo e implementazione Avevamo introdotto la differenza fra algoritmo e programma all&amp;rsquo;inizio del corso, andiamo ora a definire la differenza fra prototipo e implementazione:
Prototipo:
va a fare una descrizione dei metodi che deve avere una determinata struttura di dati.</description>
    </item>
    <item>
      <title>Wifi 802-11</title>
      <link>https://flecart.github.io/notes/wifi-802-11/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/wifi-802-11/</guid>
      <description>In this document, we will discuss the actual Wi-Fi standard that we can find in the market.
The initial slides consist of extensive lists of Wi-Fi technologies and their uses, such as Bluetooth network, Wi-Fi network, long-range Wi-Fi, and 3G network.
However, they are currently out of service.
Service Sets Basic Service Set There are various divisions within the service set, each of which provides certain types of service.
In the basic service, we have things like SSID, which is the service set identifier that is broadcasted in the beacon as described in Mac Wifi.</description>
    </item>
    <item>
      <title>Asymmetric Cryptography</title>
      <link>https://flecart.github.io/notes/asymmetric-cryptography/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/asymmetric-cryptography/</guid>
      <description>Public Key Encryption We now define a formally what is a public key encryption
Formal definition of Public Key Encryption We define a 3-tuple formed as follows: $(G, E, D)$ where
$G$ is the generator for the private and public keys, from now on identified as $(pk, sk)$ (public key and secret key) $E(pk, m)$ the encryption algorithm, that takes the $pk$ and the message in input $D(sk, c)$ the decryption algorithm, that takes the $sk$ and the ciphertext in input.</description>
    </item>
    <item>
      <title>Bag of words</title>
      <link>https://flecart.github.io/notes/bag-of-words/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bag-of-words/</guid>
      <description>Bag of words only takes into account the count of the words inside a document, ignoring all the syntax and boundaries. This method is very common for email classifications techniques. We can say bag of words can be some sort of pooling, it&amp;rsquo;s similar to the computer vision analogue. It&amp;rsquo;s difficult to say what is the best method (also a reason why people say NLP is difficult to teach).
Introduction to bag of words Faremo una introduzione di applicazione di Naïve Bayes applicato alla classificazione di documenti.</description>
    </item>
    <item>
      <title>Cauchy-Schwarz Inequality</title>
      <link>https://flecart.github.io/notes/cauchy-schwarz-inequality/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cauchy-schwarz-inequality/</guid>
      <description>This note briefly states and proves one of the most famous inequalities in geometry/analysis.
Theorem Statement Given $2n$ real numbers (you can see these two also as $n$ dimensional vectors), such as $x_{1}, \dots, x_{n}$ and $y_{1}, \dots, y_{n}$ then we have that $$ \left( \sum_{i = 1}^{n} x_{i}y_{i} \right) ^{2} \leq \left( \sum_{i= 1}^{n} x^{2}_{i} \right) \left( \sum_{i = 1}^{n} y^{2}_{i} \right) $$ In vectorial form we can rewrite this as $$ \lvert \langle u, v \rangle \rvert ^{2} \leq \langle u, u \rangle \cdot \langle v, v \rangle $$ with $u = \left( x_{1}, \dots, x_{n} \right)$ and $v = \left( y_{1}, \dots, y_{n} \right)$ and the $\langle \cdot, \cdot \rangle$ operator is the inner product.</description>
    </item>
    <item>
      <title>Central Limit Theorem and Law of Large Numbers</title>
      <link>https://flecart.github.io/notes/central-limit-theorem-and-law-of-large-numbers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/central-limit-theorem-and-law-of-large-numbers/</guid>
      <description>Bounds Markov Bound Questo bound è abbastanza banale se fatto da un punto di vista grafico, comunque afferma che $$ P(X \geq y) \leq \frac{E[X]}{y} $$ Il motivo è che (assumendo che $X$ sia una variabile aleatoria non negativa) $$ yP(X \geq y) = y\int _{x =y}^{+\infty} f(x) \, dx \leq \int _{x=y}^{+\infty} x f(x) \, d \leq \int _{-\infty}^{+\infty}xf(x) \, d = E[X] $$ Il che finisce la dimostrazione.</description>
    </item>
    <item>
      <title>Gaussian Processes</title>
      <link>https://flecart.github.io/notes/gaussian-processes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gaussian-processes/</guid>
      <description>Gaussian processes can be viewed through a Bayesian lens of the function space: rather than sampling over individual data points, we are now sampling over entire functions. They extend the idea of bayesian linear regression by introducing an infinite number of feature functions for the input XXX.
In geostatistics, Gaussian processes are referred to as kriging regressions, and many other models, such as Kalman Filters or radial basis function networks, can be understood as special cases of Gaussian processes.</description>
    </item>
    <item>
      <title>Gestione della memoria</title>
      <link>https://flecart.github.io/notes/gestione-della-memoria/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gestione-della-memoria/</guid>
      <description>Memoria statica Elementi in memoria statica (4) 🟩- Variabili globali Istruzioni macchina Costanti (Variabili locali, paramentri e ritorno di funzione?) Le primi tre elementi descritti di sopra sono sicuramente presenti dopo la fase di compilazione, infatti sono allocati dal compilatore in una zona presente nell’eseguibile (un esempio è il READONLY per le stringhe in C).
Quindi se vogliamo
Avere funzioni ricorsive Potere allocare e deallocare variabili in modo dinamico Abbiamo bisogno di far uso di Pila o Heap, che riescano a cresere e restringersi in modo dinamico.</description>
    </item>
    <item>
      <title>Grammatiche Regolari</title>
      <link>https://flecart.github.io/notes/grammatiche-regolari/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/grammatiche-regolari/</guid>
      <description>Introduzione Definizione grammatica regolare 🟩 Definizione
In pratica posso avere solamente come terminali a, oppure un suffisso a su un non terminale.
Queste grammatiche sono interessanti perché è molto facile costruire un automa che sia in grado di riconoscere questo linguaggio.
Seguendo una definizione più lasca possono anche accettare dei nonterminali epsilon
Espressione regolare a NFA 🟩 Questa sezione è anche presente in Automi e Regexp, però è riportata qui così c’è l’insieme di tutte le cose in un unico posto.</description>
    </item>
    <item>
      <title>Introduction to Advanced Machine Learning</title>
      <link>https://flecart.github.io/notes/introduction-to-advanced-machine-learning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduction-to-advanced-machine-learning/</guid>
      <description>Introduction to the course Machine learning offers a new way of thinking about reality: rather than attempting to directly capture a fragment of reality, as many traditional sciences have done, we elevate to the meta-level and strive to create an automated method for capturing it.
This first lesson will be more philosophical in nature. We are witnessing a paradigm shift in the sense described by Thomas Kuhn in his theory of scientific revolutions.</description>
    </item>
    <item>
      <title>Massive Parallel Processing</title>
      <link>https://flecart.github.io/notes/massive-parallel-processing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/massive-parallel-processing/</guid>
      <description>We have a group of mappers that work on dividing the keys for some reducers that actually work on that same group of data. The bottleneck is the assigning part: when mappers finish and need to handle the data to the reducers.
Introduction Common input formats You need to know well what
Shards Textual input binary, parquet and similars CSV and similars General framework We can see in the image taken from the course book [({fourny} 2024)](https://ghislainfourny.</description>
    </item>
    <item>
      <title>Probabilita condizionata e indipendenza</title>
      <link>https://flecart.github.io/notes/probabilita-condizionata-e-indipendenza/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/probabilita-condizionata-e-indipendenza/</guid>
      <description>Condizionata Definizione 🟩 Andiamo a definire una probabilità di un evento $A$, condizionata a un evento non nullo $B$, come
$$ P(A|B) = \dfrac{P(A\cap B)}{P(B)} $$ Questo è la cosa fondamentale per poter considerare cose come bayes perché in questo modo abbiamo una certa relazione fra causa ed effetto e anche il contrario! Cosa che ci piace molto molto molto.
La definizione di sopra è un probabilità 🟩 Dimostrazione mia</description>
    </item>
    <item>
      <title>Project Management</title>
      <link>https://flecart.github.io/notes/project-management/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/project-management/</guid>
      <description>Project, product management, project management Bisogna capire queste definizioni. Vedere https://dynamik.vercel.app/ingegneria-del-software/lucidi/13-gestione-del-progetto.pdf?from=informatica, slide 5 per definizione
Progetto: inizia e finisce in tempo preciso. È importante comunque ricordare gli steps principali per il progetto ossia ideazione, creazione, mantenimento, rilascio, e poi morte, questo in genere è per qualunque progetto.
Project Manager Compiti principali (costi e risorse) Vedere se il progetto è fattibile Allocare risorse Monitorare come sta andando. (preventivo e consuntivo). Work Breakdown structure Descrizione WBS È una suddivisione del progetto in piccoli sottoparti che si possono gestire in modo autonomo.</description>
    </item>
    <item>
      <title>Bayesian Networks</title>
      <link>https://flecart.github.io/notes/bayesian-networks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bayesian-networks/</guid>
      <description>Questi network bayesiani sono proprio dei grafi, che permettono una migliore comprensione delle relazioni causali o diagnostici fra le probabilità
Esempio rete bayesiana
Note generali Introduzione alla rete classica Una rete bayesiana ci permette di semplificare di molto il calcolo della full disjoint probability table, rendendola in questo modo
Ossia andiamo a utilizzare una probabilità locale, o sparsa per fare i conti, cosa che semplifica molto, e quindi velocizza il calcolo.</description>
    </item>
    <item>
      <title>Block Ciphers</title>
      <link>https://flecart.github.io/notes/block-ciphers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/block-ciphers/</guid>
      <description>Utilizzano blocchi per cifra invece che stream generators. $n$ bits in input and $m$ bits in output generally a key is expanded into multiple keys, one for each rounds, and applied to a round function that iterates on the $m$.
DES 56 bit 3DES 56*3 bit di chiave AES che può andare a 128, 196 o 256 Solitamente i stream ciphers studiati in OTP and Stream Ciphers sono più veloci. Cipher Speed MB/sec RC4 126 Salsa20 643 Sosemanuk 727 AES 13 3DES 109 Data Encryption Standard - 1974 da IBM su commissione di NSA (Horst Feistel designed Lucifer at IBM in early 1970) - 1976 DES is federal standard with key-len 56 bits and block-len 64 bits.</description>
    </item>
    <item>
      <title>Distributed file systems</title>
      <link>https://flecart.github.io/notes/distributed-file-systems/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/distributed-file-systems/</guid>
      <description>We want to know how to handle systems that have a large number of data. In previous lesson we have discovered how to quickly access and make Scalable systems with huge dimensions, see Cloud Storage. Object storage could store billions of files, we want to handle millions of petabyte files.
Desiderata of distributed file systems 🟩 In this case we have a Filesystem. In 2004 google created his own FS. With hundreds or thousands of machines the systems are practically guaranteed to fail.</description>
    </item>
    <item>
      <title>Inner product spaces</title>
      <link>https://flecart.github.io/notes/inner-product-spaces/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/inner-product-spaces/</guid>
      <description>This set of notes tries to fix what I haven&amp;rsquo;t learned in 2021 course in algebra. It&amp;rsquo;s about inner product spaces. A good online reference on the topic is wilkinson.
Definitions Inner product space We define the vector space $V$ to be a inner product space, if we define a inner product operator ($\langle \cdot, \cdot \rangle : V \times V \to R$) such that the following are valid:
It is linear on both arguments: $$ \langle \alpha x_{1} + \beta x_{2}, y \rangle = \alpha \langle x_{1}, y \rangle + \beta \langle x_{2}, y \rangle $$ It is a symmetric operator: $\langle x, y \rangle = \langle y, x \rangle$ It is positive definite that is we have $\forall x \in V: \langle x, x \rangle \geq 0$ with equality only if $x = \boldsymbol{0}$ An example of such operator is the classical cosine distance which is just the angle, or euclidean distance.</description>
    </item>
    <item>
      <title>Probabilistic Turing Machines</title>
      <link>https://flecart.github.io/notes/probabilistic-turing-machines/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/probabilistic-turing-machines/</guid>
      <description>Introduction to the probabilistic Turing Machine Most of real phenomena are better comprehended by a probabilistic view. This pushes to build a formal model that takes probability into account
Def: Probabilistic TM Take a non deterministic TM La macchina di Turing. At each step there is a fair coin-flip that has two legal branches. So the probability of a certain branch is $$ \mathbb{P}(b) = 2^{-k} $$ Where $k$ is the length of the branch.</description>
    </item>
    <item>
      <title>Relazioni di Ricorrenza</title>
      <link>https://flecart.github.io/notes/relazioni-di-ricorrenza/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/relazioni-di-ricorrenza/</guid>
      <description>Iterazione Questo metodo semplicemente consiste di calcolare tutte le operazioni e scriverlo con una notazione asintotica.
slide
Sostituzione (induzione) slide
Analisi della relazione di ricorrenza di fibonacci
Si può dimostrare utilizzando l&amp;rsquo;induzione che una relazione di questo tipo
$$ T(n) = \begin{cases} O(1) \\ T(n-1) + T(n-2) + 1 \end{cases} $$ Si trova che è $O(2^n), \Omega(2^{n/2})$
Analisi finale.
Si può creare una stima corretta, utilizzando la formula per il calcolo di fibonacci (che dimostri facendo osservazioni su una funzione generatrice di essa, una serie infinita).</description>
    </item>
    <item>
      <title>Ambienti di sviluppo</title>
      <link>https://flecart.github.io/notes/ambienti-di-sviluppo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/ambienti-di-sviluppo/</guid>
      <description>Ambienti di sviluppo Ambiente di sviluppo è diverso rispetto all’ambiente di deploy! bisognare fare delle differenze, sono dell macchine diverse, in questa sezione di documenti andiamo a parlare di norme e modi di lavorare per facilitare il metodo di sviluppo.
Note di compatibilità Front-end Le compatibilità, soprattutto per cose browser (quindi front-end) cambiano molto spesso, come fare a trackare queste cose? C&amp;rsquo;è un sito molto carino come https://caniuse.com/ .
La browser list, è utilizzata per specificare unt browser di target per la nostra applicazione, non ho capito bene cosa serve.</description>
    </item>
    <item>
      <title>Dependency Parsing</title>
      <link>https://flecart.github.io/notes/dependency-parsing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/dependency-parsing/</guid>
      <description>This set of note is still in TODO
Dependency Grammar has been much bigger in Europe compared to USA, where Chomsky&amp;rsquo;s grammars ruled. One of the main developers of this theory is Lucien Tesnière (1959):
“The sentence is an organized whole, the constituent elements of which are words. Every word that belongs to a sentence ceases by itself to be isolated as in the dictionary. Between the word and its neighbors, the mind perceives connections, the totality of which forms the structure of the sentence.</description>
    </item>
    <item>
      <title>Modelli Lineari di sviluppo</title>
      <link>https://flecart.github.io/notes/modelli-lineari-di-sviluppo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/modelli-lineari-di-sviluppo/</guid>
      <description>Introduzione ai modelli lineari Processi di sviluppo Definizione L’insieme strutturato di attività, eventi, documenti e procedure necessari per la costruzione di un sistema software
Cosa viene descritto (4) 🟩 Questo è proprio quanto vuole studiare l&amp;rsquo;ingegneria del software -&amp;gt; metodi di sviluppo, in modo da portare i migliori risultati possibile.
Nella formazione classica va a definire 4 concetti (soprattutto utili nel lavoro di gruppo, al fine di comunicare nella maniera più efficace):</description>
    </item>
    <item>
      <title>Relational Model</title>
      <link>https://flecart.github.io/notes/relational-model/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/relational-model/</guid>
      <description>This is the classical format that we encounter, it is the format used for relational databases introduced in databases course introduction, introduced in (Codd 1970).
Introduzione, i modelli di dati Lista modelli di dati (4) Nel tempo sono stati sviluppati molti modelli di dati:
Relational Data Model: This is the most common data model and uses tables to represent data. It organizes data into rows and columns, where each row represents a record, and each column represents an attribute of that record.</description>
    </item>
    <item>
      <title>Bottom-up Parser LR(1)</title>
      <link>https://flecart.github.io/notes/bottom-up-parser-lr1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bottom-up-parser-lr1/</guid>
      <description>Si può osservare che per il parser costruito in Bottom-up Parser LR(0), non riesce a riconoscere di linguaggi semplici come $L = \{a, ab\}$.
Esempio di quanto detto Parser SLR(1) Questi parser qui utilizzano l’idea del look ahead ampiamente utilizzata in Top-down Parser, per escludere molte produzioni.
La s sta per simple, perché utilizza una idea semplice :D, credo ahah boh.
Riduzione con follow 🟩 noi vogliamo ridurre solamente se ho follow corretto il terminale finale della stringa.</description>
    </item>
    <item>
      <title>Gestione delle risorse</title>
      <link>https://flecart.github.io/notes/gestione-delle-risorse/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gestione-delle-risorse/</guid>
      <description>Gestione delle risorse Introduzione Definizione classe, fungibilità Classe di risorse sono un insieme di risorse fra loro equivalenti (nel senso che uno può rimpiazzare l’uso dell&amp;rsquo;altro), anche detti fungibili.
Statico o dinamico Anche in economia ci sono tali definizioni! Queste risorse possono essere allocate staticamente o dinamicamente, in modo simile a quanto abbiamo detto in Gestione della memoria.
Statico quando già in fase di compilazione del processo, o di avviamento del processo gli dò la memoria, e quella sarà per tutti il tempo della sua vita.</description>
    </item>
    <item>
      <title>Integrali</title>
      <link>https://flecart.github.io/notes/integrali/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/integrali/</guid>
      <description>8.1 Introduzione 8.1.1 Il problema che risolve Vogliamo cercare di creare un metodo matematico che sia utile per calcolare area di qualunque curva.
L&amp;rsquo;idea principale per risolvere questo problema è approssimare l&amp;rsquo;area, lo facciamo utilizzando rettangoli, la formalizzazione sarà molto aiutata dal limite.
8.1.2 Sottografico di funzione $$ A = \{ (x,y) \in \mathbb{R}^2 | x \in D(f(x)), 0\leq y \leq f(x)\} $$ Praticamente sto prendendo tutti in punti positivi sotto al grafico.</description>
    </item>
    <item>
      <title>Proximal Policy Optimization</title>
      <link>https://flecart.github.io/notes/proximal-policy-optimization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/proximal-policy-optimization/</guid>
      <description>(Schulman et al. 2017) è uno degli articoli principali che praticamente hanno dato via al campo. Anche questo è buono per Policy gradients:
https://lilianweng.github.io/posts/2018-04-08-policy-gradient/
Introduzione a PPO References [1] Schulman et al. “Proximal Policy Optimization Algorithms” 2017</description>
    </item>
    <item>
      <title>Singular Value Decomposition</title>
      <link>https://flecart.github.io/notes/singular-value-decomposition/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/singular-value-decomposition/</guid>
      <description>Next time, use this resource.
Di solito è utilizzata per ridurre lo spazio utilizzato trattenendo la maggiore quantità di informazione possibile, utilizzata spesso in Principal Component Analys
Enunciato SVD slide
Immagine esplicativa
Questo è qualcosa che si può applicare a qualunque matrice. Sono di particolare interesse le matrici con numero di colonne maggiore del numero di righe.1
Slide vecchia
Relazione valori singolari con AAt 🟩- Con k ho il numero di numeri non zero che sono il rango della matrice.</description>
    </item>
    <item>
      <title>Sistemi Lineari e determinanti</title>
      <link>https://flecart.github.io/notes/sistemi-lineari-e-determinanti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/sistemi-lineari-e-determinanti/</guid>
      <description>4.1 Sistemi lineari La cosa buona è che possiamo analizzare il sistema lineare utilizzando tutti i teoremi che abbiamo sviluppato finora, quindi siamo molto più potenti per attaccare questo problema.
Definiamo un sistema lineare così
$Ax = b$ con A la matrice associata.
4.1.1 Preimmagine Data una applicazione lineare $F:V \to W$, allora la controimmagine è l&amp;rsquo;insieme dei vettori di V che fanno a finire in quel punto, in matematichese:</description>
    </item>
    <item>
      <title>The RLHF pipeline</title>
      <link>https://flecart.github.io/notes/the-rlhf-pipeline/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/the-rlhf-pipeline/</guid>
      <description>https://huyenchip.com/2023/05/02/rlhf.html è un blog post che lo descrive in modo abbastanza dettagliato e buono.
Introduzione a RLHF Questo è il processo che è quasi la migliore per la produzione di LLM moderni (maggior parte si basano su questo per dire).
Struttura generale Si può dire che RLHF si divida in 3 parti fondamentali
Completion il modello viene allenato a completare parole dal web,solitamente è molto inutile Fine tuning per le singole task, per esempio riassumere, rispondere in certo modo etc.</description>
    </item>
    <item>
      <title>VLAN</title>
      <link>https://flecart.github.io/notes/vlan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/vlan/</guid>
      <description>Introduzione Quando abbiamo una switch, ma vogliamo allo stesso momento andare a creare più LAN, allora abbiamo bisogno delle VLAN. Questi switch che hanno delle VLAN si chiamano managed switches
Queste vlan sono numerate (ricorda l’espericomento cn LUCA!).
Il problema Sono un protocollo livello 2 (Link-Layer, di collegamento), non vorremmo per esempio che un broadcast di una certa rete vada anche in altre reti che non centrino praticamente nulla, come possiamo vedere in figura.</description>
    </item>
    <item>
      <title>Database logical design</title>
      <link>https://flecart.github.io/notes/database-logical-design/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/database-logical-design/</guid>
      <description>Introduzione al design logico Conoscenze sul carico dell&amp;rsquo;applicazione, ossia se ha più read rispetto a writes per esempio, sono dei priors in pratica Un design concettuale spiegato in precedenza. E si avrà in output un design logico con anche un po&amp;rsquo; di documentazione. bisogna in questa fase valutare la performance principalmente su indicatori, ossia una operazione quante istanze visiterà? Invece di garanzie sul numero di transazioni al secondo.
Indicatori visti (2) Costo di una operazione: viene valutato in termini di numero di occorrenze di entità e associazioni che mediamente vanno visitate per rispondere a una operazione sulla base dì dati; questa schematizzazione è molto forte e, pur nelle semplici valutazioni che svilupperemo, sarà talvolta necessario riferirci a un criterio più fine; Occupazione di memoria: viene valutato in termini dello spazio di memoria (misurato per esempio in numero di byte) necessario per memorizzare i dati descritti dallo schema.</description>
    </item>
    <item>
      <title>Fourier Series</title>
      <link>https://flecart.github.io/notes/fourier-series/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/fourier-series/</guid>
      <description>Intuition The most important observation that allows Fourier series approximation is that given $k = 1, 2, \dots$ we have that $$ \frac{1}{\sqrt{ 2\pi }}, \frac{\cos(kx)}{\sqrt{ \pi }}, \frac{\sin(kx)}{\sqrt{ \pi }}, \dots $$ Form a infinitely dimensional orthonormal basis given the integral relations $$ \int_{0}^{2\pi} (\sin (kx))^{2} \, dx = \int_{0}^{2\pi} (\cos(kx))^{2} \, dx = \pi $$ $$ \int_{0}^{2\pi}\sin(kx)\sin(hx) \, dx = \int_{0}^{2\pi}\cos(kx)\cos(hx) \, dx = 0 $$ And that $$ \int_{0}^{2\pi}\sin(kx)\cos(hx) \, dx = \int_{0}^{2\pi} \sin(kx) \, dx = \int_{0}^{2\pi}\cos(hx) \, dx = 0 $$ Proofs of the relations In this section we quickly prove why the above equations hold.</description>
    </item>
    <item>
      <title>Interactive Theorem Provers</title>
      <link>https://flecart.github.io/notes/interactive-theorem-provers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/interactive-theorem-provers/</guid>
      <description>Most of times the pattern of proving and verifying it is like this $prove \to verify$, that is: there is an entity that generates the solution, and then another that tries to verify it. But more expressive algorithms could be possible if there is interaction between the two entities, ones that try to prove it, and others try to verify it. From some point of view, this is similar from what AlphaGo does when searching, there is a part that guides the search, another that actually searches for it.</description>
    </item>
    <item>
      <title>Semantica intuizionista</title>
      <link>https://flecart.github.io/notes/semantica-intuizionista/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/semantica-intuizionista/</guid>
      <description>Molto importante questo documento per avere chiara la differenza fra la logica intuizionista e la Logica Proposizionale classica.
Questa logica intuizionista non si preoccupa del noumeno platonico, ma solo di una prova reale.
Introduzione:
wikipedia
9 11 Scopi di intuizionista (3) Semantica dell&amp;rsquo;evidenza → costruzione della prova Semantica della conoscenza diretta = conoscenza diretta Semantica della calcolabilità = programma, algoritmo della soluzione 9.1 Invenzione o scoperta La semantica intuizionista vede la matematica come una creazione (e questa cosa interessa molto all&amp;rsquo;informatico perché è una prova.</description>
    </item>
    <item>
      <title>Storia del web</title>
      <link>https://flecart.github.io/notes/storia-del-web/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/storia-del-web/</guid>
      <description>Guerre dei browser Prima guerra ~1995
Fra netscape, una forma di rete (?) che poi viene ripresa da firefox da Mozilla, dopo che è stato mandato in bancarotta da Microsoft (che ha ancora con IE una grandissima fetta del mercato in questo primo periodo).
Secondo periodo di guerra ~2010
Quando arriva chrome, che vuole creare un browser che risolva tutti i problemi per creare integrazioni sui browser di altre aziende), mentre IE ha perso interesse per nuove features, che in questo periodo sono capi del proprio mercato.</description>
    </item>
    <item>
      <title>Introduction to Algorithmic Information and Complexity</title>
      <link>https://flecart.github.io/notes/introduction-to-algorithmic-information-and-complexity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduction-to-algorithmic-information-and-complexity/</guid>
      <description>Quick introduction Si assume che la descrizione più intelligente di un qualcosa è la stringa più corta che descrive quella, un po&amp;rsquo; forse è arbitrario, perché minore complessità, non è detto che sia direttamente relazionata con la difficoltà di descriverla.
Nel caso di AIT, diciamo che una cosa random non è compressibile, altrimenti posso scriverla in modo più compatto. È importante stabilire che l&amp;rsquo;alfabeto che abbiamo per rappresentare qualcosa è fissato a priori.</description>
    </item>
    <item>
      <title>Introduction to Topology</title>
      <link>https://flecart.github.io/notes/introduction-to-topology/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduction-to-topology/</guid>
      <description>This small note is an introduction to Topology that follows the introductory arguments of (Armstrong 2013).
Euler&amp;rsquo;s Theorem We will start our journey in topology following a classical example in the history of Mathematics the relation:
$$ v - e + f = 2 $$ Valid for classical Polyhedrons.
Basic definitions Polyhedron It&amp;rsquo;s a collection of plane polygons (see Programmazione lineare#Poliedro) such that:
Every polygon shares each of its edges with exactly another polygon We have vertexes that can be shared by many polygons.</description>
    </item>
    <item>
      <title>Programmi Concorrenti</title>
      <link>https://flecart.github.io/notes/programmi-concorrenti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/programmi-concorrenti/</guid>
      <description>Vorremmo cercare di stabilire una teoria riguardante programmi che vengono eseguiti appunto concorrentemente, senza una esecuzione classica uno dpo l’altro
Esempio mini-programma rallentamento
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;pthread.h&amp;gt; void test(void *s) { for (int i = 0; i &amp;lt; 10; i++) { printf(&amp;#34;%s\n&amp;#34;, s); for (int j = 0; j &amp;lt; 100000000; j++); } } int main(int argc, char *argv[]) { pthread_t t1, t2; pthread_create(&amp;amp;t1, NULL, (void *)test, &amp;#34;Uno&amp;#34;); pthread_create(&amp;amp;t2, NULL, (void *)test, &amp;#34;Due&amp;#34;); pthread_join(t1, NULL); pthread_join(t2, NULL); } Example output:</description>
    </item>
    <item>
      <title>Sezioni Critiche</title>
      <link>https://flecart.github.io/notes/sezioni-critiche/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/sezioni-critiche/</guid>
      <description>Ripasso Prox: 80 Ripasso: May 21, 2023 Ultima modifica: March 12, 2023 10:00 AM Primo Abbozzo: October 8, 2022 11:30 AM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
Elementi di ripasso 2 Sezioni Critiche Introduzione La parte di un programma che utilizza una o più risorse condivise viene detta sezione critica (critical section, o CS)
Andiamo in questa altra parte a valutare certe soluzioni:
Programma d’esempio 🟩 Vorremmo garantire che a = b invariante.</description>
    </item>
    <item>
      <title>Stirling&#39;s Approximation</title>
      <link>https://flecart.github.io/notes/stirlings-approximation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/stirlings-approximation/</guid>
      <description>This note will give a brief derivation of Stirling&amp;rsquo;s approximation. This bound is often useful for factorials. $$ x! \approx x^{x}e^{-x}\sqrt{ 2\pi x } \iff \ln x! \approx x\ln x - x + \frac{1}{2} \ln(2\pi x) $$ This proof (more like an interesting justification). is taken from page 2 of (MacKay 2003).
Let&amp;rsquo;s start with a Poisson distribution with mean $\lambda$ $$ P(r \mid \lambda) = \frac{e^{-\lambda}\lambda^{r}}{r!} $$ If $\lambda$ is large and $r \approx \lambda$, this distribution is approximated by a Gaussian distribution (it is often referred as a discrete Gaussian see Poisson processes).</description>
    </item>
    <item>
      <title>Tabelle di hash</title>
      <link>https://flecart.github.io/notes/tabelle-di-hash/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/tabelle-di-hash/</guid>
      <description>5.1 Introduzione 5.1.1 Prototipo Vogliamo implementare le operazioni del prototipo dizionario presentato in Strutture di dati elementari, e vogliamo fare solo queste 3 ma molto bene.
Insert O(1) Delete O(1) Search in O(1) La struttura dati di hash riesce a fare bene queste singole operazioni
Si vedrà che l&amp;rsquo;array modificato è il modo migliore per avere questo hash, solo generalizzando un modo per indicizzarlo che non saranno numeri (indici).
Noteremo che in media hanno operazioni costanti queste tabelle di hash (nel caso peggiore sempre lineare).</description>
    </item>
    <item>
      <title>Topological Spaces</title>
      <link>https://flecart.github.io/notes/topological-spaces/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/topological-spaces/</guid>
      <description>Introduction to topological spaces We want now to extend the idea of continuity presented in limits, which is a function $f : E^{n} \to E^{n}$ is continuous if given $x$ then $\forall\varepsilon &gt; 0$ $\exists \delta$ such that $\forall y : \lVert y -x \rVert &lt; \delta \implies \lVert f(y) - f(x) \rVert &lt; \varepsilon$. But we want to get rid of the idea of distance, and base our definition on the idea of neighborhoods, which in $E^{n}$ are just spherical radius centered around a point.</description>
    </item>
    <item>
      <title>Bayesian Linear Regression</title>
      <link>https://flecart.github.io/notes/bayesian-linear-regression/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bayesian-linear-regression/</guid>
      <description>We have a prior $p(\text{model})$, we have a posterior $p(\text{model} \mid \text{data})$, a likelihood $p(\text{data} \mid \text{model})$ and $p(\text{data})$ is called the evidence.
Classical Linear regression Let&amp;rsquo;s start with a classical regression. In this setting we need to estimate a model that is generated from this kind of data: $$ y = w^{T}x + \varepsilon $$ Where $\varepsilon \sim \mathcal{N}(0, \sigma_{n}^{2}I)$ and it&amp;rsquo;s the irreducible noise, an error that cannot be eliminated by any model in the model class, this is also called aleatoric uncertainty.</description>
    </item>
    <item>
      <title>Condensatori nel vuoto</title>
      <link>https://flecart.github.io/notes/condensatori-nel-vuoto/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/condensatori-nel-vuoto/</guid>
      <description>Introduzione ai condensatori Analisi introduttiva condensatori: tubi di flusso 🟩 Consideriamo un **tubo di flusso infinitesimo** come in immagine. abbiamo che $dQ$ è la carica totale dentro al cubo. Tale che segua le linee di campo. Il flusso totale sarebbe $$ \oint_{\Sigma} \vec{E} \cdot d\vec{s} = \frac{Q_{T}}{\varepsilon_{0}} $$ Sappiamo anche che $$ \vec{E}_{1}d\vec{s}_{1} + \vec{E}_{2}d\vec{s}_{2} = \frac{dQ_{T}}{\varepsilon_{0}} $$ Ma scegliamo il cubo di flusso in modo che le superfici siano **perpendicolari al nostro campo**, e così posso considerare il problema da un puro punto di vista **scalare**.</description>
    </item>
    <item>
      <title>Index, B-trees and hashes</title>
      <link>https://flecart.github.io/notes/index-b-trees-and-hashes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/index-b-trees-and-hashes/</guid>
      <description>Indexes Trattiamo qui di alcuni metodi che sono utilizzati per costruire indici
Introduction to indexes Gli indici sono una struttura di dati aggiuntiva che ci permette di ricercare più in fretta alcuni valori per le queries. In questa sezione proviamo ad approfondire in che modo possono essere costruite e gestite.
Search keys 🟩 Sono in breve la cosa che vogliamo andare a cercare. Solitamente sono nella forma &amp;lt;key, label&amp;gt;, che ci permette di trovare in fretta il label, che si potrebbe intendere come il valore che noi stiamo provando a cercare.</description>
    </item>
    <item>
      <title>Livello di Rete</title>
      <link>https://flecart.github.io/notes/livello-di-rete/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/livello-di-rete/</guid>
      <description>Reti di Reti Le parti importanti per questo sono Data Plane e Control Plane (che ha saltato quasi tutto, ma almeno dijkstra lo dovresti fare bene)
Introduzione (puoi skippare 🟩) La puoi skipppare perché tratta in modo molto generare parti che saranno trattati in modo più approfondito in seguito. La parte importante forse è il riassunto di cosa faccia questo livello.
Discussione rete locale globale Slide
No, non è possible creare una connessione globale utilizzando le tecnologie locali, come hub, switch e simili, perché causerebbe flooding e impedirebbe scalabilità e crescita dinamica che è classica della rete</description>
    </item>
    <item>
      <title>Memoria virtuale</title>
      <link>https://flecart.github.io/notes/memoria-virtuale/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/memoria-virtuale/</guid>
      <description>Memoria virtuale Perché è utile la MV? 🟨- I programmi non usano tutta la memoria, ma pensano di averla tutta disponibile dal suo punto di vista. L&amp;rsquo;idea principale è che molte zone di memoria sono inutili per lungo tempo, possono essere utilizzati per altro.
caricamento codice dinamico Per esempio anche a caricare il codice di un compilatore è diviso in fasi, se andiamo a caricare tutto, stiamo utilizzando solo un pezzo piccolo, tanta inefficienza, se una pagina contiene una parte del compilatore potrei caricare in memoria solamente le parti eseguite sul momento, giusto per fare un esempio diciamo.</description>
    </item>
    <item>
      <title>Training a NN</title>
      <link>https://flecart.github.io/notes/training-a-nn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/training-a-nn/</guid>
      <description>Ultima modifica: March 11, 2023 7:22 PM Primo Abbozzo: March 8, 2023 6:05 PM Studi Personali: No
Elementi di ripasso Training of NN How can we be sure that we can train well our function?
Dataset quality (this cannot be changed in training time) Models and parameters of our model, we can describe it as $L(x, \theta)$, and we try to minimize this function. Training approaches Random perturn weights, this is ispired by evolution, but it’s slow and not effective (and we can make things worse in many ways) Predict adjustments, usually we can analitically define what is the best way to minimize the loss, so we would like to follow that slope and go down!</description>
    </item>
    <item>
      <title>Accept Reject algorithm</title>
      <link>https://flecart.github.io/notes/accept-reject-algorithm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/accept-reject-algorithm/</guid>
      <description>Some useful links Main results: https://jblevins.org/notes/accept-reject
Intuition: https://en.wikipedia.org/wiki/Rejection_sampling
La cosa è che faccio sampling fra due distribuzioni diverse e devo settare anche un parametro (e a seconda di certe cose diventa molto lento).
Introduzione al metodo Vorrei utilizzare una funzione $g$ per generarne una altra, questo è il fulcro del concetto. L&amp;rsquo;idea principale è:
Conosco la funzione densità della funzione $f$ che voglio andare a generare Riesco a generare seguendo una funzione semplice, la chiamo $g$, candidate density.</description>
    </item>
    <item>
      <title>Codifica dei caratteri</title>
      <link>https://flecart.github.io/notes/codifica-dei-caratteri/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/codifica-dei-caratteri/</guid>
      <description>Introduzione sull&amp;rsquo;encoding Ossia trattiamo metodi per codificare caratteri dei linguaggi umani, come ASCII, UCS e UTF.
Digitalizzare significa encodarlo in un sistema che possa essere memorizzato su un dispositivo di memorizzazione elettronico. Ovviamente non possiamo mantenere l&amp;rsquo;informazione così come è, ma vogliamo memorizzarne una forma equivalente, ma più facile da manipolare dal punto di vista del computer. Creiamo quindi un mapping, o anche isomorfismo tra il valore di mappatura (o encoding), solitamente un valore numerico, tra il singolo valore atomico originale e il numero.</description>
    </item>
    <item>
      <title>Log Linear Models</title>
      <link>https://flecart.github.io/notes/log-linear-models/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/log-linear-models/</guid>
      <description>Log Linear Models can be considered the most basic model used in natural languages. The main idea is to try to model the correlations of our data, or how the posterior $p(y \mid x)$ varies, where $x$ is our single data point features and $y$ are the labels of interest. This is a form of generalization because contextualized events (x, y) with similar descriptions tend to have similar probabilities.
These kinds of models are so common that it has been discovered in many fields (and thus assuming different names): some of the most famous are Gibbs distributions, undirected graphical models, Markov Random Fields or Conditional Random Fields, exponential models, and (regularized) maximum entropy models.</description>
    </item>
    <item>
      <title>Mac Wifi</title>
      <link>https://flecart.github.io/notes/mac-wifi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/mac-wifi/</guid>
      <description>Introduzione Ricordiamo che vogliamo cercare di arbitrare l’accesso al canale fisico sottostante. In questo momento andiamo ad assumere di avere già tutto l’impianto di trasmissione fisica che abbiamo in Tecnologia Wireless, Modulazione wireless Fisica del Wireless.
Obiettivi: Arbitraggio del singolo canale fisico (la tesi di dottorato del prof era su collision avoidance di wifi). Sia in tempo Sia in spazio (come gestire il segnale mandato nello stesso spazio) Utilizzo minimo di energia Quality of service Adaptive behaviour (come il 6G che vuole andare ad utilizzare AI per fare predizione).</description>
    </item>
    <item>
      <title>Problemi di ricerca</title>
      <link>https://flecart.github.io/notes/problemi-di-ricerca/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/problemi-di-ricerca/</guid>
      <description>2 Problemi di ricerca In questa prima parte si tratta di ricerca semplice, ossia si utilizza un modello basato su obiettivi, di struttura atomica, in un ambiente che risulti singolo-agente, episodico, totalmente osservabile, deterministico, statico, discreto, conosciuto.
2.1 Il problema Vogliamo cercare di enunciare in un modo che possa essere formale, senza nessuna ambiguità il concetto di problema di ricerca.
2.1.1 Framework di soluzione Individuiamo 4 fasi principali per un problema di ricerca, questo è un framework molto generico.</description>
    </item>
    <item>
      <title>Vapnik-Chervonenkis Dimension</title>
      <link>https://flecart.github.io/notes/vapnik-chervonenkis-dimension/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/vapnik-chervonenkis-dimension/</guid>
      <description>This note will introduce the ideas presented by Vapnik, presented in (Shalev-Shwartz &amp;amp; Ben-David 2014) chapter 6. Briefly this says that infinite-size classes are indeed learnable.
This set of note is still a work in progress. But it&amp;rsquo;s very important for statistical learning theory.
We have that if $\lvert \mathcal{H} \rvert &lt; \infty \implies vc(\mathcal{H} \rvert) \leq \log_{2} \lvert \mathcal{H}$ Example: if $\mathcal{H}$ is the set of linear classifiers on $\mathbb{R}^{d}$ then we have that the dimension is $d + 1$.</description>
    </item>
    <item>
      <title>Equazioni non lineari</title>
      <link>https://flecart.github.io/notes/equazioni-non-lineari/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/equazioni-non-lineari/</guid>
      <description>Per trovare i zeri di una funzione continua non lineare non esistono alcuni metodi diretti che ci portano subito a una soluzione. Per questo motivo andremo ad analizzare molteplici pasis iterativi per trovare i zeri di una funzione.
La discussione di convergenza di ordine p è stata già discussa qui Note introduttive convergenza e iterazione , per quanto riguarda i metodi iterativi per risolvere sistemi di equazioni lineari
Globale e local Ricordiamo di Norme e Condizionamento, in cui il condizoinamento era più o meno una stima di quanto cambia la soluzione quando cambia brevemente l&amp;rsquo;input.</description>
    </item>
    <item>
      <title>Fisica del Wireless</title>
      <link>https://flecart.github.io/notes/fisica-del-wireless/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/fisica-del-wireless/</guid>
      <description>Introduzione Radio 🟩 &amp;lt;img src=&amp;quot;/images/notes/image/universita/ex-notion/Fisica del Wireless/Untitled.png&amp;quot; alt=&amp;quot;image/universita/ex-notion/Fisica del Wireless/Untitled&amp;quot;&amp;gt; Antenna: converte corrente in segnali radiorequenza e viceversa. le segnali radiofrequenza sono onde radio con frequenza diversa per rappresentare 1 o 0. Un altro modo per mandare 1 o 0 sarebbe semplicemente cambiare l’intensità della onda, mantenendo la stessa frequenza.
Viene utilizzata una variazione di potenziale elettrico per creare il segnale, dovrebbe essere un oscillatore armonico in pratica credo. Creando questo flusso di elettroni, crea anche un campo elettromagnetico a lui ortogonale, questa è l’onda radio, che si propaga alla velocità della luce.</description>
    </item>
    <item>
      <title>Macchine Astratte</title>
      <link>https://flecart.github.io/notes/macchine-astratte/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/macchine-astratte/</guid>
      <description>Definizione ed esempi per macchine astratte 🟩 Una macchina astratta è un qualunque insieme di algoritmi e strutture di dati che permettono di memorizzare ed eseguire il linguaggio $L$, quindi una macchina astratta esiste per esguire il proprio linguaggio (inteso come insieme finito di istruzioni primitive che riesce ad comprendere e eseguire).
Si può proprio dire che esiste una simbiosi fra macchina e linguaggio. Si potrebbe dire che la macchina fisica è soltanto una implementazione FISICA di un linguaggio, ossia una macchina che capisce ed esegue quel linguaggio e che sia solamente un caso particolare della macchina astratta.</description>
    </item>
    <item>
      <title>Markov Chains</title>
      <link>https://flecart.github.io/notes/markov-chains/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/markov-chains/</guid>
      <description>Introduzione alle catene di Markov La proprietà di Markov Una sequenza di variabili aleatorie $X_{1}, X_{2}, X_{3}, \dots$ gode della proprietà di Markov se vale:
$$ P(X_{n}| X_{n - 1}, X_{n - 2}, \dots, X_{1}) = P(X_{n}|X_{n-1}) $$ Ossia posso scordarmi tutta la storia precedente, mi interessa solamente lo stato precedente per sapere la probabilità attuale.
Da un punto di vista filosofico/fisico, ha senso perché mi sta dicendo che posso predire lo stato successivo se ho una conoscenza (completa, (lo dico io completo, originariamente non esiste)) del presente.</description>
    </item>
    <item>
      <title>Reti di flusso</title>
      <link>https://flecart.github.io/notes/reti-di-flusso/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/reti-di-flusso/</guid>
      <description>Questi problemi sono una sottoclasse della programmazione lineare con variabili reali. (Alcuni riescono a riconoscere se un problema è in questa forma, e lo risolvono in modo istantaneo se questo succede).
Un problema dei router è un classico problema di flusso, che si risolvono con questi algoritmi polinomiali
Note introduttive Rete, terminologia In questo caso andiamo ad indicare con rete un grafo con $G = (N, A)$ con $N$ nodi e $A$ archi, che solitamente sono diretti con pesi associati.</description>
    </item>
    <item>
      <title>Theoretical Notions of Security</title>
      <link>https://flecart.github.io/notes/theoretical-notions-of-security/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/theoretical-notions-of-security/</guid>
      <description>CIAA principles of security We have already outlined these principles in Sicurezza delle reti and talked about the concepts of authentication and integrity. Here we try to deepen these concepts and delve a little bit more on the attack vectors These are acronyms, usually called CIA and AAA for infrastructure
Confidentiality This is one concerns about the secrecy of the sent message. We do not want others to be able to access and read what we are doing.</description>
    </item>
    <item>
      <title>Vettore potenziale</title>
      <link>https://flecart.github.io/notes/vettore-potenziale/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/vettore-potenziale/</guid>
      <description>Introduzione al vettore potenziale Definizione vettore potenziale 🟩 Possiamo sempre scrivere il campo $\vec{B}$ come $$ \vec{B} = \vec{\nabla} \times \vec{A} $$ Con un campo vettoriale a caso $\vec{A}$, vedremo che questo campo avrà qualche utilità per fare i calcoli.
Possiamo notare che soddisfa la proprietà dell campo solenoidale citato in Magnetismo, infatti
$$ \vec{\nabla} \cdot \vec{B} = \vec{\nabla} \cdot (\vec{\nabla} \times \vec{A}) = 0 $$ Perché sappiamo che la divergenza del rotore (questo operatore dico) è sempre nullo per ragioni di Cauchy, se ne parla in Divergenza e Circuitazione.</description>
    </item>
    <item>
      <title>Alberi BST e AVL</title>
      <link>https://flecart.github.io/notes/alberi-bst-e-avl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/alberi-bst-e-avl/</guid>
      <description>Alberi BST e AVL 4.1 Alberi binari di ricerca (BST) Queste sono delle varianti rispetto all&amp;rsquo;albero, descritto in modo molto sommario sopra (binario perché ogni nodo ha al massimo due figli, mentre l&amp;rsquo;albero può averne quanti se ne vuole).
4.1.1 Introduzione La caratteristica principale dell&amp;rsquo;albero di ricerca è una condizione sulle chiavi (che hanno i figli).
Infatti questo albero binario di ricerca si può vedere come una implementazione della struttura astratta del dizionario.</description>
    </item>
    <item>
      <title>Introduction to computational statistics</title>
      <link>https://flecart.github.io/notes/introduction-to-computational-statistics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduction-to-computational-statistics/</guid>
      <description>What is it for Estimation Sampling generate numbers from any distribution! (distributions are important in statistics). Density Cumulative distribution (and others similar). Optimization how to find computationally the min and max of functions. Generating?
Random (difficile anche filosoficamente definire cosa significa questo). Molto importante perché si assume in Comp stats che abbiamo il random vero, e questa assunzione che non vale può rompere cose. And independent Sample proportion Average of something (example of the lake cannonball).</description>
    </item>
    <item>
      <title>Teoria dei Tipi</title>
      <link>https://flecart.github.io/notes/teoria-dei-tipi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/teoria-dei-tipi/</guid>
      <description>Ripasso Prox: 30 Ripasso: June 6, 2023 Ultima modifica: May 14, 2023 6:13 PM Primo Abbozzo: March 13, 2023 9:20 AM Studi Personali: No
Elementi di ripasso Teoria dei Tipi Introduzione Definizione 🟩— Un metodo sintattico praticabile per dimostrare l&amp;rsquo;assenza di determinati comportamenti del programma, fatto classificando le unità sintattiche in base ai tipi di valore che assumono
Vogliamo che fosse praticabile nel senso che effettivamente lo possiamo implementare, cioè ci permettono di avere certe tipologie di garanzia.</description>
    </item>
    <item>
      <title>Bias Variance Trade-off</title>
      <link>https://flecart.github.io/notes/bias-variance-trade-off/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bias-variance-trade-off/</guid>
      <description>This note should be considered deprecated. There is not much about Bias Variance Trade-off, and its quite random and old. For a correct derivation for this, you should consider looking at Linear Regression methods.
Introduction È una cosa ormai risaputa che c&amp;rsquo;è una sorta di trade-off fra la varianza e il bias per una certo modello. Aumentare la varianza del modello certamente ci permetterà di avere un modello che abbia un errore di training molto basso, però appena vede dei dati nuovi non sarà in grado di generalizzare correttamente.</description>
    </item>
    <item>
      <title>Campo elettrico</title>
      <link>https://flecart.github.io/notes/campo-elettrico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/campo-elettrico/</guid>
      <description>Introduzione Intuizione del campo elettrostatico Elettrostatico vs elettrodinamico 🟩 Andiamo a chiamare elettrostatico perché nel nostro caso non si sta muovendo nessuna carica all&amp;rsquo;itnerno di questo campo.
Proprietà del campo elettrostatico (5) 🟨 Le linee di forza in ogni punto dello spazio sono tangenti e concorde al campo in quel punto; le linee di forza si addensano dove l&amp;rsquo;intensità del campo e maggiore; le linee di forza non si incrociano mai, in quanto in ogni punto il campo è definito univocamente e non può avere due direzioni distinte.</description>
    </item>
    <item>
      <title>Design del database</title>
      <link>https://flecart.github.io/notes/design-del-database/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/design-del-database/</guid>
      <description>Processo design del database Il design Some design steps (3) (non impo) How to gather requirements? 🟨+ Come si può raccogliere i dati degli utilizzatori?
parlare col il personale che dovrà utilizzare questi sistemi Documentazione esistente Interview di persone che dovrà utilizzare queste risorse O Moduli per fare sampling Top-down approach La cosa brutta è che questi requisiti non possono essere standardizzati, ci sono molte necessità, molto diverse fra i loro, quindi è utile andare a parlare con gli esperti e capire cosa abbiano bisogno per i dati.</description>
    </item>
    <item>
      <title>Integrali multi-dimensionali</title>
      <link>https://flecart.github.io/notes/integrali-multi-dimensionali/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/integrali-multi-dimensionali/</guid>
      <description>Andremo ad analizzare integrali di funzioni continue su insiemi semplici (domini normali) .
Introduzione Y-semplice e regolarità È un insieme semplice di punti, in pratica, se considero un intervallo limitato e due funzioni definite in questo intervallo tale che una è sempre minore dell’altra, l’insieme y-semplice sono i punti compresi fra queste
Definizione del libro Intuizione integrale Definizione del prof. Dato un insieme semplice A e una funzione continua $f:A \to R$ allora è ben definito l’integrale $$ \int_Af(x, y) dxdy \in R $$ Osservazione 1:</description>
    </item>
    <item>
      <title>Transliteration systems</title>
      <link>https://flecart.github.io/notes/transliteration-systems/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/transliteration-systems/</guid>
      <description>This note is still a TODO.
Transliteration is learning learning a function to map strings in one character set to strings in another character set. The basic example is in multilingual applications, where it is needed to have the same string written in different languages.
The goal is to develop a probabilistic model that can map strings from input vocabulary $\Sigma$ to an output vocabulary $\Omega$.
We will extend the concepts presented in Automi e Regexp for Finite state automata to a weighted version.</description>
    </item>
    <item>
      <title>Insiemi numerici</title>
      <link>https://flecart.github.io/notes/insiemi-numerici/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/insiemi-numerici/</guid>
      <description>💡 Questa prima parte degli appunti è fortemente mancante 1.1 Insiemistica Tutta Questa prima roba di insiemistica è fatta molto meglio nel corso di logica, in particolare in questo documento
Teoria assiomatica degli insiemi
1.1.1 Definizione e caratteristiche degli insiemi Definizione di Campo ordinato (operazioni fra certi insiemi, sia per la addizione, per la moltiplicazione e simili) Corpo commutativo
Sono definiti somma e moltiplicazione e proprietà come commutatività, associatività, distributiva, inversi, opposti, zero e nullo</description>
    </item>
    <item>
      <title>Logica Proposizionale</title>
      <link>https://flecart.github.io/notes/logica-proposizionale/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/logica-proposizionale/</guid>
      <description>Con la logica proposizionale studiamo le denotazioni che hanno un valore di verità, ovvero deve essere una sentenza assertiva. Studio solamente le connotazioni che hanno una capacità denotativa, in quanto è solo quello ch emi importa.
6.1 La sintassi Vengono qui definite le produzioni che valgono in ogni singolo mondo.
$$ F ::= \top|\bot|A|B|...|\not F| F \wedge F| F \vee F| F \implies F $$ Questa è la BNF della nostra sintassi.</description>
    </item>
    <item>
      <title>System Design</title>
      <link>https://flecart.github.io/notes/system-design/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/system-design/</guid>
      <description>NOTA: tolgo dalle note perché non mi sembra importante.
Introduction to system design Packages vs diagrams 🟩- Packages fisica implementazione, perché è una cosa utile per lo sviluppo Diagrams logica visualizzazione perché aiuta solamente a comprendere meglio come funziona il sistema in toto. Components What is a component (3) 🟨 È una entità totalmente indipendente che funziona a sé, un esempio è il dll, dynamically loaded libraries presente nei sistemi di windows.</description>
    </item>
    <item>
      <title>Tokenization</title>
      <link>https://flecart.github.io/notes/tokenization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/tokenization/</guid>
      <description>Introduction to tokenization Tokenization is the process of converting normal strings into small little pieces that could be fed into one of our models. It usually comes from a tradition in programming languages, as we can see in Automi e Regexp where we define a specific token to have a known pattern, usually recognized by regular expressions.
There have been historically been many approaches to tokenization, let&amp;rsquo;s see a few:</description>
    </item>
    <item>
      <title>User authentication</title>
      <link>https://flecart.github.io/notes/user-authentication/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/user-authentication/</guid>
      <description>The user authentication is one of the most important parts for computer security, because every security policy starts with authentication. This authentication should be easy to use, if not users will not use this. So this should be a good compromise.
Parts of authentication security security:
Registration Authentication check Recovery These three are the main parts of security. Some challenges in user authentication Intermediate principals A part that we will not cover are the intermediate principals which attach the mean of transmission or intermediate devices used in the transmission.</description>
    </item>
    <item>
      <title>Accessibilità</title>
      <link>https://flecart.github.io/notes/accessibilit%C3%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/accessibilit%C3%A0/</guid>
      <description>Ci chiediamo come facciamo a rendere sistemi informatici accessibili a persone attraverso certe tecnologie.
Slide esempi di disabilità
È meglio renderlo accessibile perché è illegale (nel senso che stai facendo una discriminazione verso un certo insieme di persone).
WGAC Queste sono alcuni principi di accessibilità, basati su 4 principi fondamentali
4 principi del WGAC POUR per facilità di ricordarsi
Perceivable (che ci siano le informazioni necessarie per l&amp;rsquo;accessibilità) Operable Understandable Robus Linguaggio Il tag del linguaggio è utilizzato per sapere in che accento leggere e dare gli ordini.</description>
    </item>
    <item>
      <title>Autovalori e Autovettori</title>
      <link>https://flecart.github.io/notes/autovalori-e-autovettori/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/autovalori-e-autovettori/</guid>
      <description>Ha senso solamente parlare di autovettori quando si ha una applicazione lineare con stesso dominio e stesso codominio.
Vorremmo trovare una buona matrice che sia diagonale.
6.1 Diagonalizzabilità 6.1.1 Definizione per funzione e matrice Questo perché vorrei una base in cui si abbia un matrice diagonale. (quindi probabilmente P è una matrice identità).
Perché ci piacciono le matrici diagonali
Se ho una matrice diagonale, si ha che l&amp;rsquo;applicazione lineare è un semplice scaling dei vettori della base.</description>
    </item>
    <item>
      <title>Descrizione linguaggio</title>
      <link>https://flecart.github.io/notes/descrizione-linguaggio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/descrizione-linguaggio/</guid>
      <description>Introduzione Per questa parte c’è un sacco di roba in comune con Tecniche di definizione di semantica (4) 🟩
Trattiamo alcune caratteristiche che descrivono ad alto livello un linguaggio di programmazione. È da notare che questa parte della spiegazione del linguaggio non è limitante al solo linguaggio di programmazione, è utile per analizzare tutti i linguaggi (tranne la parte di implementazione)
Sintassi 🟩- Relazione fra segni. si occupa di decidere quando una frase è corretta.</description>
    </item>
    <item>
      <title>General SWE principles</title>
      <link>https://flecart.github.io/notes/general-swe-principles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/general-swe-principles/</guid>
      <description>This small note sections tries to fix 5 important concepts in software engineering
Sub-system and modules 🟩 We need to differentiate from sub-system, which is a part of a system that tries to achieve some objective, and a module, which is more language specific way of saying imported file, or set of functions or classes.
Information hiding 🟩 This is a very important principle present in object oriented programming. Within this philosophy we should be able to access only public methods or data, this allows the construction of abstractions that allow us to think at a higher level.</description>
    </item>
    <item>
      <title>Introduzione SO</title>
      <link>https://flecart.github.io/notes/introduzione-so/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-so/</guid>
      <description>Scopi del sistema operativo 🟩 Un sistema operativo è una astrazione sul HW che permette di
Gestire l’esecuzione di più programmi assieme (concorrenza), tramite virtualizzazione CPU e Memoria Gestire le risorse (Quindi I/O, RAM, Memoria, Networking) Fornisce una interfaccia di programmazione (API) molto più generale e potente, in grado di astrarre da dettagli di livello basso, vicini all’Hardware (come device drivers). Quindi in breve il SO è n programma che crea un ambiente civile per i programmi in cui interagire, e facilita molto il lavoro al programmatore per la sua interfaccia nuova.</description>
    </item>
    <item>
      <title>Probabilistic Parsing</title>
      <link>https://flecart.github.io/notes/probabilistic-parsing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/probabilistic-parsing/</guid>
      <description>Language Constituents A constituent is a word or a group of words that function as a single unit within a hierarchical structure
This is because there is a lot of evidence pointing towards an hierarchical organization of human language.
Example of constituents Let&amp;rsquo;s have some examples: John speaks [Spanish] fluently John speaks [Spanish and French] fluently
Mary programs the homework [in the ETH computer laboratory] Mary programs the homework [in the laboratory]</description>
    </item>
    <item>
      <title>Semafori</title>
      <link>https://flecart.github.io/notes/semafori/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/semafori/</guid>
      <description>Introduzione Concetto principale 🟩- È sempre stato introdotto da Dijkstra, 1965 (Cooperating Sequential Processes) utilizzato come strumento di cooperazione semplice
Questo è un sistema fortemente ispirato dai semafori che regolano gli incroci stradali.
due o più processi possono cooperare attraverso semplici segnali, in modo tale che un processo possa essere bloccato in specifici punti del suo programma finché non riceve un segnale da un altro processo
Primitive dei semafori 🟩- Il semaforo solitamente è una variabile intera non negativa.</description>
    </item>
    <item>
      <title>Sicurezza delle reti</title>
      <link>https://flecart.github.io/notes/sicurezza-delle-reti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/sicurezza-delle-reti/</guid>
      <description>Obiettivi della sicurezza (!!!) 🟩 Vogliamo creare delle reti che abbiamo certe garanzie di sicurezza, soprattutto:
Confidenzialità, non vorremmo che il nostro messaggio sia intercettabile e leggibili da persone intermedie Integrità: non vogliamo che messaggi possano essere cambiati senza intervento del sender Autenticazione: vorremmo sapere con chi stiamo parlando, e vorremmo essere sicuri che non stiano mentendo sull’identità. Sicurezza operativa(Availability): vorremmo essere in grado di poter continuare a fornire il servizio (quindi non sia possibile dossare, o installare malware che modifichino il comportamento del servizio).</description>
    </item>
    <item>
      <title>Convolutional NN</title>
      <link>https://flecart.github.io/notes/convolutional-nn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/convolutional-nn/</guid>
      <description>Introduction to convolutional NN The convolution operator 🟩- Il prodotto di convoluzione è matematicamente molto contorto, anche se nella pratica è una cosa molto molto semplice. In pratica voglio calcolare il valore di un pixel in funzione di certi suoi vicini, moltiplicati per un filter che in pratica è una matrice di pesi, che definisce un pattern lineare a cui sarei interessato di cercare nell’immagine.
Slides ed esempi (molto più chiaril)</description>
    </item>
    <item>
      <title>Language Models</title>
      <link>https://flecart.github.io/notes/language-models/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/language-models/</guid>
      <description>In order to understand language models we need to understand structured prediction. If you are familiar with Sentiment Analysis, where given an input text we need to classify it in a binary manner, in this case the output space usually scales in an exponential manner. The output has some structure, for example it could be a tree, it could be a set of words etc&amp;hellip; This usually needs an intersection between statistics and computer science.</description>
    </item>
    <item>
      <title>Complexity Hierarchies</title>
      <link>https://flecart.github.io/notes/complexity-hierarchies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/complexity-hierarchies/</guid>
      <description>Intractable problems are solvable in principle, but in reality they require so much time or space that there no physical computers that can solve them in reasonable time. We would like to define a clear hierarchy of these set of problems.
Space Hierarchies Def: Space constructible We say that a function $f: \mathbb{N} \to \mathbb{N}$ such that $f(n) \geq O(\log n)$ is space constructible if there exists a function from $1^{n} \to \langle f(n) \rangle$ is $O(f(n))$ space complexity.</description>
    </item>
    <item>
      <title>Estensioni di Turing e altre macchine</title>
      <link>https://flecart.github.io/notes/estensioni-di-turing-e-altre-macchine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/estensioni-di-turing-e-altre-macchine/</guid>
      <description>Sono variazioni possibili equivalenti: • Nastri addizionali • Testine addizionali • Nastri infiniti su entrambi i lati • Non-determinismo • Scelta probabilistica • Scelta quantistica Si può dire che la definizione di TM è stata robusta nella storia perché tantissimi formalismi che intuitivamente sembrano essere molto diversi rispetto alla TM alla fine possono essere dimostrate essere equivalenti.
Turing con nastri addizionali Questo è presente in modo abbastanza facile sul Sipser.</description>
    </item>
    <item>
      <title>Livello ISA</title>
      <link>https://flecart.github.io/notes/livello-isa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/livello-isa/</guid>
      <description>il livello isa è il livallo delle istruzioni
8.1 Struttura Solitamente le istruzioni sono divise in due parti:
8.1.1 Opcode e indirizzamento Opcode
Questo opcode indica la tipologia di istruzione.
Per esempio per l&amp;rsquo;architettura HACK è il primo bit, che indica se è una istruzione C oppure una istruzione A.
Questo insieme poi alle altre istruzioni che definiscono cosa deve fare costituiscono OPcode.
Indirizzamento
Poi c&amp;rsquo;è una sezione che indirizza, cioè dice all&amp;rsquo;istruzione cosa deve prendere e dove deve salvare.</description>
    </item>
    <item>
      <title>Object Detection</title>
      <link>https://flecart.github.io/notes/object-detection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/object-detection/</guid>
      <description>Introduction Semantic segmentation Vorremo trovare regioni che corrispondano a categorie diverse. E dividere in questo modo l’immagine secondo zone di informazione.
Object detection Vogliamo trovare il più piccolo box che vada a contenere l’oggetto. Questo è fatto con il bounding box.
In questo caso la funzione di loss è un pò più difficile da definire, si utilizza la funzione intersection over union con le aree, in pratica la percentuale di immagine comune diciamo.</description>
    </item>
    <item>
      <title>Optimization methods</title>
      <link>https://flecart.github.io/notes/optimization-methods/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/optimization-methods/</guid>
      <description>Metodi altri sono trovare una approssimazione facile da calcolare (simile all&amp;rsquo;approccio del modello surrogato credo). Ma nel nostro caso proviamo a trovare metodi di esplorare lo spazio dei parametri in modo intelligente.
Deterministic methods Sono utilizzabili quando ci sono delle proprietà come convessità, limitatezza, continuità.
Newton Raphson method Molte implementazioni in R usano questo metodo, è
Perfetto quando $h$ è quadratico, e in statistica molti problemi sono quadratici e funziona in modo perfetto Ma in cose non lineari si ha meno performance (perché l&amp;rsquo;hessiana è molto instabile per l&amp;rsquo;inversione, si dice che è mal condizionata, e si fa con attenzione.</description>
    </item>
    <item>
      <title>Teorema di Lagrange</title>
      <link>https://flecart.github.io/notes/teorema-di-lagrange/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/teorema-di-lagrange/</guid>
      <description>Classi laterali Dimostrazione dei lemmi sopra. La cosa interessante di questa parte è possiamo usare una classe laterale per partizionare il gruppo iniziale!
Il teorema di Lagrange Dividere significa che **partiziona** l&#39;insieme iniziale in alcuni insiemi distinti. L&#39;insieme $G:H$ è l&#39;insieme che contiene tutti i cosets, credo. Dimostrazione
|G:H| = |G|/|H| |a| divide |G| Ossia un corollario dopo il teorema di Lagrange. La cosa citata è dimostrata in Gruppi ciclici e permutazioni#Criterio $a {i} = a {j}$.</description>
    </item>
    <item>
      <title>Alberi di decisione</title>
      <link>https://flecart.github.io/notes/alberi-di-decisione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/alberi-di-decisione/</guid>
      <description>Introduzione agli alberi di decisione Setting del problema 🟩- Spazio delle ipotesi Definizione spazio ipotesi 🟩&amp;mdash; Per spazio delle ipotesi andiamo a considerare l&amp;rsquo;insieme delle funzioni rappresentabili dal nostro modello. Questo implica che l&amp;rsquo;allenamento ricerca l&amp;rsquo;ipotesi ossia la parametrizzazione ottimale del nostro modello, ottimale in quanto minimizza l&amp;rsquo;errore che viene compiuto nel training set.
L&amp;rsquo;insieme iniziale si può anche considerare come inductive bias ossia il restringimento solamente a certe ipotesi e non tutte.</description>
    </item>
    <item>
      <title>Note sull’architettura</title>
      <link>https://flecart.github.io/notes/note-sullarchitettura/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/note-sullarchitettura/</guid>
      <description>Interrupt Descrizione iniziale 🟩 Di interrupt e trap se n’è parlato un pò in Livello ISA di architettura, ora andiamo ad approfondire come viene gestito a livello SO.
Un interrupt è un segnale che viene mandato o da un dispositivo hardware (di solito dopo la fine di un processo input output) oppure da software, in questo caso viene chiamato trap che è un interrupt software sincrono..
Slide Interrupt Hardware e software</description>
    </item>
    <item>
      <title>Semplificazione grammatiche</title>
      <link>https://flecart.github.io/notes/semplificazione-grammatiche/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/semplificazione-grammatiche/</guid>
      <description>Gestione del non determinismo Il modo più facile per gestire il non determinsmo è semplificare le grammatiche quindi andiamo a vedere metodi per fare ciò.
Semplificazione grammatiche (5) Slide
No produzioni del tipo $A \to \varepsilon$ per bottom up (altrimenti va all’infinito!) No produzioni unitarie, così evito cicli in cui da A derivo sé stesso. No simboli inutili No ricorsione sinistra (divergenza per top-down) Fattorizzazione della grammatica Eliminazione delel produzioni nulle Vogliamo creare un algoritmo utile ad eliminare le produzioni che non ci piacciono.</description>
    </item>
    <item>
      <title>Counterfactual Invariance</title>
      <link>https://flecart.github.io/notes/counterfactual-invariance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/counterfactual-invariance/</guid>
      <description>Machine learning cannot distinguish between causal and environment features.
Shortcut learning Often we observe shortcut learning: the model learns some dataset dependent shortcuts (e.g. the machine that was used to take the X-ray) to make inference, but this is very brittle, and is not usually able to generalize.
Shortcut learning happens when there are correlations in the test set between causal and non-causal features. Our object of interest should be the main focus, not the environment around, in most of the cases.</description>
    </item>
    <item>
      <title>Introduction to Big Data</title>
      <link>https://flecart.github.io/notes/introduction-to-big-data/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduction-to-big-data/</guid>
      <description>Data Science is similar to physics: it attemps to create theories of realities based on some formalism that another science brings. For physics it was mathematics, for data science it is computer science. Data has grown expeditiously in these last years and has reached a distance that in metres is the distance to Jupiter. The galaxy is in the order of magnitude of 400 Yottametres, which has $3 \cdot 8$ zeros following after it.</description>
    </item>
    <item>
      <title>Kolmogorov complexity</title>
      <link>https://flecart.github.io/notes/kolmogorov-complexity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/kolmogorov-complexity/</guid>
      <description>Gran parte di quanto scrivo ora è tratto da (Li &amp;amp; Vitányi 2019). Chaitin, Kolmogorov e Solomonoff hanno elaborato il tema in modo indipendente e allo stesso tempo verso gli anni &amp;lsquo;60!
Solomonoff lo ha trovato sul problema dell&amp;rsquo;induzione all&amp;rsquo;età di 38 anni, Kolmogorov invece era già tardi, ha già trovato gli assiomi della probabilità e poi nel 65 cerca randomness. Mentre Chaiten Information = Computation e non probabilità, nel 68 all&amp;rsquo;età di 19 anni.</description>
    </item>
    <item>
      <title>Lagrange Multipliers</title>
      <link>https://flecart.github.io/notes/lagrange-multipliers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/lagrange-multipliers/</guid>
      <description>This is also known as Lagrange Optimization or undetermined multipliers. Some of these notes are based on Appendix E of (Bishop 2006), others were found when studying bits of rational mechanics. Also (Boyd &amp;amp; Vandenberghe 2004) chapter 5 should be a good resource on this topic.
Let&amp;rsquo;s consider a standard linear optimization problem $$ \begin{array} \\ \min f_{0}(x) \\ \text{subject to } f_{i}(x) \leq 0 \\ h_{j}(x) = 0 \end{array} $$ Lagrangian function And let&amp;rsquo;s consider the Lagrangian function associated to this problem defined as $$ \mathcal{L}(x, \lambda, \nu) = f_{0}(x) + \sum \lambda_{i}f_{i}(x) + \sum\nu_{j}h_{j}(x) $$ We want to say something about this function, because it is able to simplify the optimization problem a lot, but first we want to study this mathematically.</description>
    </item>
    <item>
      <title>Valutazione Espressioni</title>
      <link>https://flecart.github.io/notes/valutazione-espressioni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/valutazione-espressioni/</guid>
      <description>Espressioni, Comandi, Ricorsione Espressioni Con espressione intendiamo una entità sintattica, che una volta valutata ritornerà un valore, oppure non termina, in questo caso si dice che la espressione è INDEFINITA.
Questa è una definizione è leggermente ambigua dato che non abbiamo una definizione precisa di valutazoine, che è fortemente dipendente dalla macchina astratta in cui viene eseguito.
Notazioni (sintassi possibili) (3) 🟩 Notazione infissa
Questa è la notazione classica matematica, per cose tipo $a -b$, in cui l&amp;rsquo;operando sta nel mezzo degli operatori.</description>
    </item>
    <item>
      <title>Determinanti</title>
      <link>https://flecart.github.io/notes/determinanti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/determinanti/</guid>
      <description>Determinanti I determinanti sono un numero associato alle matrici quadrate. Più o meno ne sono il riassunto.
Proprietà Le prime 3 sono quelle fondamentali per calcolare il tutto, i numeri dopo il 3 sono alcune conseguenze.
det I = 1
Cambiare righe → cambiare il segno della determinante.
(Importante)
Se moltiplico una riga per una costante, il determinante è moltiplicato per questa costante. Se sommo una costante a una riga, allora il determinante è una somma strana&amp;hellip; Immagine di esempio</description>
    </item>
    <item>
      <title>Message Passing</title>
      <link>https://flecart.github.io/notes/message-passing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/message-passing/</guid>
      <description>ora abbiamo alcune primitive per passarci i messaggi, vogliamo creare metodo in modo che i processi si possano sincronizzare mandando messaggi.
la memoria è sempre privata.
Primitive Send e receive 🟩 Send
Spedizione del messaggio input deve avere un identificato al processo su cui spedire. Se si vuole espandere si possono avere multicast e broadcasting ma non li studieremo in questo corso.
Receive
Ricevi messaggi
Tassonomia dei message passing (!)🟩 Slide</description>
    </item>
    <item>
      <title>Monitor</title>
      <link>https://flecart.github.io/notes/monitor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/monitor/</guid>
      <description>Questo è un modo di più alto livello per creare programmazione concorrente.
Introduzione ai monitor Questo costrutto per la programmazione concorrente, prende molto dalla programmazione agli oggetti, abbiamo delle variabili presenti al monitor, private solamente accessibili ad essa, tramite procedure che sono mutex automaticamente!
Elementi costituenti 🟩 Dati locali Sequenza di inizializzazione Procedure di entrata Appena provo a chiamare una procedura, questa è fatta già in mutua esclusione!.
E possono modificare dati locali solo tramite chiamate a sue procedure</description>
    </item>
    <item>
      <title>Part of Speech Tagging</title>
      <link>https://flecart.github.io/notes/part-of-speech-tagging/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/part-of-speech-tagging/</guid>
      <description>What is a part of Speech? A part of speech (POS) is a category of words that display similar syntactic behavior, i.e., they play similar roles within the grammatical structure of sentences. It has been known since the Latin era that some categories of words behave similarly (verbs for declination for example).
The intuitive take is that knowing a specific part of speech can help understand the meaning of the sentence.</description>
    </item>
    <item>
      <title>Sicurezza OS</title>
      <link>https://flecart.github.io/notes/sicurezza-os/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/sicurezza-os/</guid>
      <description>Possiamo classificare tre aree generali quando si parla di sicurezza informatica:
Hardware Software human-ware. Non tratteremo in particolare esattamente come ogni campo viene declinato, però possiamo
Una altra tendenza generale è che più è complessa più è insicura. e questo senso di insicurezza cresce in modo maggiore rispetto al lineare.
Security principles Open Design perché così può essere scrutata da più persone Economy of mechanism spiegata sotto. Fail-safe defaults questo molto importante perché molti sistemi hanno dei default che possono essere exploitati.</description>
    </item>
    <item>
      <title>Active Learning</title>
      <link>https://flecart.github.io/notes/active-learning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/active-learning/</guid>
      <description>Active Learning concerns methods to decide how to sample the most useful information in a specific domain; how can you select the best sample for an unknown model? In this setting, we are interested in the concept of usefulness of information. One of our main goals is to reduce uncertainty, thus, Entropy-based (mutual information) methods are often used. For example, we can use active learning to choose what samples needs to be labelled in order to have highest accuracy on the trained model, when labelling is costly.</description>
    </item>
    <item>
      <title>Gaussians</title>
      <link>https://flecart.github.io/notes/gaussians/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gaussians/</guid>
      <description>aussians are one of the most important probability distributions. They arise naturally in the law of large numbers and have some nice properties that we will briefly present and prove here in this note. They are also quite common for Gaussian Processes and the Clustering algorithm. The best thing if you want to learn this part actually well is section 2.3 of (Bishop 2006), so go there my friend :)</description>
    </item>
    <item>
      <title>Linguaggi liberi e PDA</title>
      <link>https://flecart.github.io/notes/linguaggi-liberi-e-pda/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/linguaggi-liberi-e-pda/</guid>
      <description>In questa parte del nostro percorso nei linguaggi di programmazione proviamo ad espandere NFA e DFA in modo che possano riconoscere linguaggi come $ww^r | w \in \{a, b\}^*$ , con r maggiore o uguale a zero (r per dire che è il contrario di w) (questo linguaggio per il pumping lemma).
Grammatiche libere da contesto Conosciute come context-free grammars, possiamo definirle in modo matematico come una tupla $$ G = \langle \mathcal{N}, S, \Sigma, \mathcal{R} \rangle $$ Dove $\mathcal{N}$ sono i non terminali, $S$ è il non terminale iniziale, $\Sigma$ sono l&amp;rsquo;alfabeto dei simboli finali e $\mathcal{R}$ le relazioni possibili.</description>
    </item>
    <item>
      <title>Verita, Teorie, modelli, connotazione, denotazione</title>
      <link>https://flecart.github.io/notes/verita-teorie-modelli-connotazione-denotazione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/verita-teorie-modelli-connotazione-denotazione/</guid>
      <description>Questa è una necessità per stabilire il significato di una sintassi definiti.
5.1 Verità e Realtà La verità ha solamente senso quando lo si relaziona con un mondo sensibile, ossia il mondo che si può percepire con i nostri sensi.
5.1.1 Verità parametrica e assoluta Se un esperimento è ripetibile all&amp;rsquo;interno del mondo sensibili allora questa è considerata come una verità parametrica, ossia dipende da uno stato del mondo sensibile.</description>
    </item>
    <item>
      <title>Advanced SQL</title>
      <link>https://flecart.github.io/notes/advanced-sql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/advanced-sql/</guid>
      <description>Check function A volte può essere molto pesante, perché
What does check do? Viene utilizzato per introdurre un constraint check per avere sicurezza su un range. Check e innestamenti 🟩- Può essere che certe implementazioni non permettano il check innestato, questo è una cosa molto pesante, perché ogni modifica deve andare a rifare la modifica ai subalterni, quindi questo è pesante pesante.
Assertions 🟩&amp;ndash; Sono dei check fatti al livello dello schema, quindi valgono sempre, e possono essere riutilizzati in table diversi credo.</description>
    </item>
    <item>
      <title>Algoritmi di ordinamento</title>
      <link>https://flecart.github.io/notes/algoritmi-di-ordinamento/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algoritmi-di-ordinamento/</guid>
      <description>6.1 Introduzione 6.1.1 L’importanza del topic Gli algoritmi di ordinamento sono molto di base per la comprensione dell&amp;rsquo;ampio raggio degli algoritmi. Utilizzano l&amp;rsquo;analisi, introducono tecniche di risoluzione dei problemi computazionali come greedy, divide et impera e simile. Permettono un primo uso di astrazioni e l&amp;rsquo;analisi di sottoproblemi.
6.1.2 Il problema Il problema è trovare una permutazione di un insieme di numeri iniziali tale per cui tale insieme di numeri si ordinato:</description>
    </item>
    <item>
      <title>Isomorfismi</title>
      <link>https://flecart.github.io/notes/isomorfismi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/isomorfismi/</guid>
      <description>Gli isomorfismi sono delle proprietà fondamentali per stabilire una sorta di equivalenza fra i gruppi. Utilizziamo questi isomorfismi per parlare della stessa cosa ma in modi diversi.
3.1 Introduzione 3.1.1 Definizione Un gruppo si dice isomorfo rispetto ad un altro gruppo se, in paroloni semplici, esiste una funzione bigettiva tale che preservi l&amp;rsquo;operazione del gruppo.
In altre parole
$$ \phi:A \to B,\phi(ab) = \phi(a)\phi(b) $$ 3.1.2 Step di dimostrazione Esiste un modo preciso per dimostrare se due gruppi sono isomorfi.</description>
    </item>
    <item>
      <title>Structured Query Language</title>
      <link>https://flecart.github.io/notes/structured-query-language/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/structured-query-language/</guid>
      <description>Little bits of history It was invented in 1970 in Almaden (San Jose) by IBM (Don Chamberlin, Raymond Boyce worked on this) for the first relational database, called system R. Then for copyright issues it hasn&amp;rsquo;t been called SEQUEL, so they branded it as SQL.
SQL is a declarative language With declaratives language there is a separation between what I call the intentionality and the actual process. In declarative languages we just say what we want the result to be, and don&amp;rsquo;t care what the actual implementation is like.</description>
    </item>
  </channel>
</rss>
