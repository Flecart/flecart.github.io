<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>No-Tags on X. Angelo Huang&#39;s Blog</title>
    <link>https://flecart.github.io/tags/no-tags/</link>
    <description>Recent content in No-Tags on X. Angelo Huang&#39;s Blog</description>
    <image>
      <title>X. Angelo Huang&#39;s Blog</title>
      <url>https://flecart.github.io/images/papermod-cover.png</url>
      <link>https://flecart.github.io/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.143.1</generator>
    <language>en</language>
    <atom:link href="https://flecart.github.io/tags/no-tags/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Hello World</title>
      <link>https://flecart.github.io/hello-world/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/hello-world/</guid>
      <description>First blog post</description>
    </item>
    <item>
      <title>On The Double Descent Phenomenon</title>
      <link>https://flecart.github.io/notes/on-the-double-descent-phenomenon/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/on-the-double-descent-phenomenon/</guid>
      <description>&lt;p&gt;Double descent is a striking phenomenon in modern machine learning that challenges the traditional biasâ€“variance tradeoff. In classical learning theory, increasing model complexity beyond a certain point is expected to increase test error because the model starts to overfit the training data. However, in many contemporary modelsâ€”from simple linear predictors to deep neural networksâ€”a second descent in test error emerges as the model becomes even more overparameterized.&lt;/p&gt;
&lt;p&gt;At its core, the double descent curve can be understood in three stages. In the first stage, as the modelâ€™s capacity increases, the error decreases because the model is better able to capture the underlying signal in the data. As the model approaches the interpolation thresholdâ€”where the number of parameters is roughly equal to the number of data pointsâ€”the model fits the training data exactly. This exact fitting, however, makes the model extremely sensitive to noise, leading to a spike in test error. Surprisingly, when the model complexity is increased further into the highly overparameterized regime, the training algorithm (often stochastic gradient descent) tends to select from the many possible interpolating solutions one that exhibits desirable properties such as lower norm or smoothness. This implicit bias toward simpler, more generalizable solutions causes the test error to decrease again, producing the second descent.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Potenziale Elettrostatico</title>
      <link>https://flecart.github.io/notes/potenziale-elettrostatico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/potenziale-elettrostatico/</guid>
      <description>&lt;h3 id=&#34;introduzione-al-potenziale-elettrostatico&#34;&gt;Introduzione al potenziale elettrostatico&lt;/h3&gt;
&lt;p&gt;Abbiamo studiato in dinamica che il potenziale Ã¨ un concetto strettamente legato al Lavoro, ossia dalla quantitÃ  di energia necessaria per spostare un oggetto da un punto all&amp;rsquo;altro, vogliamo cercare di definire le relazioni che intercorrono nel caso della forza elettromagnetica&lt;/p&gt;
&lt;h4 id=&#34;rotore-nullo--forza-conservativa-&#34;&gt;Rotore nullo =&amp;gt; forza conservativa ðŸŸ©&lt;/h4&gt;
$$
\vec{\nabla}  \times \vec{F} \implies \vec{F} \text{ Ã¨ una forza conservativa}
$$$$
\oint_{L} \vec{F} \cdot d\vec{l} = \iint_{S} \vec{\nabla} \times \vec{F} \,d\vec{s}
$$&lt;p&gt;
E se abbiamo che il rotore Ã¨ nullo, allora la forza Ã¨ conservativa perchÃ© per definizione Ã¨ conservativa se non dipende dal percorso, e la cosa che un circuito chiuso Ã¨ sufficiente per dimostrare il sopra.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Banach Spaces</title>
      <link>https://flecart.github.io/notes/banach-spaces/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/banach-spaces/</guid>
      <description>&lt;h3 id=&#34;what-are-banach-spaces&#34;&gt;What are Banach Spaces?&lt;/h3&gt;
&lt;p&gt;A &lt;strong&gt;Banach space&lt;/strong&gt; is a complete normed vector space, meaning that every Cauchy sequence in the space converges to a limit within the space.
See &lt;a href=&#34;https://flecart.github.io/notes/spazi-vettoriali&#34;&gt;Spazi vettoriali&lt;/a&gt; for the formal definition.&lt;/p&gt;
&lt;h3 id=&#34;examples-of-banach-spaces&#34;&gt;Examples of Banach Spaces&lt;/h3&gt;
&lt;p&gt;In this section, we list some examples of the most common Banach Spaces&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;$\ell^p$ Spaces (Sequence Spaces)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Defined as:
$$
     \ell^p = \left\{ (x_n)_{n\in \mathbb{N}} \mid \sum_{n=1}^{\infty} |x_n|^p &lt; \infty \right\}, \quad 1 \leq p &lt; \infty
     $$&lt;/li&gt;
&lt;li&gt;The norm is given by:
$$
     \|x\|_p = \left( \sum_{n=1}^{\infty} |x_n|^p \right)^{1/p}
     $$&lt;/li&gt;
&lt;li&gt;When $p = \infty$, we define:
$$
     \ell^\infty = \left\{ (x_n)_{n\in \mathbb{N}} \mid \sup_n |x_n| &lt; \infty \right\}
     $$
with the norm $\|x\|_{\infty} = \sup_n |x_n|$.&lt;/li&gt;
&lt;li&gt;These spaces are Banach under their respective norms.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;$L^p$ Spaces (Function Spaces)&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Fatou&#39;s Lemma</title>
      <link>https://flecart.github.io/notes/fatous-lemma/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/fatous-lemma/</guid>
      <description>&lt;p&gt;Fatou&amp;rsquo;s lemma is a fundamental result in measure theory that deals with the relationship between limits and integrals of sequences of non-negative measurable functions.
See the &lt;a href=&#34;https://en.wikipedia.org/wiki/Fatou%27s_lemma&#34;&gt;wikipedia&lt;/a&gt; page for further info.&lt;/p&gt;
&lt;h3 id=&#34;statement-of-fatous-lemma&#34;&gt;Statement of Fatou&amp;rsquo;s Lemma&lt;/h3&gt;
&lt;p&gt;Let $(f_n)$ be a sequence of non-negative measurable functions on a measure space $(X,\mu)$. Then:&lt;/p&gt;
$$\int \liminf_{n \to \infty} f_n \,d\mu \leq \liminf_{n \to \infty} \int f_n \,d\mu$$&lt;p&gt;In words, this means that the integral of the limit inferior of a sequence of functions is less than or equal to the limit inferior of their integrals.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Convolutional NN</title>
      <link>https://flecart.github.io/notes/convolutional-nn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/convolutional-nn/</guid>
      <description>&lt;h2 id=&#34;introduction-to-convolutional-nn&#34;&gt;Introduction to convolutional NN&lt;/h2&gt;
&lt;h3 id=&#34;the-convolution-operator--&#34;&gt;The convolution operator ðŸŸ©-&lt;/h3&gt;
&lt;p&gt;Il prodotto di convoluzione Ã¨ matematicamente molto contorto, anche se nella pratica Ã¨ una cosa molto molto semplice. In pratica voglio calcolare il valore di un pixel in funzione di certi suoi vicini, moltiplicati per un &lt;strong&gt;filter&lt;/strong&gt; che in pratica Ã¨ una matrice di pesi, che definisce un pattern lineare a cui sarei interessato di cercare nellâ€™immagine.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slides ed esempi (molto piÃ¹ chiaril)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Optimal Minimax Facility Location</title>
      <link>https://flecart.github.io/notes/optimal-minimax-facility-location/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/optimal-minimax-facility-location/</guid>
      <description>&lt;p&gt;In this note we will briefly present one problem common in operation research.
The practical needs that formulated this problem are quite obvious: choosing the best location to build some important services for communities.&lt;/p&gt;
&lt;p&gt;The optimal minimax facility location refers to the placement of a facility (such as a warehouse, hospital, or service center) in such a way that the &lt;strong&gt;maximum distance or cost&lt;/strong&gt; between the facility and any of the demand points (such as customers, patients, or users) is minimized. This approach is particularly useful when the goal is to ensure that no demand point is too far from the facility, thus providing a form of equity in service delivery.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Semafori</title>
      <link>https://flecart.github.io/notes/semafori/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/semafori/</guid>
      <description>&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;concetto-principale--&#34;&gt;Concetto principale ðŸŸ©-&lt;/h3&gt;
&lt;p&gt;Ãˆ sempre stato introdotto da Dijkstra, 1965 (Cooperating Sequential Processes) utilizzato come strumento di cooperazione semplice&lt;/p&gt;
&lt;p&gt;Questo Ã¨ un sistema fortemente ispirato dai semafori che regolano gli incroci stradali.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;due o piÃ¹ processi possono cooperare attraverso semplici
segnali, in modo tale che un processo possa essere bloccato
in specifici punti del suo programma finchÃ© non riceve un
segnale da un altro processo&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;primitive-dei-semafori--&#34;&gt;Primitive dei semafori ðŸŸ©-&lt;/h3&gt;
&lt;p&gt;Il semaforo solitamente Ã¨ una &lt;strong&gt;variabile intera non negativa&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Optimization methods</title>
      <link>https://flecart.github.io/notes/optimization-methods/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/optimization-methods/</guid>
      <description>&lt;p&gt;Metodi altri sono trovare una &lt;strong&gt;approssimazione&lt;/strong&gt; facile da calcolare (simile all&amp;rsquo;approccio del modello surrogato credo).
Ma nel nostro caso proviamo a trovare metodi di esplorare lo &lt;strong&gt;spazio dei parametri&lt;/strong&gt; in modo intelligente.&lt;/p&gt;
&lt;h3 id=&#34;deterministic-methods&#34;&gt;Deterministic methods&lt;/h3&gt;
&lt;p&gt;Sono utilizzabili quando ci sono delle proprietÃ  come convessitÃ , limitatezza, continuitÃ .&lt;/p&gt;
&lt;h4 id=&#34;newton-raphson-method&#34;&gt;Newton Raphson method&lt;/h4&gt;
&lt;p&gt;Molte implementazioni in R usano questo metodo, Ã¨&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Perfetto quando $h$ Ã¨ quadratico, e in statistica molti problemi sono quadratici e funziona in modo perfetto&lt;/li&gt;
&lt;li&gt;Ma in cose non lineari si ha meno performance (perchÃ© l&amp;rsquo;hessiana Ã¨ molto instabile per l&amp;rsquo;inversione, si dice che Ã¨ mal condizionata, e si fa con attenzione.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;l&amp;rsquo;unica cosa da sapere secondo me Ã¨&lt;/p&gt;</description>
    </item>
    <item>
      <title>lâ€™intelligenza</title>
      <link>https://flecart.github.io/notes/lintelligenza/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/lintelligenza/</guid>
      <description>&lt;p&gt;Questi appunti sono stati scritti leggendo il (Russell &amp;amp; Norvig 2009).&lt;/p&gt;
&lt;h1 id=&#34;1-introduzione&#34;&gt;1 Introduzione&lt;/h1&gt;
&lt;p&gt;Lâ€™intelligenza artificiale Ã¨ un campo in velocissima espansione, con giÃ  un mercato enorme di un trillion dollars.&lt;/p&gt;
&lt;p&gt;Inoltre il suo campo di studi spazia da moltissimi campi, Ã¨ per questo che quasi potresti considerarla &lt;strong&gt;universale&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&#34;11-lintelligenza-artificiale&#34;&gt;1.1 Lâ€™intelligenza artificiale&lt;/h2&gt;
&lt;h3 id=&#34;111-cosa-Ã¨-2&#34;&gt;1.1.1 Cosa Ã¨ (2)&lt;/h3&gt;
&lt;p&gt;Nel tempo si Ã¨ cercato di definire con esattezza cosa sia lâ€™intelligenza artificiale. In generare si Ã¨ basato su alcuni parametri cardine ossia:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linguaggi liberi e PDA</title>
      <link>https://flecart.github.io/notes/linguaggi-liberi-e-pda/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/linguaggi-liberi-e-pda/</guid>
      <description>&lt;p&gt;In questa parte del nostro percorso nei linguaggi di programmazione proviamo ad espandere NFA e DFA in modo che possano riconoscere linguaggi come $ww^r | w \in \{a, b\}^*$ , con r maggiore o uguale a zero (r per dire che Ã¨ il contrario di w) (questo linguaggio per il pumping lemma).&lt;/p&gt;
&lt;h4 id=&#34;grammatiche-libere-da-contesto&#34;&gt;Grammatiche libere da contesto&lt;/h4&gt;
$$
G = \langle \mathcal{N}, S, \Sigma, \mathcal{R} \rangle 
$$&lt;p&gt;
Dove $\mathcal{N}$ sono i non terminali, $S$ Ã¨ il non terminale iniziale, $\Sigma$ sono l&amp;rsquo;alfabeto dei simboli finali e $\mathcal{R}$ le relazioni possibili.
Spesso lo scriviamo solo tramite le relazioni, perchÃ© Ã¨ la forma piÃ¹ compatta.
I nodi di una derivazione da grammatica libera da contesto Ã¨ chiamato &lt;strong&gt;costituente del linguaggio&lt;/strong&gt;. Questo Ã¨ piÃ¹ importante in linguistica.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bayesian Networks</title>
      <link>https://flecart.github.io/notes/bayesian-networks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bayesian-networks/</guid>
      <description>&lt;p&gt;Questi network bayesiani sono proprio dei grafi, che permettono una migliore comprensione delle relazioni causali o diagnostici fra le probabilitÃ &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Esempio rete bayesiana&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Bayesian Networks/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Bayesian Networks/Untitled&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;note-generali&#34;&gt;Note generali&lt;/h2&gt;
&lt;h3 id=&#34;introduzione-alla-rete-classica&#34;&gt;Introduzione alla rete classica&lt;/h3&gt;
&lt;p&gt;Una rete bayesiana ci permette di semplificare di molto il calcolo della full disjoint probability table, rendendola in questo modo&lt;/p&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Bayesian Networks/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Bayesian Networks/Untitled 1&#34;&gt;
&lt;p&gt;Ossia andiamo a utilizzare una &lt;strong&gt;probabilitÃ  locale, o sparsa&lt;/strong&gt; per fare i conti, cosa che semplifica molto, e quindi velocizza il calcolo. v&lt;/p&gt;</description>
    </item>
    <item>
      <title>Grammatiche Regolari</title>
      <link>https://flecart.github.io/notes/grammatiche-regolari/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/grammatiche-regolari/</guid>
      <description>&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;definizione-grammatica-regolare-&#34;&gt;Definizione grammatica regolare ðŸŸ©&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Definizione&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Grammatiche Regolari/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Grammatiche Regolari/Untitled 1&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In pratica posso avere solamente come terminali a, oppure un suffisso a su un non terminale.&lt;/p&gt;
&lt;p&gt;Queste grammatiche sono interessanti perchÃ© Ã¨ molto facile costruire un automa che sia in grado di riconoscere questo linguaggio.&lt;/p&gt;
&lt;p&gt;Seguendo una definizione piÃ¹ &lt;em&gt;lasca&lt;/em&gt; possono anche accettare dei nonterminali &lt;strong&gt;epsilon&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;espressione-regolare-a-nfa-&#34;&gt;Espressione regolare a NFA ðŸŸ©&lt;/h3&gt;
&lt;p&gt;Questa sezione Ã¨ anche presente in &lt;a href=&#34;https://flecart.github.io/notes/automi-e-regexp&#34;&gt;Automi e Regexp&lt;/a&gt;, perÃ² Ã¨ riportata qui cosÃ¬ câ€™Ã¨ lâ€™insieme di tutte le cose in un unico posto.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Descrizione linguaggio</title>
      <link>https://flecart.github.io/notes/descrizione-linguaggio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/descrizione-linguaggio/</guid>
      <description>&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;p&gt;Per questa parte câ€™Ã¨ un sacco di roba in comune con &lt;a href=&#34;https://flecart.github.io/notes/tecniche-di-definizione-di-semantica-(4&#34;&gt;Tecniche di definizione di semantica (4) ðŸŸ©&lt;/a&gt;-ðŸŸ©)&lt;/p&gt;
&lt;p&gt;Trattiamo alcune caratteristiche che descrivono ad alto livello un linguaggio di programmazione. Ãˆ da notare che questa parte della spiegazione del linguaggio non Ã¨ limitante al solo linguaggio di programmazione, Ã¨ utile per analizzare tutti i linguaggi (tranne la parte di implementazione)&lt;/p&gt;
&lt;h3 id=&#34;sintassi--&#34;&gt;Sintassi ðŸŸ©-&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Relazione fra segni&lt;/em&gt;. si occupa di decidere quando una frase Ã¨ corretta.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Semplificazione grammatiche</title>
      <link>https://flecart.github.io/notes/semplificazione-grammatiche/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/semplificazione-grammatiche/</guid>
      <description>&lt;h2 id=&#34;gestione-del-non-determinismo&#34;&gt;Gestione del non determinismo&lt;/h2&gt;
&lt;p&gt;Il modo piÃ¹ facile per gestire il non determinsmo Ã¨ &lt;strong&gt;semplificare le grammatiche&lt;/strong&gt; quindi andiamo a vedere metodi per fare ciÃ².&lt;/p&gt;
&lt;h3 id=&#34;semplificazione-grammatiche-5&#34;&gt;Semplificazione grammatiche (5)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Semplificazione grammatiche/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Semplificazione grammatiche/Untitled 1&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;No produzioni del tipo $A \to \varepsilon$ per bottom up (altrimenti va allâ€™infinito!)&lt;/li&gt;
&lt;li&gt;No produzioni unitarie, cosÃ¬ evito cicli in cui da A derivo sÃ© stesso.&lt;/li&gt;
&lt;li&gt;No simboli inutili&lt;/li&gt;
&lt;li&gt;No ricorsione sinistra (divergenza per top-down)&lt;/li&gt;
&lt;li&gt;Fattorizzazione della grammatica&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;eliminazione-delel-produzioni-nulle&#34;&gt;Eliminazione delel produzioni nulle&lt;/h2&gt;
&lt;p&gt;Vogliamo creare un algoritmo utile ad eliminare le produzioni che non ci piacciono.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Variabili aleatorie</title>
      <link>https://flecart.github.io/notes/variabili-aleatorie/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/variabili-aleatorie/</guid>
      <description>&lt;p&gt;Le variabili aleatorie ci permettono di dire qualcosa sullo spazio di probabilitÃ  senza andare troppo nei dettagli a considerare singoli eventi e cose simili.&lt;/p&gt;
&lt;h2 id=&#34;variabili-aleatorie-discrete&#34;&gt;Variabili aleatorie discrete&lt;/h2&gt;
&lt;p&gt;Con le variabili aleatorie cominciamo ad entrare nel noccio della questione, finalmente possiamo in un certo senso legare lâ€™outcome di un evento, alla probabilitÃ  dellâ€™evento.&lt;/p&gt;
&lt;h3 id=&#34;definizione-variabili-aleatorie-&#34;&gt;Definizione Variabili aleatorie ðŸŸ©&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Si definisce variabile aleatoria $X$ una funzione da $\Omega \to E$, con $\Omega$ il nostro spazio campionario, e $E$ qualunque insieme (quando $E = \mathbb{R}$ si parla di &lt;strong&gt;variabile aleatoria reale&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Expressiveness of NN</title>
      <link>https://flecart.github.io/notes/expressiveness-of-nn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/expressiveness-of-nn/</guid>
      <description>&lt;h2 id=&#34;the-perceptron&#34;&gt;The perceptron&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide summary of working of perceptron&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Expressiveness of NN/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Expressiveness of NN/Untitled&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Note on the bias&lt;/strong&gt;: it is only useful to move the treshhold where to consider the output to be 1 and where to be 1.&lt;/p&gt;
&lt;p&gt;Now we ask what can be predicted by a perceptron?&lt;/p&gt;
&lt;p&gt;We can see the update rule of the perceptron:&lt;/p&gt;
$$
\begin{cases}
w = w + \alpha x  \\
b = b + \alpha
\end{cases}
$$$$
\alpha = \begin{cases}
0  &amp;  \Theta(x \theta + b) = y \\
-1  &amp;  \Theta(x \theta + b) &gt; y \\
1  &amp;  \Theta(x \theta + b) &lt; y 
\end{cases}
$$&lt;h4 id=&#34;linearly-separability-necessity&#34;&gt;Linearly separability necessity&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Hyperplanes&lt;/strong&gt;, because that equation is an hyperplane, so we are sure that we can predict an hyperplane, and that it, and itâ€™s only it. (itâ€™s predicting wheter it can be above or below that line).
So the perceptron is correct &lt;strong&gt;only if the data is linearly separable&lt;/strong&gt;!&lt;/p&gt;</description>
    </item>
    <item>
      <title>Costraint Satisfaction Problems</title>
      <link>https://flecart.github.io/notes/costraint-satisfaction-problems/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/costraint-satisfaction-problems/</guid>
      <description>&lt;h2 id=&#34;definizione&#34;&gt;Definizione&lt;/h2&gt;
&lt;h3 id=&#34;caratteristiche&#34;&gt;Caratteristiche&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Variabili&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dominio&lt;/strong&gt; per ogni variabile&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Costraints&lt;/strong&gt; per ogni variabile&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Queste tre sono elementi che definiscono un problema di soddisfazione delle restrizioni, una soluzione Ã¨ un assegnamento di variabili che &lt;strong&gt;soddisfi&lt;/strong&gt; ogni restrizioone e sia allâ€™interno del dominio&lt;/p&gt;
&lt;h2 id=&#34;consistenza&#34;&gt;Consistenza&lt;/h2&gt;
&lt;p&gt;Vogliamo andare a limitare il dominio valutando le consistenze possibili&lt;/p&gt;
&lt;h3 id=&#34;consistenza-del-punto&#34;&gt;Consistenza del punto&lt;/h3&gt;
&lt;p&gt;Si puÃ² dire che un punto sia consistente se le sue variabili possibili non viola nessuna restrizione unaria: eg. se ho N e ho la restrizione n â‰¥ 0, allora avere tutto N Ã¨ inconsistente nel punto.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Problemi di ricerca</title>
      <link>https://flecart.github.io/notes/problemi-di-ricerca/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/problemi-di-ricerca/</guid>
      <description>&lt;h1 id=&#34;2-problemi-di-ricerca&#34;&gt;2 Problemi di ricerca&lt;/h1&gt;
&lt;p&gt;In questa prima parte si tratta di ricerca semplice, ossia si utilizza un modello basato su obiettivi, di struttura atomica, in un ambiente che risulti singolo-agente, episodico, totalmente osservabile, deterministico, statico, discreto, conosciuto.&lt;/p&gt;
&lt;h2 id=&#34;21-il-problema&#34;&gt;2.1 Il problema&lt;/h2&gt;
&lt;p&gt;Vogliamo cercare di enunciare in un modo che possa essere formale, senza nessuna ambiguitÃ  il concetto di problema di ricerca.&lt;/p&gt;
&lt;h3 id=&#34;211-framework-di-soluzione&#34;&gt;2.1.1 Framework di soluzione&lt;/h3&gt;
&lt;p&gt;Individuiamo 4 fasi principali per un problema di ricerca, questo Ã¨ un framework molto generico.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Gruppi Normali</title>
      <link>https://flecart.github.io/notes/gruppi-normali/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gruppi-normali/</guid>
      <description>&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;definizione-normalitÃ &#34;&gt;Definizione normalitÃ &lt;/h3&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Gruppi Normali/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Gruppi Normali/Untitled&#34;&gt;
&lt;h3 id=&#34;test-del-sottogruppo-normale&#34;&gt;Test del sottogruppo normale&lt;/h3&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Gruppi Normali/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Gruppi Normali/Untitled 1&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Dimostrazione&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Gruppi Normali/Untitled 2.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Gruppi Normali/Untitled 2&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;il-gruppo-quoziente&#34;&gt;Il gruppo quoziente&lt;/h3&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Gruppi Normali/Untitled 3.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Gruppi Normali/Untitled 3&#34;&gt;
&lt;p&gt;Lâ€™importanza del gruppo normale Ã¨ che quando esso vale, possiamo avere il gurppo fattore&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Dimostrazione&lt;/p&gt;
&lt;p&gt;!&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Gruppi Normali/Untitled 4.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Gruppi Normali/Untitled 4&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Teorema di Lagrange</title>
      <link>https://flecart.github.io/notes/teorema-di-lagrange/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/teorema-di-lagrange/</guid>
      <description>&lt;h2 id=&#34;classi-laterali&#34;&gt;Classi laterali&lt;/h2&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Teorema di Lagrange/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Teorema di Lagrange/Untitled&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Dimostrazione dei lemmi sopra.
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Teorema di Lagrange/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Teorema di Lagrange/Untitled 1&#34;&gt;&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Teorema di Lagrange/Untitled 2.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Teorema di Lagrange/Untitled 2&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;La cosa interessante di questa parte Ã¨ possiamo usare una classe laterale per partizionare il gruppo iniziale!&lt;/p&gt;
&lt;h2 id=&#34;il-teorema-di-lagrange&#34;&gt;Il teorema di Lagrange&lt;/h2&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Teorema di Lagrange/Untitled 3.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Teorema di Lagrange/Untitled 3&#34;&gt;
Dividere significa che **partiziona** l&#39;insieme iniziale in alcuni insiemi distinti.
L&#39;insieme $G:H$ Ã¨ l&#39;insieme che contiene tutti i cosets, credo.
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Dimostrazione&lt;/p&gt;</description>
    </item>
    <item>
      <title>Object orientation</title>
      <link>https://flecart.github.io/notes/object-orientation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/object-orientation/</guid>
      <description>&lt;p&gt;Ripasso Prox: 10
Ripasso: May 29, 2023
Ultima modifica: May 19, 2023 10:33 AM
Primo Abbozzo: May 8, 2023 9:20 AM
Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ‘
Studi Personali: No&lt;/p&gt;
&lt;h1 id=&#34;elementi-di-ripasso&#34;&gt;Elementi di ripasso&lt;/h1&gt;
&lt;h1 id=&#34;object-orientation&#34;&gt;Object orientation&lt;/h1&gt;
&lt;h2 id=&#34;il-tipo-di-dato-astratto&#34;&gt;il tipo di dato astratto&lt;/h2&gt;
&lt;h3 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h3&gt;
&lt;p&gt;Per questi tipi di dato non ci interessa di sapere cosa ci sia sotto (storato come bit? storato come sabbia boh), ci interessa solamente che abbia quei metodi, che possiamo in un certo senso identificare come la sua capsula, &lt;strong&gt;opaca&lt;/strong&gt; in questo caso.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Metodi di Discesa</title>
      <link>https://flecart.github.io/notes/metodi-di-discesa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/metodi-di-discesa/</guid>
      <description>&lt;h2 id=&#34;introduzione-ai-metodi-di-discesa&#34;&gt;Introduzione ai metodi di discesa.&lt;/h2&gt;
&lt;h3 id=&#34;generali-sui-metodi-di-discesa&#34;&gt;Generali sui metodi di discesa&lt;/h3&gt;
&lt;p&gt;Vogliamo creare algoritmi che riescano a trovare i punti di minimo delle funzioni non vincolate.&lt;/p&gt;
&lt;p&gt;In generale &lt;strong&gt;si trova un punto stazionario (condizioni necessarie)&lt;/strong&gt; ma non Ã¨ garantito lo stato ottimo.&lt;/p&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Metodi di Discesa/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Metodi di Discesa/Untitled&#34;&gt;
&lt;p&gt;Solitamente sono divisi in &lt;strong&gt;first order methods&lt;/strong&gt; in cui viene considerata solamente la derivata prima della funzione. E cose di metodi superiori.&lt;/p&gt;
&lt;h3 id=&#34;condizioni-di-arresto-classiche-2--&#34;&gt;Condizioni di arresto classiche (2) ðŸŸ©-&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide&lt;/p&gt;</description>
    </item>
    <item>
      <title>Training a NN</title>
      <link>https://flecart.github.io/notes/training-a-nn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/training-a-nn/</guid>
      <description>&lt;p&gt;Ultima modifica: March 11, 2023 7:22 PM
Primo Abbozzo: March 8, 2023 6:05 PM
Studi Personali: No&lt;/p&gt;
&lt;h1 id=&#34;elementi-di-ripasso&#34;&gt;Elementi di ripasso&lt;/h1&gt;
&lt;h1 id=&#34;training-of-nn&#34;&gt;Training of NN&lt;/h1&gt;
&lt;p&gt;How can we be sure that we can train well our function?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Dataset quality (this cannot be changed in training time)&lt;/li&gt;
&lt;li&gt;Models and parameters of our model, we can describe it as $L(x, \theta)$, and we try to minimize this function.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;training-approaches&#34;&gt;Training approaches&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Random perturn weights&lt;/strong&gt;, this is ispired by evolution, but itâ€™s slow and not effective (and we can make things worse in many ways)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Predict adjustments&lt;/strong&gt;, usually we can analitically define what is the best way to minimize the loss, so we would like to follow that slope and go down!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;When we try to learn with the second method we usually follow the direction of a derivative (this is also an idea of gradient descent that we discussed in &lt;a href=&#34;https://flecart.github.io/notes/metodi-di-discesa&#34;&gt;Metodi di Discesa&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Proximal Polixy Optimization</title>
      <link>https://flecart.github.io/notes/proximal-polixy-optimization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/proximal-polixy-optimization/</guid>
      <description>&lt;p&gt;This documents attempts to briefly present the algorithm and some experiments found online about it.
The following repo seems to be a good resource: &lt;a href=&#34;https://github.com/ericyangyu/PPO-for-Beginners&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Usually, PPO is explained as an &lt;strong&gt;actor critic framework&lt;/strong&gt;. This means there is an &lt;em&gt;agent&lt;/em&gt; that acts on the environment, and then there is a &lt;em&gt;critic&lt;/em&gt; that collects the feedback from the environment.
The main idea about this framework is to &lt;em&gt;select&lt;/em&gt; a policy that is similar, so that it is &lt;em&gt;less probable&lt;/em&gt; that a bad policy, a very different policy from the original is selected. This is achieved by clipping over the advantage. And then&lt;/p&gt;</description>
    </item>
    <item>
      <title>Algebra lineare numerica</title>
      <link>https://flecart.github.io/notes/algebra-lineare-numerica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algebra-lineare-numerica/</guid>
      <description>&lt;p&gt;In questa sezione andiamo ad indagare metodi di &lt;strong&gt;scomposizione&lt;/strong&gt;, iterativi e non. Ci sono molte matrici importanti per questa parte che dovremmo prendere confidenza.&lt;/p&gt;
&lt;h4 id=&#34;immagini&#34;&gt;Immagini&lt;/h4&gt;
&lt;p&gt;Lab 2 images&lt;/p&gt;
&lt;h2 id=&#34;metodo-di-gauss&#34;&gt;Metodo di gauss&lt;/h2&gt;
&lt;p&gt;Vogliamo cercare un metodo per calcolare soluzioni a sistemi di equazione del genere:&lt;/p&gt;
&lt;p&gt;$Ax = b$, classico. Supponiamo che questo sistema abbia una soluzione.&lt;/p&gt;
&lt;p&gt;Il nostro obiettivo sarebbe scomporre la matrice $A = LU$
come prodotto di due matrici Lower triangular e Upper triangular.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Measure Theory</title>
      <link>https://flecart.github.io/notes/measure-theory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/measure-theory/</guid>
      <description>&lt;p&gt;Ultima modifica: September 18, 2022 9:43 AM
Primo Abbozzo: September 16, 2022 9:52 AM
Studi Personali: Yes&lt;/p&gt;
&lt;h1 id=&#34;elementi-di-ripasso&#34;&gt;Elementi di ripasso&lt;/h1&gt;
&lt;h1 id=&#34;measure-theory&#34;&gt;Measure Theory&lt;/h1&gt;
&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;requirements-of-the-measure-function&#34;&gt;Requirements of the measure function&lt;/h3&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Measure Theory/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Measure Theory/Untitled&#34;&gt;
&lt;p&gt;Vorremmo cercare di &lt;strong&gt;estendere il concetto di misurabilitÃ &lt;/strong&gt; a gruppi molto piÃ¹ ampi di un singolo intervallo, vorrei creare una funzione che sia in grado di misurare degli insiemi. *su vedrÃ  che sono impossibili).&lt;/p&gt;
&lt;h3 id=&#34;impossibilitÃ -di-questi-requirements-assurdo&#34;&gt;ImpossibilitÃ  di questi requirements (assurdo)&lt;/h3&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Measure Theory/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Measure Theory/Untitled 1&#34;&gt;
&lt;p&gt;&lt;strong&gt;Costruzione dellâ€™insieme di interesse&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Gruppi</title>
      <link>https://flecart.github.io/notes/gruppi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gruppi/</guid>
      <description>&lt;h2 id=&#34;definizione-gruppo&#34;&gt;Definizione gruppo&lt;/h2&gt;
&lt;p&gt;Qualunque insieme piÃ¹ operazione tale per cui:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Esistenza dell&amp;rsquo;inverso per ogni elemento $\forall g \in G, \exists g^{-1} \in G : gg^{-1} = e$&lt;/li&gt;
&lt;li&gt;Esistenza di un elemento neutro $\exists e \in G: \forall g \in G, eg = g$&lt;/li&gt;
&lt;li&gt;AssociativitÃ : $(gh)f = g(hf)$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Closure&lt;/strong&gt;: $\forall g, h \in G \implies gh \in G$&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;unicitÃ -dellelemento-neutro&#34;&gt;UnicitÃ  dellâ€™elemento neutro&lt;/h3&gt;
&lt;p&gt;Supponiamo di avere un gruppo $G$ e due elementi neutri $e, f$
Allora abbiamo che
$ae = a = af$ perÃ² se moltiplichiamo per l&amp;rsquo;inversa abbiamo che
$a^{-1}ae = a^{-1}af \implies e = f$&lt;/p&gt;</description>
    </item>
    <item>
      <title>Fn Ordine superiore</title>
      <link>https://flecart.github.io/notes/fn-ordine-superiore/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/fn-ordine-superiore/</guid>
      <description>&lt;p&gt;Questa parte Ã¨ strettamente collegata conl a parte di &lt;a href=&#34;https://flecart.github.io/notes/astrazione-sul-controllo&#34;&gt;Astrazione sul controllo&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Si parla di &lt;strong&gt;passare le funzioni come dati&lt;/strong&gt;. e quindi possono essere passati come se fossero dei parametri.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;un linguaggio di programmazione Ã¨ di ordine superiore qualora
ammetta funzioni sia come parametro che come risultato di altre funzioni.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;La parte molto simile alla precedente Ã¨ il fatto di &lt;strong&gt;valutare&lt;/strong&gt; la funzione nell&amp;rsquo;ambiente iniziale, quindi bisogna utilizzare un sistema simile a quello del passaggio per nome.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Nomi e Scope</title>
      <link>https://flecart.github.io/notes/nomi-e-scope/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/nomi-e-scope/</guid>
      <description>&lt;h2 id=&#34;i-nomi-e-oggetti&#34;&gt;I Nomi e oggetti&lt;/h2&gt;
&lt;h3 id=&#34;oggetti-denotati-e-identificatori&#34;&gt;Oggetti denotati e identificatoriðŸŸ©&lt;/h3&gt;
&lt;p&gt;I nomi sono sequenze di caratteri o numeri aka: &lt;strong&gt;token alfanumerico&lt;/strong&gt; (anche &lt;strong&gt;IDENTIFICATORE&lt;/strong&gt; (per token guardare &lt;a href=&#34;https://flecart.github.io/notes/grammatiche-regolari&#34;&gt;Grammatiche Regolari&lt;/a&gt;) utilizzate principalmente come &lt;strong&gt;Astrazione sul controllo e sui dati&lt;/strong&gt; (quindi sono cose molto piÃ¹ facili da ricordare rispetto il suo encoding binario o a indirizzi). Infatti utilizziamo i nomi per evitare di interessarci di informazioni come lâ€™indirizzo di memoria del nostro dato o per creare una interfaccia con visibili solo nome della procedura e parametri.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Teoria dei Tipi</title>
      <link>https://flecart.github.io/notes/teoria-dei-tipi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/teoria-dei-tipi/</guid>
      <description>&lt;p&gt;Ripasso Prox: 30
Ripasso: June 6, 2023
Ultima modifica: May 14, 2023 6:13 PM
Primo Abbozzo: March 13, 2023 9:20 AM
Studi Personali: No&lt;/p&gt;
&lt;h1 id=&#34;elementi-di-ripasso&#34;&gt;Elementi di ripasso&lt;/h1&gt;
&lt;h1 id=&#34;teoria-dei-tipi&#34;&gt;Teoria dei Tipi&lt;/h1&gt;
&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;definizione-&#34;&gt;Definizione ðŸŸ©â€”&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Un metodo sintattico &lt;strong&gt;praticabile&lt;/strong&gt; per dimostrare
l&amp;rsquo;assenza di determinati comportamenti del
programma, fatto classificando le unitÃ  sintattiche in
base ai tipi di valore che assumono&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Vogliamo che fosse praticabile nel senso che effettivamente lo possiamo implementare, cioÃ¨ ci permettono di avere certe tipologie di garanzia. ma ancora Ã¨ una definizione molto ampia. E di solito si puÃ² fare una analisi statica del comportamento del programma.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Agente Logico</title>
      <link>https://flecart.github.io/notes/agente-logico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/agente-logico/</guid>
      <description>&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;nozioni-base&#34;&gt;Nozioni base&lt;/h3&gt;
&lt;p&gt;Questi sono le parole chiave di questo capitolo, ci permettono di parlare con chiarezza riguardo lâ€™agente logico.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sentence&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Knowledge Base&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Axiom&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Inference&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;background knowledge&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Knowledge representation language&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Knowledge level&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Implementation level&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Esempio generale di agente logico&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Agente Logico/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Agente Logico/Untitled&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;logica-proposizionale&#34;&gt;Logica proposizionale&lt;/h2&gt;
&lt;h3 id=&#34;sintassi-del-linguaggio&#34;&gt;Sintassi del linguaggio&lt;/h3&gt;
&lt;p&gt;Descrivere la BNF della logica proposizionale.&lt;/p&gt;
&lt;p&gt;per sapere cosa sia la BNF di questo Ã¨ molto piÃ¹ facile rifarsi agli appunti di logica presi durante lâ€™anno di corso 2021/2022 &lt;a href=&#34;https://flecart.github.io/notes/logica-proposizionale&#34;&gt;Logica Proposizionale&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Astrazione sul controllo</title>
      <link>https://flecart.github.io/notes/astrazione-sul-controllo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/astrazione-sul-controllo/</guid>
      <description>&lt;h2 id=&#34;significato-di-astrazione&#34;&gt;Significato di astrazione&lt;/h2&gt;
&lt;p&gt;L&amp;rsquo;astrazione Ã¨ una cosa fondamentale nell&amp;rsquo;informatica, lâ€™abbiamo visto anche nella prima lezione in assoluto per architettura, il sistema a strati di &lt;a href=&#34;https://flecart.github.io/notes/architettura-e-livelli-1,-2&#34;&gt;Architettura e livelli 1, 2&lt;/a&gt; reti e simili.&lt;/p&gt;
&lt;p&gt;Il principali metodi sono &lt;strong&gt;astrazioni sul controllo e sui dati&lt;/strong&gt; sui dati stiamo cominciando a parlarne in &lt;a href=&#34;https://flecart.github.io/notes/teoria-dei-tipi&#34;&gt;Teoria dei Tipi&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Le astrazioni sono utili a &lt;strong&gt;nascondere dettagli&lt;/strong&gt; per qualche fenomeno o simile (ricorda l&amp;rsquo;esempio della mappa, che non Ã¨ il territorio Ã¨ una astrazione su essa, che contiene ancora informazioni utili). Vogliamo quindi &lt;strong&gt;concentrarci su quanto ci interessa&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Automi e Regexp</title>
      <link>https://flecart.github.io/notes/automi-e-regexp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/automi-e-regexp/</guid>
      <description>&lt;p&gt;Per lâ€™analisi lessicale vogliamo cercare di ricordare le &lt;strong&gt;parole legali&lt;/strong&gt; all&amp;rsquo;interno di questo linguaggio e questo Ã¨ fatto con i linguaggi regolari.&lt;/p&gt;
&lt;h2 id=&#34;introduzione-a-analizzatori-lessicali&#34;&gt;Introduzione a analizzatori lessicali&lt;/h2&gt;
&lt;h3 id=&#34;token-&#34;&gt;Token ðŸŸ©&lt;/h3&gt;
&lt;p&gt;Struttura del token Ã¨ fatto da due parti&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Identificatore della classe del token&lt;/li&gt;
&lt;li&gt;Identificatore del valore del token&lt;/li&gt;
&lt;li&gt;Pattern e lessema ci sono direi boh&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;pattern-e-lessema-&#34;&gt;Pattern e Lessema ðŸŸ©&lt;/h3&gt;
&lt;p&gt;I pattern sono una descrizione generale della forma dei valori di una classe di token.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bottom-up Parser LR(0)</title>
      <link>https://flecart.github.io/notes/bottom-up-parser-lr0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bottom-up-parser-lr0/</guid>
      <description>&lt;p&gt;Descrivo ora alcune domande utili per ripasso:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Quali sono schematicmente quali sono le operazioni migliori per un parser top-down?&lt;/li&gt;
&lt;li&gt;Cosa Ã¨ un prefisso viabile?&lt;/li&gt;
&lt;li&gt;Quali sono i conflitti possibli, e come risolverliâ€¦&lt;/li&gt;
&lt;li&gt;Non sai nemmeno definire inmodo formale cosa sia un item&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;bottom-up&#34;&gt;Bottom up&lt;/h2&gt;
&lt;h3 id=&#34;intro-shift-reduce-e-lr-&#34;&gt;Intro shift-reduce e LR ðŸŸ©&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Bottom-up Parser LR(0)/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Bottom-up Parser LR(0)/Untitled 1&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In breve:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Shift = simbolo terminale messo nella stack&lt;/li&gt;
&lt;li&gt;Riduzione utilizzando una produzione&lt;/li&gt;
&lt;li&gt;LR = dettura da Sinistra, creazione della stringa da destra (derivazione rightmost)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;algoritmo-classico-&#34;&gt;Algoritmo classico ðŸŸ¨+&lt;/h3&gt;
&lt;p&gt;Quello che credo che intendevo per questo algoritmo classico Ã¨ quello non deterministico, nel senso che prova a fare backtracking, finchÃ© non ha finito tutte le possibilitÃ , oppure trova la derivazione giusta.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bottom-up Parser LR(1)</title>
      <link>https://flecart.github.io/notes/bottom-up-parser-lr1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bottom-up-parser-lr1/</guid>
      <description>&lt;p&gt;Si puÃ² osservare che per il parser costruito in &lt;a href=&#34;https://flecart.github.io/notes/bottom-up-parser-lr(0&#34;&gt;Bottom-up Parser LR(0)&lt;/a&gt;), non riesce a riconoscere di linguaggi semplici come $L = \{a, ab\}$.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Esempio di quanto detto
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Bottom-up Parser -LR(1)/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Bottom-up Parser -LR(1)/Untitled 1&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;parser-slr1&#34;&gt;Parser SLR(1)&lt;/h2&gt;
&lt;p&gt;Questi parser qui utilizzano lâ€™idea del look ahead ampiamente utilizzata in &lt;a href=&#34;https://flecart.github.io/notes/top-down-parser&#34;&gt;Top-down Parser&lt;/a&gt;, per escludere molte produzioni.&lt;/p&gt;
&lt;p&gt;La s sta per &lt;strong&gt;simple&lt;/strong&gt;, perchÃ© utilizza una idea semplice :D, credo ahah boh.&lt;/p&gt;
&lt;h3 id=&#34;riduzione-con-follow-&#34;&gt;Riduzione con follow ðŸŸ©&lt;/h3&gt;
&lt;p&gt;noi vogliamo &lt;strong&gt;ridurre solamente se ho follow&lt;/strong&gt; corretto il terminale finale della stringa.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Explainability of CNN</title>
      <link>https://flecart.github.io/notes/explainability-of-cnn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/explainability-of-cnn/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Capire in che modo una rete convoluzionale ci puÃ² dare insight migliori su come funzionano questi networks.&lt;/p&gt;
&lt;h3 id=&#34;visualizzazione-dei-hidden-layers&#34;&gt;Visualizzazione dei hidden layers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide visualization&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Explainability of CNN/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Explainability of CNN/Untitled&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Potremmo fissare una immagine anche a caso, e modificare la x in modo che sia piÃ¹ simile a quanto vuole computare il neurone. In questo modo genero una immagine che generi una activation forte nel neuron trainato, e si potrebbe dire che sia il genere di immagine che viene generata da essa.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Fondamenti teorica</title>
      <link>https://flecart.github.io/notes/fondamenti-teorica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/fondamenti-teorica/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://virtuale.unibo.it/pluginfile.php/1295166/mod_resource/content/0/Lez18-Gorrieri.pdf&#34;&gt;&lt;a href=&#34;https://virtuale.unibo.it/pluginfile.php/1295166/mod_resource/content/0/Lez18-Gorrieri.pdf&#34;&gt;https://virtuale.unibo.it/pluginfile.php/1295166/mod_resource/content/0/Lez18-Gorrieri.pdf&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;halting-problem&#34;&gt;Halting problem&lt;/h2&gt;
&lt;p&gt;Questo asserisce che &lt;strong&gt;non esiste nessun programma che sia in grado di decidere la terminazione di un altro programma&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Questo Ã¨ un problema che ci Ã¨ interessante perchÃ© vorremmo costruire un compilatore che  sia in grado di osservare &lt;strong&gt;tutti gli errori possibili&lt;/strong&gt; del programma. Come vedremo tra poco la risposta sarÃ  negativa.&lt;/p&gt;
&lt;h3 id=&#34;dimostrazione-tesi-&#34;&gt;Dimostrazione tesi ðŸŸ¨++&lt;/h3&gt;
&lt;p&gt;Supponiamo che questo programma esista, lo chiamiamo &lt;code&gt;check(P)&lt;/code&gt; che restituisce 0 se termina 1 se non termina, allora devo poter essere in grado di scrivere un programma di questo genere&lt;/p&gt;</description>
    </item>
    <item>
      <title>Garbage Collection</title>
      <link>https://flecart.github.io/notes/garbage-collection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/garbage-collection/</guid>
      <description>&lt;h2 id=&#34;on-dangling-pointers&#34;&gt;On dangling pointers&lt;/h2&gt;
&lt;h3 id=&#34;tombstones-&#34;&gt;Tombstones ðŸŸ©&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slides tombstones&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Garbage Collection/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Garbage Collection/Untitled&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Quando alloco, alloco anche una tombstone, e tutti i riferimenti passano per quella. (quindi ho due dereference per lâ€™accesso) quando vado a deallocare segno la tombstone come RIP, NULL.&lt;/p&gt;
&lt;p&gt;Dopo molto tempo ho il problema del cimitero che diventa molto grande. Anche se non punta piÃ¹ a niente, il cimitero.&lt;/p&gt;
&lt;h3 id=&#34;keys-and-locks-&#34;&gt;Keys and locks ðŸŸ©&lt;/h3&gt;
&lt;p&gt;Un pÃ² di overhead in piÃ¹ dal punto di vista della memoria, che Ã¨ doppio&lt;/p&gt;</description>
    </item>
    <item>
      <title>Interpolazione</title>
      <link>https://flecart.github.io/notes/interpolazione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/interpolazione/</guid>
      <description>&lt;p&gt;Vogliamo in questa sezione andare ad indagare la costruzione di funzioni che passano in tutti i punti che vogliamo, appunto interpolare. La funzione Ã¨ molto simile alla regressione trattata in &lt;a href=&#34;https://flecart.github.io/notes/minimi-quadrati&#34;&gt;Minimi quadrati&lt;/a&gt; (con il metodo della regressione, chiamato anche approssimazione ai minimi quadrati).&lt;/p&gt;
&lt;p&gt;Quindi mentre la precedente voleva andare a minimizzare l&amp;rsquo;errore, questo attuale va a creare proprio da 0 la funzione che ci passa sempre.&lt;/p&gt;
&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;p&gt;Andremo a creare una funzione f tale che per ogni x in input si abbia &lt;strong&gt;esattamente&lt;/strong&gt; la y in output&lt;/p&gt;</description>
    </item>
    <item>
      <title>Isomorfismi</title>
      <link>https://flecart.github.io/notes/isomorfismi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/isomorfismi/</guid>
      <description>&lt;p&gt;Gli isomorfismi sono delle proprietÃ  fondamentali per stabilire una sorta di equivalenza fra i gruppi. Utilizziamo questi isomorfismi per parlare della stessa cosa ma in modi diversi.&lt;/p&gt;
&lt;h2 id=&#34;31-introduzione&#34;&gt;3.1 Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;311-definizione&#34;&gt;3.1.1 Definizione&lt;/h3&gt;
&lt;p&gt;Un gruppo si dice isomorfo rispetto ad un altro gruppo se, in paroloni semplici, esiste una funzione bigettiva tale che preservi l&amp;rsquo;operazione del gruppo.&lt;/p&gt;
&lt;p&gt;In altre parole&lt;/p&gt;
$$
\phi:A \to B,\phi(ab) = \phi(a)\phi(b)
$$&lt;h3 id=&#34;312-step-di-dimostrazione&#34;&gt;3.1.2 Step di dimostrazione&lt;/h3&gt;
&lt;p&gt;Esiste un modo preciso per dimostrare se due gruppi sono isomorfi. In particolare:&lt;/p&gt;</description>
    </item>
    <item>
      <title>LR(k) e YACC</title>
      <link>https://flecart.github.io/notes/lrk-e-yacc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/lrk-e-yacc/</guid>
      <description>&lt;h2 id=&#34;lrk&#34;&gt;LR(k)&lt;/h2&gt;
&lt;h3 id=&#34;grammatiche-lrk-&#34;&gt;Grammatiche LR(k) ðŸŸ©&lt;/h3&gt;
&lt;p&gt;Anche in questo caso proviamo a generalizzare il concetto dei pirmi k caratteri, in modo da generalizzare in qualche senso il concetto di LR(k), quindi &lt;strong&gt;andiamo a modificare la closure&lt;/strong&gt; considerando ora first k&lt;/p&gt;
&lt;p&gt;Per ricordarti come si calcolava first k, andare a guardare &lt;a href=&#34;https://flecart.github.io/notes/top-down-parser&#34;&gt;Top-down Parser&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;il problema che poi diventa pratico riguardo questo Ã¨ l&amp;rsquo;impossibilitÃ  di gestire &lt;strong&gt;stringhe lunghezza k&lt;/strong&gt; che sono una assurditÃ  (esponenziale per la lunghezza)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Macchine Astratte</title>
      <link>https://flecart.github.io/notes/macchine-astratte/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/macchine-astratte/</guid>
      <description>&lt;h3 id=&#34;definizione-ed-esempi-per-macchine-astratte-&#34;&gt;Definizione ed esempi per macchine astratte ðŸŸ©&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Una macchina astratta Ã¨ un qualunque insieme di algoritmi e strutture di dati che permettono di memorizzare ed eseguire il linguaggio $L$, quindi una macchina astratta esiste per esguire &lt;strong&gt;il proprio linguaggio&lt;/strong&gt; (inteso come insieme finito di istruzioni primitive che riesce ad  comprendere e eseguire).&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Si puÃ² proprio dire che &lt;em&gt;esiste una simbiosi&lt;/em&gt; fra macchina e linguaggio. Si potrebbe dire che la macchina fisica Ã¨ soltanto una implementazione FISICA di un linguaggio, ossia una macchina che capisce ed esegue quel linguaggio e che sia solamente un caso particolare della macchina astratta.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Object Detection</title>
      <link>https://flecart.github.io/notes/object-detection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/object-detection/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;h3 id=&#34;semantic-segmentation&#34;&gt;Semantic segmentation&lt;/h3&gt;
&lt;p&gt;Vorremo trovare &lt;strong&gt;regioni che corrispondano a categorie diverse&lt;/strong&gt;. E dividere in questo modo lâ€™immagine secondo zone di informazione.&lt;/p&gt;
&lt;h3 id=&#34;object-detection&#34;&gt;Object detection&lt;/h3&gt;
&lt;p&gt;Vogliamo trovare &lt;strong&gt;il piÃ¹ piccolo box&lt;/strong&gt; che vada a contenere lâ€™oggetto. Questo Ã¨ fatto con il &lt;strong&gt;bounding box&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;In questo caso la funzione di loss Ã¨ un pÃ² piÃ¹ difficile da definire, si utilizza la funzione &lt;strong&gt;intersection over union&lt;/strong&gt; con le aree, in pratica la percentuale di immagine comune diciamo.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Polimorfismo</title>
      <link>https://flecart.github.io/notes/polimorfismo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/polimorfismo/</guid>
      <description>&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;monoforfo-&#34;&gt;Monoforfo ðŸŸ©&lt;/h3&gt;
&lt;p&gt;Quando non posso utilizzare un tipo come parametro. Ossia non possiamo definire una funzione generica.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide monomorfismo&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Polimorfismo/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Polimorfismo/Untitled&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;polimorfismo&#34;&gt;Polimorfismo&lt;/h2&gt;
&lt;p&gt;Polimorfismo, come dice il nome, significa avere tante forme, in questo caso tanti tipi. Ma avere tanti tipi non Ã¨ una cosa ambigua? Questa cosa si risolve solitamente a compile time (facendo checks di sottotipo, oppure dispatch della funzione corretta).&lt;/p&gt;
&lt;h3 id=&#34;tipologie-di-polimorfismo-3-&#34;&gt;Tipologie di Polimorfismo (3) ðŸŸ©&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide tipologie di monomorfismo&lt;/p&gt;</description>
    </item>
    <item>
      <title>Probabilita condizionata e indipendenza</title>
      <link>https://flecart.github.io/notes/probabilita-condizionata-e-indipendenza/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/probabilita-condizionata-e-indipendenza/</guid>
      <description>&lt;h2 id=&#34;condizionata&#34;&gt;Condizionata&lt;/h2&gt;
&lt;h3 id=&#34;definizione-&#34;&gt;Definizione ðŸŸ©&lt;/h3&gt;
&lt;p&gt;Andiamo a definire una probabilitÃ  di un evento $A$, condizionata a un evento non nullo $B$, come&lt;/p&gt;
$$
P(A|B) = \dfrac{P(A\cap B)}{P(B)}
$$&lt;p&gt;Questo Ã¨ la cosa fondamentale per poter considerare cose come bayes perchÃ© in questo modo abbiamo una certa relazione fra causa ed effetto e anche il contrario! Cosa che ci piace molto molto molto.&lt;/p&gt;
&lt;h3 id=&#34;la-definizione-di-sopra-Ã¨-un-probabilitÃ -&#34;&gt;La definizione di sopra Ã¨ un probabilitÃ  ðŸŸ©&lt;/h3&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/ProbabilitÃ  condizionata e indipendenza/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;ProbabilitÃ  condizionata e indipendenza/Untitled&#34;&gt;
&lt;p&gt;&lt;strong&gt;Dimostrazione&lt;/strong&gt; mia&lt;/p&gt;</description>
    </item>
    <item>
      <title>Rappresentazione della conoscenza</title>
      <link>https://flecart.github.io/notes/rappresentazione-della-conoscenza/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/rappresentazione-della-conoscenza/</guid>
      <description>&lt;p&gt;Questo Ã¨ stato un capitolo molto vasto, che andava in certi punti a toccare la filosofia, la fisica. Un aspetto, quello di &lt;strong&gt;codifica&lt;/strong&gt; delle informazioni reali in un ambiente logico (che per quanto i miei pregiudizi siano, ritengo una cosa molto impossibile, molto limitata e altrettanto impossibile). Si tratta dello &lt;strong&gt;studio della logica per rappresentazione di conoscenza&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Fatto sta che mi sembra assurdamente teorico tanto da non aver nessun utilizzo (probabilmente mi sbaglio di grosso), e che sia roba da filosofi.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Semantica di un linguaggio</title>
      <link>https://flecart.github.io/notes/semantica-di-un-linguaggio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/semantica-di-un-linguaggio/</guid>
      <description>&lt;h2 id=&#34;vincoli-sintattici-contestuali&#34;&gt;Vincoli sintattici contestuali&lt;/h2&gt;
&lt;h3 id=&#34;intro-dipendenze-da-contesto-&#34;&gt;Intro: dipendenze da contesto ðŸŸ©&lt;/h3&gt;
&lt;p&gt;I vincoli sintattici non sono esprimibili tramite BNF perchÃ© dipendono dal contesto, mentre le grammatiche libere sono per definizione libere da contesto, vogliamo quindi trovare una soluzione a questo problema. Vengono usati metodi Ad-Hoc nella fase di &lt;strong&gt;analisi semantica&lt;/strong&gt; del programma.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Grammatiche dipendenti dal contesto&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Queste grammatiche sono molto piÃ¹ complicate (e lente) rispetto a quelle libere da contesto, quindi Ã¨ poco pratico e non utilizzabile (tempo esponenziale, quindi non finisce mai).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Top-down Parser</title>
      <link>https://flecart.github.io/notes/top-down-parser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/top-down-parser/</guid>
      <description>&lt;h2 id=&#34;top-down&#34;&gt;Top-down&lt;/h2&gt;
&lt;h3 id=&#34;algoritmo-di-parsing-&#34;&gt;Algoritmo di parsing ðŸŸ©&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Top-down Parser/Untitled 1&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Questo si potrebbe considerare come algoritmo classico di parsing con non determinismo. (vado avanti, ed esploro tutto, senza look ahead).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Esempio di esecuzione&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 2.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Top-down Parser/Untitled 2&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;commenti-efficienza-di-sopra-&#34;&gt;Commenti efficienza di sopra ðŸŸ©&lt;/h3&gt;
&lt;p&gt;Ãˆ molto inefficiente, in particolare si potrebbe trovare una compessitÃ  esponenziale del tipo&lt;/p&gt;
&lt;p&gt;$O(b^{|w|})$, con b il massimo numero di produzioni. (la produzione maggiore la espando sempre!)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Valutazione Espressioni</title>
      <link>https://flecart.github.io/notes/valutazione-espressioni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/valutazione-espressioni/</guid>
      <description>&lt;h1 id=&#34;espressioni-comandi-ricorsione&#34;&gt;Espressioni, Comandi, Ricorsione&lt;/h1&gt;
&lt;h2 id=&#34;espressioni&#34;&gt;Espressioni&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Con espressione intendiamo una entitÃ  sintattica, che una volta valutata &lt;strong&gt;ritornerÃ  un valore&lt;/strong&gt;, oppure non termina, in questo caso si dice che la espressione Ã¨ INDEFINITA.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Questa Ã¨ una definizione Ã¨ leggermente ambigua dato che non abbiamo una definizione precisa di valutazoine, che Ã¨ fortemente dipendente dalla macchina astratta in cui viene eseguito.&lt;/p&gt;
&lt;h3 id=&#34;notazioni-sintassi-possibili-3-&#34;&gt;Notazioni (sintassi possibili) (3) ðŸŸ©&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Notazione infissa&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Questa Ã¨ la notazione classica matematica, per cose tipo $a -b$, in cui l&amp;rsquo;operando sta nel mezzo degli operatori.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Algebra dei tipi</title>
      <link>https://flecart.github.io/notes/algebra-dei-tipi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algebra-dei-tipi/</guid>
      <description>&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Algebra dei tipi/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Algebra dei tipi/Untitled&#34;&gt;
&lt;h3 id=&#34;equivalenza-dei-tipi-2-&#34;&gt;Equivalenza dei tipi (2) ðŸŸ©&lt;/h3&gt;
&lt;p&gt;Quando possiamo dire che due tipi siano uguali? Solitamente vengono utilizzati due metodi:&lt;/p&gt;
&lt;h4 id=&#34;equivalenza-nominale&#34;&gt;Equivalenza Nominale&lt;/h4&gt;
&lt;p&gt;Quando un nuono tipo introduce un nuovo nome diverso fra tutti i presenti. Credo cosÃ¬ vada golang.
Quindi in questo caso si puÃ² dire che un tipo &lt;strong&gt;Ã¨ equivalente solamente a sÃ© stesso&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Vogliamo fare in questo modo perchÃ© se definiamo un nuovo tipo solitamente dovrebbe avere funzioni diverse, quindi Ã¨ giusto che sia diverso da uqello iniziale.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Classi OOP</title>
      <link>https://flecart.github.io/notes/classi-oop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/classi-oop/</guid>
      <description>&lt;h2 id=&#34;introduzione-a-oop&#34;&gt;Introduzione a OOP&lt;/h2&gt;
&lt;p&gt;Per la definizione di classe andare a guardare &lt;a href=&#34;https://flecart.github.io/notes/object-orientation&#34;&gt;Object orientation&lt;/a&gt;, perÃ² lo ripeto in questa occasione, Ã¨ solamente un modello su cui andare a costruire degli oggetti.&lt;/p&gt;
&lt;h3 id=&#34;capisaldi&#34;&gt;CapisaldiðŸŸ©&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Incapsulazione&lt;/li&gt;
&lt;li&gt;Astrazione&lt;/li&gt;
&lt;li&gt;EreditarietÃ &lt;/li&gt;
&lt;li&gt;Dispatch dinamico&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;costruttori--&#34;&gt;Costruttori ðŸŸ©-&lt;/h3&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Classi OOP/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Classi OOP/Untitled&#34;&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Classi OOP/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Classi OOP/Untitled 1&#34;&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Classi OOP/Untitled 2.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Classi OOP/Untitled 2&#34;&gt;
&lt;p&gt;Il costruttore Ã¨ un codice utilizzato per &lt;strong&gt;inizializzare correttamente lo stato&lt;/strong&gt; interno. Le regole sono le stesse dei metodi sovraccaricati (dinamica per la chiamata, statica per il numero dei parametri che prende in input).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Deblur di immagini</title>
      <link>https://flecart.github.io/notes/deblur-di-immagini/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/deblur-di-immagini/</guid>
      <description>&lt;h3 id=&#34;origini-di-sfocatura&#34;&gt;Origini di sfocatura&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;/images/notes/image/universita/ex-notion/Immagini/Untitled.png&amp;quot; style=&amp;quot;width: 100%&amp;quot; class=&amp;quot;center&amp;quot; alt=&amp;quot;image/universita/ex-notion/Immagini/Untitled&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;Rumore causata da problemi fisici che sono &lt;strong&gt;errori di lettura&lt;/strong&gt; del segnale analogico Questo si indica anche come errore gaussiano bianco e si puÃ² considerare &lt;em&gt;additivo&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Rumore causato dalla digitalizzazione, quindi dalla discretizzazione di essa.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide formalizzazione errori per sfocatura&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Immagini/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Immagini/Untitled 1&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;point-spread-function&#34;&gt;Point spread function&lt;/h3&gt;
&lt;p&gt;Un unico pixel bianco sembra influenzare il suo ambiente nero, come in immagine&lt;/p&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Immagini/Untitled 2.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Immagini/Untitled 2&#34;&gt;
&lt;p&gt;Vorremmo utilizzare delle funzioni ce siano in grado di approssimare questa funzione.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Gestione delle eccezioni</title>
      <link>https://flecart.github.io/notes/gestione-delle-eccezioni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gestione-delle-eccezioni/</guid>
      <description>&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;metodi-alternativi-di-gestione-degli-errori-3-&#34;&gt;Metodi alternativi di gestione degli errori (3) ðŸŸ©&lt;/h3&gt;
&lt;p&gt;A volte le computazioni falliscono. Potremmo gestirle con i result come accennato in &lt;a href=&#34;https://flecart.github.io/notes/polimorfismo&#34;&gt;Polimorfismo&lt;/a&gt;, perÃ² diventa molto macchinoso fare tutte le funzioni che debbano inoltrare solamente delle results. bisogna trovare un modo piÃ¹ naturale. Ecco che arriva una gestione delle eccezioni direttamente nel linguaggio. Si tratta un sistema di comunicazione degli errori.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ALTRI METODI&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Results, stile monadico, vedi sopra.&lt;/li&gt;
&lt;li&gt;definire dei valori eccezionali (questo si va spesso in C)&lt;/li&gt;
&lt;li&gt;Il chiamato dice al chiamante una cosa da chiamare quando fallisce. Diciamo &lt;strong&gt;inversione del controllo&lt;/strong&gt; perchÃ© in questo caso Ã¨ il chiamato che dice cosa fare. Ma rende il codice poco composizionale, quindi difficile da seguire.
(Questa Ã¨ la soluzione molto piÃ¹ simile alla gestione effettiva degli errori). Ma nelle eccezioni vere non Ã¨ il chiamato che ritorn al&amp;rsquo;indirizzo da eseguire ma Ã¨ il runtime che decide cosa andare ad eseguire. Questa cosa non interrompe il flusso del calcolo&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Con le eccezioni vogliamo &lt;strong&gt;trasferire il controllo a un gestore delle eccezioni&lt;/strong&gt; questo gestore solitamente si trova sulla stack (va a risalire tutta la stack di chiamata fino a raggiungere questo gestore).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Introduzione alla probabilita</title>
      <link>https://flecart.github.io/notes/introduzione-alla-probabilita/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-alla-probabilita/</guid>
      <description>&lt;h1 id=&#34;note&#34;&gt;Note:&lt;/h1&gt;
&lt;p&gt;Questo corso Ã¨ troppo astratto. PiÃ¹ che probabilitÃ  tratta di teoria della Misura. Quindi affossatoâ€¦&lt;/p&gt;
&lt;p&gt;Link della serie: &lt;a href=&#34;https://www.youtube.com/watch?v=172m7qVy_FQ&amp;list=PLrb6X_RiBI94b6dzCx-QwM-r0aZpJyPxS&#34;&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=172m7qVy_FQ&amp;amp;list=PLrb6X_RiBI94b6dzCx-QwM-r0aZpJyPxS&#34;&gt;https://www.youtube.com/watch?v=172m7qVy_FQ&amp;list=PLrb6X_RiBI94b6dzCx-QwM-r0aZpJyPxS&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;campo-di-probabilitÃ &#34;&gt;Campo (di probabilitÃ )&lt;/h1&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/Introduzione alla probabilitÃ /Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;Introduzione alla probabilitÃ /Untitled&#34;&gt;
&lt;p&gt;Nota:&lt;/p&gt;
&lt;p&gt;2 e 3 â‡’ 4&lt;/p&gt;
&lt;p&gt;2 e 4 â‡’ 3&lt;/p&gt;
&lt;p&gt;Quindi 3 e 4 sono interscambiabili, e si potrebbe eliminare uno dei due.&lt;/p&gt;
&lt;p&gt;Anche il fatto che il vuoto sia presente in F si puÃ² omettere. combinando 1 e 2 ottengo il vuoto (complementare dellâ€™insieme che prenda tutto).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linguaggi Deterministici e DPDA</title>
      <link>https://flecart.github.io/notes/linguaggi-deterministici-e-dpda/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/linguaggi-deterministici-e-dpda/</guid>
      <description>&lt;h2 id=&#34;dpda&#34;&gt;DPDA&lt;/h2&gt;
&lt;h3 id=&#34;definizione-2&#34;&gt;Definizione (2)ðŸŸ©&lt;/h3&gt;
&lt;p&gt;La definizione di DPDA Ã¨ molto simile a quella trattata in &lt;a href=&#34;https://flecart.github.io/notes/linguaggi-liberi-e-pda&#34;&gt;Linguaggi liberi e PDA&lt;/a&gt;, con solo costraints sulla deterministicitÃ , che si traducono in due condizioni:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Al massimo posso avere un risultato per ogni coppia di lettura e simbolo su stack&lt;/li&gt;
&lt;li&gt;Se ho una transizione senza leggere, posso avere solo quella&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Linguaggi Deterministici e DPDA/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Linguaggi Deterministici e DPDA/Untitled 1&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;linguaggio-libero-deterministico&#34;&gt;Linguaggio libero deterministico&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Un linguaggio Ã¨ libero deterministico se esiste un PDA che lo riconosce per &lt;strong&gt;stato finale&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Planning automatico</title>
      <link>https://flecart.github.io/notes/planning-automatico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/planning-automatico/</guid>
      <description>&lt;h1 id=&#34;planning-automatico&#34;&gt;Planning Automatico&lt;/h1&gt;
&lt;p&gt;Vogliamo andare a creare un programma che sia in grado di creare un piano per fare una azione, andiamo in questo capitolo gli algoritmi storicamente migliori adatti a risolvere questo problema&lt;/p&gt;
&lt;h2 id=&#34;il-problema-di-pianificazione&#34;&gt;Il problema di pianificazione&lt;/h2&gt;
&lt;p&gt;Andiamo a rappresentare il nostro problema di pianificazione con un linguaggio molto simile alla &lt;a href=&#34;https://flecart.github.io/notes/logica-del-primo-ordine&#34;&gt;Logica del Primo ordine&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Ãˆ il PDDL ossia il &lt;strong&gt;Planning domain definition language&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;pddl&#34;&gt;PDDL&lt;/h3&gt;
&lt;p&gt;Questo linguaggio Ã¨ definito da&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Una serie di predicati in FOL iniziali&lt;/li&gt;
&lt;li&gt;Una serie di predicati in FOL di arrivo&lt;/li&gt;
&lt;li&gt;Una serie di azioni
&lt;ol&gt;
&lt;li&gt;Con una serie di precondizioni&lt;/li&gt;
&lt;li&gt;E una serie di effetti&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Il nostro obiettivo sarÃ  principalmente raggiungere un obiettivo finale, utilizzando le azioni per cambiare lo stato attuale&lt;/p&gt;</description>
    </item>
    <item>
      <title>Calcolo di numeri finiti</title>
      <link>https://flecart.github.io/notes/calcolo-di-numeri-finiti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/calcolo-di-numeri-finiti/</guid>
      <description>&lt;h1 id=&#34;1-calcolo-dei-numeri-finiti&#34;&gt;1 Calcolo dei numeri finiti&lt;/h1&gt;
&lt;p&gt;Il calcolo Ã¨ numerico perchÃ© si differenzia rispetto a un calcolo normale perchÃ© Ã¨ &lt;em&gt;finito&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&#34;11-errore-nei-calcoli&#34;&gt;1.1 Errore nei calcoli&lt;/h2&gt;
&lt;h3 id=&#34;111-tipologie-di-errore-5-&#34;&gt;1.1.1 Tipologie di errore (5) ðŸŸ©&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Errore di misura&lt;/strong&gt;, dovuto alle imperfezioni dello strumento di misura dei dati del problema.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Errore di troncamento&lt;/strong&gt;, quando un procedimento infinito viene realizzato come procedimento finito. (esempio: calcolo del valore di una funzione tramite sviluppo in serie, perchÃ© dato che lâ€™algoritmo deve essere finito, devo prima o poi interrompere il calcolo, ecco qui lâ€™errore).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Errore inerente&lt;/strong&gt;, dovuto al fatto che i dati di un problema non sono in una forma buona diciamo&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Errore di rappresentazione (simil troncamento)&lt;/strong&gt; non sempre appartengono allâ€™insieme $\mathbb{F}$ dei numeri rappresentabili e quindi vengono approssimati.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Errore algoritmico&lt;/strong&gt;, dovuto al &lt;em&gt;propagarsi&lt;/em&gt; degli errori di arrotondamento sulle singole operazioni in un procedimento complesso.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;112-misura-dellaccuratezza-&#34;&gt;1.1.2 Misura dellâ€™accuratezza ðŸŸ©&lt;/h3&gt;
&lt;p&gt;Anche per lâ€™accuratezza di una misura utilizziamo degli errori (questi tipi di errori li hai anche studiati in fisica durante il liceo).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Introduction to computational statistics</title>
      <link>https://flecart.github.io/notes/introduction-to-computational-statistics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduction-to-computational-statistics/</guid>
      <description>&lt;h3 id=&#34;what-is-it-for&#34;&gt;What is it for&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Estimation&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sampling&lt;/strong&gt; generate numbers from &lt;em&gt;any&lt;/em&gt; distribution! (distributions are important in statistics).
&lt;ol&gt;
&lt;li&gt;Density&lt;/li&gt;
&lt;li&gt;Cumulative distribution (and others similar).&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Optimization&lt;/strong&gt; how to find computationally the min and max of functions.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Generating?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Random (difficile anche filosoficamente definire cosa significa questo).
&lt;ol&gt;
&lt;li&gt;Molto importante perchÃ© si assume in Comp stats che abbiamo il random vero, e questa assunzione che non vale puÃ² rompere cose.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;And independent&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;sample-proportion&#34;&gt;Sample proportion&lt;/h4&gt;
&lt;p&gt;Average of something (example of the lake cannonball).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Scelta del PO</title>
      <link>https://flecart.github.io/notes/scelta-del-po/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/scelta-del-po/</guid>
      <description>&lt;p&gt;La cosa che rende il PO diverso rispetto agli sviluppatori Ã¨ la &lt;strong&gt;conoscenza&lt;/strong&gt; delle necessitÃ  del cliente. Questo permette di prioritizzare del task e capire in che modo dovrebbe essere il prodotto finale. In questo modo si crea una &lt;strong&gt;vision&lt;/strong&gt; del prodotto.
Pensiamo che il PO debba condividere questa informazione e prendere decisioni di gruppo.&lt;/p&gt;
&lt;h4 id=&#34;domande-da-fare&#34;&gt;Domande da fare:&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;La user interface, come sembra il wireframe?&lt;/li&gt;
&lt;li&gt;Pensavamo di utilizzare i social solamente per i login, pensavate di utilizzare anche per altro durante il gioco?
&lt;ol&gt;
&lt;li&gt;Bassa prioritÃ  (poter condividere i risultati con un post).&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Vorreste poter selezionare il livello del bot? Quanto sarebbe il massimo livello e quale il minimo?
4. Per kriegspiel la forza Ã¨ massima.&lt;/li&gt;
&lt;li&gt;Cosa Ã¨ la modalitÃ  &amp;lsquo;mob&amp;rsquo; per giocare (2 descrizione del problema documento progetto).
&lt;ol&gt;
&lt;li&gt;si intende il social che permette di condividere mosse.&lt;/li&gt;
&lt;li&gt;tutte le persone interessante possono rispondere con tempo un giorno, e la maggioranza determina la risposta.&lt;/li&gt;
&lt;li&gt;Bassa prioritÃ .&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Esistono i soci (utenti registrati) e non, cosa puÃ² fare un utente non registrato? E quelli registrati? O definiamo noi?&lt;/li&gt;
&lt;li&gt;Che genere di commenti deve fare l&amp;rsquo;AI durante la partita?
&lt;ol&gt;
&lt;li&gt;Va bene qualunque commento (anche in giro), commenti interessanti sul contesto).&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;In che modo salvare una partita? Solamente la sequenza delle mosse o possibilitÃ  di riprendere la partita?
&lt;ol&gt;
&lt;li&gt;Non Ã¨ richiesto poter salvare e riprendere nei giochi a informazione incompleta&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;La seconda cosa interessante per l&amp;rsquo;utente?
&lt;ol&gt;
&lt;li&gt;Leaderboard (non per noi, ELO).&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Cosa deve avere la leaderboard per giochi diversi da bad chess?
&lt;ol&gt;
&lt;li&gt;Legato all&amp;rsquo;ELO questa, il classico.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;O mobile o web o come ci pare (non Ã¨ importante).
No sicurezza, non Ã¨ importante.
50 giocatori max.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Sezioni Critiche</title>
      <link>https://flecart.github.io/notes/sezioni-critiche/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/sezioni-critiche/</guid>
      <description>&lt;p&gt;Ripasso Prox: 80
Ripasso: May 21, 2023
Ultima modifica: March 12, 2023 10:00 AM
Primo Abbozzo: October 8, 2022 11:30 AM
Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ‘
Studi Personali: No&lt;/p&gt;
&lt;h1 id=&#34;elementi-di-ripasso&#34;&gt;Elementi di ripasso&lt;/h1&gt;
&lt;h1 id=&#34;2-sezioni-critiche&#34;&gt;2 Sezioni Critiche&lt;/h1&gt;
&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;La parte di un programma che utilizza una o piÃ¹ risorse
condivise viene detta sezione critica (critical section, o CS)&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Andiamo in questa altra parte a valutare certe soluzioni:&lt;/p&gt;
&lt;h3 id=&#34;programma-desempio-&#34;&gt;Programma dâ€™esempio ðŸŸ©&lt;/h3&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Sezioni Critiche/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Sezioni Critiche/Untitled&#34;&gt;
&lt;p&gt;Vorremmo garantire che &lt;strong&gt;a = b invariante.&lt;/strong&gt; (espressione logica verificata nell&amp;rsquo;esecuzione di questo programma). quindi una coerenza di uno prima dell&amp;rsquo;altro vogliamo.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Accept Reject algorithm</title>
      <link>https://flecart.github.io/notes/accept-reject-algorithm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/accept-reject-algorithm/</guid>
      <description>&lt;h4 id=&#34;some-useful-links&#34;&gt;Some useful links&lt;/h4&gt;
&lt;p&gt;Main results: &lt;a href=&#34;https://jblevins.org/notes/accept-reject&#34;&gt;&lt;a href=&#34;https://jblevins.org/notes/accept-reject&#34;&gt;https://jblevins.org/notes/accept-reject&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Intuition: &lt;a href=&#34;https://en.wikipedia.org/wiki/Rejection_sampling&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Rejection_sampling&#34;&gt;https://en.wikipedia.org/wiki/Rejection_sampling&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;La cosa Ã¨ che faccio sampling fra due distribuzioni diverse e devo settare anche un parametro (e a seconda di certe cose diventa molto lento).&lt;/p&gt;
&lt;h4 id=&#34;introduzione-al-metodo&#34;&gt;Introduzione al metodo&lt;/h4&gt;
&lt;p&gt;Vorrei utilizzare una funzione $g$ per generarne una altra, questo Ã¨ il fulcro del concetto.
L&amp;rsquo;idea principale Ã¨:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Conosco la funzione densitÃ  della funzione $f$ che voglio andare a generare&lt;/li&gt;
&lt;li&gt;Riesco a generare seguendo una funzione semplice, la chiamo $g$, &lt;strong&gt;candidate density&lt;/strong&gt;. (che Ã¨ la densitÃ  che utilizzo per calcolare il target che non conosco molto bene).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ma devono esserci due cose:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kolmogorov complexity</title>
      <link>https://flecart.github.io/notes/kolmogorov-complexity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/kolmogorov-complexity/</guid>
      <description>&lt;p&gt;Gran parte di quanto scrivo ora Ã¨ tratto da &lt;a href=&#34;http://link.springer.com/10.1007/978-3-030-11298-1&#34;&gt;(Li &amp;amp; VitÃ¡nyi 2019)&lt;/a&gt;.
Chaitin, Kolmogorov e Solomonoff hanno elaborato il tema in modo indipendente e allo stesso tempo verso gli anni &amp;lsquo;60!&lt;/p&gt;
&lt;p&gt;Solomonoff lo ha trovato sul problema dell&amp;rsquo;induzione all&amp;rsquo;etÃ  di 38 anni, Kolmogorov invece era giÃ  tardi, ha giÃ  trovato gli assiomi della probabilitÃ  e poi nel 65 cerca randomness. Mentre Chaiten Information = Computation e non probabilitÃ , nel 68 all&amp;rsquo;etÃ  di 19 anni.
In AI teorico questo sembra un tema molto importante.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Project Management</title>
      <link>https://flecart.github.io/notes/project-management/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/project-management/</guid>
      <description>&lt;h4 id=&#34;project-product-management-project-management&#34;&gt;Project, product management, project management&lt;/h4&gt;
&lt;p&gt;Bisogna capire queste definizioni.
Vedere &lt;a href=&#34;https://dynamik.vercel.app/ingegneria-del-software/lucidi/13-gestione-del-progetto.pdf?from=informatica,&#34;&gt;&lt;a href=&#34;https://dynamik.vercel.app/ingegneria-del-software/lucidi/13-gestione-del-progetto.pdf?from=informatica&#34;&gt;https://dynamik.vercel.app/ingegneria-del-software/lucidi/13-gestione-del-progetto.pdf?from=informatica&lt;/a&gt;,&lt;/a&gt; slide 5 per definizione&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Progetto: inizia e finisce in tempo preciso.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ãˆ importante comunque ricordare gli steps principali per il progetto ossia ideazione, creazione, mantenimento, rilascio, e poi morte, questo in genere Ã¨ per qualunque progetto.&lt;/p&gt;
&lt;h3 id=&#34;project-manager&#34;&gt;Project Manager&lt;/h3&gt;
&lt;h4 id=&#34;compiti-principali-costi-e-risorse&#34;&gt;Compiti principali (costi e risorse)&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Vedere se il progetto Ã¨ fattibile&lt;/li&gt;
&lt;li&gt;Allocare risorse&lt;/li&gt;
&lt;li&gt;Monitorare come sta andando. (preventivo e consuntivo).
&lt;img src=&#34;https://flecart.github.io/images/notes/Project Management-1701099646139.jpeg&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;Project Management-1701099646139&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;work-breakdown-structure&#34;&gt;Work Breakdown structure&lt;/h3&gt;
&lt;h4 id=&#34;descrizione-wbs&#34;&gt;Descrizione WBS&lt;/h4&gt;
&lt;p&gt;Ãˆ una suddivisione del progetto in piccoli sottoparti che si possono gestire in modo autonomo.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
