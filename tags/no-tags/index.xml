<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>No-Tags on X. Angelo Huang&#39;s Blog</title>
    <link>https://flecart.github.io/tags/no-tags/</link>
    <description>Recent content in No-Tags on X. Angelo Huang&#39;s Blog</description>
    <image>
      <title>X. Angelo Huang&#39;s Blog</title>
      <url>https://flecart.github.io/images/papermod-cover.png</url>
      <link>https://flecart.github.io/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.143.1</generator>
    <language>en</language>
    <atom:link href="https://flecart.github.io/tags/no-tags/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Hello World</title>
      <link>https://flecart.github.io/hello-world/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/hello-world/</guid>
      <description>First blog post</description>
    </item>
    <item>
      <title>Accept Reject algorithm</title>
      <link>https://flecart.github.io/notes/accept-reject-algorithm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/accept-reject-algorithm/</guid>
      <description>&lt;h4 id=&#34;some-useful-links&#34;&gt;Some useful links&lt;/h4&gt;
&lt;p&gt;Main results: &lt;a href=&#34;https://jblevins.org/notes/accept-reject&#34;&gt;https://jblevins.org/notes/accept-reject&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Intuition: &lt;a href=&#34;https://en.wikipedia.org/wiki/Rejection_sampling&#34;&gt;https://en.wikipedia.org/wiki/Rejection_sampling&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;La cosa √® che faccio sampling fra due distribuzioni diverse e devo settare anche un parametro (e a seconda di certe cose diventa molto lento).&lt;/p&gt;
&lt;h4 id=&#34;introduzione-al-metodo&#34;&gt;Introduzione al metodo&lt;/h4&gt;
&lt;p&gt;Vorrei utilizzare una funzione $g$ per generarne una altra, questo √® il fulcro del concetto.
L&amp;rsquo;idea principale √®:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Conosco la funzione densit√† della funzione $f$ che voglio andare a generare&lt;/li&gt;
&lt;li&gt;Riesco a generare seguendo una funzione semplice, la chiamo $g$, &lt;strong&gt;candidate density&lt;/strong&gt;. (che √® la densit√† che utilizzo per calcolare il target che non conosco molto bene).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ma devono esserci due cose:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Agente Logico</title>
      <link>https://flecart.github.io/notes/agente-logico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/agente-logico/</guid>
      <description>&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;nozioni-base&#34;&gt;Nozioni base&lt;/h3&gt;
&lt;p&gt;Questi sono le parole chiave di questo capitolo, ci permettono di parlare con chiarezza riguardo l‚Äôagente logico.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sentence&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Knowledge Base&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Axiom&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Inference&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;background knowledge&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Knowledge representation language&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Knowledge level&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Implementation level&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Esempio generale di agente logico&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Agente Logico/Untitled.png&#34; alt=&#34;image/universita/ex-notion/Agente Logico/Untitled&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;logica-proposizionale&#34;&gt;Logica proposizionale&lt;/h2&gt;
&lt;h3 id=&#34;sintassi-del-linguaggio&#34;&gt;Sintassi del linguaggio&lt;/h3&gt;
&lt;p&gt;Descrivere la BNF della logica proposizionale.&lt;/p&gt;
&lt;p&gt;per sapere cosa sia la BNF di questo √® molto pi√π facile rifarsi agli appunti di logica presi durante l‚Äôanno di corso 2021/2022 &lt;a href=&#34;https://flecart.github.io/notes/logica-proposizionale/&#34;&gt;Logica Proposizionale&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Algebra dei tipi</title>
      <link>https://flecart.github.io/notes/algebra-dei-tipi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algebra-dei-tipi/</guid>
      <description>&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Algebra dei tipi/Untitled.png&#34; alt=&#34;image/universita/ex-notion/Algebra dei tipi/Untitled&#34;&gt;
&lt;h3 id=&#34;equivalenza-dei-tipi-2-&#34;&gt;Equivalenza dei tipi (2) üü©&lt;/h3&gt;
&lt;p&gt;Quando possiamo dire che due tipi siano uguali? Solitamente vengono utilizzati due metodi:&lt;/p&gt;
&lt;h4 id=&#34;equivalenza-nominale&#34;&gt;Equivalenza Nominale&lt;/h4&gt;
&lt;p&gt;Quando un nuono tipo introduce un nuovo nome diverso fra tutti i presenti. Credo cos√¨ vada golang.
Quindi in questo caso si pu√≤ dire che un tipo &lt;strong&gt;√® equivalente solamente a s√© stesso&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Vogliamo fare in questo modo perch√© se definiamo un nuovo tipo solitamente dovrebbe avere funzioni diverse, quindi √® giusto che sia diverso da uqello iniziale.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Algebra lineare numerica</title>
      <link>https://flecart.github.io/notes/algebra-lineare-numerica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algebra-lineare-numerica/</guid>
      <description>&lt;p&gt;In questa sezione andiamo ad indagare metodi di &lt;strong&gt;scomposizione&lt;/strong&gt;, iterativi e non. Ci sono molte matrici importanti per questa parte che dovremmo prendere confidenza.&lt;/p&gt;
&lt;h4 id=&#34;immagini&#34;&gt;Immagini&lt;/h4&gt;
&lt;p&gt;Lab 2 images&lt;/p&gt;
&lt;h2 id=&#34;metodo-di-gauss&#34;&gt;Metodo di gauss&lt;/h2&gt;
&lt;p&gt;Vogliamo cercare un metodo per calcolare soluzioni a sistemi di equazione del genere:&lt;/p&gt;
&lt;p&gt;$Ax = b$, classico. Supponiamo che questo sistema abbia una soluzione.&lt;/p&gt;
&lt;p&gt;Il nostro obiettivo sarebbe scomporre la matrice $A = LU$
come prodotto di due matrici Lower triangular e Upper triangular.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Astrazione sul controllo</title>
      <link>https://flecart.github.io/notes/astrazione-sul-controllo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/astrazione-sul-controllo/</guid>
      <description>&lt;h2 id=&#34;significato-di-astrazione&#34;&gt;Significato di astrazione&lt;/h2&gt;
&lt;p&gt;L&amp;rsquo;astrazione √® una cosa fondamentale nell&amp;rsquo;informatica, l‚Äôabbiamo visto anche nella prima lezione in assoluto per architettura, il sistema a strati di &lt;a href=&#34;https://flecart.github.io/notes/architettura-e-livelli-1-2/&#34;&gt;Architettura e livelli 1, 2&lt;/a&gt; reti e simili.&lt;/p&gt;
&lt;p&gt;Il principali metodi sono &lt;strong&gt;astrazioni sul controllo e sui dati&lt;/strong&gt; sui dati stiamo cominciando a parlarne in &lt;a href=&#34;https://flecart.github.io/notes/teoria-dei-tipi/&#34;&gt;Teoria dei Tipi&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Le astrazioni sono utili a &lt;strong&gt;nascondere dettagli&lt;/strong&gt; per qualche fenomeno o simile (ricorda l&amp;rsquo;esempio della mappa, che non √® il territorio √® una astrazione su essa, che contiene ancora informazioni utili). Vogliamo quindi &lt;strong&gt;concentrarci su quanto ci interessa&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Automi e Regexp</title>
      <link>https://flecart.github.io/notes/automi-e-regexp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/automi-e-regexp/</guid>
      <description>&lt;p&gt;Per l‚Äôanalisi lessicale vogliamo cercare di ricordare le &lt;strong&gt;parole legali&lt;/strong&gt; all&amp;rsquo;interno di questo linguaggio e questo √® fatto con i linguaggi regolari.&lt;/p&gt;
&lt;h2 id=&#34;introduzione-a-analizzatori-lessicali&#34;&gt;Introduzione a analizzatori lessicali&lt;/h2&gt;
&lt;h3 id=&#34;token-&#34;&gt;Token üü©&lt;/h3&gt;
&lt;p&gt;Struttura del token √® fatto da due parti&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Identificatore della classe del token&lt;/li&gt;
&lt;li&gt;Identificatore del valore del token&lt;/li&gt;
&lt;li&gt;Pattern e lessema ci sono direi boh&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;pattern-e-lessema-&#34;&gt;Pattern e Lessema üü©&lt;/h3&gt;
&lt;p&gt;I pattern sono una descrizione generale della forma dei valori di una classe di token.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Banach Spaces</title>
      <link>https://flecart.github.io/notes/banach-spaces/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/banach-spaces/</guid>
      <description>&lt;h3 id=&#34;what-are-banach-spaces&#34;&gt;What are Banach Spaces?&lt;/h3&gt;
&lt;p&gt;A &lt;strong&gt;Banach space&lt;/strong&gt; is a complete normed vector space, meaning that every Cauchy sequence in the space converges to a limit within the space.
See &lt;a href=&#34;https://flecart.github.io/notes/spazi-vettoriali/&#34;&gt;Spazi vettoriali&lt;/a&gt; for the formal definition.&lt;/p&gt;
&lt;h3 id=&#34;examples-of-banach-spaces&#34;&gt;Examples of Banach Spaces&lt;/h3&gt;
&lt;p&gt;In this section, we list some examples of the most common Banach Spaces&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;$\ell^p$ Spaces (Sequence Spaces)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Defined as:
$$
     \ell^p = \left\{ (x_n)_{n\in \mathbb{N}} \mid \sum_{n=1}^{\infty} |x_n|^p &lt; \infty \right\}, \quad 1 \leq p &lt; \infty
     $$&lt;/li&gt;
&lt;li&gt;The norm is given by:
$$
     \|x\|_p = \left( \sum_{n=1}^{\infty} |x_n|^p \right)^{1/p}
     $$&lt;/li&gt;
&lt;li&gt;When $p = \infty$, we define:
$$
     \ell^\infty = \left\{ (x_n)_{n\in \mathbb{N}} \mid \sup_n |x_n| &lt; \infty \right\}
     $$
with the norm $\|x\|_{\infty} = \sup_n |x_n|$.&lt;/li&gt;
&lt;li&gt;These spaces are Banach under their respective norms.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;$L^p$ Spaces (Function Spaces)&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bayesian Networks</title>
      <link>https://flecart.github.io/notes/bayesian-networks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bayesian-networks/</guid>
      <description>&lt;p&gt;Questi network bayesiani sono proprio dei grafi, che permettono una migliore comprensione delle relazioni causali o diagnostici fra le probabilit√†&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Esempio rete bayesiana&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Bayesian Networks/Untitled.png&#34; alt=&#34;image/universita/ex-notion/Bayesian Networks/Untitled&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;note-generali&#34;&gt;Note generali&lt;/h2&gt;
&lt;h3 id=&#34;introduzione-alla-rete-classica&#34;&gt;Introduzione alla rete classica&lt;/h3&gt;
&lt;p&gt;Una rete bayesiana ci permette di semplificare di molto il calcolo della full disjoint probability table, rendendola in questo modo&lt;/p&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Bayesian Networks/Untitled 1.png&#34; alt=&#34;image/universita/ex-notion/Bayesian Networks/Untitled 1&#34;&gt;
&lt;p&gt;Ossia andiamo a utilizzare una &lt;strong&gt;probabilit√† locale, o sparsa&lt;/strong&gt; per fare i conti, cosa che semplifica molto, e quindi velocizza il calcolo. v&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bottom-up Parser LR(0)</title>
      <link>https://flecart.github.io/notes/bottom-up-parser-lr0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bottom-up-parser-lr0/</guid>
      <description>&lt;p&gt;Descrivo ora alcune domande utili per ripasso:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Quali sono schematicmente quali sono le operazioni migliori per un parser top-down?&lt;/li&gt;
&lt;li&gt;Cosa √® un prefisso viabile?&lt;/li&gt;
&lt;li&gt;Quali sono i conflitti possibli, e come risolverli‚Ä¶&lt;/li&gt;
&lt;li&gt;Non sai nemmeno definire inmodo formale cosa sia un item&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;bottom-up&#34;&gt;Bottom up&lt;/h2&gt;
&lt;h3 id=&#34;intro-shift-reduce-e-lr-&#34;&gt;Intro shift-reduce e LR üü©&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Bottom-up Parser LR(0)/Untitled 1.png&#34; alt=&#34;image/universita/ex-notion/Bottom-up Parser LR(0)/Untitled 1&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In breve:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Shift = simbolo terminale messo nella stack&lt;/li&gt;
&lt;li&gt;Riduzione utilizzando una produzione&lt;/li&gt;
&lt;li&gt;LR = dettura da Sinistra, creazione della stringa da destra (derivazione rightmost)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;algoritmo-classico-&#34;&gt;Algoritmo classico üü®+&lt;/h3&gt;
&lt;p&gt;Quello che credo che intendevo per questo algoritmo classico √® quello non deterministico, nel senso che prova a fare backtracking, finch√© non ha finito tutte le possibilit√†, oppure trova la derivazione giusta.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bottom-up Parser LR(1)</title>
      <link>https://flecart.github.io/notes/bottom-up-parser-lr1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bottom-up-parser-lr1/</guid>
      <description>&lt;p&gt;Si pu√≤ osservare che per il parser costruito in &lt;a href=&#34;https://flecart.github.io/notes/bottom-up-parser-lr0/&#34;&gt;Bottom-up Parser LR(0)&lt;/a&gt;, non riesce a riconoscere di linguaggi semplici come $L = \{a, ab\}$.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Esempio di quanto detto
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Bottom-up Parser -LR(1)/Untitled 1.png&#34; alt=&#34;image/universita/ex-notion/Bottom-up Parser -LR(1)/Untitled 1&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;parser-slr1&#34;&gt;Parser SLR(1)&lt;/h2&gt;
&lt;p&gt;Questi parser qui utilizzano l‚Äôidea del look ahead ampiamente utilizzata in &lt;a href=&#34;https://flecart.github.io/notes/top-down-parser/&#34;&gt;Top-down Parser&lt;/a&gt;, per escludere molte produzioni.&lt;/p&gt;
&lt;p&gt;La s sta per &lt;strong&gt;simple&lt;/strong&gt;, perch√© utilizza una idea semplice :D, credo ahah boh.&lt;/p&gt;
&lt;h3 id=&#34;riduzione-con-follow-&#34;&gt;Riduzione con follow üü©&lt;/h3&gt;
&lt;p&gt;noi vogliamo &lt;strong&gt;ridurre solamente se ho follow&lt;/strong&gt; corretto il terminale finale della stringa.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Calcolo di numeri finiti</title>
      <link>https://flecart.github.io/notes/calcolo-di-numeri-finiti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/calcolo-di-numeri-finiti/</guid>
      <description>&lt;h1 id=&#34;1-calcolo-dei-numeri-finiti&#34;&gt;1 Calcolo dei numeri finiti&lt;/h1&gt;
&lt;p&gt;Il calcolo √® numerico perch√© si differenzia rispetto a un calcolo normale perch√© √® &lt;em&gt;finito&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&#34;11-errore-nei-calcoli&#34;&gt;1.1 Errore nei calcoli&lt;/h2&gt;
&lt;h3 id=&#34;111-tipologie-di-errore-5-&#34;&gt;1.1.1 Tipologie di errore (5) üü©&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Errore di misura&lt;/strong&gt;, dovuto alle imperfezioni dello strumento di misura dei dati del problema.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Errore di troncamento&lt;/strong&gt;, quando un procedimento infinito viene realizzato come procedimento finito. (esempio: calcolo del valore di una funzione tramite sviluppo in serie, perch√© dato che l‚Äôalgoritmo deve essere finito, devo prima o poi interrompere il calcolo, ecco qui l‚Äôerrore).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Errore inerente&lt;/strong&gt;, dovuto al fatto che i dati di un problema non sono in una forma buona diciamo&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Errore di rappresentazione (simil troncamento)&lt;/strong&gt; non sempre appartengono all‚Äôinsieme $\mathbb{F}$ dei numeri rappresentabili e quindi vengono approssimati.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Errore algoritmico&lt;/strong&gt;, dovuto al &lt;em&gt;propagarsi&lt;/em&gt; degli errori di arrotondamento sulle singole operazioni in un procedimento complesso.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;112-misura-dellaccuratezza-&#34;&gt;1.1.2 Misura dell‚Äôaccuratezza üü©&lt;/h3&gt;
&lt;p&gt;Anche per l‚Äôaccuratezza di una misura utilizziamo degli errori (questi tipi di errori li hai anche studiati in fisica durante il liceo).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Circuit Motifs</title>
      <link>https://flecart.github.io/notes/circuit-motifs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/circuit-motifs/</guid>
      <description>&lt;p&gt;Work like &lt;a href=&#34;https://www.science.org/doi/10.1126/science.abg7285&#34;&gt;(Luo 2021)&lt;/a&gt; show that our brain has naturally some types of circuits, which can be classified mainly as 4 types as described in (Wang et al.):&lt;/p&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/Circuit Motifs-20240717152808884.webp&#34; alt=&#34;Circuit Motifs-20240717152808884&#34;&gt;
&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;
&lt;p&gt;[1] Luo &lt;a href=&#34;https://www.science.org/doi/10.1126/science.abg7285&#34;&gt;‚ÄúArchitectures of Neuronal Circuits‚Äù&lt;/a&gt; Science Vol. 373(6559), pp. eabg7285 2021&lt;/p&gt;
&lt;p&gt;[2] Wang et al. ‚ÄúCircuitNet: A Generic Neural Network to Realize  Universal Circuit Motif Modeling‚Äù&lt;/p&gt;</description>
    </item>
    <item>
      <title>Classi OOP</title>
      <link>https://flecart.github.io/notes/classi-oop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/classi-oop/</guid>
      <description>&lt;h2 id=&#34;introduzione-a-oop&#34;&gt;Introduzione a OOP&lt;/h2&gt;
&lt;p&gt;Per la definizione di classe andare a guardare &lt;a href=&#34;https://flecart.github.io/notes/object-orientation/&#34;&gt;Object orientation&lt;/a&gt;, per√≤ lo ripeto in questa occasione, √® solamente un modello su cui andare a costruire degli oggetti.&lt;/p&gt;
&lt;h3 id=&#34;capisaldi&#34;&gt;Capisaldiüü©&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Incapsulazione&lt;/li&gt;
&lt;li&gt;Astrazione&lt;/li&gt;
&lt;li&gt;Ereditariet√†&lt;/li&gt;
&lt;li&gt;Dispatch dinamico&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;costruttori--&#34;&gt;Costruttori üü©-&lt;/h3&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Classi OOP/Untitled.png&#34; alt=&#34;image/universita/ex-notion/Classi OOP/Untitled&#34;&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Classi OOP/Untitled 1.png&#34; alt=&#34;image/universita/ex-notion/Classi OOP/Untitled 1&#34;&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Classi OOP/Untitled 2.png&#34; alt=&#34;image/universita/ex-notion/Classi OOP/Untitled 2&#34;&gt;
&lt;p&gt;Il costruttore √® un codice utilizzato per &lt;strong&gt;inizializzare correttamente lo stato&lt;/strong&gt; interno. Le regole sono le stesse dei metodi sovraccaricati (dinamica per la chiamata, statica per il numero dei parametri che prende in input).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Convolutional NN</title>
      <link>https://flecart.github.io/notes/convolutional-nn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/convolutional-nn/</guid>
      <description>&lt;h2 id=&#34;introduction-to-convolutional-nn&#34;&gt;Introduction to convolutional NN&lt;/h2&gt;
&lt;h3 id=&#34;the-convolution-operator--&#34;&gt;The convolution operator üü©-&lt;/h3&gt;
&lt;p&gt;Il prodotto di convoluzione √® matematicamente molto contorto, anche se nella pratica √® una cosa molto molto semplice. In pratica voglio calcolare il valore di un pixel in funzione di certi suoi vicini, moltiplicati per un &lt;strong&gt;filter&lt;/strong&gt; che in pratica √® una matrice di pesi, che definisce un pattern lineare a cui sarei interessato di cercare nell‚Äôimmagine.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slides ed esempi (molto pi√π chiaril)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Costraint Satisfaction Problems</title>
      <link>https://flecart.github.io/notes/costraint-satisfaction-problems/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/costraint-satisfaction-problems/</guid>
      <description>&lt;h2 id=&#34;definizione&#34;&gt;Definizione&lt;/h2&gt;
&lt;h3 id=&#34;caratteristiche&#34;&gt;Caratteristiche&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Variabili&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dominio&lt;/strong&gt; per ogni variabile&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Costraints&lt;/strong&gt; per ogni variabile&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Queste tre sono elementi che definiscono un problema di soddisfazione delle restrizioni, una soluzione √® un assegnamento di variabili che &lt;strong&gt;soddisfi&lt;/strong&gt; ogni restrizioone e sia all‚Äôinterno del dominio&lt;/p&gt;
&lt;h2 id=&#34;consistenza&#34;&gt;Consistenza&lt;/h2&gt;
&lt;p&gt;Vogliamo andare a limitare il dominio valutando le consistenze possibili&lt;/p&gt;
&lt;h3 id=&#34;consistenza-del-punto&#34;&gt;Consistenza del punto&lt;/h3&gt;
&lt;p&gt;Si pu√≤ dire che un punto sia consistente se le sue variabili possibili non viola nessuna restrizione unaria: eg. se ho N e ho la restrizione n ‚â• 0, allora avere tutto N √® inconsistente nel punto.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Deblur di immagini</title>
      <link>https://flecart.github.io/notes/deblur-di-immagini/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/deblur-di-immagini/</guid>
      <description>&lt;h3 id=&#34;origini-di-sfocatura&#34;&gt;Origini di sfocatura&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;/images/notes/image/universita/ex-notion/Immagini/Untitled.png&amp;quot; alt=&amp;quot;image/universita/ex-notion/Immagini/Untitled&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;Rumore causata da problemi fisici che sono &lt;strong&gt;errori di lettura&lt;/strong&gt; del segnale analogico Questo si indica anche come errore gaussiano bianco e si pu√≤ considerare &lt;em&gt;additivo&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Rumore causato dalla digitalizzazione, quindi dalla discretizzazione di essa.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide formalizzazione errori per sfocatura&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Immagini/Untitled 1.png&#34; alt=&#34;image/universita/ex-notion/Immagini/Untitled 1&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;point-spread-function&#34;&gt;Point spread function&lt;/h3&gt;
&lt;p&gt;Un unico pixel bianco sembra influenzare il suo ambiente nero, come in immagine&lt;/p&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Immagini/Untitled 2.png&#34; alt=&#34;image/universita/ex-notion/Immagini/Untitled 2&#34;&gt;
&lt;p&gt;Vorremmo utilizzare delle funzioni ce siano in grado di approssimare questa funzione.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Descrizione linguaggio</title>
      <link>https://flecart.github.io/notes/descrizione-linguaggio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/descrizione-linguaggio/</guid>
      <description>&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;p&gt;Per questa parte c‚Äô√® un sacco di roba in comune con &lt;a href=&#34;https://flecart.github.io/notes/tecniche-di-definizione-di-semantica-%284%29-%F0%9F%9F%A9&#34;&gt;Tecniche di definizione di semantica (4) üü©&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Trattiamo alcune caratteristiche che descrivono ad alto livello un linguaggio di programmazione. √à da notare che questa parte della spiegazione del linguaggio non √® limitante al solo linguaggio di programmazione, √® utile per analizzare tutti i linguaggi (tranne la parte di implementazione)&lt;/p&gt;
&lt;h3 id=&#34;sintassi--&#34;&gt;Sintassi üü©-&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Relazione fra segni&lt;/em&gt;. si occupa di decidere quando una frase √® corretta.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Explainability of CNN</title>
      <link>https://flecart.github.io/notes/explainability-of-cnn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/explainability-of-cnn/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Capire in che modo una rete convoluzionale ci pu√≤ dare insight migliori su come funzionano questi networks.&lt;/p&gt;
&lt;h3 id=&#34;visualizzazione-dei-hidden-layers&#34;&gt;Visualizzazione dei hidden layers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide visualization&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Explainability of CNN/Untitled.png&#34; alt=&#34;image/universita/ex-notion/Explainability of CNN/Untitled&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Potremmo fissare una immagine anche a caso, e modificare la x in modo che sia pi√π simile a quanto vuole computare il neurone. In questo modo genero una immagine che generi una activation forte nel neuron trainato, e si potrebbe dire che sia il genere di immagine che viene generata da essa.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Expressiveness of NN</title>
      <link>https://flecart.github.io/notes/expressiveness-of-nn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/expressiveness-of-nn/</guid>
      <description>&lt;h2 id=&#34;the-perceptron&#34;&gt;The perceptron&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide summary of working of perceptron&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Expressiveness of NN/Untitled.png&#34; alt=&#34;image/universita/ex-notion/Expressiveness of NN/Untitled&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Note on the bias&lt;/strong&gt;: it is only useful to move the treshhold where to consider the output to be 1 and where to be 1.&lt;/p&gt;
&lt;p&gt;Now we ask what can be predicted by a perceptron?&lt;/p&gt;
&lt;p&gt;We can see the update rule of the perceptron:&lt;/p&gt;
$$
\begin{cases}
w = w + \alpha x  \\
b = b + \alpha
\end{cases}
$$$$
\alpha = \begin{cases}
0  &amp;  \Theta(x \theta + b) = y \\
-1  &amp;  \Theta(x \theta + b) &gt; y \\
1  &amp;  \Theta(x \theta + b) &lt; y 
\end{cases}
$$&lt;h4 id=&#34;linearly-separability-necessity&#34;&gt;Linearly separability necessity&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Hyperplanes&lt;/strong&gt;, because that equation is an hyperplane, so we are sure that we can predict an hyperplane, and that it, and it‚Äôs only it. (it‚Äôs predicting wheter it can be above or below that line).
So the perceptron is correct &lt;strong&gt;only if the data is linearly separable&lt;/strong&gt;!&lt;/p&gt;</description>
    </item>
    <item>
      <title>Fatou&#39;s Lemma</title>
      <link>https://flecart.github.io/notes/fatous-lemma/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/fatous-lemma/</guid>
      <description>&lt;p&gt;Fatou&amp;rsquo;s lemma is a fundamental result in measure theory that deals with the relationship between limits and integrals of sequences of non-negative measurable functions.
See the &lt;a href=&#34;https://en.wikipedia.org/wiki/Fatou%27s_lemma&#34;&gt;wikipedia&lt;/a&gt; page for further info.&lt;/p&gt;
&lt;h3 id=&#34;statement-of-fatous-lemma&#34;&gt;Statement of Fatou&amp;rsquo;s Lemma&lt;/h3&gt;
&lt;p&gt;Let $(f_n)$ be a sequence of non-negative measurable functions on a measure space $(X,\mu)$. Then:&lt;/p&gt;
$$\int \liminf_{n \to \infty} f_n \,d\mu \leq \liminf_{n \to \infty} \int f_n \,d\mu$$&lt;p&gt;In words, this means that the integral of the limit inferior of a sequence of functions is less than or equal to the limit inferior of their integrals.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Fn Ordine superiore</title>
      <link>https://flecart.github.io/notes/fn-ordine-superiore/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/fn-ordine-superiore/</guid>
      <description>&lt;p&gt;Questa parte √® strettamente collegata conl a parte di &lt;a href=&#34;https://flecart.github.io/notes/astrazione-sul-controllo/&#34;&gt;Astrazione sul controllo&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Si parla di &lt;strong&gt;passare le funzioni come dati&lt;/strong&gt;. e quindi possono essere passati come se fossero dei parametri.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;un linguaggio di programmazione √® di ordine superiore qualora
ammetta funzioni sia come parametro che come risultato di altre funzioni.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;La parte molto simile alla precedente √® il fatto di &lt;strong&gt;valutare&lt;/strong&gt; la funzione nell&amp;rsquo;ambiente iniziale, quindi bisogna utilizzare un sistema simile a quello del passaggio per nome.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Fondamenti teorica</title>
      <link>https://flecart.github.io/notes/fondamenti-teorica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/fondamenti-teorica/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://virtuale.unibo.it/pluginfile.php/1295166/mod_resource/content/0/Lez18-Gorrieri.pdf&#34;&gt;https://virtuale.unibo.it/pluginfile.php/1295166/mod_resource/content/0/Lez18-Gorrieri.pdf&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;halting-problem&#34;&gt;Halting problem&lt;/h2&gt;
&lt;p&gt;Questo asserisce che &lt;strong&gt;non esiste nessun programma che sia in grado di decidere la terminazione di un altro programma&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Questo √® un problema che ci √® interessante perch√© vorremmo costruire un compilatore che  sia in grado di osservare &lt;strong&gt;tutti gli errori possibili&lt;/strong&gt; del programma. Come vedremo tra poco la risposta sar√† negativa.&lt;/p&gt;
&lt;h3 id=&#34;dimostrazione-tesi-&#34;&gt;Dimostrazione tesi üü®++&lt;/h3&gt;
&lt;p&gt;Supponiamo che questo programma esista, lo chiamiamo &lt;code&gt;check(P)&lt;/code&gt; che restituisce 0 se termina 1 se non termina, allora devo poter essere in grado di scrivere un programma di questo genere&lt;/p&gt;</description>
    </item>
    <item>
      <title>Garbage Collection</title>
      <link>https://flecart.github.io/notes/garbage-collection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/garbage-collection/</guid>
      <description>&lt;h2 id=&#34;on-dangling-pointers&#34;&gt;On dangling pointers&lt;/h2&gt;
&lt;h3 id=&#34;tombstones-&#34;&gt;Tombstones üü©&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slides tombstones&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Garbage Collection/Untitled.png&#34; alt=&#34;image/universita/ex-notion/Garbage Collection/Untitled&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Quando alloco, alloco anche una tombstone, e tutti i riferimenti passano per quella. (quindi ho due dereference per l‚Äôaccesso) quando vado a deallocare segno la tombstone come RIP, NULL.&lt;/p&gt;
&lt;p&gt;Dopo molto tempo ho il problema del cimitero che diventa molto grande. Anche se non punta pi√π a niente, il cimitero.&lt;/p&gt;
&lt;h3 id=&#34;keys-and-locks-&#34;&gt;Keys and locks üü©&lt;/h3&gt;
&lt;p&gt;Un p√≤ di overhead in pi√π dal punto di vista della memoria, che √® doppio&lt;/p&gt;</description>
    </item>
    <item>
      <title>Gestione delle eccezioni</title>
      <link>https://flecart.github.io/notes/gestione-delle-eccezioni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gestione-delle-eccezioni/</guid>
      <description>&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;metodi-alternativi-di-gestione-degli-errori-3-&#34;&gt;Metodi alternativi di gestione degli errori (3) üü©&lt;/h3&gt;
&lt;p&gt;A volte le computazioni falliscono. Potremmo gestirle con i result come accennato in &lt;a href=&#34;https://flecart.github.io/notes/polimorfismo/&#34;&gt;Polimorfismo&lt;/a&gt;, per√≤ diventa molto macchinoso fare tutte le funzioni che debbano inoltrare solamente delle results. bisogna trovare un modo pi√π naturale. Ecco che arriva una gestione delle eccezioni direttamente nel linguaggio. Si tratta un sistema di comunicazione degli errori.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ALTRI METODI&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Results, stile monadico, vedi sopra.&lt;/li&gt;
&lt;li&gt;definire dei valori eccezionali (questo si va spesso in C)&lt;/li&gt;
&lt;li&gt;Il chiamato dice al chiamante una cosa da chiamare quando fallisce. Diciamo &lt;strong&gt;inversione del controllo&lt;/strong&gt; perch√© in questo caso √® il chiamato che dice cosa fare. Ma rende il codice poco composizionale, quindi difficile da seguire.
(Questa √® la soluzione molto pi√π simile alla gestione effettiva degli errori). Ma nelle eccezioni vere non √® il chiamato che ritorn al&amp;rsquo;indirizzo da eseguire ma √® il runtime che decide cosa andare ad eseguire. Questa cosa non interrompe il flusso del calcolo&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Con le eccezioni vogliamo &lt;strong&gt;trasferire il controllo a un gestore delle eccezioni&lt;/strong&gt; questo gestore solitamente si trova sulla stack (va a risalire tutta la stack di chiamata fino a raggiungere questo gestore).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Grammatiche Regolari</title>
      <link>https://flecart.github.io/notes/grammatiche-regolari/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/grammatiche-regolari/</guid>
      <description>&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;definizione-grammatica-regolare-&#34;&gt;Definizione grammatica regolare üü©&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Definizione&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Grammatiche Regolari/Untitled 1.png&#34; alt=&#34;image/universita/ex-notion/Grammatiche Regolari/Untitled 1&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In pratica posso avere solamente come terminali a, oppure un suffisso a su un non terminale.&lt;/p&gt;
&lt;p&gt;Queste grammatiche sono interessanti perch√© √® molto facile costruire un automa che sia in grado di riconoscere questo linguaggio.&lt;/p&gt;
&lt;p&gt;Seguendo una definizione pi√π &lt;em&gt;lasca&lt;/em&gt; possono anche accettare dei nonterminali &lt;strong&gt;epsilon&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;espressione-regolare-a-nfa-&#34;&gt;Espressione regolare a NFA üü©&lt;/h3&gt;
&lt;p&gt;Questa sezione √® anche presente in &lt;a href=&#34;https://flecart.github.io/notes/automi-e-regexp/&#34;&gt;Automi e Regexp&lt;/a&gt;, per√≤ √® riportata qui cos√¨ c‚Äô√® l‚Äôinsieme di tutte le cose in un unico posto.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Gruppi</title>
      <link>https://flecart.github.io/notes/gruppi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gruppi/</guid>
      <description>&lt;h2 id=&#34;definizione-gruppo&#34;&gt;Definizione gruppo&lt;/h2&gt;
&lt;p&gt;Qualunque insieme pi√π operazione tale per cui:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Esistenza dell&amp;rsquo;inverso per ogni elemento $\forall g \in G, \exists g^{-1} \in G : gg^{-1} = e$&lt;/li&gt;
&lt;li&gt;Esistenza di un elemento neutro $\exists e \in G: \forall g \in G, eg = g$&lt;/li&gt;
&lt;li&gt;Associativit√†: $(gh)f = g(hf)$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Closure&lt;/strong&gt;: $\forall g, h \in G \implies gh \in G$&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;unicit√†-dellelemento-neutro&#34;&gt;Unicit√† dell‚Äôelemento neutro&lt;/h3&gt;
&lt;p&gt;Supponiamo di avere un gruppo $G$ e due elementi neutri $e, f$
Allora abbiamo che
$ae = a = af$ per√≤ se moltiplichiamo per l&amp;rsquo;inversa abbiamo che
$a^{-1}ae = a^{-1}af \implies e = f$&lt;/p&gt;</description>
    </item>
    <item>
      <title>Gruppi Normali</title>
      <link>https://flecart.github.io/notes/gruppi-normali/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gruppi-normali/</guid>
      <description>&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;definizione-normalit√†&#34;&gt;Definizione normalit√†&lt;/h3&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Gruppi Normali/Untitled.png&#34; alt=&#34;image/universita/ex-notion/Gruppi Normali/Untitled&#34;&gt;
&lt;h3 id=&#34;test-del-sottogruppo-normale&#34;&gt;Test del sottogruppo normale&lt;/h3&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Gruppi Normali/Untitled 1.png&#34; alt=&#34;image/universita/ex-notion/Gruppi Normali/Untitled 1&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Dimostrazione&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Gruppi Normali/Untitled 2.png&#34; alt=&#34;image/universita/ex-notion/Gruppi Normali/Untitled 2&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;il-gruppo-quoziente&#34;&gt;Il gruppo quoziente&lt;/h3&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Gruppi Normali/Untitled 3.png&#34; alt=&#34;image/universita/ex-notion/Gruppi Normali/Untitled 3&#34;&gt;
&lt;p&gt;L‚Äôimportanza del gruppo normale √® che quando esso vale, possiamo avere il gurppo fattore&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Dimostrazione&lt;/p&gt;
&lt;p&gt;!&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Gruppi Normali/Untitled 4.png&#34; alt=&#34;image/universita/ex-notion/Gruppi Normali/Untitled 4&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Interpolazione</title>
      <link>https://flecart.github.io/notes/interpolazione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/interpolazione/</guid>
      <description>&lt;p&gt;Vogliamo in questa sezione andare ad indagare la costruzione di funzioni che passano in tutti i punti che vogliamo, appunto interpolare. La funzione √® molto simile alla regressione trattata in &lt;a href=&#34;https://flecart.github.io/notes/minimi-quadrati/&#34;&gt;Minimi quadrati&lt;/a&gt; (con il metodo della regressione, chiamato anche approssimazione ai minimi quadrati).&lt;/p&gt;
&lt;p&gt;Quindi mentre la precedente voleva andare a minimizzare l&amp;rsquo;errore, questo attuale va a creare proprio da 0 la funzione che ci passa sempre.&lt;/p&gt;
&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;p&gt;Andremo a creare una funzione f tale che per ogni x in input si abbia &lt;strong&gt;esattamente&lt;/strong&gt; la y in output&lt;/p&gt;</description>
    </item>
    <item>
      <title>Introduction to computational statistics</title>
      <link>https://flecart.github.io/notes/introduction-to-computational-statistics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduction-to-computational-statistics/</guid>
      <description>&lt;h3 id=&#34;what-is-it-for&#34;&gt;What is it for&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Estimation&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sampling&lt;/strong&gt; generate numbers from &lt;em&gt;any&lt;/em&gt; distribution! (distributions are important in statistics).
&lt;ol&gt;
&lt;li&gt;Density&lt;/li&gt;
&lt;li&gt;Cumulative distribution (and others similar).&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Optimization&lt;/strong&gt; how to find computationally the min and max of functions.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Generating?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Random (difficile anche filosoficamente definire cosa significa questo).
&lt;ol&gt;
&lt;li&gt;Molto importante perch√© si assume in Comp stats che abbiamo il random vero, e questa assunzione che non vale pu√≤ rompere cose.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;And independent&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;sample-proportion&#34;&gt;Sample proportion&lt;/h4&gt;
&lt;p&gt;Average of something (example of the lake cannonball).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Introduzione alla probabilita</title>
      <link>https://flecart.github.io/notes/introduzione-alla-probabilita/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-alla-probabilita/</guid>
      <description>&lt;h1 id=&#34;note&#34;&gt;Note:&lt;/h1&gt;
&lt;p&gt;Questo corso √® troppo astratto. Pi√π che probabilit√† tratta di teoria della Misura. Quindi affossato‚Ä¶&lt;/p&gt;
&lt;p&gt;Link della serie: &lt;a href=&#34;https://www.youtube.com/watch?v=172m7qVy_FQ&amp;amp;list=PLrb6X_RiBI94b6dzCx-QwM-r0aZpJyPxS&#34;&gt;https://www.youtube.com/watch?v=172m7qVy_FQ&amp;amp;list=PLrb6X_RiBI94b6dzCx-QwM-r0aZpJyPxS&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;campo-di-probabilit√†&#34;&gt;Campo (di probabilit√†)&lt;/h1&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/Introduzione alla probabilit√†/Untitled.png&#34; alt=&#34;Introduzione alla probabilit√†/Untitled&#34;&gt;
&lt;p&gt;Nota:&lt;/p&gt;
&lt;p&gt;2 e 3 ‚áí 4&lt;/p&gt;
&lt;p&gt;2 e 4 ‚áí 3&lt;/p&gt;
&lt;p&gt;Quindi 3 e 4 sono interscambiabili, e si potrebbe eliminare uno dei due.&lt;/p&gt;
&lt;p&gt;Anche il fatto che il vuoto sia presente in F si pu√≤ omettere. combinando 1 e 2 ottengo il vuoto (complementare dell‚Äôinsieme che prenda tutto).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Isomorfismi</title>
      <link>https://flecart.github.io/notes/isomorfismi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/isomorfismi/</guid>
      <description>&lt;p&gt;Gli isomorfismi sono delle propriet√† fondamentali per stabilire una sorta di equivalenza fra i gruppi. Utilizziamo questi isomorfismi per parlare della stessa cosa ma in modi diversi.&lt;/p&gt;
&lt;h2 id=&#34;31-introduzione&#34;&gt;3.1 Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;311-definizione&#34;&gt;3.1.1 Definizione&lt;/h3&gt;
&lt;p&gt;Un gruppo si dice isomorfo rispetto ad un altro gruppo se, in paroloni semplici, esiste una funzione bigettiva tale che preservi l&amp;rsquo;operazione del gruppo.&lt;/p&gt;
&lt;p&gt;In altre parole&lt;/p&gt;
$$
\phi:A \to B,\phi(ab) = \phi(a)\phi(b)
$$&lt;h3 id=&#34;312-step-di-dimostrazione&#34;&gt;3.1.2 Step di dimostrazione&lt;/h3&gt;
&lt;p&gt;Esiste un modo preciso per dimostrare se due gruppi sono isomorfi. In particolare:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kolmogorov complexity</title>
      <link>https://flecart.github.io/notes/kolmogorov-complexity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/kolmogorov-complexity/</guid>
      <description>&lt;p&gt;Gran parte di quanto scrivo ora √® tratto da &lt;a href=&#34;http://link.springer.com/10.1007/978-3-030-11298-1&#34;&gt;(Li &amp;amp; Vit√°nyi 2019)&lt;/a&gt;.
Chaitin, Kolmogorov e Solomonoff hanno elaborato il tema in modo indipendente e allo stesso tempo verso gli anni &amp;lsquo;60!&lt;/p&gt;
&lt;p&gt;Solomonoff lo ha trovato sul problema dell&amp;rsquo;induzione all&amp;rsquo;et√† di 38 anni, Kolmogorov invece era gi√† tardi, ha gi√† trovato gli assiomi della probabilit√† e poi nel 65 cerca randomness. Mentre Chaiten Information = Computation e non probabilit√†, nel 68 all&amp;rsquo;et√† di 19 anni.
In AI teorico questo sembra un tema molto importante.&lt;/p&gt;</description>
    </item>
    <item>
      <title>l‚Äôintelligenza</title>
      <link>https://flecart.github.io/notes/lintelligenza/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/lintelligenza/</guid>
      <description>&lt;p&gt;Questi appunti sono stati scritti leggendo il (Russell &amp;amp; Norvig 2009).&lt;/p&gt;
&lt;h1 id=&#34;1-introduzione&#34;&gt;1 Introduzione&lt;/h1&gt;
&lt;p&gt;L‚Äôintelligenza artificiale √® un campo in velocissima espansione, con gi√† un mercato enorme di un trillion dollars.&lt;/p&gt;
&lt;p&gt;Inoltre il suo campo di studi spazia da moltissimi campi, √® per questo che quasi potresti considerarla &lt;strong&gt;universale&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&#34;11-lintelligenza-artificiale&#34;&gt;1.1 L‚Äôintelligenza artificiale&lt;/h2&gt;
&lt;h3 id=&#34;111-cosa-√®-2&#34;&gt;1.1.1 Cosa √® (2)&lt;/h3&gt;
&lt;p&gt;Nel tempo si √® cercato di definire con esattezza cosa sia l‚Äôintelligenza artificiale. In generare si √® basato su alcuni parametri cardine ossia:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linguaggi Deterministici e DPDA</title>
      <link>https://flecart.github.io/notes/linguaggi-deterministici-e-dpda/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/linguaggi-deterministici-e-dpda/</guid>
      <description>&lt;h2 id=&#34;dpda&#34;&gt;DPDA&lt;/h2&gt;
&lt;h3 id=&#34;definizione-2&#34;&gt;Definizione (2)üü©&lt;/h3&gt;
&lt;p&gt;La definizione di DPDA √® molto simile a quella trattata in &lt;a href=&#34;https://flecart.github.io/notes/linguaggi-liberi-e-pda/&#34;&gt;Linguaggi liberi e PDA&lt;/a&gt;, con solo costraints sulla deterministicit√†, che si traducono in due condizioni:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Al massimo posso avere un risultato per ogni coppia di lettura e simbolo su stack&lt;/li&gt;
&lt;li&gt;Se ho una transizione senza leggere, posso avere solo quella&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Linguaggi Deterministici e DPDA/Untitled 1.png&#34; alt=&#34;image/universita/ex-notion/Linguaggi Deterministici e DPDA/Untitled 1&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;linguaggio-libero-deterministico&#34;&gt;Linguaggio libero deterministico&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Un linguaggio √® libero deterministico se esiste un PDA che lo riconosce per &lt;strong&gt;stato finale&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linguaggi liberi e PDA</title>
      <link>https://flecart.github.io/notes/linguaggi-liberi-e-pda/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/linguaggi-liberi-e-pda/</guid>
      <description>&lt;p&gt;In questa parte del nostro percorso nei linguaggi di programmazione proviamo ad espandere NFA e DFA in modo che possano riconoscere linguaggi come $ww^r | w \in \{a, b\}^*$ , con r maggiore o uguale a zero (r per dire che √® il contrario di w) (questo linguaggio per il pumping lemma).&lt;/p&gt;
&lt;h4 id=&#34;grammatiche-libere-da-contesto&#34;&gt;Grammatiche libere da contesto&lt;/h4&gt;
$$
G = \langle \mathcal{N}, S, \Sigma, \mathcal{R} \rangle 
$$&lt;p&gt;
Dove $\mathcal{N}$ sono i non terminali, $S$ √® il non terminale iniziale, $\Sigma$ sono l&amp;rsquo;alfabeto dei simboli finali e $\mathcal{R}$ le relazioni possibili.
Spesso lo scriviamo solo tramite le relazioni, perch√© √® la forma pi√π compatta.
I nodi di una derivazione da grammatica libera da contesto √® chiamato &lt;strong&gt;costituente del linguaggio&lt;/strong&gt;. Questo √® pi√π importante in linguistica.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LR(k) e YACC</title>
      <link>https://flecart.github.io/notes/lrk-e-yacc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/lrk-e-yacc/</guid>
      <description>&lt;h2 id=&#34;lrk&#34;&gt;LR(k)&lt;/h2&gt;
&lt;h3 id=&#34;grammatiche-lrk-&#34;&gt;Grammatiche LR(k) üü©&lt;/h3&gt;
&lt;p&gt;Anche in questo caso proviamo a generalizzare il concetto dei pirmi k caratteri, in modo da generalizzare in qualche senso il concetto di LR(k), quindi &lt;strong&gt;andiamo a modificare la closure&lt;/strong&gt; considerando ora first k&lt;/p&gt;
&lt;p&gt;Per ricordarti come si calcolava first k, andare a guardare &lt;a href=&#34;https://flecart.github.io/notes/top-down-parser/&#34;&gt;Top-down Parser&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;il problema che poi diventa pratico riguardo questo √® l&amp;rsquo;impossibilit√† di gestire &lt;strong&gt;stringhe lunghezza k&lt;/strong&gt; che sono una assurdit√† (esponenziale per la lunghezza)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Macchine Astratte</title>
      <link>https://flecart.github.io/notes/macchine-astratte/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/macchine-astratte/</guid>
      <description>&lt;h3 id=&#34;definizione-ed-esempi-per-macchine-astratte-&#34;&gt;Definizione ed esempi per macchine astratte üü©&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Una macchina astratta √® un qualunque insieme di algoritmi e strutture di dati che permettono di memorizzare ed eseguire il linguaggio $L$, quindi una macchina astratta esiste per esguire &lt;strong&gt;il proprio linguaggio&lt;/strong&gt; (inteso come insieme finito di istruzioni primitive che riesce ad  comprendere e eseguire).&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Si pu√≤ proprio dire che &lt;em&gt;esiste una simbiosi&lt;/em&gt; fra macchina e linguaggio. Si potrebbe dire che la macchina fisica √® soltanto una implementazione FISICA di un linguaggio, ossia una macchina che capisce ed esegue quel linguaggio e che sia solamente un caso particolare della macchina astratta.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Measure Theory</title>
      <link>https://flecart.github.io/notes/measure-theory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/measure-theory/</guid>
      <description>&lt;p&gt;Ultima modifica: September 18, 2022 9:43 AM
Primo Abbozzo: September 16, 2022 9:52 AM
Studi Personali: Yes&lt;/p&gt;
&lt;h1 id=&#34;elementi-di-ripasso&#34;&gt;Elementi di ripasso&lt;/h1&gt;
&lt;h1 id=&#34;measure-theory&#34;&gt;Measure Theory&lt;/h1&gt;
&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;requirements-of-the-measure-function&#34;&gt;Requirements of the measure function&lt;/h3&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Measure Theory/Untitled.png&#34; alt=&#34;image/universita/ex-notion/Measure Theory/Untitled&#34;&gt;
&lt;p&gt;Vorremmo cercare di &lt;strong&gt;estendere il concetto di misurabilit√†&lt;/strong&gt; a gruppi molto pi√π ampi di un singolo intervallo, vorrei creare una funzione che sia in grado di misurare degli insiemi. *su vedr√† che sono impossibili).&lt;/p&gt;
&lt;h3 id=&#34;impossibilit√†-di-questi-requirements-assurdo&#34;&gt;Impossibilit√† di questi requirements (assurdo)&lt;/h3&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Measure Theory/Untitled 1.png&#34; alt=&#34;image/universita/ex-notion/Measure Theory/Untitled 1&#34;&gt;
&lt;p&gt;&lt;strong&gt;Costruzione dell‚Äôinsieme di interesse&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Metodi di Discesa</title>
      <link>https://flecart.github.io/notes/metodi-di-discesa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/metodi-di-discesa/</guid>
      <description>&lt;h2 id=&#34;introduzione-ai-metodi-di-discesa&#34;&gt;Introduzione ai metodi di discesa.&lt;/h2&gt;
&lt;h3 id=&#34;generali-sui-metodi-di-discesa&#34;&gt;Generali sui metodi di discesa&lt;/h3&gt;
&lt;p&gt;Vogliamo creare algoritmi che riescano a trovare i punti di minimo delle funzioni non vincolate.&lt;/p&gt;
&lt;p&gt;In generale &lt;strong&gt;si trova un punto stazionario (condizioni necessarie)&lt;/strong&gt; ma non √® garantito lo stato ottimo.&lt;/p&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Metodi di Discesa/Untitled.png&#34; alt=&#34;image/universita/ex-notion/Metodi di Discesa/Untitled&#34;&gt;
&lt;p&gt;Solitamente sono divisi in &lt;strong&gt;first order methods&lt;/strong&gt; in cui viene considerata solamente la derivata prima della funzione. E cose di metodi superiori.&lt;/p&gt;
&lt;h3 id=&#34;condizioni-di-arresto-classiche-2--&#34;&gt;Condizioni di arresto classiche (2) üü©-&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide&lt;/p&gt;</description>
    </item>
    <item>
      <title>Nomi e Scope</title>
      <link>https://flecart.github.io/notes/nomi-e-scope/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/nomi-e-scope/</guid>
      <description>&lt;h2 id=&#34;i-nomi-e-oggetti&#34;&gt;I Nomi e oggetti&lt;/h2&gt;
&lt;h3 id=&#34;oggetti-denotati-e-identificatori&#34;&gt;Oggetti denotati e identificatoriüü©&lt;/h3&gt;
&lt;p&gt;I nomi sono sequenze di caratteri o numeri aka: &lt;strong&gt;token alfanumerico&lt;/strong&gt; (anche &lt;strong&gt;IDENTIFICATORE&lt;/strong&gt; (per token guardare &lt;a href=&#34;https://flecart.github.io/notes/grammatiche-regolari/&#34;&gt;Grammatiche Regolari&lt;/a&gt;) utilizzate principalmente come &lt;strong&gt;Astrazione sul controllo e sui dati&lt;/strong&gt; (quindi sono cose molto pi√π facili da ricordare rispetto il suo encoding binario o a indirizzi). Infatti utilizziamo i nomi per evitare di interessarci di informazioni come l‚Äôindirizzo di memoria del nostro dato o per creare una interfaccia con visibili solo nome della procedura e parametri.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Object Detection</title>
      <link>https://flecart.github.io/notes/object-detection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/object-detection/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;h3 id=&#34;semantic-segmentation&#34;&gt;Semantic segmentation&lt;/h3&gt;
&lt;p&gt;Vorremo trovare &lt;strong&gt;regioni che corrispondano a categorie diverse&lt;/strong&gt;. E dividere in questo modo l‚Äôimmagine secondo zone di informazione.&lt;/p&gt;
&lt;h3 id=&#34;object-detection&#34;&gt;Object detection&lt;/h3&gt;
&lt;p&gt;Vogliamo trovare &lt;strong&gt;il pi√π piccolo box&lt;/strong&gt; che vada a contenere l‚Äôoggetto. Questo √® fatto con il &lt;strong&gt;bounding box&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;In questo caso la funzione di loss √® un p√≤ pi√π difficile da definire, si utilizza la funzione &lt;strong&gt;intersection over union&lt;/strong&gt; con le aree, in pratica la percentuale di immagine comune diciamo.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Object orientation</title>
      <link>https://flecart.github.io/notes/object-orientation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/object-orientation/</guid>
      <description>&lt;p&gt;Ripasso Prox: 10
Ripasso: May 29, 2023
Ultima modifica: May 19, 2023 10:33 AM
Primo Abbozzo: May 8, 2023 9:20 AM
Stato: üåïüåïüåïüåïüåë
Studi Personali: No&lt;/p&gt;
&lt;h1 id=&#34;elementi-di-ripasso&#34;&gt;Elementi di ripasso&lt;/h1&gt;
&lt;h1 id=&#34;object-orientation&#34;&gt;Object orientation&lt;/h1&gt;
&lt;h2 id=&#34;il-tipo-di-dato-astratto&#34;&gt;il tipo di dato astratto&lt;/h2&gt;
&lt;h3 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h3&gt;
&lt;p&gt;Per questi tipi di dato non ci interessa di sapere cosa ci sia sotto (storato come bit? storato come sabbia boh), ci interessa solamente che abbia quei metodi, che possiamo in un certo senso identificare come la sua capsula, &lt;strong&gt;opaca&lt;/strong&gt; in questo caso.&lt;/p&gt;</description>
    </item>
    <item>
      <title>On The Double Descent Phenomenon</title>
      <link>https://flecart.github.io/notes/on-the-double-descent-phenomenon/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/on-the-double-descent-phenomenon/</guid>
      <description>&lt;p&gt;Double descent is a striking phenomenon in modern machine learning that challenges the traditional bias‚Äìvariance tradeoff. In classical learning theory, increasing model complexity beyond a certain point is expected to increase test error because the model starts to overfit the training data. However, in many contemporary models‚Äîfrom simple linear predictors to deep neural networks‚Äîa second descent in test error emerges as the model becomes even more overparameterized.&lt;/p&gt;
&lt;p&gt;At its core, the double descent curve can be understood in three stages. In the first stage, as the model‚Äôs capacity increases, the error decreases because the model is better able to capture the underlying signal in the data. As the model approaches the interpolation threshold‚Äîwhere the number of parameters is roughly equal to the number of data points‚Äîthe model fits the training data exactly. This exact fitting, however, makes the model extremely sensitive to noise, leading to a spike in test error. Surprisingly, when the model complexity is increased further into the highly overparameterized regime, the training algorithm (often stochastic gradient descent) tends to select from the many possible interpolating solutions one that exhibits desirable properties such as lower norm or smoothness. This implicit bias toward simpler, more generalizable solutions causes the test error to decrease again, producing the second descent.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Optimal Minimax Facility Location</title>
      <link>https://flecart.github.io/notes/optimal-minimax-facility-location/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/optimal-minimax-facility-location/</guid>
      <description>&lt;p&gt;In this note we will briefly present one problem common in operation research.
The practical needs that formulated this problem are quite obvious: choosing the best location to build some important services for communities.&lt;/p&gt;
&lt;p&gt;The optimal minimax facility location refers to the placement of a facility (such as a warehouse, hospital, or service center) in such a way that the &lt;strong&gt;maximum distance or cost&lt;/strong&gt; between the facility and any of the demand points (such as customers, patients, or users) is minimized. This approach is particularly useful when the goal is to ensure that no demand point is too far from the facility, thus providing a form of equity in service delivery.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Optimization methods</title>
      <link>https://flecart.github.io/notes/optimization-methods/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/optimization-methods/</guid>
      <description>&lt;p&gt;Metodi altri sono trovare una &lt;strong&gt;approssimazione&lt;/strong&gt; facile da calcolare (simile all&amp;rsquo;approccio del modello surrogato credo).
Ma nel nostro caso proviamo a trovare metodi di esplorare lo &lt;strong&gt;spazio dei parametri&lt;/strong&gt; in modo intelligente.&lt;/p&gt;
&lt;h3 id=&#34;deterministic-methods&#34;&gt;Deterministic methods&lt;/h3&gt;
&lt;p&gt;Sono utilizzabili quando ci sono delle propriet√† come convessit√†, limitatezza, continuit√†.&lt;/p&gt;
&lt;h4 id=&#34;newton-raphson-method&#34;&gt;Newton Raphson method&lt;/h4&gt;
&lt;p&gt;Molte implementazioni in R usano questo metodo, √®&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Perfetto quando $h$ √® quadratico, e in statistica molti problemi sono quadratici e funziona in modo perfetto&lt;/li&gt;
&lt;li&gt;Ma in cose non lineari si ha meno performance (perch√© l&amp;rsquo;hessiana √® molto instabile per l&amp;rsquo;inversione, si dice che √® mal condizionata, e si fa con attenzione.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;l&amp;rsquo;unica cosa da sapere secondo me √®&lt;/p&gt;</description>
    </item>
    <item>
      <title>Planning automatico</title>
      <link>https://flecart.github.io/notes/planning-automatico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/planning-automatico/</guid>
      <description>&lt;h1 id=&#34;planning-automatico&#34;&gt;Planning Automatico&lt;/h1&gt;
&lt;p&gt;Vogliamo andare a creare un programma che sia in grado di creare un piano per fare una azione, andiamo in questo capitolo gli algoritmi storicamente migliori adatti a risolvere questo problema&lt;/p&gt;
&lt;h2 id=&#34;il-problema-di-pianificazione&#34;&gt;Il problema di pianificazione&lt;/h2&gt;
&lt;p&gt;Andiamo a rappresentare il nostro problema di pianificazione con un linguaggio molto simile alla &lt;a href=&#34;https://flecart.github.io/notes/logica-del-primo-ordine/&#34;&gt;Logica del Primo ordine&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;√à il PDDL ossia il &lt;strong&gt;Planning domain definition language&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;pddl&#34;&gt;PDDL&lt;/h3&gt;
&lt;p&gt;Questo linguaggio √® definito da&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Una serie di predicati in FOL iniziali&lt;/li&gt;
&lt;li&gt;Una serie di predicati in FOL di arrivo&lt;/li&gt;
&lt;li&gt;Una serie di azioni
&lt;ol&gt;
&lt;li&gt;Con una serie di precondizioni&lt;/li&gt;
&lt;li&gt;E una serie di effetti&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Il nostro obiettivo sar√† principalmente raggiungere un obiettivo finale, utilizzando le azioni per cambiare lo stato attuale&lt;/p&gt;</description>
    </item>
    <item>
      <title>Polimorfismo</title>
      <link>https://flecart.github.io/notes/polimorfismo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/polimorfismo/</guid>
      <description>&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;monoforfo-&#34;&gt;Monoforfo üü©&lt;/h3&gt;
&lt;p&gt;Quando non posso utilizzare un tipo come parametro. Ossia non possiamo definire una funzione generica.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide monomorfismo&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Polimorfismo/Untitled.png&#34; alt=&#34;image/universita/ex-notion/Polimorfismo/Untitled&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;polimorfismo&#34;&gt;Polimorfismo&lt;/h2&gt;
&lt;p&gt;Polimorfismo, come dice il nome, significa avere tante forme, in questo caso tanti tipi. Ma avere tanti tipi non √® una cosa ambigua? Questa cosa si risolve solitamente a compile time (facendo checks di sottotipo, oppure dispatch della funzione corretta).&lt;/p&gt;
&lt;h3 id=&#34;tipologie-di-polimorfismo-3-&#34;&gt;Tipologie di Polimorfismo (3) üü©&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide tipologie di monomorfismo&lt;/p&gt;</description>
    </item>
    <item>
      <title>Probabilita condizionata e indipendenza</title>
      <link>https://flecart.github.io/notes/probabilita-condizionata-e-indipendenza/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/probabilita-condizionata-e-indipendenza/</guid>
      <description>&lt;h2 id=&#34;condizionata&#34;&gt;Condizionata&lt;/h2&gt;
&lt;h3 id=&#34;definizione-&#34;&gt;Definizione üü©&lt;/h3&gt;
&lt;p&gt;Andiamo a definire una probabilit√† di un evento $A$, condizionata a un evento non nullo $B$, come&lt;/p&gt;
$$
P(A|B) = \dfrac{P(A\cap B)}{P(B)}
$$&lt;p&gt;Questo √® la cosa fondamentale per poter considerare cose come bayes perch√© in questo modo abbiamo una certa relazione fra causa ed effetto e anche il contrario! Cosa che ci piace molto molto molto.&lt;/p&gt;
&lt;h3 id=&#34;la-definizione-di-sopra-√®-un-probabilit√†-&#34;&gt;La definizione di sopra √® un probabilit√† üü©&lt;/h3&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/Probabilit√† condizionata e indipendenza/Untitled.png&#34; alt=&#34;Probabilit√† condizionata e indipendenza/Untitled&#34;&gt;
&lt;p&gt;&lt;strong&gt;Dimostrazione&lt;/strong&gt; mia&lt;/p&gt;</description>
    </item>
    <item>
      <title>Problemi di ricerca</title>
      <link>https://flecart.github.io/notes/problemi-di-ricerca/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/problemi-di-ricerca/</guid>
      <description>&lt;h1 id=&#34;2-problemi-di-ricerca&#34;&gt;2 Problemi di ricerca&lt;/h1&gt;
&lt;p&gt;In questa prima parte si tratta di ricerca semplice, ossia si utilizza un modello basato su obiettivi, di struttura atomica, in un ambiente che risulti singolo-agente, episodico, totalmente osservabile, deterministico, statico, discreto, conosciuto.&lt;/p&gt;
&lt;h2 id=&#34;21-il-problema&#34;&gt;2.1 Il problema&lt;/h2&gt;
&lt;p&gt;Vogliamo cercare di enunciare in un modo che possa essere formale, senza nessuna ambiguit√† il concetto di problema di ricerca.&lt;/p&gt;
&lt;h3 id=&#34;211-framework-di-soluzione&#34;&gt;2.1.1 Framework di soluzione&lt;/h3&gt;
&lt;p&gt;Individuiamo 4 fasi principali per un problema di ricerca, questo √® un framework molto generico.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Project Management</title>
      <link>https://flecart.github.io/notes/project-management/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/project-management/</guid>
      <description>&lt;h4 id=&#34;project-product-management-project-management&#34;&gt;Project, product management, project management&lt;/h4&gt;
&lt;p&gt;Bisogna capire queste definizioni.
Vedere &lt;a href=&#34;https://dynamik.vercel.app/ingegneria-del-software/lucidi/13-gestione-del-progetto.pdf?from=informatica,&#34;&gt;https://dynamik.vercel.app/ingegneria-del-software/lucidi/13-gestione-del-progetto.pdf?from=informatica,&lt;/a&gt; slide 5 per definizione&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Progetto: inizia e finisce in tempo preciso.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;√à importante comunque ricordare gli steps principali per il progetto ossia ideazione, creazione, mantenimento, rilascio, e poi morte, questo in genere √® per qualunque progetto.&lt;/p&gt;
&lt;h3 id=&#34;project-manager&#34;&gt;Project Manager&lt;/h3&gt;
&lt;h4 id=&#34;compiti-principali-costi-e-risorse&#34;&gt;Compiti principali (costi e risorse)&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Vedere se il progetto √® fattibile&lt;/li&gt;
&lt;li&gt;Allocare risorse&lt;/li&gt;
&lt;li&gt;Monitorare come sta andando. (preventivo e consuntivo).
&lt;img src=&#34;https://flecart.github.io/images/notes/Project Management-1701099646139.jpeg&#34; alt=&#34;Project Management-1701099646139&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;work-breakdown-structure&#34;&gt;Work Breakdown structure&lt;/h3&gt;
&lt;h4 id=&#34;descrizione-wbs&#34;&gt;Descrizione WBS&lt;/h4&gt;
&lt;p&gt;√à una suddivisione del progetto in piccoli sottoparti che si possono gestire in modo autonomo.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Proximal Polixy Optimization</title>
      <link>https://flecart.github.io/notes/proximal-polixy-optimization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/proximal-polixy-optimization/</guid>
      <description>&lt;p&gt;This documents attempts to briefly present the algorithm and some experiments found online about it.
The following repo seems to be a good resource: &lt;a href=&#34;https://github.com/ericyangyu/PPO-for-Beginners&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Usually, PPO is explained as an &lt;strong&gt;actor critic framework&lt;/strong&gt;. This means there is an &lt;em&gt;agent&lt;/em&gt; that acts on the environment, and then there is a &lt;em&gt;critic&lt;/em&gt; that collects the feedback from the environment.
The main idea about this framework is to &lt;em&gt;select&lt;/em&gt; a policy that is similar, so that it is &lt;em&gt;less probable&lt;/em&gt; that a bad policy, a very different policy from the original is selected. This is achieved by clipping over the advantage. And then&lt;/p&gt;</description>
    </item>
    <item>
      <title>Rappresentazione della conoscenza</title>
      <link>https://flecart.github.io/notes/rappresentazione-della-conoscenza/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/rappresentazione-della-conoscenza/</guid>
      <description>&lt;p&gt;Questo √® stato un capitolo molto vasto, che andava in certi punti a toccare la filosofia, la fisica. Un aspetto, quello di &lt;strong&gt;codifica&lt;/strong&gt; delle informazioni reali in un ambiente logico (che per quanto i miei pregiudizi siano, ritengo una cosa molto impossibile, molto limitata e altrettanto impossibile). Si tratta dello &lt;strong&gt;studio della logica per rappresentazione di conoscenza&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Fatto sta che mi sembra assurdamente teorico tanto da non aver nessun utilizzo (probabilmente mi sbaglio di grosso), e che sia roba da filosofi.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Scelta del PO</title>
      <link>https://flecart.github.io/notes/scelta-del-po/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/scelta-del-po/</guid>
      <description>&lt;p&gt;La cosa che rende il PO diverso rispetto agli sviluppatori √® la &lt;strong&gt;conoscenza&lt;/strong&gt; delle necessit√† del cliente. Questo permette di prioritizzare del task e capire in che modo dovrebbe essere il prodotto finale. In questo modo si crea una &lt;strong&gt;vision&lt;/strong&gt; del prodotto.
Pensiamo che il PO debba condividere questa informazione e prendere decisioni di gruppo.&lt;/p&gt;
&lt;h4 id=&#34;domande-da-fare&#34;&gt;Domande da fare:&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;La user interface, come sembra il wireframe?&lt;/li&gt;
&lt;li&gt;Pensavamo di utilizzare i social solamente per i login, pensavate di utilizzare anche per altro durante il gioco?
&lt;ol&gt;
&lt;li&gt;Bassa priorit√† (poter condividere i risultati con un post).&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Vorreste poter selezionare il livello del bot? Quanto sarebbe il massimo livello e quale il minimo?
4. Per kriegspiel la forza √® massima.&lt;/li&gt;
&lt;li&gt;Cosa √® la modalit√† &amp;lsquo;mob&amp;rsquo; per giocare (2 descrizione del problema documento progetto).
&lt;ol&gt;
&lt;li&gt;si intende il social che permette di condividere mosse.&lt;/li&gt;
&lt;li&gt;tutte le persone interessante possono rispondere con tempo un giorno, e la maggioranza determina la risposta.&lt;/li&gt;
&lt;li&gt;Bassa priorit√†.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Esistono i soci (utenti registrati) e non, cosa pu√≤ fare un utente non registrato? E quelli registrati? O definiamo noi?&lt;/li&gt;
&lt;li&gt;Che genere di commenti deve fare l&amp;rsquo;AI durante la partita?
&lt;ol&gt;
&lt;li&gt;Va bene qualunque commento (anche in giro), commenti interessanti sul contesto).&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;In che modo salvare una partita? Solamente la sequenza delle mosse o possibilit√† di riprendere la partita?
&lt;ol&gt;
&lt;li&gt;Non √® richiesto poter salvare e riprendere nei giochi a informazione incompleta&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;La seconda cosa interessante per l&amp;rsquo;utente?
&lt;ol&gt;
&lt;li&gt;Leaderboard (non per noi, ELO).&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Cosa deve avere la leaderboard per giochi diversi da bad chess?
&lt;ol&gt;
&lt;li&gt;Legato all&amp;rsquo;ELO questa, il classico.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;O mobile o web o come ci pare (non √® importante).
No sicurezza, non √® importante.
50 giocatori max.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Semafori</title>
      <link>https://flecart.github.io/notes/semafori/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/semafori/</guid>
      <description>&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;concetto-principale--&#34;&gt;Concetto principale üü©-&lt;/h3&gt;
&lt;p&gt;√à sempre stato introdotto da Dijkstra, 1965 (Cooperating Sequential Processes) utilizzato come strumento di cooperazione semplice&lt;/p&gt;
&lt;p&gt;Questo √® un sistema fortemente ispirato dai semafori che regolano gli incroci stradali.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;due o pi√π processi possono cooperare attraverso semplici
segnali, in modo tale che un processo possa essere bloccato
in specifici punti del suo programma finch√© non riceve un
segnale da un altro processo&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;primitive-dei-semafori--&#34;&gt;Primitive dei semafori üü©-&lt;/h3&gt;
&lt;p&gt;Il semaforo solitamente √® una &lt;strong&gt;variabile intera non negativa&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Semantica di un linguaggio</title>
      <link>https://flecart.github.io/notes/semantica-di-un-linguaggio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/semantica-di-un-linguaggio/</guid>
      <description>&lt;h2 id=&#34;vincoli-sintattici-contestuali&#34;&gt;Vincoli sintattici contestuali&lt;/h2&gt;
&lt;h3 id=&#34;intro-dipendenze-da-contesto-&#34;&gt;Intro: dipendenze da contesto üü©&lt;/h3&gt;
&lt;p&gt;I vincoli sintattici non sono esprimibili tramite BNF perch√© dipendono dal contesto, mentre le grammatiche libere sono per definizione libere da contesto, vogliamo quindi trovare una soluzione a questo problema. Vengono usati metodi Ad-Hoc nella fase di &lt;strong&gt;analisi semantica&lt;/strong&gt; del programma.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Grammatiche dipendenti dal contesto&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Queste grammatiche sono molto pi√π complicate (e lente) rispetto a quelle libere da contesto, quindi √® poco pratico e non utilizzabile (tempo esponenziale, quindi non finisce mai).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Semplificazione grammatiche</title>
      <link>https://flecart.github.io/notes/semplificazione-grammatiche/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/semplificazione-grammatiche/</guid>
      <description>&lt;h2 id=&#34;gestione-del-non-determinismo&#34;&gt;Gestione del non determinismo&lt;/h2&gt;
&lt;p&gt;Il modo pi√π facile per gestire il non determinsmo √® &lt;strong&gt;semplificare le grammatiche&lt;/strong&gt; quindi andiamo a vedere metodi per fare ci√≤.&lt;/p&gt;
&lt;h3 id=&#34;semplificazione-grammatiche-5&#34;&gt;Semplificazione grammatiche (5)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Semplificazione grammatiche/Untitled 1.png&#34; alt=&#34;image/universita/ex-notion/Semplificazione grammatiche/Untitled 1&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;No produzioni del tipo $A \to \varepsilon$ per bottom up (altrimenti va all‚Äôinfinito!)&lt;/li&gt;
&lt;li&gt;No produzioni unitarie, cos√¨ evito cicli in cui da A derivo s√© stesso.&lt;/li&gt;
&lt;li&gt;No simboli inutili&lt;/li&gt;
&lt;li&gt;No ricorsione sinistra (divergenza per top-down)&lt;/li&gt;
&lt;li&gt;Fattorizzazione della grammatica&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;eliminazione-delel-produzioni-nulle&#34;&gt;Eliminazione delel produzioni nulle&lt;/h2&gt;
&lt;p&gt;Vogliamo creare un algoritmo utile ad eliminare le produzioni che non ci piacciono.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Sezioni Critiche</title>
      <link>https://flecart.github.io/notes/sezioni-critiche/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/sezioni-critiche/</guid>
      <description>&lt;p&gt;Ripasso Prox: 80
Ripasso: May 21, 2023
Ultima modifica: March 12, 2023 10:00 AM
Primo Abbozzo: October 8, 2022 11:30 AM
Stato: üåïüåïüåïüåïüåë
Studi Personali: No&lt;/p&gt;
&lt;h1 id=&#34;elementi-di-ripasso&#34;&gt;Elementi di ripasso&lt;/h1&gt;
&lt;h1 id=&#34;2-sezioni-critiche&#34;&gt;2 Sezioni Critiche&lt;/h1&gt;
&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;La parte di un programma che utilizza una o pi√π risorse
condivise viene detta sezione critica (critical section, o CS)&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Andiamo in questa altra parte a valutare certe soluzioni:&lt;/p&gt;
&lt;h3 id=&#34;programma-desempio-&#34;&gt;Programma d‚Äôesempio üü©&lt;/h3&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Sezioni Critiche/Untitled.png&#34; alt=&#34;image/universita/ex-notion/Sezioni Critiche/Untitled&#34;&gt;
&lt;p&gt;Vorremmo garantire che &lt;strong&gt;a = b invariante.&lt;/strong&gt; (espressione logica verificata nell&amp;rsquo;esecuzione di questo programma). quindi una coerenza di uno prima dell&amp;rsquo;altro vogliamo.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Teorema di Lagrange</title>
      <link>https://flecart.github.io/notes/teorema-di-lagrange/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/teorema-di-lagrange/</guid>
      <description>&lt;h2 id=&#34;classi-laterali&#34;&gt;Classi laterali&lt;/h2&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Teorema di Lagrange/Untitled.png&#34; alt=&#34;image/universita/ex-notion/Teorema di Lagrange/Untitled&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Dimostrazione dei lemmi sopra.
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Teorema di Lagrange/Untitled 1.png&#34; alt=&#34;image/universita/ex-notion/Teorema di Lagrange/Untitled 1&#34;&gt;&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Teorema di Lagrange/Untitled 2.png&#34; alt=&#34;image/universita/ex-notion/Teorema di Lagrange/Untitled 2&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;La cosa interessante di questa parte √® possiamo usare una classe laterale per partizionare il gruppo iniziale!&lt;/p&gt;
&lt;h2 id=&#34;il-teorema-di-lagrange&#34;&gt;Il teorema di Lagrange&lt;/h2&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Teorema di Lagrange/Untitled 3.png&#34; alt=&#34;image/universita/ex-notion/Teorema di Lagrange/Untitled 3&#34;&gt;
Dividere significa che **partiziona** l&#39;insieme iniziale in alcuni insiemi distinti.
L&#39;insieme $G:H$ √® l&#39;insieme che contiene tutti i cosets, credo.
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Dimostrazione&lt;/p&gt;</description>
    </item>
    <item>
      <title>Teoria dei Tipi</title>
      <link>https://flecart.github.io/notes/teoria-dei-tipi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/teoria-dei-tipi/</guid>
      <description>&lt;p&gt;Ripasso Prox: 30
Ripasso: June 6, 2023
Ultima modifica: May 14, 2023 6:13 PM
Primo Abbozzo: March 13, 2023 9:20 AM
Studi Personali: No&lt;/p&gt;
&lt;h1 id=&#34;elementi-di-ripasso&#34;&gt;Elementi di ripasso&lt;/h1&gt;
&lt;h1 id=&#34;teoria-dei-tipi&#34;&gt;Teoria dei Tipi&lt;/h1&gt;
&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;definizione-&#34;&gt;Definizione üü©‚Äî&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Un metodo sintattico &lt;strong&gt;praticabile&lt;/strong&gt; per dimostrare
l&amp;rsquo;assenza di determinati comportamenti del
programma, fatto classificando le unit√† sintattiche in
base ai tipi di valore che assumono&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Vogliamo che fosse praticabile nel senso che effettivamente lo possiamo implementare, cio√® ci permettono di avere certe tipologie di garanzia. ma ancora √® una definizione molto ampia. E di solito si pu√≤ fare una analisi statica del comportamento del programma.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Top-down Parser</title>
      <link>https://flecart.github.io/notes/top-down-parser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/top-down-parser/</guid>
      <description>&lt;h2 id=&#34;top-down&#34;&gt;Top-down&lt;/h2&gt;
&lt;h3 id=&#34;algoritmo-di-parsing-&#34;&gt;Algoritmo di parsing üü©&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 1.png&#34; alt=&#34;image/universita/ex-notion/Top-down Parser/Untitled 1&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Questo si potrebbe considerare come algoritmo classico di parsing con non determinismo. (vado avanti, ed esploro tutto, senza look ahead).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Esempio di esecuzione&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 2.png&#34; alt=&#34;image/universita/ex-notion/Top-down Parser/Untitled 2&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;commenti-efficienza-di-sopra-&#34;&gt;Commenti efficienza di sopra üü©&lt;/h3&gt;
&lt;p&gt;√à molto inefficiente, in particolare si potrebbe trovare una compessit√† esponenziale del tipo&lt;/p&gt;
&lt;p&gt;$O(b^{|w|})$, con b il massimo numero di produzioni. (la produzione maggiore la espando sempre!)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide&lt;/p&gt;</description>
    </item>
    <item>
      <title>Training a NN</title>
      <link>https://flecart.github.io/notes/training-a-nn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/training-a-nn/</guid>
      <description>&lt;p&gt;Ultima modifica: March 11, 2023 7:22 PM
Primo Abbozzo: March 8, 2023 6:05 PM
Studi Personali: No&lt;/p&gt;
&lt;h1 id=&#34;elementi-di-ripasso&#34;&gt;Elementi di ripasso&lt;/h1&gt;
&lt;h1 id=&#34;training-of-nn&#34;&gt;Training of NN&lt;/h1&gt;
&lt;p&gt;How can we be sure that we can train well our function?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Dataset quality (this cannot be changed in training time)&lt;/li&gt;
&lt;li&gt;Models and parameters of our model, we can describe it as $L(x, \theta)$, and we try to minimize this function.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;training-approaches&#34;&gt;Training approaches&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Random perturn weights&lt;/strong&gt;, this is ispired by evolution, but it‚Äôs slow and not effective (and we can make things worse in many ways)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Predict adjustments&lt;/strong&gt;, usually we can analitically define what is the best way to minimize the loss, so we would like to follow that slope and go down!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;When we try to learn with the second method we usually follow the direction of a derivative (this is also an idea of gradient descent that we discussed in &lt;a href=&#34;https://flecart.github.io/notes/metodi-di-discesa/&#34;&gt;Metodi di Discesa&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Valutazione Espressioni</title>
      <link>https://flecart.github.io/notes/valutazione-espressioni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/valutazione-espressioni/</guid>
      <description>&lt;h1 id=&#34;espressioni-comandi-ricorsione&#34;&gt;Espressioni, Comandi, Ricorsione&lt;/h1&gt;
&lt;h2 id=&#34;espressioni&#34;&gt;Espressioni&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Con espressione intendiamo una entit√† sintattica, che una volta valutata &lt;strong&gt;ritorner√† un valore&lt;/strong&gt;, oppure non termina, in questo caso si dice che la espressione √® INDEFINITA.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Questa √® una definizione √® leggermente ambigua dato che non abbiamo una definizione precisa di valutazoine, che √® fortemente dipendente dalla macchina astratta in cui viene eseguito.&lt;/p&gt;
&lt;h3 id=&#34;notazioni-sintassi-possibili-3-&#34;&gt;Notazioni (sintassi possibili) (3) üü©&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Notazione infissa&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Questa √® la notazione classica matematica, per cose tipo $a -b$, in cui l&amp;rsquo;operando sta nel mezzo degli operatori.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Variabili aleatorie</title>
      <link>https://flecart.github.io/notes/variabili-aleatorie/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/variabili-aleatorie/</guid>
      <description>&lt;p&gt;Le variabili aleatorie ci permettono di dire qualcosa sullo spazio di probabilit√† senza andare troppo nei dettagli a considerare singoli eventi e cose simili.&lt;/p&gt;
&lt;h2 id=&#34;variabili-aleatorie-discrete&#34;&gt;Variabili aleatorie discrete&lt;/h2&gt;
&lt;p&gt;Con le variabili aleatorie cominciamo ad entrare nel noccio della questione, finalmente possiamo in un certo senso legare l‚Äôoutcome di un evento, alla probabilit√† dell‚Äôevento.&lt;/p&gt;
&lt;h3 id=&#34;definizione-variabili-aleatorie-&#34;&gt;Definizione Variabili aleatorie üü©&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Si definisce variabile aleatoria $X$ una funzione da $\Omega \to E$, con $\Omega$ il nostro spazio campionario, e $E$ qualunque insieme (quando $E = \mathbb{R}$ si parla di &lt;strong&gt;variabile aleatoria reale&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
