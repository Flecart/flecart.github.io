<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>No-Tags on X. Angelo Huang&#39;s Blog</title>
    <link>https://flecart.github.io/tags/no-tags/</link>
    <description>Recent content in No-Tags on X. Angelo Huang&#39;s Blog</description>
    <image>
      <title>X. Angelo Huang&#39;s Blog</title>
      <url>https://flecart.github.io/images/papermod-cover.png</url>
      <link>https://flecart.github.io/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.143.1</generator>
    <language>en</language>
    <atom:link href="https://flecart.github.io/tags/no-tags/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CMMRS 2025</title>
      <link>https://flecart.github.io/notes/cmmrs-2025/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cmmrs-2025/</guid>
      <description>&lt;p&gt;A motorcycle talk founded the CMMRS.
I am wondering if small applications like these are enough in having actual impact. It does have some impacts on the people there mmm.
The seed was eaten, as his metaphor, industry is eating out most of the talent. And academia is still important as a propulsion engine.&lt;/p&gt;
&lt;p&gt;I don&amp;rsquo;t think it is something general, you need something specific for sure.
They say its not recruiting informercial and repeat it a lot. But it seems very strange. They say its more christian like opportunity to&lt;/p&gt;</description>
    </item>
    <item>
      <title>Astrazione sul controllo</title>
      <link>https://flecart.github.io/notes/astrazione-sul-controllo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/astrazione-sul-controllo/</guid>
      <description>&lt;h2 id=&#34;significato-di-astrazione&#34;&gt;Significato di astrazione&lt;/h2&gt;
&lt;p&gt;L&amp;rsquo;astrazione è una cosa fondamentale nell&amp;rsquo;informatica, l’abbiamo visto anche nella prima lezione in assoluto per architettura, il sistema a strati di &lt;a href=&#34;https://flecart.github.io/notes/architettura-e-livelli-1,-2&#34;&gt;Architettura e livelli 1, 2&lt;/a&gt; reti e simili.&lt;/p&gt;
&lt;p&gt;Il principali metodi sono &lt;strong&gt;astrazioni sul controllo e sui dati&lt;/strong&gt; sui dati stiamo cominciando a parlarne in &lt;a href=&#34;https://flecart.github.io/notes/teoria-dei-tipi&#34;&gt;Teoria dei Tipi&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Le astrazioni sono utili a &lt;strong&gt;nascondere dettagli&lt;/strong&gt; per qualche fenomeno o simile (ricorda l&amp;rsquo;esempio della mappa, che non è il territorio è una astrazione su essa, che contiene ancora informazioni utili). Vogliamo quindi &lt;strong&gt;concentrarci su quanto ci interessa&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Automi e Regexp</title>
      <link>https://flecart.github.io/notes/automi-e-regexp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/automi-e-regexp/</guid>
      <description>&lt;p&gt;Per l’analisi lessicale vogliamo cercare di ricordare le &lt;strong&gt;parole legali&lt;/strong&gt; all&amp;rsquo;interno di questo linguaggio e questo è fatto con i linguaggi regolari.&lt;/p&gt;
&lt;h2 id=&#34;introduzione-a-analizzatori-lessicali&#34;&gt;Introduzione a analizzatori lessicali&lt;/h2&gt;
&lt;h3 id=&#34;token&#34;&gt;Token&lt;/h3&gt;
&lt;p&gt;Struttura del token è fatto da due parti&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Identificatore della classe del token&lt;/li&gt;
&lt;li&gt;Identificatore del valore del token&lt;/li&gt;
&lt;li&gt;Pattern e lessema ci sono direi boh&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;pattern-e-lessema&#34;&gt;Pattern e Lessema&lt;/h3&gt;
&lt;p&gt;I pattern sono una descrizione generale della forma dei valori di una classe di token.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Algebra lineare numerica</title>
      <link>https://flecart.github.io/notes/algebra-lineare-numerica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algebra-lineare-numerica/</guid>
      <description>&lt;p&gt;In questa sezione andiamo ad indagare metodi di &lt;strong&gt;scomposizione&lt;/strong&gt;, iterativi e non. Ci sono molte matrici importanti per questa parte che dovremmo prendere confidenza.&lt;/p&gt;
&lt;h4 id=&#34;immagini&#34;&gt;Immagini&lt;/h4&gt;
&lt;p&gt;Lab 2 images&lt;/p&gt;
&lt;h2 id=&#34;metodo-di-gauss&#34;&gt;Metodo di gauss&lt;/h2&gt;
&lt;p&gt;Vogliamo cercare un metodo per calcolare soluzioni a sistemi di equazione del genere:&lt;/p&gt;
&lt;p&gt;$Ax = b$, classico. Supponiamo che questo sistema abbia una soluzione.&lt;/p&gt;
&lt;p&gt;Il nostro obiettivo sarebbe scomporre la matrice $A = LU$
come prodotto di due matrici Lower triangular e Upper triangular.&lt;/p&gt;</description>
    </item>
    <item>
      <title>On The Double Descent Phenomenon</title>
      <link>https://flecart.github.io/notes/on-the-double-descent-phenomenon/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/on-the-double-descent-phenomenon/</guid>
      <description>&lt;p&gt;Double descent is a striking phenomenon in modern machine learning that challenges the traditional bias–variance tradeoff. In classical learning theory, increasing model complexity beyond a certain point is expected to increase test error because the model starts to overfit the training data. However, in many contemporary models—from simple linear predictors to deep neural networks—a second descent in test error emerges as the model becomes even more overparameterized.&lt;/p&gt;
&lt;p&gt;At its core, the double descent curve can be understood in three stages. In the first stage, as the model’s capacity increases, the error decreases because the model is better able to capture the underlying signal in the data. As the model approaches the interpolation threshold—where the number of parameters is roughly equal to the number of data points—the model fits the training data exactly. This exact fitting, however, makes the model extremely sensitive to noise, leading to a spike in test error. Surprisingly, when the model complexity is increased further into the highly overparameterized regime, the training algorithm (often stochastic gradient descent) tends to select from the many possible interpolating solutions one that exhibits desirable properties such as lower norm or smoothness. This implicit bias toward simpler, more generalizable solutions causes the test error to decrease again, producing the second descent.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Potenziale Elettrostatico</title>
      <link>https://flecart.github.io/notes/potenziale-elettrostatico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/potenziale-elettrostatico/</guid>
      <description>&lt;h3 id=&#34;introduzione-al-potenziale-elettrostatico&#34;&gt;Introduzione al potenziale elettrostatico&lt;/h3&gt;
&lt;p&gt;Abbiamo studiato in dinamica che il potenziale è un concetto strettamente legato al Lavoro, ossia dalla quantità di energia necessaria per spostare un oggetto da un punto all&amp;rsquo;altro, vogliamo cercare di definire le relazioni che intercorrono nel caso della forza elettromagnetica&lt;/p&gt;
&lt;h4 id=&#34;rotore-nullo--forza-conservativa&#34;&gt;Rotore nullo =&amp;gt; forza conservativa&lt;/h4&gt;
$$
\vec{\nabla}  \times \vec{F} \implies \vec{F} \text{ è una forza conservativa}
$$$$
\oint_{L} \vec{F} \cdot d\vec{l} = \iint_{S} \vec{\nabla} \times \vec{F} \,d\vec{s}
$$&lt;p&gt;
E se abbiamo che il rotore è nullo, allora la forza è conservativa perché per definizione è conservativa se non dipende dal percorso, e la cosa che un circuito chiuso è sufficiente per dimostrare il sopra.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Banach Spaces</title>
      <link>https://flecart.github.io/notes/banach-spaces/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/banach-spaces/</guid>
      <description>&lt;h3 id=&#34;what-are-banach-spaces&#34;&gt;What are Banach Spaces?&lt;/h3&gt;
&lt;p&gt;A &lt;strong&gt;Banach space&lt;/strong&gt; is a complete normed vector space, meaning that every Cauchy sequence in the space converges to a limit within the space.
See &lt;a href=&#34;https://flecart.github.io/notes/spazi-vettoriali&#34;&gt;Spazi vettoriali&lt;/a&gt; for the formal definition.&lt;/p&gt;
&lt;h3 id=&#34;examples-of-banach-spaces&#34;&gt;Examples of Banach Spaces&lt;/h3&gt;
&lt;p&gt;In this section, we list some examples of the most common Banach Spaces&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;$\ell^p$ Spaces (Sequence Spaces)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Defined as:
$$
     \ell^p = \left\{ (x_n)_{n\in \mathbb{N}} \mid \sum_{n=1}^{\infty} |x_n|^p &lt; \infty \right\}, \quad 1 \leq p &lt; \infty
     $$&lt;/li&gt;
&lt;li&gt;The norm is given by:
$$
     \|x\|_p = \left( \sum_{n=1}^{\infty} |x_n|^p \right)^{1/p}
     $$&lt;/li&gt;
&lt;li&gt;When $p = \infty$, we define:
$$
     \ell^\infty = \left\{ (x_n)_{n\in \mathbb{N}} \mid \sup_n |x_n| &lt; \infty \right\}
     $$
with the norm $\|x\|_{\infty} = \sup_n |x_n|$.&lt;/li&gt;
&lt;li&gt;These spaces are Banach under their respective norms.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;$L^p$ Spaces (Function Spaces)&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Fatou&#39;s Lemma</title>
      <link>https://flecart.github.io/notes/fatous-lemma/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/fatous-lemma/</guid>
      <description>&lt;p&gt;Fatou&amp;rsquo;s lemma is a fundamental result in measure theory that deals with the relationship between limits and integrals of sequences of non-negative measurable functions.
See the &lt;a href=&#34;https://en.wikipedia.org/wiki/Fatou%27s_lemma&#34;&gt;wikipedia&lt;/a&gt; page for further info.&lt;/p&gt;
&lt;h3 id=&#34;statement-of-fatous-lemma&#34;&gt;Statement of Fatou&amp;rsquo;s Lemma&lt;/h3&gt;
&lt;p&gt;Let $(f_n)$ be a sequence of non-negative measurable functions on a measure space $(X,\mu)$. Then:&lt;/p&gt;
$$\int \liminf_{n \to \infty} f_n \,d\mu \leq \liminf_{n \to \infty} \int f_n \,d\mu$$&lt;p&gt;In words, this means that the integral of the limit inferior of a sequence of functions is less than or equal to the limit inferior of their integrals.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Optimal Minimax Facility Location</title>
      <link>https://flecart.github.io/notes/optimal-minimax-facility-location/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/optimal-minimax-facility-location/</guid>
      <description>&lt;p&gt;In this note we will briefly present one problem common in operation research.
The practical needs that formulated this problem are quite obvious: choosing the best location to build some important services for communities.&lt;/p&gt;
&lt;p&gt;The optimal minimax facility location refers to the placement of a facility (such as a warehouse, hospital, or service center) in such a way that the &lt;strong&gt;maximum distance or cost&lt;/strong&gt; between the facility and any of the demand points (such as customers, patients, or users) is minimized. This approach is particularly useful when the goal is to ensure that no demand point is too far from the facility, thus providing a form of equity in service delivery.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Semafori</title>
      <link>https://flecart.github.io/notes/semafori/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/semafori/</guid>
      <description>&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;concetto-principale&#34;&gt;Concetto principale&lt;/h3&gt;
&lt;p&gt;È sempre stato introdotto da Dijkstra, 1965 (Cooperating Sequential Processes) utilizzato come strumento di cooperazione semplice&lt;/p&gt;
&lt;p&gt;Questo è un sistema fortemente ispirato dai semafori che regolano gli incroci stradali.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;due o più processi possono cooperare attraverso semplici
segnali, in modo tale che un processo possa essere bloccato
in specifici punti del suo programma finché non riceve un
segnale da un altro processo&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;primitive-dei-semafori&#34;&gt;Primitive dei semafori&lt;/h3&gt;
&lt;p&gt;Il semaforo solitamente è una &lt;strong&gt;variabile intera non negativa&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Optimization methods</title>
      <link>https://flecart.github.io/notes/optimization-methods/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/optimization-methods/</guid>
      <description>&lt;p&gt;Metodi altri sono trovare una &lt;strong&gt;approssimazione&lt;/strong&gt; facile da calcolare (simile all&amp;rsquo;approccio del modello surrogato credo).
Ma nel nostro caso proviamo a trovare metodi di esplorare lo &lt;strong&gt;spazio dei parametri&lt;/strong&gt; in modo intelligente.&lt;/p&gt;
&lt;h3 id=&#34;deterministic-methods&#34;&gt;Deterministic methods&lt;/h3&gt;
&lt;p&gt;Sono utilizzabili quando ci sono delle proprietà come convessità, limitatezza, continuità.&lt;/p&gt;
&lt;h4 id=&#34;newton-raphson-method&#34;&gt;Newton Raphson method&lt;/h4&gt;
&lt;p&gt;Molte implementazioni in R usano questo metodo, è&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Perfetto quando $h$ è quadratico, e in statistica molti problemi sono quadratici e funziona in modo perfetto&lt;/li&gt;
&lt;li&gt;Ma in cose non lineari si ha meno performance (perché l&amp;rsquo;hessiana è molto instabile per l&amp;rsquo;inversione, si dice che è mal condizionata, e si fa con attenzione.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;l&amp;rsquo;unica cosa da sapere secondo me è&lt;/p&gt;</description>
    </item>
    <item>
      <title>Grammatiche Regolari</title>
      <link>https://flecart.github.io/notes/grammatiche-regolari/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/grammatiche-regolari/</guid>
      <description>&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;definizione-grammatica-regolare&#34;&gt;Definizione grammatica regolare&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Definizione&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Grammatiche Regolari/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Grammatiche Regolari/Untitled 1&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In pratica posso avere solamente come terminali a, oppure un suffisso a su un non terminale.&lt;/p&gt;
&lt;p&gt;Queste grammatiche sono interessanti perché è molto facile costruire un automa che sia in grado di riconoscere questo linguaggio.&lt;/p&gt;
&lt;p&gt;Seguendo una definizione più &lt;em&gt;lasca&lt;/em&gt; possono anche accettare dei nonterminali &lt;strong&gt;epsilon&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;espressione-regolare-a-nfa&#34;&gt;Espressione regolare a NFA&lt;/h3&gt;
&lt;p&gt;Questa sezione è anche presente in &lt;a href=&#34;https://flecart.github.io/notes/automi-e-regexp&#34;&gt;Automi e Regexp&lt;/a&gt;, però è riportata qui così c’è l’insieme di tutte le cose in un unico posto.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Descrizione linguaggio</title>
      <link>https://flecart.github.io/notes/descrizione-linguaggio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/descrizione-linguaggio/</guid>
      <description>&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;p&gt;Per questa parte c’è un sacco di roba in comune con [Tecniche di definizione di semantica (4)&lt;/p&gt;
&lt;p&gt;Trattiamo alcune caratteristiche che descrivono ad alto livello un linguaggio di programmazione. È da notare che questa parte della spiegazione del linguaggio non è limitante al solo linguaggio di programmazione, è utile per analizzare tutti i linguaggi (tranne la parte di implementazione)&lt;/p&gt;
&lt;h3 id=&#34;sintassi&#34;&gt;Sintassi&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Relazione fra segni&lt;/em&gt;. si occupa di decidere quando una frase è corretta.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Variabili aleatorie</title>
      <link>https://flecart.github.io/notes/variabili-aleatorie/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/variabili-aleatorie/</guid>
      <description>&lt;p&gt;Le variabili aleatorie ci permettono di dire qualcosa sullo spazio di probabilità senza andare troppo nei dettagli a considerare singoli eventi e cose simili.&lt;/p&gt;
&lt;h2 id=&#34;variabili-aleatorie-discrete&#34;&gt;Variabili aleatorie discrete&lt;/h2&gt;
&lt;p&gt;Con le variabili aleatorie cominciamo ad entrare nel noccio della questione, finalmente possiamo in un certo senso legare l’outcome di un evento, alla probabilità dell’evento.&lt;/p&gt;
&lt;h3 id=&#34;definizione-variabili-aleatorie&#34;&gt;Definizione Variabili aleatorie&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Si definisce variabile aleatoria $X$ una funzione da $\Omega \to E$, con $\Omega$ il nostro spazio campionario, e $E$ qualunque insieme (quando $E = \mathbb{R}$ si parla di &lt;strong&gt;variabile aleatoria reale&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Expressiveness of NN</title>
      <link>https://flecart.github.io/notes/expressiveness-of-nn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/expressiveness-of-nn/</guid>
      <description>&lt;h2 id=&#34;the-perceptron&#34;&gt;The perceptron&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide summary of working of perceptron&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Expressiveness of NN/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Expressiveness of NN/Untitled&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Note on the bias&lt;/strong&gt;: it is only useful to move the treshhold where to consider the output to be 1 and where to be 1.&lt;/p&gt;
&lt;p&gt;Now we ask what can be predicted by a perceptron?&lt;/p&gt;
&lt;p&gt;We can see the update rule of the perceptron:&lt;/p&gt;
$$
\begin{cases}
w = w + \alpha x  \\
b = b + \alpha
\end{cases}
$$$$
\alpha = \begin{cases}
0  &amp;  \Theta(x \theta + b) = y \\
-1  &amp;  \Theta(x \theta + b) &gt; y \\
1  &amp;  \Theta(x \theta + b) &lt; y 
\end{cases}
$$&lt;h4 id=&#34;linearly-separability-necessity&#34;&gt;Linearly separability necessity&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Hyperplanes&lt;/strong&gt;, because that equation is an hyperplane, so we are sure that we can predict an hyperplane, and that it, and it’s only it. (it’s predicting wheter it can be above or below that line).
So the perceptron is correct &lt;strong&gt;only if the data is linearly separable&lt;/strong&gt;!&lt;/p&gt;</description>
    </item>
    <item>
      <title>Gruppi Normali</title>
      <link>https://flecart.github.io/notes/gruppi-normali/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gruppi-normali/</guid>
      <description>&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;definizione-normalità&#34;&gt;Definizione normalità&lt;/h3&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Gruppi Normali/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Gruppi Normali/Untitled&#34;&gt;
&lt;h3 id=&#34;test-del-sottogruppo-normale&#34;&gt;Test del sottogruppo normale&lt;/h3&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Gruppi Normali/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Gruppi Normali/Untitled 1&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Dimostrazione&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Gruppi Normali/Untitled 2.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Gruppi Normali/Untitled 2&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;il-gruppo-quoziente&#34;&gt;Il gruppo quoziente&lt;/h3&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Gruppi Normali/Untitled 3.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Gruppi Normali/Untitled 3&#34;&gt;
&lt;p&gt;L’importanza del gruppo normale è che quando esso vale, possiamo avere il gurppo fattore&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Dimostrazione&lt;/p&gt;
&lt;p&gt;!&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Gruppi Normali/Untitled 4.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Gruppi Normali/Untitled 4&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Teorema di Lagrange</title>
      <link>https://flecart.github.io/notes/teorema-di-lagrange/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/teorema-di-lagrange/</guid>
      <description>&lt;h2 id=&#34;classi-laterali&#34;&gt;Classi laterali&lt;/h2&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Teorema di Lagrange/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Teorema di Lagrange/Untitled&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Dimostrazione dei lemmi sopra.
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Teorema di Lagrange/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Teorema di Lagrange/Untitled 1&#34;&gt;&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Teorema di Lagrange/Untitled 2.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Teorema di Lagrange/Untitled 2&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;La cosa interessante di questa parte è possiamo usare una classe laterale per partizionare il gruppo iniziale!&lt;/p&gt;
&lt;h2 id=&#34;il-teorema-di-lagrange&#34;&gt;Il teorema di Lagrange&lt;/h2&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Teorema di Lagrange/Untitled 3.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Teorema di Lagrange/Untitled 3&#34;&gt;
Dividere significa che **partiziona** l&#39;insieme iniziale in alcuni insiemi distinti.
L&#39;insieme $G:H$ è l&#39;insieme che contiene tutti i cosets, credo.
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Dimostrazione&lt;/p&gt;</description>
    </item>
    <item>
      <title>Metodi di Discesa</title>
      <link>https://flecart.github.io/notes/metodi-di-discesa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/metodi-di-discesa/</guid>
      <description>&lt;h2 id=&#34;introduzione-ai-metodi-di-discesa&#34;&gt;Introduzione ai metodi di discesa.&lt;/h2&gt;
&lt;h3 id=&#34;generali-sui-metodi-di-discesa&#34;&gt;Generali sui metodi di discesa&lt;/h3&gt;
&lt;p&gt;Vogliamo creare algoritmi che riescano a trovare i punti di minimo delle funzioni non vincolate.&lt;/p&gt;
&lt;p&gt;In generale &lt;strong&gt;si trova un punto stazionario (condizioni necessarie)&lt;/strong&gt; ma non è garantito lo stato ottimo.&lt;/p&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Metodi di Discesa/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Metodi di Discesa/Untitled&#34;&gt;
&lt;p&gt;Solitamente sono divisi in &lt;strong&gt;first order methods&lt;/strong&gt; in cui viene considerata solamente la derivata prima della funzione. E cose di metodi superiori.&lt;/p&gt;
&lt;h3 id=&#34;condizioni-di-arresto-classiche-2&#34;&gt;Condizioni di arresto classiche (2)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide&lt;/p&gt;</description>
    </item>
    <item>
      <title>Proximal Polixy Optimization</title>
      <link>https://flecart.github.io/notes/proximal-polixy-optimization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/proximal-polixy-optimization/</guid>
      <description>&lt;p&gt;This documents attempts to briefly present the algorithm and some experiments found online about it.
The following repo seems to be a good resource: &lt;a href=&#34;https://github.com/ericyangyu/PPO-for-Beginners&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Usually, PPO is explained as an &lt;strong&gt;actor critic framework&lt;/strong&gt;. This means there is an &lt;em&gt;agent&lt;/em&gt; that acts on the environment, and then there is a &lt;em&gt;critic&lt;/em&gt; that collects the feedback from the environment.
The main idea about this framework is to &lt;em&gt;select&lt;/em&gt; a policy that is similar, so that it is &lt;em&gt;less probable&lt;/em&gt; that a bad policy, a very different policy from the original is selected. This is achieved by clipping over the advantage. And then&lt;/p&gt;</description>
    </item>
    <item>
      <title>Measure Theory</title>
      <link>https://flecart.github.io/notes/measure-theory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/measure-theory/</guid>
      <description>&lt;p&gt;Ultima modifica: September 18, 2022 9:43 AM
Primo Abbozzo: September 16, 2022 9:52 AM
Studi Personali: Yes&lt;/p&gt;
&lt;h1 id=&#34;elementi-di-ripasso&#34;&gt;Elementi di ripasso&lt;/h1&gt;
&lt;h1 id=&#34;measure-theory&#34;&gt;Measure Theory&lt;/h1&gt;
&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;requirements-of-the-measure-function&#34;&gt;Requirements of the measure function&lt;/h3&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Measure Theory/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Measure Theory/Untitled&#34;&gt;
&lt;p&gt;Vorremmo cercare di &lt;strong&gt;estendere il concetto di misurabilità&lt;/strong&gt; a gruppi molto più ampi di un singolo intervallo, vorrei creare una funzione che sia in grado di misurare degli insiemi. *su vedrà che sono impossibili).&lt;/p&gt;
&lt;h3 id=&#34;impossibilità-di-questi-requirements-assurdo&#34;&gt;Impossibilità di questi requirements (assurdo)&lt;/h3&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Measure Theory/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Measure Theory/Untitled 1&#34;&gt;
&lt;p&gt;&lt;strong&gt;Costruzione dell’insieme di interesse&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Gruppi</title>
      <link>https://flecart.github.io/notes/gruppi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gruppi/</guid>
      <description>&lt;h2 id=&#34;definizione-gruppo&#34;&gt;Definizione gruppo&lt;/h2&gt;
&lt;p&gt;Qualunque insieme più operazione tale per cui:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Esistenza dell&amp;rsquo;inverso per ogni elemento $\forall g \in G, \exists g^{-1} \in G : gg^{-1} = e$&lt;/li&gt;
&lt;li&gt;Esistenza di un elemento neutro $\exists e \in G: \forall g \in G, eg = g$&lt;/li&gt;
&lt;li&gt;Associatività: $(gh)f = g(hf)$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Closure&lt;/strong&gt;: $\forall g, h \in G \implies gh \in G$&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;unicità-dellelemento-neutro&#34;&gt;Unicità dell’elemento neutro&lt;/h3&gt;
&lt;p&gt;Supponiamo di avere un gruppo $G$ e due elementi neutri $e, f$
Allora abbiamo che
$ae = a = af$ però se moltiplichiamo per l&amp;rsquo;inversa abbiamo che
$a^{-1}ae = a^{-1}af \implies e = f$&lt;/p&gt;</description>
    </item>
    <item>
      <title>Fn Ordine superiore</title>
      <link>https://flecart.github.io/notes/fn-ordine-superiore/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/fn-ordine-superiore/</guid>
      <description>&lt;p&gt;Questa parte è strettamente collegata conl a parte di &lt;a href=&#34;https://flecart.github.io/notes/astrazione-sul-controllo&#34;&gt;Astrazione sul controllo&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Si parla di &lt;strong&gt;passare le funzioni come dati&lt;/strong&gt;. e quindi possono essere passati come se fossero dei parametri.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;un linguaggio di programmazione è di ordine superiore qualora
ammetta funzioni sia come parametro che come risultato di altre funzioni.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;La parte molto simile alla precedente è il fatto di &lt;strong&gt;valutare&lt;/strong&gt; la funzione nell&amp;rsquo;ambiente iniziale, quindi bisogna utilizzare un sistema simile a quello del passaggio per nome.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bottom-up Parser LR(0)</title>
      <link>https://flecart.github.io/notes/bottom-up-parser-lr0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bottom-up-parser-lr0/</guid>
      <description>&lt;p&gt;Descrivo ora alcune domande utili per ripasso:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Quali sono schematicmente quali sono le operazioni migliori per un parser top-down?&lt;/li&gt;
&lt;li&gt;Cosa è un prefisso viabile?&lt;/li&gt;
&lt;li&gt;Quali sono i conflitti possibli, e come risolverli…&lt;/li&gt;
&lt;li&gt;Non sai nemmeno definire inmodo formale cosa sia un item&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;bottom-up&#34;&gt;Bottom up&lt;/h2&gt;
&lt;h3 id=&#34;intro-shift-reduce-e-lr&#34;&gt;Intro shift-reduce e LR&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Bottom-up Parser LR(0)/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Bottom-up Parser LR(0)/Untitled 1&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In breve:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Shift = simbolo terminale messo nella stack&lt;/li&gt;
&lt;li&gt;Riduzione utilizzando una produzione&lt;/li&gt;
&lt;li&gt;LR = dettura da Sinistra, creazione della stringa da destra (derivazione rightmost)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;algoritmo-classico&#34;&gt;Algoritmo classico&lt;/h3&gt;
&lt;p&gt;Quello che credo che intendevo per questo algoritmo classico è quello non deterministico, nel senso che prova a fare backtracking, finché non ha finito tutte le possibilità, oppure trova la derivazione giusta.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bottom-up Parser LR(1)</title>
      <link>https://flecart.github.io/notes/bottom-up-parser-lr1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bottom-up-parser-lr1/</guid>
      <description>&lt;p&gt;Si può osservare che per il parser costruito in &lt;a href=&#34;https://flecart.github.io/notes/bottom-up-parser-lr(0&#34;&gt;Bottom-up Parser LR(0)&lt;/a&gt;), non riesce a riconoscere di linguaggi semplici come $L = \{a, ab\}$.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Esempio di quanto detto
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Bottom-up Parser -LR(1)/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Bottom-up Parser -LR(1)/Untitled 1&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;parser-slr1&#34;&gt;Parser SLR(1)&lt;/h2&gt;
&lt;p&gt;Questi parser qui utilizzano l’idea del look ahead ampiamente utilizzata in &lt;a href=&#34;https://flecart.github.io/notes/top-down-parser&#34;&gt;Top-down Parser&lt;/a&gt;, per escludere molte produzioni.&lt;/p&gt;
&lt;p&gt;La s sta per &lt;strong&gt;simple&lt;/strong&gt;, perché utilizza una idea semplice :D, credo ahah boh.&lt;/p&gt;
&lt;h3 id=&#34;riduzione-con-follow&#34;&gt;Riduzione con follow&lt;/h3&gt;
&lt;p&gt;noi vogliamo &lt;strong&gt;ridurre solamente se ho follow&lt;/strong&gt; corretto il terminale finale della stringa.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Explainability of CNN</title>
      <link>https://flecart.github.io/notes/explainability-of-cnn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/explainability-of-cnn/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Capire in che modo una rete convoluzionale ci può dare insight migliori su come funzionano questi networks.&lt;/p&gt;
&lt;h3 id=&#34;visualizzazione-dei-hidden-layers&#34;&gt;Visualizzazione dei hidden layers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide visualization&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Explainability of CNN/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Explainability of CNN/Untitled&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Potremmo fissare una immagine anche a caso, e modificare la x in modo che sia più simile a quanto vuole computare il neurone. In questo modo genero una immagine che generi una activation forte nel neuron trainato, e si potrebbe dire che sia il genere di immagine che viene generata da essa.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Fondamenti teorica</title>
      <link>https://flecart.github.io/notes/fondamenti-teorica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/fondamenti-teorica/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://virtuale.unibo.it/pluginfile.php/1295166/mod_resource/content/0/Lez18-Gorrieri.pdf&#34;&gt;&lt;a href=&#34;https://virtuale.unibo.it/pluginfile.php/1295166/mod_resource/content/0/Lez18-Gorrieri.pdf&#34;&gt;https://virtuale.unibo.it/pluginfile.php/1295166/mod_resource/content/0/Lez18-Gorrieri.pdf&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;halting-problem&#34;&gt;Halting problem&lt;/h2&gt;
&lt;p&gt;Questo asserisce che &lt;strong&gt;non esiste nessun programma che sia in grado di decidere la terminazione di un altro programma&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Questo è un problema che ci è interessante perché vorremmo costruire un compilatore che  sia in grado di osservare &lt;strong&gt;tutti gli errori possibili&lt;/strong&gt; del programma. Come vedremo tra poco la risposta sarà negativa.&lt;/p&gt;
&lt;h3 id=&#34;dimostrazione-tesi&#34;&gt;Dimostrazione tesi&lt;/h3&gt;
&lt;p&gt;Supponiamo che questo programma esista, lo chiamiamo &lt;code&gt;check(P)&lt;/code&gt; che restituisce 0 se termina 1 se non termina, allora devo poter essere in grado di scrivere un programma di questo genere&lt;/p&gt;</description>
    </item>
    <item>
      <title>Garbage Collection</title>
      <link>https://flecart.github.io/notes/garbage-collection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/garbage-collection/</guid>
      <description>&lt;h2 id=&#34;on-dangling-pointers&#34;&gt;On dangling pointers&lt;/h2&gt;
&lt;h3 id=&#34;tombstones&#34;&gt;Tombstones&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slides tombstones&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Garbage Collection/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Garbage Collection/Untitled&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Quando alloco, alloco anche una tombstone, e tutti i riferimenti passano per quella. (quindi ho due dereference per l’accesso) quando vado a deallocare segno la tombstone come RIP, NULL.&lt;/p&gt;
&lt;p&gt;Dopo molto tempo ho il problema del cimitero che diventa molto grande. Anche se non punta più a niente, il cimitero.&lt;/p&gt;
&lt;h3 id=&#34;keys-and-locks&#34;&gt;Keys and locks&lt;/h3&gt;
&lt;p&gt;Un pò di overhead in più dal punto di vista della memoria, che è doppio&lt;/p&gt;</description>
    </item>
    <item>
      <title>Interpolazione</title>
      <link>https://flecart.github.io/notes/interpolazione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/interpolazione/</guid>
      <description>&lt;p&gt;Vogliamo in questa sezione andare ad indagare la costruzione di funzioni che passano in tutti i punti che vogliamo, appunto interpolare. La funzione è molto simile alla regressione trattata in &lt;a href=&#34;https://flecart.github.io/notes/minimi-quadrati&#34;&gt;Minimi quadrati&lt;/a&gt; (con il metodo della regressione, chiamato anche approssimazione ai minimi quadrati).&lt;/p&gt;
&lt;p&gt;Quindi mentre la precedente voleva andare a minimizzare l&amp;rsquo;errore, questo attuale va a creare proprio da 0 la funzione che ci passa sempre.&lt;/p&gt;
&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;p&gt;Andremo a creare una funzione f tale che per ogni x in input si abbia &lt;strong&gt;esattamente&lt;/strong&gt; la y in output&lt;/p&gt;</description>
    </item>
    <item>
      <title>Isomorfismi</title>
      <link>https://flecart.github.io/notes/isomorfismi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/isomorfismi/</guid>
      <description>&lt;p&gt;Gli isomorfismi sono delle proprietà fondamentali per stabilire una sorta di equivalenza fra i gruppi. Utilizziamo questi isomorfismi per parlare della stessa cosa ma in modi diversi.&lt;/p&gt;
&lt;h2 id=&#34;31-introduzione&#34;&gt;3.1 Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;311-definizione&#34;&gt;3.1.1 Definizione&lt;/h3&gt;
&lt;p&gt;Un gruppo si dice isomorfo rispetto ad un altro gruppo se, in paroloni semplici, esiste una funzione bigettiva tale che preservi l&amp;rsquo;operazione del gruppo.&lt;/p&gt;
&lt;p&gt;In altre parole&lt;/p&gt;
$$
\phi:A \to B,\phi(ab) = \phi(a)\phi(b)
$$&lt;h3 id=&#34;312-step-di-dimostrazione&#34;&gt;3.1.2 Step di dimostrazione&lt;/h3&gt;
&lt;p&gt;Esiste un modo preciso per dimostrare se due gruppi sono isomorfi. In particolare:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Object Detection</title>
      <link>https://flecart.github.io/notes/object-detection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/object-detection/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;h3 id=&#34;semantic-segmentation&#34;&gt;Semantic segmentation&lt;/h3&gt;
&lt;p&gt;Vorremo trovare &lt;strong&gt;regioni che corrispondano a categorie diverse&lt;/strong&gt;. E dividere in questo modo l’immagine secondo zone di informazione.&lt;/p&gt;
&lt;h3 id=&#34;object-detection&#34;&gt;Object detection&lt;/h3&gt;
&lt;p&gt;Vogliamo trovare &lt;strong&gt;il più piccolo box&lt;/strong&gt; che vada a contenere l’oggetto. Questo è fatto con il &lt;strong&gt;bounding box&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;In questo caso la funzione di loss è un pò più difficile da definire, si utilizza la funzione &lt;strong&gt;intersection over union&lt;/strong&gt; con le aree, in pratica la percentuale di immagine comune diciamo.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Probabilita condizionata e indipendenza</title>
      <link>https://flecart.github.io/notes/probabilita-condizionata-e-indipendenza/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/probabilita-condizionata-e-indipendenza/</guid>
      <description>&lt;h2 id=&#34;condizionata&#34;&gt;Condizionata&lt;/h2&gt;
&lt;h3 id=&#34;definizione&#34;&gt;Definizione&lt;/h3&gt;
&lt;p&gt;Andiamo a definire una probabilità di un evento $A$, condizionata a un evento non nullo $B$, come&lt;/p&gt;
$$
P(A|B) = \dfrac{P(A\cap B)}{P(B)}
$$&lt;p&gt;Questo è la cosa fondamentale per poter considerare cose come bayes perché in questo modo abbiamo una certa relazione fra causa ed effetto e anche il contrario! Cosa che ci piace molto molto molto.&lt;/p&gt;
&lt;h3 id=&#34;la-definizione-di-sopra-è-un-probabilità&#34;&gt;La definizione di sopra è un probabilità&lt;/h3&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/Probabilità condizionata e indipendenza/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;Probabilità condizionata e indipendenza/Untitled&#34;&gt;
&lt;p&gt;&lt;strong&gt;Dimostrazione&lt;/strong&gt; mia&lt;/p&gt;</description>
    </item>
    <item>
      <title>Algebra dei tipi</title>
      <link>https://flecart.github.io/notes/algebra-dei-tipi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algebra-dei-tipi/</guid>
      <description>&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Algebra dei tipi/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Algebra dei tipi/Untitled&#34;&gt;
&lt;h3 id=&#34;equivalenza-dei-tipi-2&#34;&gt;Equivalenza dei tipi (2)&lt;/h3&gt;
&lt;p&gt;Quando possiamo dire che due tipi siano uguali? Solitamente vengono utilizzati due metodi:&lt;/p&gt;
&lt;h4 id=&#34;equivalenza-nominale&#34;&gt;Equivalenza Nominale&lt;/h4&gt;
&lt;p&gt;Quando un nuono tipo introduce un nuovo nome diverso fra tutti i presenti. Credo così vada golang.
Quindi in questo caso si può dire che un tipo &lt;strong&gt;è equivalente solamente a sé stesso&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Vogliamo fare in questo modo perché se definiamo un nuovo tipo solitamente dovrebbe avere funzioni diverse, quindi è giusto che sia diverso da uqello iniziale.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Deblur di immagini</title>
      <link>https://flecart.github.io/notes/deblur-di-immagini/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/deblur-di-immagini/</guid>
      <description>&lt;h3 id=&#34;origini-di-sfocatura&#34;&gt;Origini di sfocatura&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;/images/notes/image/universita/ex-notion/Immagini/Untitled.png&amp;quot; style=&amp;quot;width: 100%&amp;quot; class=&amp;quot;center&amp;quot; alt=&amp;quot;image/universita/ex-notion/Immagini/Untitled&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;Rumore causata da problemi fisici che sono &lt;strong&gt;errori di lettura&lt;/strong&gt; del segnale analogico Questo si indica anche come errore gaussiano bianco e si può considerare &lt;em&gt;additivo&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Rumore causato dalla digitalizzazione, quindi dalla discretizzazione di essa.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide formalizzazione errori per sfocatura&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Immagini/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Immagini/Untitled 1&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;point-spread-function&#34;&gt;Point spread function&lt;/h3&gt;
&lt;p&gt;Un unico pixel bianco sembra influenzare il suo ambiente nero, come in immagine&lt;/p&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Immagini/Untitled 2.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Immagini/Untitled 2&#34;&gt;
&lt;p&gt;Vorremmo utilizzare delle funzioni ce siano in grado di approssimare questa funzione.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Gestione delle eccezioni</title>
      <link>https://flecart.github.io/notes/gestione-delle-eccezioni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gestione-delle-eccezioni/</guid>
      <description>&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;metodi-alternativi-di-gestione-degli-errori-3&#34;&gt;Metodi alternativi di gestione degli errori (3)&lt;/h3&gt;
&lt;p&gt;A volte le computazioni falliscono. Potremmo gestirle con i result come accennato in &lt;a href=&#34;https://flecart.github.io/notes/polimorfismo&#34;&gt;Polimorfismo&lt;/a&gt;, però diventa molto macchinoso fare tutte le funzioni che debbano inoltrare solamente delle results. bisogna trovare un modo più naturale. Ecco che arriva una gestione delle eccezioni direttamente nel linguaggio. Si tratta un sistema di comunicazione degli errori.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ALTRI METODI&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Results, stile monadico, vedi sopra.&lt;/li&gt;
&lt;li&gt;definire dei valori eccezionali (questo si va spesso in C)&lt;/li&gt;
&lt;li&gt;Il chiamato dice al chiamante una cosa da chiamare quando fallisce. Diciamo &lt;strong&gt;inversione del controllo&lt;/strong&gt; perché in questo caso è il chiamato che dice cosa fare. Ma rende il codice poco composizionale, quindi difficile da seguire.
(Questa è la soluzione molto più simile alla gestione effettiva degli errori). Ma nelle eccezioni vere non è il chiamato che ritorn al&amp;rsquo;indirizzo da eseguire ma è il runtime che decide cosa andare ad eseguire. Questa cosa non interrompe il flusso del calcolo&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Con le eccezioni vogliamo &lt;strong&gt;trasferire il controllo a un gestore delle eccezioni&lt;/strong&gt; questo gestore solitamente si trova sulla stack (va a risalire tutta la stack di chiamata fino a raggiungere questo gestore).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Introduzione alla probabilita</title>
      <link>https://flecart.github.io/notes/introduzione-alla-probabilita/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-alla-probabilita/</guid>
      <description>&lt;h1 id=&#34;note&#34;&gt;Note:&lt;/h1&gt;
&lt;p&gt;Questo corso è troppo astratto. Più che probabilità tratta di teoria della Misura. Quindi affossato…&lt;/p&gt;
&lt;p&gt;Link della serie: &lt;a href=&#34;https://www.youtube.com/watch?v=172m7qVy_FQ&amp;list=PLrb6X_RiBI94b6dzCx-QwM-r0aZpJyPxS&#34;&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=172m7qVy_FQ&amp;amp;list=PLrb6X_RiBI94b6dzCx-QwM-r0aZpJyPxS&#34;&gt;https://www.youtube.com/watch?v=172m7qVy_FQ&amp;list=PLrb6X_RiBI94b6dzCx-QwM-r0aZpJyPxS&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;campo-di-probabilità&#34;&gt;Campo (di probabilità)&lt;/h1&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/Introduzione alla probabilità/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;Introduzione alla probabilità/Untitled&#34;&gt;
&lt;p&gt;Nota:&lt;/p&gt;
&lt;p&gt;2 e 3 ⇒ 4&lt;/p&gt;
&lt;p&gt;2 e 4 ⇒ 3&lt;/p&gt;
&lt;p&gt;Quindi 3 e 4 sono interscambiabili, e si potrebbe eliminare uno dei due.&lt;/p&gt;
&lt;p&gt;Anche il fatto che il vuoto sia presente in F si può omettere. combinando 1 e 2 ottengo il vuoto (complementare dell’insieme che prenda tutto).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Calcolo di numeri finiti</title>
      <link>https://flecart.github.io/notes/calcolo-di-numeri-finiti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/calcolo-di-numeri-finiti/</guid>
      <description>&lt;h1 id=&#34;1-calcolo-dei-numeri-finiti&#34;&gt;1 Calcolo dei numeri finiti&lt;/h1&gt;
&lt;p&gt;Il calcolo è numerico perché si differenzia rispetto a un calcolo normale perché è &lt;em&gt;finito&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&#34;11-errore-nei-calcoli&#34;&gt;1.1 Errore nei calcoli&lt;/h2&gt;
&lt;h3 id=&#34;111-tipologie-di-errore-5&#34;&gt;1.1.1 Tipologie di errore (5)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Errore di misura&lt;/strong&gt;, dovuto alle imperfezioni dello strumento di misura dei dati del problema.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Errore di troncamento&lt;/strong&gt;, quando un procedimento infinito viene realizzato come procedimento finito. (esempio: calcolo del valore di una funzione tramite sviluppo in serie, perché dato che l’algoritmo deve essere finito, devo prima o poi interrompere il calcolo, ecco qui l’errore).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Errore inerente&lt;/strong&gt;, dovuto al fatto che i dati di un problema non sono in una forma buona diciamo&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Errore di rappresentazione (simil troncamento)&lt;/strong&gt; non sempre appartengono all’insieme $\mathbb{F}$ dei numeri rappresentabili e quindi vengono approssimati.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Errore algoritmico&lt;/strong&gt;, dovuto al &lt;em&gt;propagarsi&lt;/em&gt; degli errori di arrotondamento sulle singole operazioni in un procedimento complesso.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;112-misura-dellaccuratezza&#34;&gt;1.1.2 Misura dell’accuratezza&lt;/h3&gt;
&lt;p&gt;Anche per l’accuratezza di una misura utilizziamo degli errori (questi tipi di errori li hai anche studiati in fisica durante il liceo).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Introduction to computational statistics</title>
      <link>https://flecart.github.io/notes/introduction-to-computational-statistics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduction-to-computational-statistics/</guid>
      <description>&lt;h3 id=&#34;what-is-it-for&#34;&gt;What is it for&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Estimation&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sampling&lt;/strong&gt; generate numbers from &lt;em&gt;any&lt;/em&gt; distribution! (distributions are important in statistics).
&lt;ol&gt;
&lt;li&gt;Density&lt;/li&gt;
&lt;li&gt;Cumulative distribution (and others similar).&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Optimization&lt;/strong&gt; how to find computationally the min and max of functions.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Generating?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Random (difficile anche filosoficamente definire cosa significa questo).
&lt;ol&gt;
&lt;li&gt;Molto importante perché si assume in Comp stats che abbiamo il random vero, e questa assunzione che non vale può rompere cose.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;And independent&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;sample-proportion&#34;&gt;Sample proportion&lt;/h4&gt;
&lt;p&gt;Average of something (example of the lake cannonball).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Scelta del PO</title>
      <link>https://flecart.github.io/notes/scelta-del-po/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/scelta-del-po/</guid>
      <description>&lt;p&gt;La cosa che rende il PO diverso rispetto agli sviluppatori è la &lt;strong&gt;conoscenza&lt;/strong&gt; delle necessità del cliente. Questo permette di prioritizzare del task e capire in che modo dovrebbe essere il prodotto finale. In questo modo si crea una &lt;strong&gt;vision&lt;/strong&gt; del prodotto.
Pensiamo che il PO debba condividere questa informazione e prendere decisioni di gruppo.&lt;/p&gt;
&lt;h4 id=&#34;domande-da-fare&#34;&gt;Domande da fare:&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;La user interface, come sembra il wireframe?&lt;/li&gt;
&lt;li&gt;Pensavamo di utilizzare i social solamente per i login, pensavate di utilizzare anche per altro durante il gioco?
&lt;ol&gt;
&lt;li&gt;Bassa priorità (poter condividere i risultati con un post).&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Vorreste poter selezionare il livello del bot? Quanto sarebbe il massimo livello e quale il minimo?
4. Per kriegspiel la forza è massima.&lt;/li&gt;
&lt;li&gt;Cosa è la modalità &amp;lsquo;mob&amp;rsquo; per giocare (2 descrizione del problema documento progetto).
&lt;ol&gt;
&lt;li&gt;si intende il social che permette di condividere mosse.&lt;/li&gt;
&lt;li&gt;tutte le persone interessante possono rispondere con tempo un giorno, e la maggioranza determina la risposta.&lt;/li&gt;
&lt;li&gt;Bassa priorità.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Esistono i soci (utenti registrati) e non, cosa può fare un utente non registrato? E quelli registrati? O definiamo noi?&lt;/li&gt;
&lt;li&gt;Che genere di commenti deve fare l&amp;rsquo;AI durante la partita?
&lt;ol&gt;
&lt;li&gt;Va bene qualunque commento (anche in giro), commenti interessanti sul contesto).&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;In che modo salvare una partita? Solamente la sequenza delle mosse o possibilità di riprendere la partita?
&lt;ol&gt;
&lt;li&gt;Non è richiesto poter salvare e riprendere nei giochi a informazione incompleta&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;La seconda cosa interessante per l&amp;rsquo;utente?
&lt;ol&gt;
&lt;li&gt;Leaderboard (non per noi, ELO).&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Cosa deve avere la leaderboard per giochi diversi da bad chess?
&lt;ol&gt;
&lt;li&gt;Legato all&amp;rsquo;ELO questa, il classico.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;O mobile o web o come ci pare (non è importante).
No sicurezza, non è importante.
50 giocatori max.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Sezioni Critiche</title>
      <link>https://flecart.github.io/notes/sezioni-critiche/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/sezioni-critiche/</guid>
      <description>&lt;p&gt;Ripasso Prox: 80
Ripasso: May 21, 2023
Ultima modifica: March 12, 2023 10:00 AM
Primo Abbozzo: October 8, 2022 11:30 AM
Stato: 🌕🌕🌕🌕🌑
Studi Personali: No&lt;/p&gt;
&lt;h1 id=&#34;elementi-di-ripasso&#34;&gt;Elementi di ripasso&lt;/h1&gt;
&lt;h1 id=&#34;2-sezioni-critiche&#34;&gt;2 Sezioni Critiche&lt;/h1&gt;
&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;La parte di un programma che utilizza una o più risorse
condivise viene detta sezione critica (critical section, o CS)&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Andiamo in questa altra parte a valutare certe soluzioni:&lt;/p&gt;
&lt;h3 id=&#34;programma-desempio&#34;&gt;Programma d’esempio&lt;/h3&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Sezioni Critiche/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Sezioni Critiche/Untitled&#34;&gt;
&lt;p&gt;Vorremmo garantire che &lt;strong&gt;a = b invariante.&lt;/strong&gt; (espressione logica verificata nell&amp;rsquo;esecuzione di questo programma). quindi una coerenza di uno prima dell&amp;rsquo;altro vogliamo.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Accept Reject algorithm</title>
      <link>https://flecart.github.io/notes/accept-reject-algorithm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/accept-reject-algorithm/</guid>
      <description>&lt;h4 id=&#34;some-useful-links&#34;&gt;Some useful links&lt;/h4&gt;
&lt;p&gt;Main results: &lt;a href=&#34;https://jblevins.org/notes/accept-reject&#34;&gt;&lt;a href=&#34;https://jblevins.org/notes/accept-reject&#34;&gt;https://jblevins.org/notes/accept-reject&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Intuition: &lt;a href=&#34;https://en.wikipedia.org/wiki/Rejection_sampling&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Rejection_sampling&#34;&gt;https://en.wikipedia.org/wiki/Rejection_sampling&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;La cosa è che faccio sampling fra due distribuzioni diverse e devo settare anche un parametro (e a seconda di certe cose diventa molto lento).&lt;/p&gt;
&lt;h4 id=&#34;introduzione-al-metodo&#34;&gt;Introduzione al metodo&lt;/h4&gt;
&lt;p&gt;Vorrei utilizzare una funzione $g$ per generarne una altra, questo è il fulcro del concetto.
L&amp;rsquo;idea principale è:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Conosco la funzione densità della funzione $f$ che voglio andare a generare&lt;/li&gt;
&lt;li&gt;Riesco a generare seguendo una funzione semplice, la chiamo $g$, &lt;strong&gt;candidate density&lt;/strong&gt;. (che è la densità che utilizzo per calcolare il target che non conosco molto bene).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ma devono esserci due cose:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kolmogorov complexity</title>
      <link>https://flecart.github.io/notes/kolmogorov-complexity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/kolmogorov-complexity/</guid>
      <description>&lt;p&gt;Gran parte di quanto scrivo ora è tratto da &lt;a href=&#34;http://link.springer.com/10.1007/978-3-030-11298-1&#34;&gt;(Li &amp;amp; Vit{&#39;a}nyi 2019)&lt;/a&gt;.
Chaitin, Kolmogorov e Solomonoff hanno elaborato il tema in modo indipendente e allo stesso tempo verso gli anni &amp;lsquo;60!&lt;/p&gt;
&lt;p&gt;Solomonoff lo ha trovato sul problema dell&amp;rsquo;induzione all&amp;rsquo;età di 38 anni, Kolmogorov invece era già tardi, ha già trovato gli assiomi della probabilità e poi nel 65 cerca randomness. Mentre Chaiten Information = Computation e non probabilità, nel 68 all&amp;rsquo;età di 19 anni.
In AI teorico questo sembra un tema molto importante.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Project Management</title>
      <link>https://flecart.github.io/notes/project-management/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/project-management/</guid>
      <description>&lt;h4 id=&#34;project-product-management-project-management&#34;&gt;Project, product management, project management&lt;/h4&gt;
&lt;p&gt;Bisogna capire queste definizioni.
Vedere &lt;a href=&#34;https://dynamik.vercel.app/ingegneria-del-software/lucidi/13-gestione-del-progetto.pdf?from=informatica,&#34;&gt;&lt;a href=&#34;https://dynamik.vercel.app/ingegneria-del-software/lucidi/13-gestione-del-progetto.pdf?from=informatica&#34;&gt;https://dynamik.vercel.app/ingegneria-del-software/lucidi/13-gestione-del-progetto.pdf?from=informatica&lt;/a&gt;,&lt;/a&gt; slide 5 per definizione&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Progetto: inizia e finisce in tempo preciso.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;È importante comunque ricordare gli steps principali per il progetto ossia ideazione, creazione, mantenimento, rilascio, e poi morte, questo in genere è per qualunque progetto.&lt;/p&gt;
&lt;h3 id=&#34;project-manager&#34;&gt;Project Manager&lt;/h3&gt;
&lt;h4 id=&#34;compiti-principali-costi-e-risorse&#34;&gt;Compiti principali (costi e risorse)&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Vedere se il progetto è fattibile&lt;/li&gt;
&lt;li&gt;Allocare risorse&lt;/li&gt;
&lt;li&gt;Monitorare come sta andando. (preventivo e consuntivo).
&lt;img src=&#34;https://flecart.github.io/images/notes/Project Management-1701099646139.jpeg&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;Project Management-1701099646139&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;work-breakdown-structure&#34;&gt;Work Breakdown structure&lt;/h3&gt;
&lt;h4 id=&#34;descrizione-wbs&#34;&gt;Descrizione WBS&lt;/h4&gt;
&lt;p&gt;È una suddivisione del progetto in piccoli sottoparti che si possono gestire in modo autonomo.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
