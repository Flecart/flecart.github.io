<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>No-Tags on X. Angelo Huang&#39;s Blog</title>
    <link>https://flecart.github.io/tags/no-tags/</link>
    <description>Recent content in No-Tags on X. Angelo Huang&#39;s Blog</description>
    <image>
      <title>X. Angelo Huang&#39;s Blog</title>
      <url>https://flecart.github.io/images/papermod-cover.png</url>
      <link>https://flecart.github.io/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <atom:link href="https://flecart.github.io/tags/no-tags/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Expressiveness of NN</title>
      <link>https://flecart.github.io/notes/expressiveness-of-nn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/expressiveness-of-nn/</guid>
      <description>The perceptron Slide summary of working of perceptron
Note on the bias: it is only useful to move the treshhold where to consider the output to be 1 and where to be 1.
Now we ask what can be predicted by a perceptron?
Hyperplanes Hyperplanes, because that equation is an hyperplane, so we are sure that we can predict an hyperplane, and that it, and it’s only it. (it’s predicting wheter it can be above or below that line).</description>
    </item>
    <item>
      <title>Problemi di ricerca</title>
      <link>https://flecart.github.io/notes/problemi-di-ricerca/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/problemi-di-ricerca/</guid>
      <description>Ripasso Prox: 36 Ultima modifica: December 29, 2022 3:24 PM Primo Abbozzo: June 30, 2022 2:38 PM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso September 10, 2022
Mi sono scordato gli stati possibili. Quasi niente sulla ricerca per algoritmi non deterministici e non osservabili. 2 Problemi di ricerca In questa prima parte si tratta di ricerca semplice, ossia si utilizza un modello basato su obiettivi, di struttura atomica, in un ambiente che risulti singolo-agente, episodico, totalmente osservabile, deterministico, statico, discreto, conosciuto.</description>
    </item>
    <item>
      <title>Accessibilità</title>
      <link>https://flecart.github.io/notes/accessibilit%C3%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/accessibilit%C3%A0/</guid>
      <description>Ci chiediamo come facciamo a rendere sistemi informatici accessibili a persone attraverso certe tecnologie.
Slide esempi di disabilità
È meglio renderlo accessibile perché è illegale (nel senso che stai facendo una discriminazione verso un certo insieme di persone).
WGAC Queste sono alcuni principi di accessibilità, basati su 4 principi fondamentali
4 principi del WGAC POUR per facilità di ricordarsi
Perceivable (che ci siano le informazioni necessarie per l&amp;rsquo;accessibilità) Operable Understandable Robus Linguaggio Il tag del linguaggio è utilizzato per sapere in che accento leggere e dare gli ordini.</description>
    </item>
    <item>
      <title>Consensus protocols</title>
      <link>https://flecart.github.io/notes/consensus-protocols/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/consensus-protocols/</guid>
      <description>Introduzione Vogliamo tenere in modo sincronizzato alcune macchine, questo è il nostro obiettivo. Questo è un problema abbastanza difficile… Come tenere in sync se ci sono alcuni nodi maligni o la rete che non è bona?
Assunzioni principali (2) Esiste internet Esiste Crittografia Queste sono le assunzioni che non saranno mai rilassate per l’intero corso, diciamo che sono la nostra base su cui possiamo andare a costruire la base per il nostro studio.</description>
    </item>
    <item>
      <title>Programmi Concorrenti</title>
      <link>https://flecart.github.io/notes/programmi-concorrenti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/programmi-concorrenti/</guid>
      <description>Vorremmo cercare di stabilire una teoria riguardante programmi che vengono eseguiti appunto concorrentemente, senza una esecuzione classica uno dpo l’altro
Esempio mini-programma rallentamento
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;pthread.h&amp;gt; void test(void *s) { for (int i = 0; i &amp;lt; 10; i++) { printf(&amp;#34;%s\n&amp;#34;, s); for (int j = 0; j &amp;lt; 100000000; j++); } } int main(int argc, char *argv[]) { pthread_t t1, t2; pthread_create(&amp;amp;t1, NULL, (void *)test, &amp;#34;Uno&amp;#34;); pthread_create(&amp;amp;t2, NULL, (void *)test, &amp;#34;Due&amp;#34;); pthread_join(t1, NULL); pthread_join(t2, NULL); } Example output:</description>
    </item>
    <item>
      <title>Strutture</title>
      <link>https://flecart.github.io/notes/strutture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/strutture/</guid>
      <description>Ultima modifica: November 2, 2021 10:50 AM Primo Abbozzo: November 2, 2021 9:22 AM Studi Personali: No
Elementi di ripasso Strutture Caratteristiche La caratteristica principale è che le strutture permettono di avere valori eterogenei mentre prima avevamo solo array, ossia valori omogenei, uguali fra di loro.
Questo è anche il modo solito con cui fare dei database! Teneere roba ordinata
Sintassi Accesso Blablabla
Copia Si può copiare un array in modo molto semplice, basta un uguale, mentre invece con gli array non si poteva semplicemente copiare (perché copiava il pointer) ora a quanto pare copia in automatico.</description>
    </item>
    <item>
      <title>Codifica dei caratteri</title>
      <link>https://flecart.github.io/notes/codifica-dei-caratteri/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/codifica-dei-caratteri/</guid>
      <description>Sull&amp;rsquo;encoding Introduzione 🟩 Ossia trattiamo metodi per codificare caratteri dei linguaggi umani, come ASCII, UCS e UTF.
Digitalizzare significa encodarlo in un sistema che possa essere memorizzato su un dispositivo di memorizzazione elettronico. Ovviamente non possiamo mantenere l&amp;rsquo;informazione così come è, ma vogliamo memorizzarne una forma equivalente, ma più facile da manipolare dal punto di vista del computer. Creiamo quindi un mapping, o anche isomorfismo tra il valore di mappatura (o encoding), solitamente un valore numerico, tra il singolo valore atomico originale e il numero.</description>
    </item>
    <item>
      <title>Uniform Resource Identifier</title>
      <link>https://flecart.github.io/notes/uniform-resource-identifier/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/uniform-resource-identifier/</guid>
      <description>Ripasso: May 14, 2023 Ultima modifica: June 17, 2023 11:54 PM Primo Abbozzo: February 24, 2023 1:33 PM Studi Personali: No
Elementi di ripasso URI Sono stata LA vera invenzione di Berners Lee accennati in Storia del web. Il problema è avere un modo per identificare una risorsa in modo univoco sull’internet.
Introduzione La risorsa 🟩 Una risorsa è qualunque struttura che sia oggetto di scambio tra applicazioni all’interno del World Wide Web.</description>
    </item>
    <item>
      <title>Bottom-up Parser LR(0)</title>
      <link>https://flecart.github.io/notes/bottom-up-parser-lr0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bottom-up-parser-lr0/</guid>
      <description>Descrivo ora alcune domande utili per ripasso:
Quali sono schematicmente quali sono le operazioni migliori per un parser top-down? Cosa è un prefisso viabile? Quali sono i conflitti possibli, e come risolverli… Non sai nemmeno definire inmodo formale cosa sia un item Bottom up Intro shift-reduce e LR 🟩 Slide
In breve:
Shift = simbolo terminale messo nella stack Riduzione utilizzando una produzione LR = dettura da Sinistra, creazione della stringa da destra (derivazione rightmost) Algoritmo classico 🟨+ Quello che credo che intendevo per questo algoritmo classico è quello non deterministico, nel senso che prova a fare backtracking, finché non ha finito tutte le possibilità, oppure trova la derivazione giusta.</description>
    </item>
    <item>
      <title>Neural Networks</title>
      <link>https://flecart.github.io/notes/neural-networks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/neural-networks/</guid>
      <description>Introduction: a neuron Skipped. Look at Andrew Ng&amp;rsquo;s Coursera course for this part. Historical notes are (Rosenblatt 1958).
Structure Linear + activation In pratica possiamo dire che un neurone in questa parte di AI è una funzione lineare (quindi che non fa altro che $w^Tx + b$ di solito indicata con $z$) ossia moltiplicazione lineare, e poi una funzione non lineare tra 0 e 1 che mi indica o meno se la cosa è attivata o meno.</description>
    </item>
    <item>
      <title>Cookie e autenticazione</title>
      <link>https://flecart.github.io/notes/cookie-e-autenticazione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cookie-e-autenticazione/</guid>
      <description>Ripasso: May 14, 2023 Ultima modifica: May 6, 2023 6:25 PM Primo Abbozzo: March 30, 2023 4:20 PM Studi Personali: No
Cookies Gli utilizzi più soliti sono per Autenticazione e per Autorizzazione, perché sono delle informazioni che il server genera e mette al client, come se fossero dei segreti cifrati.
Cookie Questi sono una estensione di netscape, che si appoggiano al protocollo HTTP per implementare certe funzionalità (soprattutto il fatto di essere stateless, quindi è utile per avere informazioni sugli stati su qualcosa.</description>
    </item>
    <item>
      <title>LR(k) e YACC</title>
      <link>https://flecart.github.io/notes/lrk-e-yacc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/lrk-e-yacc/</guid>
      <description>LR(k) Grammatiche LR(k) 🟩 Anche in questo caso proviamo a generalizzare il concetto dei pirmi k caratteri, in modo da generalizzare in qualche senso il concetto di LR(k), quindi andiamo a modificare la closure considerando ora first k
Per ricordarti come si calcolava first k, andare a guardare Top-down Parser
il problema che poi diventa pratico riguardo questo è l&amp;rsquo;impossibilità di gestire stringhe lunghezza k che sono una assurdità (esponenziale per la lunghezza)</description>
    </item>
    <item>
      <title>Variabili aleatorie</title>
      <link>https://flecart.github.io/notes/variabili-aleatorie/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/variabili-aleatorie/</guid>
      <description>Variabili aleatorie discrete Con le variabili aleatorie cominciamo ad entrare nel noccio della questione, finalmente possiamo in un certo senso legare l’outcome di un evento, alla probabilità dell’evento.
Definizione VA 🟩 Si definisce variabile aleatoria $X$ una funzione da $\Omega \to E$, con Omega il nostro spazio campionario, e $E$ qualunque insieme (quando $E = \mathbb{R}$ si parla di variabile aleatoria reale
Quindi un esempio classico per il dado, potremmo definire una variabile aleatoria dallo spazio campionario $\Omega = [1, 2, 3, 4, 5, 6]$ ai reali, tali che $X(1) = 1, X(2) = 2$ etc, in questo senso stiamo facendo una funzione fra abitanti di insiemi diversi, ma resta una funzione.</description>
    </item>
    <item>
      <title>Introduzione alla probabilita</title>
      <link>https://flecart.github.io/notes/introduzione-alla-probabilita/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-alla-probabilita/</guid>
      <description>Note: Questo corso è troppo astratto. Più che probabilità tratta di teoria della Misura. Quindi affossato…
Link della serie: https://www.youtube.com/watch?v=172m7qVy_FQ&amp;amp;list=PLrb6X_RiBI94b6dzCx-QwM-r0aZpJyPxS
Campo (di probabilità) Nota:
2 e 3 ⇒ 4
2 e 4 ⇒ 3
Quindi 3 e 4 sono interscambiabili, e si potrebbe eliminare uno dei due.
Anche il fatto che il vuoto sia presente in F si può omettere. combinando 1 e 2 ottengo il vuoto (complementare dell’insieme che prenda tutto).</description>
    </item>
    <item>
      <title>Convolutional NN</title>
      <link>https://flecart.github.io/notes/convolutional-nn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/convolutional-nn/</guid>
      <description>Introduction to convolutional NN The convolution operator 🟩- Il prodotto di convoluzione è matematicamente molto contorto, anche se nella pratica è una cosa molto molto semplice. In pratica voglio calcolare il valore di un pixel in funzione di certi suoi vicini, moltiplicati per un filter che in pratica è una matrice di pesi, che definisce un pattern lineare a cui sarei interessato di cercare nell’immagine.
Slides ed esempi (molto più chiaril)</description>
    </item>
    <item>
      <title>Agente Logico</title>
      <link>https://flecart.github.io/notes/agente-logico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/agente-logico/</guid>
      <description>Introduzione Nozioni base Questi sono le parole chiave di questo capitolo, ci permettono di parlare con chiarezza riguardo l’agente logico.
Sentence
Knowledge Base
Axiom
Inference
background knowledge
Knowledge representation language
Knowledge level
Implementation level
Esempio generale di agente logico
Logica proposizionale Sintassi del linguaggio Descrivere la BNF della logica proposizionale.
per sapere cosa sia la BNF di questo è molto più facile rifarsi agli appunti di logica presi durante l’anno di corso 2021/2022 Logica Proposizionale.</description>
    </item>
    <item>
      <title>Calcolo di numeri finiti</title>
      <link>https://flecart.github.io/notes/calcolo-di-numeri-finiti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/calcolo-di-numeri-finiti/</guid>
      <description>1 Calcolo dei numeri finiti Il calcolo è numerico perché si differenzia rispetto a un calcolo normale perché è finito.
1.1 Errore nei calcoli 1.1.1 Tipologie di errore (5) 🟩 Errore di misura, dovuto alle imperfezioni dello strumento di misura dei dati del problema. Errore di troncamento, quando un procedimento infinito viene realizzato come procedimento finito. (esempio: calcolo del valore di una funzione tramite sviluppo in serie, perché dato che l’algoritmo deve essere finito, devo prima o poi interrompere il calcolo, ecco qui l’errore).</description>
    </item>
    <item>
      <title>Architettura e livelli 1, 2</title>
      <link>https://flecart.github.io/notes/architettura-e-livelli-1-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/architettura-e-livelli-1-2/</guid>
      <description>Perché a stack 🟩- Capire l’architettura significa capire la struttura (l’organizzazione) del nostro app e comprenderne i motivi (i sottoproblemi risolti) che ogni livello prova a risolvere
La soluzione che è stata individuata, e ha rappresentato uno dei principali cardini del successo delle reti e della nascita di Internet, è data dalla separazione delle classi di protocolli in livelli. La struttura dei livelli dei protocolli di rete prende il nome di architettura dei protocolli di rete.</description>
    </item>
    <item>
      <title>Debugging</title>
      <link>https://flecart.github.io/notes/debugging/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/debugging/</guid>
      <description>Ultima modifica: February 25, 2023 2:07 PM Primo Abbozzo: November 9, 2021 3:00 PM Studi Personali: No
Il debugging è un ambito che interessa molto a Lanese perché è molto affine al suo ambito di ricerca.
Condizioni di correttezza Un programma di si dice corretto quando restituisce il valore voluto per ogni condizione di input
Esempi di programmi sbagliati Un programma che a volte si pianta e non va più. Un programma con cicli infiniti.</description>
    </item>
    <item>
      <title>Grammatiche Regolari</title>
      <link>https://flecart.github.io/notes/grammatiche-regolari/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/grammatiche-regolari/</guid>
      <description>Introduzione Definizione grammatica regolare 🟩 Definizione
In pratica posso avere solamente come terminali a, oppure un suffisso a su un non terminale.
Queste grammatiche sono interessanti perché è molto facile costruire un automa che sia in grado di riconoscere questo linguaggio.
Seguendo una definizione più lasca possono anche accettare dei nonterminali epsilon
Espressione regolare a NFA 🟩 Questa sezione è anche presente in Automi e Regexp, però è riportata qui così c’è l’insieme di tutte le cose in un unico posto.</description>
    </item>
    <item>
      <title>Hello World</title>
      <link>https://flecart.github.io/hello-world/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/hello-world/</guid>
      <description>First blog post</description>
    </item>
    <item>
      <title>Livello di Rete</title>
      <link>https://flecart.github.io/notes/livello-di-rete/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/livello-di-rete/</guid>
      <description>Reti di Reti Le parti importanti per questo sono Data Plane e Control Plane (che ha saltato quasi tutto, ma almeno dijkstra lo dovresti fare bene)
Introduzione (puoi skippare 🟩) La puoi skipppare perché tratta in modo molto generare parti che saranno trattati in modo più approfondito in seguito. La parte importante forse è il riassunto di cosa faccia questo livello.
Discussione rete locale globale Slide
No, non è possible creare una connessione globale utilizzando le tecnologie locali, come hub, switch e simili, perché causerebbe flooding e impedirebbe scalabilità e crescita dinamica che è classica della rete</description>
    </item>
    <item>
      <title>Storia del web</title>
      <link>https://flecart.github.io/notes/storia-del-web/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/storia-del-web/</guid>
      <description>Guerre dei browser Prima guerra ~1995
Fra netscape, una forma di rete (?) che poi viene ripresa da firefox da Mozilla, dopo che è stato mandato in bancarotta da Microsoft (che ha ancora con IE una grandissima fetta del mercato in questo primo periodo).
Secondo periodo di guerra ~2010
Quando arriva chrome, che vuole creare un browser che risolva tutti i problemi per creare integrazioni sui browser di altre aziende), mentre IE ha perso interesse per nuove features, che in questo periodo sono capi del proprio mercato.</description>
    </item>
    <item>
      <title>Devices OS</title>
      <link>https://flecart.github.io/notes/devices-os/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/devices-os/</guid>
      <description>Devices Categorizzazione (6)🟨- Trasferimento dei dati Accesso al device sinconia del trasferimento condivisone fra processi Velocità del trasferimento I/O direction (scrittura o lettura) Vediamo che molte caratteristiche sono riguardo il trasferimento
Slide categorizzazione I/O
Blocchi o caratteri 🟩- Slide devices blocchi o caratteri
Tecniche di gestione devices (4) 🟨- Buffering Possiamo mettere un buffer per favorire la comunicazione fra i devices. la cos amigliore che fa è creare maggiore efficienza. Un altro motivo è la velocità diversa di consumo.</description>
    </item>
    <item>
      <title>Macchine Astratte</title>
      <link>https://flecart.github.io/notes/macchine-astratte/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/macchine-astratte/</guid>
      <description>Definizione ed esempi per macchine astratte 🟩 Una macchina astratta è un qualunque insieme di algoritmi e strutture di dati che permettono di memorizzare ed eseguire il linguaggio $L$, quindi una macchina astratta esiste per esguire il proprio linguaggio (inteso come insieme finito di istruzioni primitive che riesce ad comprendere e eseguire).
Si può proprio dire che esiste una simbiosi fra macchina e linguaggio. Si potrebbe dire che la macchina fisica è soltanto una implementazione FISICA di un linguaggio, ossia una macchina che capisce ed esegue quel linguaggio e che sia solamente un caso particolare della macchina astratta.</description>
    </item>
    <item>
      <title>Bayesian Networks</title>
      <link>https://flecart.github.io/notes/bayesian-networks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bayesian-networks/</guid>
      <description>Questi network bayesiani sono proprio dei grafi, che permettono una migliore comprensione delle relazioni causali o diagnostici fra le probabilità
Esempio rete bayesiana
Note generali Introduzione alla rete classica Una rete bayesiana ci permette di semplificare di molto il calcolo della full disjoint probability table, rendendola in questo modo
Ossia andiamo a utilizzare una probabilità locale, o sparsa per fare i conti, cosa che semplifica molto, e quindi velocizza il calcolo.</description>
    </item>
    <item>
      <title>Isomorfismi</title>
      <link>https://flecart.github.io/notes/isomorfismi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/isomorfismi/</guid>
      <description>Gli isomorfismi sono delle proprietà fondamentali per stabilire una sorta di equivalenza fra i gruppi. Utilizziamo questi isomorfismi per parlare della stessa cosa ma in modi diversi.
3.1 Introduzione 3.1.1 Definizione Un gruppo si dice isomorfo rispetto ad un altro gruppo se, in paroloni semplici, esiste una funzione bigettiva tale che preservi l&amp;rsquo;operazione del gruppo.
In altre parole
$$ \phi:A \to B,\phi(ab) = \phi(a)\phi(b) $$ 3.1.2 Step di dimostrazione Esiste un modo preciso per dimostrare se due gruppi sono isomorfi.</description>
    </item>
    <item>
      <title>Classi OOP</title>
      <link>https://flecart.github.io/notes/classi-oop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/classi-oop/</guid>
      <description>Introduzione a OOP Per la definizione di classe andare a guardare Object orientation, però lo ripeto in questa occasione, è solamente un modello su cui andare a costruire degli oggetti.
Capisaldi🟩 Incapsulazione Astrazione Ereditarietà Dispatch dinamico Costruttori 🟩- Il costruttore è un codice utilizzato per inizializzare correttamente lo stato interno. Le regole sono le stesse dei metodi sovraccaricati (dinamica per la chiamata, statica per il numero dei parametri che prende in input).</description>
    </item>
    <item>
      <title>Reti Preparazione Esami</title>
      <link>https://flecart.github.io/notes/reti-preparazione-esami/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/reti-preparazione-esami/</guid>
      <description>Ultima modifica: May 1, 2023 10:37 AM Primo Abbozzo: April 30, 2023 5:06 PM Studi Personali: No
Elementi di ripasso 2022-06-10 Es 3 (sicurezza) Testo [15] Alice spedisce a Bob un messaggio M1 molto grande con la sola garanzia di non ripudiabilità (ovvero Alice non potrà mai dimostrare di avere spedito un messaggio diverso da quello ricevuto da Bob), ma non serve privacy (tutti possono leggere M1). Bob in seguito risponde ad Alice con un messaggio m2 molto piccolo del quale deve essere però data garanzia di mittente (solo Bob può averlo spedito), di privacy (nessuno oltre ad Alice può leggerlo) e non Replay (ovvero Alice deve accettarlo una volta sola da Bob).</description>
    </item>
    <item>
      <title>Garbage Collection</title>
      <link>https://flecart.github.io/notes/garbage-collection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/garbage-collection/</guid>
      <description>On dangling pointers Tombstones 🟩 Slides tombstones
Quando alloco, alloco anche una tombstone, e tutti i riferimenti passano per quella. (quindi ho due dereference per l’accesso) quando vado a deallocare segno la tombstone come RIP, NULL.
Dopo molto tempo ho il problema del cimitero che diventa molto grande. Anche se non punta più a niente, il cimitero.
Keys and locks 🟩 Un pò di overhead in più dal punto di vista della memoria, che è doppio</description>
    </item>
    <item>
      <title>Metodi di Discesa</title>
      <link>https://flecart.github.io/notes/metodi-di-discesa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/metodi-di-discesa/</guid>
      <description>Introduzione ai metodi di discesa. Generali sui metodi di discesa Vogliamo creare algoritmi che riescano a trovare i punti di minimo delle funzioni non vincolate.
In generale si trova un punto stazionario (condizioni necessarie) ma non è garantito lo stato ottimo.
Solitamente sono divisi in first order methods in cui viene considerata solamente la derivata prima della funzione. E cose di metodi superiori.
Condizioni di arresto classiche (2) 🟩- Slide</description>
    </item>
    <item>
      <title>VLAN</title>
      <link>https://flecart.github.io/notes/vlan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/vlan/</guid>
      <description>Ultima modifica: May 17, 2023 3:14 PM Primo Abbozzo: May 17, 2023 1:48 PM Studi Personali: No
Elementi di ripasso VLAN Introduzione Quando abbiamo una switch, ma vogliamo allo stesso momento andare a creare più LAN, allora abbiamo bisogno delle VLAN. Questi switch che hanno delle VLAN si chiamano managed switches
Queste vlan sono numerate (ricorda l’espericomento cn LUCA!).
Il problema Sono un protocollo livello 2 (Link-Layer, di collegamento), non vorremmo per esempio che un broadcast di una certa rete vada anche in altre reti che non centrino praticamente nulla, come possiamo vedere in figura.</description>
    </item>
    <item>
      <title>Antenne</title>
      <link>https://flecart.github.io/notes/antenne/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/antenne/</guid>
      <description>Omnidirezionali Antenne omnidirezionali 🟩 Slides antenne omnidirezionali
Il senso di omnidirezionale è in tutte le direzioni dell&amp;rsquo;antenna (nota: non è isotropico, perché non è da un singolo punto).
in passato era importante andare a guardare la direzione per trovare la polarizzazione migliore. Praticamente irradia a 360 gradi sul piano permedicolare all’antenna.
Esempio pattern di radiazione
Questo genere di antenne sono irrealizzabili la più simile è la antenna dipolo dipolo, ma comunque non rispetta le antenne in questo verso diciamo.</description>
    </item>
    <item>
      <title>Grafi</title>
      <link>https://flecart.github.io/notes/grafi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/grafi/</guid>
      <description>Rappresentazione e terminologia Operazioni importanti
Definizione di grafo È un insieme di nodi e di archi. (prendili da insiemi corretti)
Metodi di rappresentazione Liste di incidenza (In pratica numero tutti gli archi e storo il valore dell&amp;rsquo;arco incidente per ogni nodo)
Liste di adiacenza Classico usato per cp, si storano direttamente pointer a nodi di interesse
Matrici di adiacenza Se esiste un arco fra due nodi, metto un uno in questa posizione (si può utilizzare una cosa simile per mantenere il peso di un arco)</description>
    </item>
    <item>
      <title>HTTP e REST</title>
      <link>https://flecart.github.io/notes/http-e-rest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/http-e-rest/</guid>
      <description>HTTP HYPERTEXT-TRANSFER-PROTOCOL
Caratteristiche principali (3) 🟨 Slide caratteristiche
Comunicazioni fra client e server, e quanto sono comunicate le cose si chiude la connessione e ci sono politiche di caching molto bone (tipo con i proxy) Generico: perché è un protocollo utilizzato per caricare moltissime tipologie di risorse! Stateless, ossia non vengono mantenute informazioni su scambi vecchi, in un certo modo ne abbiamo parlato in Sicurezza delle reti quando abbiamo parlato di firewall stateless.</description>
    </item>
    <item>
      <title>Introduzione a blockchain</title>
      <link>https://flecart.github.io/notes/introduzione-a-blockchain/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-a-blockchain/</guid>
      <description>Blockchain stack Vogliamo andare ora a descrivere la stack delle blockchain, in modo simile a quanto fatto con le internet, perché anche qui possiamo organizzarlo a stack!
Nota: le astrazioni fra questi layer non sono definiti bene come osi osint.
Layer - 0 Internet Internet (semi-reliable point-to-point communication) and cryptography (specifically, cryptographic hash functions and secure digital signatures).
Layer - 1 Consensus Ci concentreremo sui protocolli di questo per la maggior parte di quanto faremo!</description>
    </item>
    <item>
      <title>Nomi e Scope</title>
      <link>https://flecart.github.io/notes/nomi-e-scope/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/nomi-e-scope/</guid>
      <description>I Nomi e oggetti Oggetti denotati e identificatori🟩 I nomi sono sequenze di caratteri o numeri aka: token alfanumerico (anche IDENTIFICATORE (per token guardare Grammatiche Regolari) utilizzate principalmente come Astrazione sul controllo e sui dati (quindi sono cose molto più facili da ricordare rispetto il suo encoding binario o a indirizzi). Infatti utilizziamo i nomi per evitare di interessarci di informazioni come l’indirizzo di memoria del nostro dato o per creare una interfaccia con visibili solo nome della procedura e parametri.</description>
    </item>
    <item>
      <title>Polimorfismo</title>
      <link>https://flecart.github.io/notes/polimorfismo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/polimorfismo/</guid>
      <description>Introduzione Monoforfo 🟩 Quando non posso utilizzare un tipo come parametro. Ossia non possiamo definire una funzione generica.
Slide monomorfismo
Polimorfismo Polimorfismo, come dice il nome, significa avere tante forme, in questo caso tanti tipi. Ma avere tanti tipi non è una cosa ambigua? Questa cosa si risolve solitamente a compile time (facendo checks di sottotipo, oppure dispatch della funzione corretta).
Tipologie di Polimorfismo (3) 🟩 Slide tipologie di monomorfismo</description>
    </item>
    <item>
      <title>Project Management</title>
      <link>https://flecart.github.io/notes/project-management/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/project-management/</guid>
      <description>Project, product management, project management Bisogna capire queste definizioni. Vedere https://dynamik.vercel.app/ingegneria-del-software/lucidi/13-gestione-del-progetto.pdf?from=informatica, slide 5 per definizione
Progetto: inizia e finisce in tempo preciso. È importante comunque ricordare gli steps principali per il progetto ossia ideazione, creazione, mantenimento, rilascio, e poi morte, questo in genere è per qualunque progetto.
Project Manager Compiti principali (costi e risorse) Vedere se il progetto è fattibile Allocare risorse Monitorare come sta andando. (preventivo e consuntivo). Work Breakdown structure Descrizione WBS È una suddivisione del progetto in piccoli sottoparti che si possono gestire in modo autonomo.</description>
    </item>
    <item>
      <title>Top-down Parser</title>
      <link>https://flecart.github.io/notes/top-down-parser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/top-down-parser/</guid>
      <description>Top-down Algoritmo di parsing 🟩 Slide
Questo si potrebbe considerare come algoritmo classico di parsing con non determinismo. (vado avanti, ed esploro tutto, senza look ahead).
Esempio di esecuzione
Commenti efficienza di sopra 🟩 È molto inefficiente, in particolare si potrebbe trovare una compessità esponenziale del tipo
$O(b^{|w|})$, con b il massimo numero di produzioni. (la produzione maggiore la espando sempre!)
Slide
Si può rendere molto più efficiente con un valore di lookahead.</description>
    </item>
    <item>
      <title>CSS</title>
      <link>https://flecart.github.io/notes/css/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/css/</guid>
      <description>Cascading Style Sheets Inizialmente HTML era per la presentazione, abbiamo ancora un pò di attributi storici e tag storici per questa parte di presentazione descritto in HTML e Markup.
Introduzione È un linguaggio indipendente per la descrizione della grafica. La cosa bella è iil fatto di essere indipendente, quindi è adatto a HTML, a XML e simili.
Una cosa particolare è il cascading quindi il fatto che dichiarazioni più nuove sovrascrivano o espandino dichiarazione vecchie.</description>
    </item>
    <item>
      <title>Scheduler</title>
      <link>https://flecart.github.io/notes/scheduler/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/scheduler/</guid>
      <description>Il suo scopo principale è gestire l&amp;rsquo;avvicendamento dei processi. Ad esempio sospendere il processo che chiede I/O. O un sistema time sharing, quando arriva un interrupt sul time.
Solitamente il nome scheduler è solamente un gestore dell&amp;rsquo;avvicendamento, si può quindi utilizzare per indicare scheduler di altro tipo.
Note introduttive Diagramma di Gantt Questo è il diagramma per presentare lo scheduling, ossia da quando a quando è eseguito cosa
Esempio gantt</description>
    </item>
    <item>
      <title>Transformers</title>
      <link>https://flecart.github.io/notes/transformers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/transformers/</guid>
      <description>TODO.
Positional encoding We need to keep positional information about the contents.
Th: High dimensional unit vectors are almost always orthogonal This theorem states that given $a, b \in \mathbb{R}^{n}$, and $\lVert a \rVert = \lVert b \rVert = 1$ we have that it is highly probable that $a \cdot b &lt; \varepsilon$. For a small epsilon. This is not exactly a formal proof (we haven&amp;rsquo;t formalized the idea of highly probable).</description>
    </item>
    <item>
      <title>Optimization methods</title>
      <link>https://flecart.github.io/notes/optimization-methods/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/optimization-methods/</guid>
      <description>Metodi altri sono trovare una approssimazione facile da calcolare (simile all&amp;rsquo;approccio del modello surrogato credo). Ma nel nostro caso proviamo a trovare metodi di esplorare lo spazio dei parametri in modo intelligente.
Deterministic methods Sono utilizzabili quando ci sono delle proprietà come convessità, limitatezza, continuità.
Newton Raphson method Molte implementazioni in R usano questo metodo, è
Perfetto quando $h$ è quadratico, e in statistica molti problemi sono quadratici e funziona in modo perfetto Ma in cose non lineari si ha meno performance (perché l&amp;rsquo;hessiana è molto instabile per l&amp;rsquo;inversione, si dice che è mal condizionata, e si fa con attenzione.</description>
    </item>
    <item>
      <title>Linguaggi Deterministici e DPDA</title>
      <link>https://flecart.github.io/notes/linguaggi-deterministici-e-dpda/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/linguaggi-deterministici-e-dpda/</guid>
      <description>DPDA Definizione (2)🟩 La definizione di DPDA è molto simile a quella trattata in Linguaggi liberi e PDA, con solo costraints sulla deterministicità, che si traducono in due condizioni:
Al massimo posso avere un risultato per ogni coppia di lettura e simbolo su stack Se ho una transizione senza leggere, posso avere solo quella Slide
Linguaggio libero deterministico Un linguaggio è libero deterministico se esiste un PDA che lo riconosce per stato finale.</description>
    </item>
    <item>
      <title>Metadati web e web semantico</title>
      <link>https://flecart.github.io/notes/metadati-web-e-web-semantico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/metadati-web-e-web-semantico/</guid>
      <description>Ripasso: May 19, 2023 Ultima modifica: May 11, 2023 8:38 PM Primo Abbozzo: May 5, 2023 2:21 PM Studi Personali: No
Metadati web https://csunibo.github.io/tecnologie-web/lucidi/teoria/23-metadati.pdf https://csunibo.github.io/tecnologie-web/lucidi/teoria/24-a-web-semantico-lod-rdf-json-ld.pdf
inconfrontabilità del sapere Stessa informazione in forme diverse Stessa parola per cose diversa. Serializzazione La semantica è relegata alle applicazioni che devono decidere in che modo interpretarli, oppure esseri umani.
PICS Platform for Internet Content Selection vuole cercare di tenere sotto controllo i materiali del film.</description>
    </item>
    <item>
      <title>Tecniche algoritmiche</title>
      <link>https://flecart.github.io/notes/tecniche-algoritmiche/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/tecniche-algoritmiche/</guid>
      <description>In questa nota andiamo a parlare in modo sommario (si impara probabilmente molto meglio con la pratica) di generali tipologie di approcci che esistono per affrontare problemi di tipo algoritmico.
Divide et impera Introduzione Abbiamo già visto L&amp;rsquo;utilizzo di questa tecnica per quick e merge sort in Algoritmi di ordinamento
Questa tecnica si focalizza in tre passi fondamentali:
Dividere il problema in sotto-problemi Risolvere il sotto-problema Mergiare le soluzioni di questi sotto-problemi.</description>
    </item>
    <item>
      <title>Algebra dei tipi</title>
      <link>https://flecart.github.io/notes/algebra-dei-tipi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algebra-dei-tipi/</guid>
      <description>Equivalenza dei tipi (2) 🟩 Quando possiamo dire che due tipi siano uguali? Solitamente vengono utilizzati due metodi:
Equivalenza Nominale Quando un nuono tipo introduce un nuovo nome diverso fra tutti i presenti. Credo così vada golang. Quindi in questo caso si può dire che un tipo è equivalente solamente a sé stesso.
Vogliamo fare in questo modo perché se definiamo un nuovo tipo solitamente dovrebbe avere funzioni diverse, quindi è giusto che sia diverso da uqello iniziale.</description>
    </item>
    <item>
      <title>Javascript</title>
      <link>https://flecart.github.io/notes/javascript/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/javascript/</guid>
      <description>Ripasso: May 14, 2023 Ultima modifica: May 6, 2023 6:25 PM Primo Abbozzo: March 20, 2023 3:16 PM Studi Personali: No
Elementi di ripasso Javascript Obiettivo principale è esegurie codice clientside
Un pò di storia nato all’inizio della prima guerra dei browser (da netscape, explorer è in visual basic comunque non compatibile con JS) come il fratellino di java nel senso che runnava ovunque, attualmente è ECMAScript, ed è la versione migliore.</description>
    </item>
    <item>
      <title>Fondamenti teorica</title>
      <link>https://flecart.github.io/notes/fondamenti-teorica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/fondamenti-teorica/</guid>
      <description>https://virtuale.unibo.it/pluginfile.php/1295166/mod_resource/content/0/Lez18-Gorrieri.pdf
Halting problem Questo asserisce che non esiste nessun programma che sia in grado di decidere la terminazione di un altro programma
Questo è un problema che ci è interessante perché vorremmo costruire un compilatore che sia in grado di osservare tutti gli errori possibili del programma. Come vedremo tra poco la risposta sarà negativa.
Dimostrazione tesi 🟨++ Supponiamo che questo programma esista, lo chiamiamo check(P) che restituisce 0 se termina 1 se non termina, allora devo poter essere in grado di scrivere un programma di questo genere</description>
    </item>
    <item>
      <title>Goals of Distributed systems</title>
      <link>https://flecart.github.io/notes/goals-of-distributed-systems/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/goals-of-distributed-systems/</guid>
      <description>Dependable systems Introduzione Possiamo individuare alcune proprietà dei sistemi distribuiti. Però non siamo riusciti a renderli logicamente validi. Sono ancora un pò misti di linguaggio naturale e della sua ambiguità! Comunque possiamo ridurci per guardare quanto un sistema sia affidabile a guardare poche sue caratteristiche precise.
Caratteristiche fondamentali (4) Queste proprietà sono pensate naturalmente caratterizzanti dei sistemi. In particolare dovrebbero essere tutti misurabili.
Availability
Che risponde nell’istante in cui fai una richiesta.</description>
    </item>
    <item>
      <title>Inferential Social Learning</title>
      <link>https://flecart.github.io/notes/inferential-social-learning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/inferential-social-learning/</guid>
      <description>This is a theory from developmental psychology. It concerns about how a child is learning from a teacher. I discovered this field with (Gweon et al. 2023). But it is quite difficult to know how this could be useful for machines (not enough technical details about how).
The main idea is that
Childrens need to infer about teacher&amp;rsquo;s mental states to learn (I don&amp;rsquo;t know if this is true, but personally I don&amp;rsquo;t think is always true, you can learn with just a book, inferring mental states is not a necessity) Teacher&amp;rsquo;s need to choose the best example.</description>
    </item>
    <item>
      <title>Linguaggi liberi e PDA</title>
      <link>https://flecart.github.io/notes/linguaggi-liberi-e-pda/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/linguaggi-liberi-e-pda/</guid>
      <description>In questa parte del nostro percorso nei linguaggi di programmazione proviamo ad espandere NFA e DFA in modo che possano riconoscere linguaggi come $ww^r | w \in \{a, b\}^*$ , con r maggiore o uguale a zero (r per dire che è il contrario di w) (questo linguaggio per il pumping lemma).
Push-down automata Introduzione automi a pila (7)🟩 &amp;ndash; L’idea principale per espandere gli NFA è il concetto di stato o memoria, avere quindi una stack o pila può rendere molto più espressivo queste entità.</description>
    </item>
    <item>
      <title>Rappresentazione della conoscenza</title>
      <link>https://flecart.github.io/notes/rappresentazione-della-conoscenza/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/rappresentazione-della-conoscenza/</guid>
      <description>Questo è stato un capitolo molto vasto, che andava in certi punti a toccare la filosofia, la fisica. Un aspetto, quello di codifica delle informazioni reali in un ambiente logico (che per quanto i miei pregiudizi siano, ritengo una cosa molto impossibile, molto limitata e altrettanto impossibile). Si tratta dello studio della logica per rappresentazione di conoscenza.
Fatto sta che mi sembra assurdamente teorico tanto da non aver nessun utilizzo (probabilmente mi sbaglio di grosso), e che sia roba da filosofi.</description>
    </item>
    <item>
      <title>Valutazione Espressioni</title>
      <link>https://flecart.github.io/notes/valutazione-espressioni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/valutazione-espressioni/</guid>
      <description>Espressioni, Comandi, Ricorsione Espressioni Con espressione intendiamo una entità sintattica, che una volta valutata ritornerà un valore, oppure non termina, in questo caso si dice che la espressione è INDEFINITA.
Questa è una definizione è leggermente ambigua dato che non abbiamo una definizione precisa di valutazoine, che è fortemente dipendente dalla macchina astratta in cui viene eseguito.
Notazioni (sintassi possibili) (3) 🟩 Notazione infissa
Questa è la notazione classica matematica, per cose tipo $a -b$, in cui l&amp;rsquo;operando sta nel mezzo degli operatori.</description>
    </item>
    <item>
      <title>Algoritmi di ordinamento</title>
      <link>https://flecart.github.io/notes/algoritmi-di-ordinamento/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algoritmi-di-ordinamento/</guid>
      <description>6.1 Introduzione 6.1.1 L’importanza del topic Gli algoritmi di ordinamento sono molto di base per la comprensione dell&amp;rsquo;ampio raggio degli algoritmi. Utilizzano l&amp;rsquo;analisi, introducono tecniche di risoluzione dei problemi computazionali come greedy, divide et impera e simile. Permettono un primo uso di astrazioni e l&amp;rsquo;analisi di sottoproblemi.
6.1.2 Il problema Il problema è trovare una permutazione di un insieme di numeri iniziali tale per cui tale insieme di numeri si ordinato:</description>
    </item>
    <item>
      <title>Inverse Transform</title>
      <link>https://flecart.github.io/notes/inverse-transform/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/inverse-transform/</guid>
      <description>How can we transform a uniform into a random variable? It is true that we have $$ F(x) = \int _{-\infty}^{x} f(t) \, dt $$ A volte la densità non è definita, mentre la funzione cumulativa lo è , per questo spesso cominciamo a definire partendo dalla definizione.
Suppose we have a $x \sim F_{X}(x)$ where $F$ is a cumulative distribution function, same thing, we just need to take the set, normal cumulative distribution function that we saw a lot in other courses.</description>
    </item>
    <item>
      <title>Spazi di probabilita</title>
      <link>https://flecart.github.io/notes/spazi-di-probabilita/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/spazi-di-probabilita/</guid>
      <description>La probabilità Termini Esito ed esperimenti aleatorio L’evento è quello che accade, mentre un esperimento aleatorio qualcosa di cui vogliamo andare a misurare la probabilità diciamo. Esperimento aleatorio: esperimento di cui non conosciamo il risultato con certezza. Esito: risultato dell’esperimento aleatorio
Spazio campionario ed evento Spazio campionatorio Lo spazio campionatorio è l&amp;rsquo;insieme di tutti gli stati possibili per una certa cosa da misurare (ossia di un esperimento aleatorio), gli stati sono talvolta anche chiamati sample points oppure outcomes in modo più semplice.</description>
    </item>
    <item>
      <title>Wifi 802-11</title>
      <link>https://flecart.github.io/notes/wifi-802-11/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/wifi-802-11/</guid>
      <description>In this document, we will discuss the actual Wi-Fi standard that we can find in the market.
The initial slides consist of extensive lists of Wi-Fi technologies and their uses, such as Bluetooth network, Wi-Fi network, long-range Wi-Fi, and 3G network.
However, they are currently out of service.
Service Sets Basic Service Set There are various divisions within the service set, each of which provides certain types of service.
In the basic service, we have things like SSID, which is the service set identifier that is broadcasted in the beacon as described in Mac Wifi.</description>
    </item>
    <item>
      <title>Circuit Motifs</title>
      <link>https://flecart.github.io/notes/circuit-motifs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/circuit-motifs/</guid>
      <description>Work like (Luo 2021) show that our brain has naturally some types of circuits, which can be classified mainly as 4 types as described in (Wang et al.):
References [1] Luo “Architectures of Neuronal Circuits” Science Vol. 373(6559), pp. eabg7285 2021
[2] Wang et al. “CircuitNet: A Generic Neural Network to Realize Universal Circuit Motif Modeling”</description>
    </item>
    <item>
      <title>Fisica del Wireless</title>
      <link>https://flecart.github.io/notes/fisica-del-wireless/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/fisica-del-wireless/</guid>
      <description>Introduzione Radio 🟩 &amp;lt;img src=&amp;quot;/images/notes/image/universita/ex-notion/Fisica del Wireless/Untitled.png&amp;quot; alt=&amp;quot;image/universita/ex-notion/Fisica del Wireless/Untitled&amp;quot;&amp;gt; Antenna: converte corrente in segnali radiorequenza e viceversa. le segnali radiofrequenza sono onde radio con frequenza diversa per rappresentare 1 o 0. Un altro modo per mandare 1 o 0 sarebbe semplicemente cambiare l’intensità della onda, mantenendo la stessa frequenza.
Viene utilizzata una variazione di potenziale elettrico per creare il segnale, dovrebbe essere un oscillatore armonico in pratica credo. Creando questo flusso di elettroni, crea anche un campo elettromagnetico a lui ortogonale, questa è l’onda radio, che si propaga alla velocità della luce.</description>
    </item>
    <item>
      <title>Mac Wifi</title>
      <link>https://flecart.github.io/notes/mac-wifi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/mac-wifi/</guid>
      <description>Introduzione Ricordiamo che vogliamo cercare di arbitrare l’accesso al canale fisico sottostante. In questo momento andiamo ad assumere di avere già tutto l’impianto di trasmissione fisica che abbiamo in Tecnologia Wireless, Modulazione wireless Fisica del Wireless.
Obiettivi: Arbitraggio del singolo canale fisico (la tesi di dottorato del prof era su collision avoidance di wifi). Sia in tempo Sia in spazio (come gestire il segnale mandato nello stesso spazio) Utilizzo minimo di energia Quality of service Adaptive behaviour (come il 6G che vuole andare ad utilizzare AI per fare predizione).</description>
    </item>
    <item>
      <title>Descrizione linguaggio</title>
      <link>https://flecart.github.io/notes/descrizione-linguaggio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/descrizione-linguaggio/</guid>
      <description>Introduzione Per questa parte c’è un sacco di roba in comune con Tecniche di definizione di semantica (4) 🟩
Trattiamo alcune caratteristiche che descrivono ad alto livello un linguaggio di programmazione. È da notare che questa parte della spiegazione del linguaggio non è limitante al solo linguaggio di programmazione, è utile per analizzare tutti i linguaggi (tranne la parte di implementazione)
Sintassi 🟩- Relazione fra segni. si occupa di decidere quando una frase è corretta.</description>
    </item>
    <item>
      <title>Measure Theory</title>
      <link>https://flecart.github.io/notes/measure-theory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/measure-theory/</guid>
      <description>Ultima modifica: September 18, 2022 9:43 AM Primo Abbozzo: September 16, 2022 9:52 AM Studi Personali: Yes
Elementi di ripasso Measure Theory Introduzione Requirements of the measure function Vorremmo cercare di estendere il concetto di misurabilità a gruppi molto più ampi di un singolo intervallo, vorrei creare una funzione che sia in grado di misurare degli insiemi. *su vedrà che sono impossibili).
Impossibilità di questi requirements (assurdo) Costruzione dell’insieme di interesse</description>
    </item>
    <item>
      <title>Norme e Condizionamento</title>
      <link>https://flecart.github.io/notes/norme-e-condizionamento/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/norme-e-condizionamento/</guid>
      <description>Errore inerente Bisogna cercare di generalizzare il concetto di errore e lo si fa con la norma
Norma vettoriale È una funzione da $f: \mathbb{R}^n \to \mathbb{R}$ indicata con due barrette, questa funzione mi dà un concetto di distanza.
Proprietà della norma Si definisce una norma una funzione che soddisfa queste proprietà
$\lVert x \rVert \geq 0$ per ogni $x \in \mathbb{R}^{n}$ $\lVert x \rVert = 0 \iff x = 0$ $\lVert \alpha x \rVert = \lvert \alpha \rvert \lVert x \rVert$ per ogni $x \in \mathbb{R}^{n}$ e $\alpha \in \mathbb{R}$ Vale la disuguaglianza triangolare, ossia $\forall x, y \in \mathbb{R}^{n}, \lVert x + y \rVert \leq \lVert x \rVert + \lVert y \rVert$.</description>
    </item>
    <item>
      <title>Object Detection</title>
      <link>https://flecart.github.io/notes/object-detection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/object-detection/</guid>
      <description>Introduction Semantic segmentation Vorremo trovare regioni che corrispondano a categorie diverse. E dividere in questo modo l’immagine secondo zone di informazione.
Object detection Vogliamo trovare il più piccolo box che vada a contenere l’oggetto. Questo è fatto con il bounding box.
In questo caso la funzione di loss è un pò più difficile da definire, si utilizza la funzione intersection over union con le aree, in pratica la percentuale di immagine comune diciamo.</description>
    </item>
    <item>
      <title>Object orientation</title>
      <link>https://flecart.github.io/notes/object-orientation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/object-orientation/</guid>
      <description>Ripasso Prox: 10 Ripasso: May 29, 2023 Ultima modifica: May 19, 2023 10:33 AM Primo Abbozzo: May 8, 2023 9:20 AM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
Elementi di ripasso Object orientation il tipo di dato astratto Introduzione Per questi tipi di dato non ci interessa di sapere cosa ci sia sotto (storato come bit? storato come sabbia boh), ci interessa solamente che abbia quei metodi, che possiamo in un certo senso identificare come la sua capsula, opaca in questo caso.</description>
    </item>
    <item>
      <title>Ambienti di sviluppo</title>
      <link>https://flecart.github.io/notes/ambienti-di-sviluppo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/ambienti-di-sviluppo/</guid>
      <description>Ultima modifica: March 24, 2023 7:35 PM Primo Abbozzo: March 24, 2023 2:23 PM Studi Personali: No
Ambienti di sviluppo Ambiente di sviluppo è diverso rispetto all’ambiente di deploy! bisognare fare delle differenze, sono dell macchine diverse, in questa sezione di documenti andiamo a parlare di norme e modi di lavorare per facilitare il metodo di sviluppo.
Note di compatibilità Front-end Le compatibilità, soprattutto per cose browser (quindi front-end) cambiano molto spesso, come fare a trackare queste cose?</description>
    </item>
    <item>
      <title>Fn Ordine superiore</title>
      <link>https://flecart.github.io/notes/fn-ordine-superiore/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/fn-ordine-superiore/</guid>
      <description>Questa parte è strettamente collegata conl a parte di Astrazione sul controllo.
Si parla di passare le funzioni come dati. e quindi possono essere passati come se fossero dei parametri.
un linguaggio di programmazione è di ordine superiore qualora ammetta funzioni sia come parametro che come risultato di altre funzioni.
La parte molto simile alla precedente è il fatto di valutare la funzione nell&amp;rsquo;ambiente iniziale, quindi bisogna utilizzare un sistema simile a quello del passaggio per nome.</description>
    </item>
    <item>
      <title>Sezioni Critiche</title>
      <link>https://flecart.github.io/notes/sezioni-critiche/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/sezioni-critiche/</guid>
      <description>Ripasso Prox: 80 Ripasso: May 21, 2023 Ultima modifica: March 12, 2023 10:00 AM Primo Abbozzo: October 8, 2022 11:30 AM Stato: 🌕🌕🌕🌕🌑 Studi Personali: No
Elementi di ripasso 2 Sezioni Critiche Introduzione La parte di un programma che utilizza una o più risorse condivise viene detta sezione critica (critical section, o CS)
Andiamo in questa altra parte a valutare certe soluzioni:
Programma d’esempio 🟩 Vorremmo garantire che a = b invariante.</description>
    </item>
    <item>
      <title>Automi e Regexp</title>
      <link>https://flecart.github.io/notes/automi-e-regexp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/automi-e-regexp/</guid>
      <description>Per l’analisi lessicale vogliamo cercare di ricordare le parole legali all&amp;rsquo;interno di questo linguaggio e questo è fatto con i linguaggi regolari.
Introduzione a analizzatori lessicali Token 🟩 Struttura del token è fatto da due parti
Identificatore della classe del token Identificatore del valore del token Pattern e lessema ci sono direi boh Pattern e Lessema 🟩 I pattern sono una descrizione generale della forma dei valori di una classe di token.</description>
    </item>
    <item>
      <title>Bias Variance Trade-off</title>
      <link>https://flecart.github.io/notes/bias-variance-trade-off/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bias-variance-trade-off/</guid>
      <description>Introduction È una cosa ormai risaputa che c&amp;rsquo;è una sorta di trade-off fra la varianza e il bias per una certo modello. Aumentare la varianza del modello certamente ci permetterà di avere un modello che abbia un errore di training molto basso, però appena vede dei dati nuovi non sarà in grado di generalizzare correttamente. Dall&amp;rsquo;altra parte avere un bias alto significa avere un modello eccessivamente semplice, poco flessibile, che comunque allenato non riesce ad avere una grande accuratezza né in fase di allenamento, né di in fase di validazione o di test.</description>
    </item>
    <item>
      <title>Gestione delle eccezioni</title>
      <link>https://flecart.github.io/notes/gestione-delle-eccezioni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gestione-delle-eccezioni/</guid>
      <description>Introduzione Metodi alternativi di gestione degli errori (3) 🟩 A volte le computazioni falliscono. Potremmo gestirle con i result come accennato in Polimorfismo, però diventa molto macchinoso fare tutte le funzioni che debbano inoltrare solamente delle results. bisogna trovare un modo più naturale. Ecco che arriva una gestione delle eccezioni direttamente nel linguaggio. Si tratta un sistema di comunicazione degli errori.
ALTRI METODI
Results, stile monadico, vedi sopra. definire dei valori eccezionali (questo si va spesso in C) Il chiamato dice al chiamante una cosa da chiamare quando fallisce.</description>
    </item>
    <item>
      <title>Algebra lineare numerica</title>
      <link>https://flecart.github.io/notes/algebra-lineare-numerica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algebra-lineare-numerica/</guid>
      <description>In questa sezione andiamo ad indagare metodi di scomposizione, iterativi e non. Ci sono molte matrici importanti per questa parte che dovremmo prendere confidenza.
Immagini Lab 2 images
Metodo di gauss Vogliamo cercare un metodo per calcolare soluzioni a sistemi di equazione del genere:
$Ax = b$, classico. Supponiamo che questo sistema abbia una soluzione.
Il nostro obiettivo sarebbe scomporre la matrice $A = LU$ come prodotto di due matrici Lower triangular e Upper triangular.</description>
    </item>
    <item>
      <title>Modulazione wireless</title>
      <link>https://flecart.github.io/notes/modulazione-wireless/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/modulazione-wireless/</guid>
      <description>Introduzione Digital modulation 🟨 Slide introduzione
Modulazione digitale: prendiamo un dato digitale e trasmesso con un segnale analogico, come le RF.
ASK: amplitude shift keying
FSK: frequency shift
PSK: phase shift
Questi sono i tre metodi principali, che dipendono dalle caratteristiche dell’onda descritte in Fisica del Wireless.
TRE CARATTERISTICHE
Power
Resistenza interferenze. (robustezza)
ANALOG MODULATION
Per modulare un segnale analogico si utilizzano principalemente AM o FM, amplitude o frequency modulation, raramente si utilizza PM.</description>
    </item>
    <item>
      <title>Data Plane</title>
      <link>https://flecart.github.io/notes/data-plane/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/data-plane/</guid>
      <description>Ripasso Prox: 30 Ripasso: May 20, 2023 Ultima modifica: May 14, 2023 5:18 PM Primo Abbozzo: March 10, 2023 12:10 PM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Introduzione Data or Control plane come fanno i router a fare forwarding dei pacchetti? e decidere come mandare? Come fanno a passare. Sono le tabelle di instradamento. Si può dire di end-to-end perché solamente il sender e receiver andranno a livello applicazione, e leggeranno le cose (se criptato veramente solo loro riescono a fare questo).</description>
    </item>
    <item>
      <title>Gruppi Normali</title>
      <link>https://flecart.github.io/notes/gruppi-normali/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gruppi-normali/</guid>
      <description>Elementi di ripasso Gruppi normali e quoziente Introduzione Definizione normalità Test del sottogruppo normale Dimostrazione
Il gruppo quoziente L’importanza del gruppo normale è che quando esso vale, possiamo avere il gurppo fattore
Dimostrazione
!</description>
    </item>
    <item>
      <title>Processi e thread</title>
      <link>https://flecart.github.io/notes/processi-e-thread/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/processi-e-thread/</guid>
      <description>Il processo e la gestione dell&amp;rsquo;esecuzione è uno dei compiti principali dei sistemi operativi. Lo vuole fare in maniera efficace ed efficiente, come descritto in Note sull’architettura.
Slide schema generale tabelle
Processi Il process control block è la struttura di dati principali da comprendere.
Ha una tabella dei file aperti, che sono dei file descriptor (all&amp;rsquo;interno della propria struttura di dati), riferiti a una tabella dell&amp;rsquo;interno sistema credo, e questi puntano a un VNode che permette di localizzarlo nella memoria secondaria.</description>
    </item>
    <item>
      <title>Deblur di immagini</title>
      <link>https://flecart.github.io/notes/deblur-di-immagini/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/deblur-di-immagini/</guid>
      <description>Origini di sfocatura &amp;lt;img src=&amp;quot;/images/notes/image/universita/ex-notion/Immagini/Untitled.png&amp;quot; alt=&amp;quot;image/universita/ex-notion/Immagini/Untitled&amp;quot;&amp;gt; Rumore causata da problemi fisici che sono errori di lettura del segnale analogico Questo si indica anche come errore gaussiano bianco e si può considerare additivo. Rumore causato dalla digitalizzazione, quindi dalla discretizzazione di essa. Slide formalizzazione errori per sfocatura
Point spread function Un unico pixel bianco sembra influenzare il suo ambiente nero, come in immagine
Vorremmo utilizzare delle funzioni ce siano in grado di approssimare questa funzione.</description>
    </item>
    <item>
      <title>Semantica di un linguaggio</title>
      <link>https://flecart.github.io/notes/semantica-di-un-linguaggio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/semantica-di-un-linguaggio/</guid>
      <description>Vincoli sintattici contestuali Intro: dipendenze da contesto 🟩 I vincoli sintattici non sono esprimibili tramite BNF perché dipendono dal contesto, mentre le grammatiche libere sono per definizione libere da contesto, vogliamo quindi trovare una soluzione a questo problema. Vengono usati metodi Ad-Hoc nella fase di analisi semantica del programma.
Grammatiche dipendenti dal contesto
Queste grammatiche sono molto più complicate (e lente) rispetto a quelle libere da contesto, quindi è poco pratico e non utilizzabile (tempo esponenziale, quindi non finisce mai).</description>
    </item>
    <item>
      <title>Semplificazione grammatiche</title>
      <link>https://flecart.github.io/notes/semplificazione-grammatiche/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/semplificazione-grammatiche/</guid>
      <description>Gestione del non determinismo Il modo più facile per gestire il non determinsmo è semplificare le grammatiche quindi andiamo a vedere metodi per fare ciò.
Semplificazione grammatiche (5) Slide
No produzioni del tipo $A \to \varepsilon$ per bottom up (altrimenti va all’infinito!) No produzioni unitarie, così evito cicli in cui da A derivo sé stesso. No simboli inutili No ricorsione sinistra (divergenza per top-down) Fattorizzazione della grammatica Eliminazione delel produzioni nulle Vogliamo creare un algoritmo utile ad eliminare le produzioni che non ci piacciono.</description>
    </item>
    <item>
      <title>Syncronous model</title>
      <link>https://flecart.github.io/notes/syncronous-model/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/syncronous-model/</guid>
      <description>Introduction Da ricordare il &amp;ldquo;The State Machine Replication (SMR) Problem&amp;rdquo; in Consensus protocols che è importantissimo per comprendere questa parte.
Storia locale Transazioni al singolo noto Problema del sync fra tutti questi nodi.
Goal of SMR solution in blockchains Andiamo a considerare alcune proprietà di safety e liveness Programmi Concorrenti
Consistenza i nodi devono essere daccordo su quale transazione mettere prima e dopo → stessa storia per tutte le transazioni. (con la possibilità di alcuni nodi che siano indietro, ma solo prefisso!</description>
    </item>
    <item>
      <title>Cammini</title>
      <link>https://flecart.github.io/notes/cammini/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cammini/</guid>
      <description>Ultima modifica: October 17, 2021 10:38 AM Primo Abbozzo: October 16, 2021 5:16 PM Studi Personali: No
Elementi di ripasso 1 Cammini 1.1 Il cammino minimo 1.1.1 Definizione e caratteristiche 1.1.2 Costi negativi Sono cose molto brutte
1.1.3 Cammino minimo semplice Costruzione di cammini minimi 1.2 Vertici 1.2.1 definizione distanza fra due vertici Costo del cammino minimo che li connette
Condizione di bellman Albero dei cammini minimi Rilassamento Definizione Si va a vedere dove non funziona la disuguaglianza triangolare, se localmente non funziona ovvero se per esempio succede $D_{xu} + \omega(u,y) &lt; D_{xy}$ per qualche vertice all&amp;rsquo;interno del grafo, so di per certo che la distanza $D_{xy}$ non è una distanza, quindi possiamo riassegnarla in modo che verifichi la disuguaglianza</description>
    </item>
    <item>
      <title>Introduzione SO</title>
      <link>https://flecart.github.io/notes/introduzione-so/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-so/</guid>
      <description>Scopi del sistema operativo 🟩 Un sistema operativo è una astrazione sul HW che permette di
Gestire l’esecuzione di più programmi assieme (concorrenza), tramite virtualizzazione CPU e Memoria Gestire le risorse (Quindi I/O, RAM, Memoria, Networking) Fornisce una interfaccia di programmazione (API) molto più generale e potente, in grado di astrarre da dettagli di livello basso, vicini all’Hardware (come device drivers). Quindi in breve il SO è n programma che crea un ambiente civile per i programmi in cui interagire, e facilita molto il lavoro al programmatore per la sua interfaccia nuova.</description>
    </item>
    <item>
      <title>l’intelligenza</title>
      <link>https://flecart.github.io/notes/lintelligenza/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/lintelligenza/</guid>
      <description>1 Introduzione L’intelligenza artificiale è un campo in velocissima espansione, con già un mercato enorme di un trillion dollars.
Inoltre il suo campo di studi spazia da moltissimi campi, è per questo che quasi potresti considerarla universale.
1.1 L’intelligenza artificiale 1.1.1 Cosa è (2) Nel tempo si è cercato di definire con esattessa cosa sia l’intelligenza artificiale. In generare si è basato su alcuni parametri cardine ossia:
La capacità di replicare attività umane / la capacità di applicare attività razionali La capacità di ragionare / il comportamento intelligente Su questi due binomi sono stati fatti dei modelli, andiamo ora a scoprire in che senso l’intelligenza artificiale è intelligente.</description>
    </item>
    <item>
      <title>Log degli esercizi</title>
      <link>https://flecart.github.io/notes/log-degli-esercizi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/log-degli-esercizi/</guid>
      <description>Ultima modifica: May 13, 2023 4:44 PM Primo Abbozzo: January 14, 2023 11:55 AM Studi Personali: No
Log esercizi fatti Data, compito, C1 fatto? c2 fatto?
2022.09.06 [http://www.cs.unibo.it/~renzo/so/compiti/2022.09.06.tot.pdf] (36 KB) X X 2022.07.20 [http://www.cs.unibo.it/~renzo/so/compiti/2022.07.20.tot.pdf] (36 KB) X X (non me lo ricordo) 2022.06.21 [http://www.cs.unibo.it/~renzo/so/compiti/2022.06.21.tot.pdf] (40 KB) X X X 2022.06.01 [http://www.cs.unibo.it/~renzo/so/compiti/2022.06.01.tot.pdf] (36 KB) X X 2022.02.14 [http://www.cs.unibo.it/~renzo/so/compiti/2022.02.14.tot.pdf] (40 KB) X X 2022.01.17 [http://www.cs.unibo.it/~renzo/so/compiti/2022.01.17.tot.pdf] (36 KB) X X X X 2021.09.15 [http://www.</description>
    </item>
    <item>
      <title>Network Address Translation</title>
      <link>https://flecart.github.io/notes/network-address-translation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/network-address-translation/</guid>
      <description>NAT Network address translation Introduzione Col il NAT possiamo avere tutto lo spazio degli IP di cui abbiamo bisogno, che però non sono esposti. All&amp;rsquo;esterno vengono esposte solamente l’IP del NAT.
Schema classico NAT
Quindi in breve
All&amp;rsquo;esterno è esposto solamente l&amp;rsquo;indirizzo del router, il router, a seconda della porta giusta, dà in risposta al computer giusto, quindi all&amp;rsquo;interno della nostra rete conosciamo tutti gli indirizzi IP giusti.
Addr translation table 🟩 Sembra che ad ogni richiesta ci sia una table di transizione all&amp;rsquo;interno del router che matcha porta → indirizzo locale corretto!</description>
    </item>
    <item>
      <title>Function approximation</title>
      <link>https://flecart.github.io/notes/function-approximation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/function-approximation/</guid>
      <description>We have enormous state functions, having a generic approssimation could really help! We want to use a differentiable value function so that we can use gradient descent to optimize it, for example a good way of loss would be $$ J(w) = \mathbb{E}_\pi[(V^\pi(s) - \hat{V}^\pi(s;w))^2] $$ The second one is parametrized with $w$. There are two ways (recuperali!) MC policy or Time differential (that is boostrapped, instead the Monte carlo uses a full simulation in order to know what to use).</description>
    </item>
    <item>
      <title>Interpolazione</title>
      <link>https://flecart.github.io/notes/interpolazione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/interpolazione/</guid>
      <description>Vogliamo in questa sezione andare ad indagare la costruzione di funzioni che passano in tutti i punti che vogliamo, appunto interpolare. La funzione è molto simile alla regressione trattata in Minimi quadrati (con il metodo della regressione, chiamato anche approssimazione ai minimi quadrati).
Quindi mentre la precedente voleva andare a minimizzare l&amp;rsquo;errore, questo attuale va a creare proprio da 0 la funzione che ci passa sempre.
Introduzione Andremo a creare una funzione f tale che per ogni x in input si abbia esattamente la y in output</description>
    </item>
    <item>
      <title>Scelta del PO</title>
      <link>https://flecart.github.io/notes/scelta-del-po/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/scelta-del-po/</guid>
      <description>La cosa che rende il PO diverso rispetto agli sviluppatori è la conoscenza delle necessità del cliente. Questo permette di prioritizzare del task e capire in che modo dovrebbe essere il prodotto finale. In questo modo si crea una vision del prodotto. Pensiamo che il PO debba condividere questa informazione e prendere decisioni di gruppo.
Domande da fare: La user interface, come sembra il wireframe? Pensavamo di utilizzare i social solamente per i login, pensavate di utilizzare anche per altro durante il gioco?</description>
    </item>
    <item>
      <title>Accept Reject algorithm</title>
      <link>https://flecart.github.io/notes/accept-reject-algorithm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/accept-reject-algorithm/</guid>
      <description>Some useful links Main results: https://jblevins.org/notes/accept-reject
Intuition: https://en.wikipedia.org/wiki/Rejection_sampling
La cosa è che faccio sampling fra due distribuzioni diverse e devo settare anche un parametro (e a seconda di certe cose diventa molto lento).
Introduzione al metodo Vorrei utilizzare una funzione $g$ per generarne una altra, questo è il fulcro del concetto. L&amp;rsquo;idea principale è:
Conosco la funzione densità della funzione $f$ che voglio andare a generare Riesco a generare seguendo una funzione semplice, la chiamo $g$, candidate density.</description>
    </item>
    <item>
      <title>Gruppi</title>
      <link>https://flecart.github.io/notes/gruppi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/gruppi/</guid>
      <description>Definizione gruppo Qualunque insieme più operazione tale per cui:
Esistenza dell&amp;rsquo;inverso per ogni elemento $\forall g \in G, \exists g^{-1} \in G : gg^{-1} = e$ Esistenza di un elemento neutro $\exists e \in G: \forall g \in G, eg = g$ Associatività: $(gh)f = g(hf)$ Closure: $\forall g, h \in G \implies gh \in G$ Unicità dell’elemento neutro Supponiamo di avere un gruppo $G$ e due elementi neutri $e, f$ Allora abbiamo che $ae = a = af$ però se moltiplichiamo per l&amp;rsquo;inversa abbiamo che $a^{-1}ae = a^{-1}af \implies e = f$</description>
    </item>
    <item>
      <title>Introduction to computational statistics</title>
      <link>https://flecart.github.io/notes/introduction-to-computational-statistics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduction-to-computational-statistics/</guid>
      <description>What is it for Estimation Sampling generate numbers from any distribution! (distributions are important in statistics). Density Cumulative distribution (and others similar). Optimization how to find computationally the min and max of functions. Generating?
Random (difficile anche filosoficamente definire cosa significa questo). Molto importante perché si assume in Comp stats che abbiamo il random vero, e questa assunzione che non vale può rompere cose. And independent Sample proportion Average of something (example of the lake cannonball).</description>
    </item>
    <item>
      <title>Memoria virtuale</title>
      <link>https://flecart.github.io/notes/memoria-virtuale/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/memoria-virtuale/</guid>
      <description>Memoria virtuale Perché è utile la MV? 🟨- I programmi non usano tutta la memoria, ma pensano di averla tutta disponibile dal suo punto di vista. L&amp;rsquo;idea principale è che molte zone di memoria sono inutili per lungo tempo, possono essere utilizzati per altro.
caricamento codice dinamico Per esempio anche a caricare il codice di un compilatore è diviso in fasi, se andiamo a caricare tutto, stiamo utilizzando solo un pezzo piccolo, tanta inefficienza, se una pagina contiene una parte del compilatore potrei caricare in memoria solamente le parti eseguite sul momento, giusto per fare un esempio diciamo.</description>
    </item>
    <item>
      <title>Monte carlo integration</title>
      <link>https://flecart.github.io/notes/monte-carlo-integration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/monte-carlo-integration/</guid>
      <description>DI Law of Large Numbers e Central limit theorem ne parliamo in Central Limit Theorem and Law of Large Numbers. Usually these methods are useful when you need to calculate following something similar to Bayes rule, but don&amp;rsquo;t know how to calculate the denominator, often infeasible integral. We estimate this value without explicitly calculating that.
Interested in $\mathbb{P}(x) = \frac{1}{z} \mathbb{P}^{*}(x) = \frac{1}{Z} e^{-E(x)}$ Can evaluate E(x) at any x.</description>
    </item>
    <item>
      <title>Partially synchronous model</title>
      <link>https://flecart.github.io/notes/partially-synchronous-model/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/partially-synchronous-model/</guid>
      <description>Ultima modifica: January 3, 2023 3:59 PM Primo Abbozzo: January 3, 2023 3:58 PM Studi Personali: No
Elementi di ripasso Argomento https://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf</description>
    </item>
    <item>
      <title>Recurrent Neural Networks</title>
      <link>https://flecart.github.io/notes/recurrent-neural-networks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/recurrent-neural-networks/</guid>
      <description>Introduzione ai RNN Vorremmo costruire un modello che fosse in grado di predire delle cose che dipendono da vecchie sequenze (quindi un network che abbia in un qualche senso la memoria di un coso passato).
Riassunto in slide Formalizzazione del network Stato interno La differenza principale col percettrone è la presenza di uno stato interno nascosto, che continua a trasformarsi a seconda degli input, lo chiamiamo interno perché non è dato in output, ma viene se</description>
    </item>
    <item>
      <title>Deduzione naturale</title>
      <link>https://flecart.github.io/notes/deduzione-naturale/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/deduzione-naturale/</guid>
      <description>La deduzione naturale è un possibile sistema deduttivo che utilizza il linguaggio naturale per questo motivo più beginner friendly. Lo facciamo prima per la Logica Proposizionale che è molto facile
Il sistema deduttivo Poniamo l&amp;rsquo;esistenza di Assiomi (formule in una certa logica) e regole di inferenza definite sotto. Esempi sono $P \vdash \varphi$ se $\varphi$ è un assioma. O altre cose simili con $\land$ e simili&amp;hellip;
Una dimostrazione allora è una sequenza di $\varphi_{1}, \dots, \varphi_{n}$ dove $\varphi_{i}$ è derivata con le regole di inferenza e $\varphi_{1}, \dots, \varphi_{i - 1}$.</description>
    </item>
    <item>
      <title>Preparazione Esame</title>
      <link>https://flecart.github.io/notes/preparazione-esame/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/preparazione-esame/</guid>
      <description>Ultima modifica: June 21, 2023 9:07 PM Primo Abbozzo: June 17, 2023 11:59 PM Studi Personali: No
URI Cosa sono? Per cosa vengono utilizzati? Che differenza c&amp;rsquo;è fra URL e URN? sintassi dell’URI Alcuni esempi di schema (e relativo utilizzo e sintassi per l’URI) IRI e IDN, cosa sono? Cosa sono i CURIE? Cosa è URL Ref e come viene risolto Cosa è uri resolution, e cosa uri dereference? Cosa è LOD?</description>
    </item>
    <item>
      <title>Explainability of CNN</title>
      <link>https://flecart.github.io/notes/explainability-of-cnn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/explainability-of-cnn/</guid>
      <description>Introduction Capire in che modo una rete convoluzionale ci può dare insight migliori su come funzionano questi networks.
Visualizzazione dei hidden layers Slide visualization
Potremmo fissare una immagine anche a caso, e modificare la x in modo che sia più simile a quanto vuole computare il neurone. In questo modo genero una immagine che generi una activation forte nel neuron trainato, e si potrebbe dire che sia il genere di immagine che viene generata da essa.</description>
    </item>
    <item>
      <title>Proximal Polixy Optimization</title>
      <link>https://flecart.github.io/notes/proximal-polixy-optimization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/proximal-polixy-optimization/</guid>
      <description>This documents attempts to briefly present the algorithm and some experiments found online about it. The following repo seems to be a good resource: here.
Usually, PPO is explained as an actor critic framework. This means there is an agent that acts on the environment, and then there is a critic that collects the feedback from the environment. The main idea about this framework is to select a policy that is similar, so that it is less probable that a bad policy, a very different policy from the original is selected.</description>
    </item>
    <item>
      <title>Teoria dei Tipi</title>
      <link>https://flecart.github.io/notes/teoria-dei-tipi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/teoria-dei-tipi/</guid>
      <description>Ripasso Prox: 30 Ripasso: June 6, 2023 Ultima modifica: May 14, 2023 6:13 PM Primo Abbozzo: March 13, 2023 9:20 AM Studi Personali: No
Elementi di ripasso Teoria dei Tipi Introduzione Definizione 🟩— Un metodo sintattico praticabile per dimostrare l&amp;rsquo;assenza di determinati comportamenti del programma, fatto classificando le unità sintattiche in base ai tipi di valore che assumono
Vogliamo che fosse praticabile nel senso che effettivamente lo possiamo implementare, cioè ci permettono di avere certe tipologie di garanzia.</description>
    </item>
    <item>
      <title>HTML e Markup</title>
      <link>https://flecart.github.io/notes/html-e-markup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/html-e-markup/</guid>
      <description>Markup Introduzione alle funzioni del markup 🟩 La semantica di una parola è caratterizzata dalla mia scelta (design sul significato). Non mi dice molto, quindi proviamo a raccontare qualcosa in più.
Definiamo markup ogni mezzo per rendere esplicita una particolare interpretazione di un testo.
In particolare è un modo per esplicitare qualche significato. (un pò come la punteggiatura, che da qualche altra informazione oltre le singole parole, rende più chiaro l&amp;rsquo;uso del testo).</description>
    </item>
    <item>
      <title>Paginazione e segmentazione</title>
      <link>https://flecart.github.io/notes/paginazione-e-segmentazione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/paginazione-e-segmentazione/</guid>
      <description>Memoria sistema Operativo Guradare Memoria virtuale Per vedere come vengono rimpiazzate le pagine
In quest sezione andiamo a parlare di come fanno molti processi a venire eseguiti insieme, anche se lo spazio di memoria fisico è lo stesso. Andiamo quindi a parlare di spazio di indirizzi, risoluzione di questi indirizzi logici, segmentazione e paginazione. (e molto di più!)
MMU Controlla se l’accesso di memoria è bono o meno. (traduzione fra indirizzo logico e fisico)</description>
    </item>
    <item>
      <title>Semafori</title>
      <link>https://flecart.github.io/notes/semafori/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/semafori/</guid>
      <description>Introduzione Concetto principale 🟩- È sempre stato introdotto da Dijkstra, 1965 (Cooperating Sequential Processes) utilizzato come strumento di cooperazione semplice
Questo è un sistema fortemente ispirato dai semafori che regolano gli incroci stradali.
due o più processi possono cooperare attraverso semplici segnali, in modo tale che un processo possa essere bloccato in specifici punti del suo programma finché non riceve un segnale da un altro processo
Primitive dei semafori 🟩- Il semaforo solitamente è una variabile intera non negativa.</description>
    </item>
    <item>
      <title>CSP problems</title>
      <link>https://flecart.github.io/notes/csp-problems/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/csp-problems/</guid>
      <description>Costraint Satisfaction Problems.
Definizione Caratteristiche Variabili Dominio per ogni variabile Costraints per ogni variabile Queste tre sono elementi che definiscono un problema di soddisfazione delle restrizioni, una soluzione è un assegnamento di variabili che soddisfi ogni restrizioone e sia all’interno del dominio
Consistenza Vogliamo andare a limitare il dominio valutando le consistenze possibili
Consistenza del punto Si può dire che un punto sia consistente se le sue variabili possibili non viola nessuna restrizione unaria: eg.</description>
    </item>
    <item>
      <title>Filesystem</title>
      <link>https://flecart.github.io/notes/filesystem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/filesystem/</guid>
      <description>Perché filesystem? Questa è l&amp;rsquo;idea presa dall&amp;rsquo;archivio, come se fosse un ufficio che deve tenere delle pratiche ordinate in cartelle e cartelloni.
L’utilizzo principale è dare un interfaccia comune di accesso ai dispositivi. perché dispositivi diversi hanno sotto modi di accedere diversi, questa interfaccia facilita molto l&amp;rsquo;accesso.
Informazioni dei files (5+) 🟨 Il file è l’unità logica di memorizzazione. il formato che c&amp;rsquo;è dentro è gestito dall&amp;rsquo;applicazione, non dal file system!</description>
    </item>
    <item>
      <title>Introduction to statistical learning</title>
      <link>https://flecart.github.io/notes/introduction-to-statistical-learning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduction-to-statistical-learning/</guid>
      <description>#statistics
Introduzione This is a short introduction to statistical learning, made with the help of the book ISLP (mi sento positivo ad affrontare la lettura di questo libro, ora che sta in python non lo vedo più come un libro solamente per statistici)
statistical learning refers to a set of approaches for estimating $f$ .
Utilizzi del statistical learning Solitamente sono due gli utilizzi Predizione e inferenza. Per predizione intendiamo il miglior modello che possa produrre le Y che ancora non conosciamo.</description>
    </item>
    <item>
      <title>Introduction to Theory of Mind</title>
      <link>https://flecart.github.io/notes/introduction-to-theory-of-mind/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduction-to-theory-of-mind/</guid>
      <description>In this note I will try to write down some of my own research I conducted in this field for my bachelor&amp;rsquo;s thesis. This will be a set of notes that try to describe what Theory of Mind (ToM) is generally considered to be in the scientific community.
What is Theory of Mind? This term has been popularized by (Premack &amp;amp; Woodruff 1978) in the study of Chimpanzees. In his seminal article in 1978, Premack describes the theory of mind as the ability of individuals to ascribe mental states of themselves and other individuals, such as sensory perceptions, beliefs, and desires, and the ability to use this knowledge about other individuals to predict their behaviour.</description>
    </item>
    <item>
      <title>Teorema di Lagrange</title>
      <link>https://flecart.github.io/notes/teorema-di-lagrange/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/teorema-di-lagrange/</guid>
      <description>Classi laterali Dimostrazione dei lemmi sopra. La cosa interessante di questa parte è possiamo usare una classe laterale per partizionare il gruppo iniziale!
Il teorema di Lagrange Dividere significa che **partiziona** l&#39;insieme iniziale in alcuni insiemi distinti. L&#39;insieme $G:H$ è l&#39;insieme che contiene tutti i cosets, credo. Dimostrazione
|G:H| = |G|/|H| |a| divide |G| Ossia un corollario dopo il teorema di Lagrange. La cosa citata è dimostrata in Gruppi ciclici e permutazioni#Criterio $a {i} = a {j}$.</description>
    </item>
    <item>
      <title>Training a NN</title>
      <link>https://flecart.github.io/notes/training-a-nn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/training-a-nn/</guid>
      <description>Ultima modifica: March 11, 2023 7:22 PM Primo Abbozzo: March 8, 2023 6:05 PM Studi Personali: No
Elementi di ripasso Training of NN How can we be sure that we can train well our function?
Dataset quality (this cannot be changed in training time) Models and parameters of our model, we can describe it as $L(x, \theta)$, and we try to minimize this function. Training approaches Random perturn weights, this is ispired by evolution, but it’s slow and not effective (and we can make things worse in many ways) Predict adjustments, usually we can analitically define what is the best way to minimize the loss, so we would like to follow that slope and go down!</description>
    </item>
    <item>
      <title>Architettura software dell’OS</title>
      <link>https://flecart.github.io/notes/architettura-software-dellos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/architettura-software-dellos/</guid>
      <description>A seconda dell&amp;rsquo;utilizzatore l’OS può essere molte cose, come solamente l’interfaccia se sei un programmatore, servizi (se sei un utente, ma gran parte dei servizi sono astratti e l&amp;rsquo;utente ne può anche essere a non-conoscenza).
Ma se sei un programmatore OS ti interessa capire le componenti principali dell’OS
Slide componenti OS alto livello
Introduzione sui componenti (salto) Questa parte la salto perché è una descrizione molto generale di cosa si occupa L’os verso drivers, processi, filesystem I/O, quindi non è molto importante</description>
    </item>
    <item>
      <title>Introduzione a reti</title>
      <link>https://flecart.github.io/notes/introduzione-a-reti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-a-reti/</guid>
      <description>Questa nota raccoglie note introduttive al corso di reti dei calcolatori fatto all&amp;rsquo;università di Bologna.
0.1.1 Definizione di rete di calcolatori (2) 🟩- I requisiti sono principalmente 2
Essere autonomi nel calcolo (capacità di eseguire dei programmi) Essere interconnessi (capacità di ricevere ed inviare dei segnali) Gli scopi sono principalmente per la comunicazione fra utenti o calcolatori.
Non-esempi
Rete telefonica, non sono autonomi Rete televisiva Esempi
Smartphones con wi-fi WWW E-mail Una rete di calcolatori è un insieme di dispositivi autonomi, cioè in grado di eseguire e svolgere autonomamente i compiti programmati di calcolo e di comunicazione, interconnessi tra loro da supporti fisici alla trasmissione di segnali.</description>
    </item>
    <item>
      <title>Planning automatico</title>
      <link>https://flecart.github.io/notes/planning-automatico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/planning-automatico/</guid>
      <description>Planning Automatico Vogliamo andare a creare un programma che sia in grado di creare un piano per fare una azione, andiamo in questo capitolo gli algoritmi storicamente migliori adatti a risolvere questo problema
Il problema di pianificazione Andiamo a rappresentare il nostro problema di pianificazione con un linguaggio molto simile alla Logica del Primo ordine.
È il PDDL ossia il Planning domain definition language
PDDL Questo linguaggio è definito da</description>
    </item>
    <item>
      <title>Attention</title>
      <link>https://flecart.github.io/notes/attention/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/attention/</guid>
      <description>This note tries to summarize what I think I know about the attention architecture in Transformers. First introduced in (Bahdanau et al. 2014). Attention is an architecture used in Transformers to encode a soft version of dictionaries. Usually it is called self-attention when everything we want is just trying to change the values of the $X$ with a value. This value is called attention weight.
In standard attention based architectures the self-attention layer is computed as follows.</description>
    </item>
    <item>
      <title>Livello di trasporto</title>
      <link>https://flecart.github.io/notes/livello-di-trasporto/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/livello-di-trasporto/</guid>
      <description>Guardare la parte equivalente in Note Esame che è simile.
Livello di trasporto Si parla di livello logico di trasporto, ma gran parte ne abbiamo già parlato in Livello applicazione e socket di UDP, TCP e Socket. trasporto end-to-end, nel senso che livello traporto viene visto solamente ad inizio e alla fine, in tutti i nodi intermedi non è visto sto pacchetto.
UDP (3) 🟩- Slide UDP
Classico inizio e fine porta del socket.</description>
    </item>
    <item>
      <title>Message Passing</title>
      <link>https://flecart.github.io/notes/message-passing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/message-passing/</guid>
      <description>ora abbiamo alcune primitive per passarci i messaggi, vogliamo creare metodo in modo che i processi si possano sincronizzare mandando messaggi.
la memoria è sempre privata.
Primitive Send e receive 🟩 Send
Spedizione del messaggio input deve avere un identificato al processo su cui spedire. Se si vuole espandere si possono avere multicast e broadcasting ma non li studieremo in questo corso.
Receive
Ricevi messaggi
Tassonomia dei message passing (!)🟩 Slide</description>
    </item>
    <item>
      <title>Kolmogorov complexity</title>
      <link>https://flecart.github.io/notes/kolmogorov-complexity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/kolmogorov-complexity/</guid>
      <description>Gran parte di quanto scrivo ora è tratto da (Li &amp;amp; Vitányi 2019). Chaitin, Kolmogorov e Solomonoff hanno elaborato il tema in modo indipendente e allo stesso tempo verso gli anni &amp;lsquo;60!
Solomonoff lo ha trovato sul problema dell&amp;rsquo;induzione all&amp;rsquo;età di 38 anni, Kolmogorov invece era già tardi, ha già trovato gli assiomi della probabilità e poi nel 65 cerca randomness. Mentre Chaiten Information = Computation e non probabilità, nel 68 all&amp;rsquo;età di 19 anni.</description>
    </item>
    <item>
      <title>Note sull’architettura</title>
      <link>https://flecart.github.io/notes/note-sullarchitettura/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/note-sullarchitettura/</guid>
      <description>Interrupt Descrizione iniziale 🟩 Di interrupt e trap se n’è parlato un pò in Livello ISA di architettura, ora andiamo ad approfondire come viene gestito a livello SO.
Un interrupt è un segnale che viene mandato o da un dispositivo hardware (di solito dopo la fine di un processo input output) oppure da software, in questo caso viene chiamato trap che è un interrupt software sincrono..
Slide Interrupt Hardware e software</description>
    </item>
    <item>
      <title>Astrazione sul controllo</title>
      <link>https://flecart.github.io/notes/astrazione-sul-controllo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/astrazione-sul-controllo/</guid>
      <description>Significato di astrazione L&amp;rsquo;astrazione è una cosa fondamentale nell&amp;rsquo;informatica, l’abbiamo visto anche nella prima lezione in assoluto per architettura, il sistema a strati di Architettura e livelli 1, 2 reti e simili.
Il principali metodi sono astrazioni sul controllo e sui dati sui dati stiamo cominciando a parlarne in Teoria dei Tipi.
Le astrazioni sono utili a nascondere dettagli per qualche fenomeno o simile (ricorda l&amp;rsquo;esempio della mappa, che non è il territorio è una astrazione su essa, che contiene ancora informazioni utili).</description>
    </item>
    <item>
      <title>k-esimo priority-q DSU</title>
      <link>https://flecart.github.io/notes/k-esimo-priority-q-dsu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/k-esimo-priority-q-dsu/</guid>
      <description>Questo documento è totalmente concentrato sull&amp;rsquo;analisi del problema della selezione del k-esimo elemento.
7.1 Introduzione al problema Dato un array di elementi vogliamo cercare di trovare un modo efficiente per selezionare il k-esimo elemento, ossia un elemento che sia maggiore di k-1 elementi
7.1.1 Note sull&amp;rsquo;utilizzo Questo algoritmo è utile per esempio per sapere cosa displayare in una pagina di ricerca, perché per esempio posso avere blocchi di tanta roba 140k, mentre ovviamente posso selezionare solamente un blocco ristretto.</description>
    </item>
    <item>
      <title>Monitor</title>
      <link>https://flecart.github.io/notes/monitor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/monitor/</guid>
      <description>Questo è un modo di più alto livello per creare programmazione concorrente.
Introduzione ai monitor Questo costrutto per la programmazione concorrente, prende molto dalla programmazione agli oggetti, abbiamo delle variabili presenti al monitor, private solamente accessibili ad essa, tramite procedure che sono mutex automaticamente!
Elementi costituenti 🟩 Dati locali Sequenza di inizializzazione Procedure di entrata Appena provo a chiamare una procedura, questa è fatta già in mutua esclusione!.
E possono modificare dati locali solo tramite chiamate a sue procedure</description>
    </item>
    <item>
      <title>Probabilita condizionata e indipendenza</title>
      <link>https://flecart.github.io/notes/probabilita-condizionata-e-indipendenza/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/probabilita-condizionata-e-indipendenza/</guid>
      <description>Condizionata Definizione 🟩 Andiamo a definire una probabilità di un evento $A$, condizionata a un evento non nullo $B$, come
$$ P(A|B) = \dfrac{P(A\cap B)}{P(B)} $$ Questo è la cosa fondamentale per poter considerare cose come bayes perché in questo modo abbiamo una certa relazione fra causa ed effetto e anche il contrario! Cosa che ci piace molto molto molto.
La definizione di sopra è un probabilità 🟩 Dimostrazione mia</description>
    </item>
    <item>
      <title>Tecnologia Wireless</title>
      <link>https://flecart.github.io/notes/tecnologia-wireless/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/tecnologia-wireless/</guid>
      <description>Introduzione Spettro del wireless networks (skip) Slide spettro Wirelesss networks
Questo solamente la classica differenziazione fra radio, visibile, raggi x raggi gamma etcetera.
Se andiamo a guardare le onde radio, quelle che ci interessano, se ho frequenza alta ho densità di frequenza alta, se ho frequenza bassa ho alta capacità di suparamento di ostacoli.
ISM è una banda da 2 a 5.0 GHz e c&amp;rsquo;è tutto il WiFi, bluetooth. (anche wifi a 5 ghz.</description>
    </item>
    <item>
      <title>Bottom-up Parser LR(1)</title>
      <link>https://flecart.github.io/notes/bottom-up-parser-lr1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bottom-up-parser-lr1/</guid>
      <description>Si può osservare che per il parser costruito in Bottom-up Parser LR(0), non riesce a riconoscere di linguaggi semplici come $L = \{a, ab\}$.
Esempio di quanto detto Parser SLR(1) Questi parser qui utilizzano l’idea del look ahead ampiamente utilizzata in Top-down Parser, per escludere molte produzioni.
La s sta per simple, perché utilizza una idea semplice :D, credo ahah boh.
Riduzione con follow 🟩 noi vogliamo ridurre solamente se ho follow corretto il terminale finale della stringa.</description>
    </item>
    <item>
      <title>Introduzione sistemi operativi</title>
      <link>https://flecart.github.io/notes/introduzione-sistemi-operativi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-sistemi-operativi/</guid>
      <description>Ultima modifica: March 1, 2023 9:52 AM Primo Abbozzo: October 16, 2021 6:09 PM Studi Personali: Yes
Elementi di ripasso 1 Introduzione In questa sezione andiamo ad indagare cosa fa il sistema operativo
Note Generali 4 Parti di un sistema di calcolo Struttura Memoria Vedi Memoria per il corso di Architettura
Tipologie di SO Bimodalità SO Utente e Kernel
Interrupt, Trap, System or Supervisor Call System call 🟩- per maggiori info sui modi di chiamata delle syscall</description>
    </item>
  </channel>
</rss>
