<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>‚òÅCloud-Computing on X. Angelo Huang&#39;s Blog</title>
    <link>https://flecart.github.io/tags/cloud-computing/</link>
    <description>Recent content in ‚òÅCloud-Computing on X. Angelo Huang&#39;s Blog</description>
    <image>
      <title>X. Angelo Huang&#39;s Blog</title>
      <url>https://flecart.github.io/images/papermod-cover.png</url>
      <link>https://flecart.github.io/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.143.1</generator>
    <language>en</language>
    <atom:link href="https://flecart.github.io/tags/cloud-computing/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Communication APIs</title>
      <link>https://flecart.github.io/notes/communication-apis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/communication-apis/</guid>
      <description>&lt;p&gt;How can we coordinate services to actually understand what they are doing, or what the user wants them to do? How to manage networks errors? This note will mainly focus on high level communication protocols to coordinate this kind of communication.&lt;/p&gt;
&lt;h2 id=&#34;remote-procedure-calls&#34;&gt;Remote Procedure Calls&lt;/h2&gt;
&lt;h3 id=&#34;history-and-basic-idea&#34;&gt;History and Basic Idea&lt;/h3&gt;
&lt;p&gt;This has been the main idea, introduced in 1984, using the idea of &lt;strong&gt;stubs&lt;/strong&gt;, see &lt;a href=&#34;https://dl.acm.org/doi/10.1145/2080.357392&#34;&gt;(Birrell &amp;amp; Nelson 1984)&lt;/a&gt;. The system basically calls the remote procedure as i&lt;em&gt;f it was local&lt;/em&gt; on the high level, but on a lower level a network request is sent.
The architecture has remained the same in these years.
It hides all the complexity in the stub (marshaling, binding and sending, without caring about the sockets and communication matters).
One problem is that it might be hiding the complexity too well. The programmer has surely an ease of programming, but design consideration should consider overloads generated by the network communication.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cloud Storage</title>
      <link>https://flecart.github.io/notes/cloud-storage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cloud-storage/</guid>
      <description>&lt;h2 id=&#34;object-stores&#34;&gt;Object Stores&lt;/h2&gt;
&lt;h3 id=&#34;characteristics-of-cloud-systems&#34;&gt;Characteristics of Cloud Systems&lt;/h3&gt;
&lt;h4 id=&#34;object-storage-design-principles-&#34;&gt;Object storage design principles üü®++&lt;/h4&gt;
&lt;p&gt;We don&amp;rsquo;t want the hierarchy that is common in &lt;a href=&#34;https://flecart.github.io/notes/filesystem&#34;&gt;Filesystem&lt;/a&gt;s, so we need to simplify that and have these four principles:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Black-box objects&lt;/li&gt;
&lt;li&gt;Flat and global &lt;strong&gt;key-value&lt;/strong&gt; model (trivial model, easy to access, without the need to trasverse a file hierarchy).&lt;/li&gt;
&lt;li&gt;Flexible &lt;strong&gt;metadata&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Commodity hardware (the battery idea of Tesla until 2017).&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;object-storage-usages-&#34;&gt;Object storage usages üü©&lt;/h4&gt;
&lt;p&gt;Object storage are useful to store things that are usually read-intensive. Some examples are&lt;/p&gt;</description>
    </item>
    <item>
      <title>Content Delivery Networks</title>
      <link>https://flecart.github.io/notes/content-delivery-networks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/content-delivery-networks/</guid>
      <description>&lt;p&gt;CDNs are intermediary servers that replicate read intensive data to provide better performance when user requests them.
A close relative of CDNs is edge computing (e.g. gaming stations) where lots of computation is done directly close to the user.&lt;/p&gt;
&lt;h4 id=&#34;types-of-cdns&#34;&gt;Types of CDNs&lt;/h4&gt;
&lt;p&gt;Mainly three types of CDNs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Highly distributed ones.&lt;/li&gt;
&lt;li&gt;Database based ones.&lt;/li&gt;
&lt;li&gt;Ad-hoc CDNs.
&lt;img src=&#34;https://flecart.github.io/images/notes/Content Delivery Networks-20250403143719218.webp&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;Content Delivery Networks-20250403143719218&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;advantages-and-disadvantages&#34;&gt;Advantages and disadvantages&lt;/h4&gt;
&lt;p&gt;The main reason we use CDNs is to lower the value of latency: we are in fact bringing the data closer to the user.
We have much less data in length to be transmitted.
Yet we have some disadvantages too:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cloud Reliability</title>
      <link>https://flecart.github.io/notes/cloud-reliability/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cloud-reliability/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Reliability is the ability of a system to remain &lt;strong&gt;operational&lt;/strong&gt; over time, i.e., to offer the service it was designed for.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Cloud Hardware and software fails. In this note, we will try to find methods to analyze and predict when components fail, and how we can prevent this problem.&lt;/p&gt;
&lt;h3 id=&#34;defining-the-vocabulary&#34;&gt;Defining the vocabulary&lt;/h3&gt;
&lt;h4 id=&#34;availability&#34;&gt;Availability&lt;/h4&gt;
$$
\text{Availability} = \frac{\text{Uptime}}{\text{Uptime} + \text{Downtime}}
$$&lt;h4 id=&#34;mttf-mean-time-to-failure&#34;&gt;MTTF: Mean Time To Failure&lt;/h4&gt;
$$
\text{MTTF} = \frac{1}{r}
$$&lt;p&gt;
This definition does not include repair time, and assumes the failures are independent with each other.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Devices OS</title>
      <link>https://flecart.github.io/notes/devices-os/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/devices-os/</guid>
      <description>&lt;h2 id=&#34;devices&#34;&gt;Devices&lt;/h2&gt;
&lt;h3 id=&#34;categorizzazione-6-&#34;&gt;Categorizzazione (6)üü®-&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Trasferimento dei dati&lt;/li&gt;
&lt;li&gt;Accesso al device&lt;/li&gt;
&lt;li&gt;sinfonia del trasferimento&lt;/li&gt;
&lt;li&gt;condivisone fra processi&lt;/li&gt;
&lt;li&gt;Velocit√† del trasferimento&lt;/li&gt;
&lt;li&gt;I/O direction (scrittura o lettura)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Vediamo che molte caratteristiche sono riguardo il trasferimento&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide categorizzazione I/O&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Devices OS/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Devices OS/Untitled&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;blocchi-o-caratteri--&#34;&gt;Blocchi o caratteri üü©-&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide devices blocchi o caratteri&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Devices OS/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Devices OS/Untitled 1&#34;&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Devices OS/Untitled 2.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Devices OS/Untitled 2&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tecniche-di-gestione-devices-4--&#34;&gt;Tecniche di gestione devices (4) üü®-&lt;/h3&gt;
&lt;h4 id=&#34;buffering&#34;&gt;Buffering&lt;/h4&gt;
&lt;p&gt;Possiamo mettere un buffer per favorire la comunicazione fra i devices. la cosa migliore che fa √® creare maggiore efficienza. Un altro motivo √® la &lt;strong&gt;velocit√† diversa di consumo&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Queueing Theory</title>
      <link>https://flecart.github.io/notes/queueing-theory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/queueing-theory/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Queueing theory is the theory behind what happens when you have lots of jobs, scarce resources, and subsequently long queues and delays. It is literally the ‚Äútheory of queues‚Äù: what makes queues appear and how to make them go away.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This is basically what happens in clusters, where you have a limited number of workers that need to execute a number of jobs.&lt;/p&gt;
&lt;p&gt;We need some little maths to model the &lt;strong&gt;stochastic process&lt;/strong&gt; of request arrivals.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cloud Computing Services</title>
      <link>https://flecart.github.io/notes/cloud-computing-services/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cloud-computing-services/</guid>
      <description>&lt;h2 id=&#34;cloud-computing-an-overview&#34;&gt;Cloud Computing: An Overview&lt;/h2&gt;
&lt;p&gt;Cloud shifted the paradigm from owning hardware to renting computing resources on-demand. Hardware became a service.&lt;/p&gt;
&lt;h4 id=&#34;key-players-in-the-cloud-industry-&#34;&gt;Key Players in the Cloud Industry üü®&lt;/h4&gt;
&lt;p&gt;The cloud computing market is dominated by several major providers, often referred to as the &amp;ldquo;Big Seven&amp;rdquo;, also called &lt;strong&gt;hyper-scalers&lt;/strong&gt;. They are usually not interested in making it interoperable (they prefer the lock-in).&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Amazon Web Services (AWS)&lt;/strong&gt;: The largest provider, offering a comprehensive suite of cloud services.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Microsoft Azure&lt;/strong&gt;: Known for deep integration with enterprise systems and hybrid cloud solutions.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Google Cloud Platform (GCP)&lt;/strong&gt;: Excels in data analytics, AI/ML, and Kubernetes-based solutions.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IBM Cloud&lt;/strong&gt;: Focuses on hybrid cloud and enterprise-grade AI.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Oracle Cloud&lt;/strong&gt;: Specializes in database solutions and enterprise applications.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Alibaba Cloud&lt;/strong&gt;: The leading provider in Asia, offering services similar to AWS.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Salesforce&lt;/strong&gt;: A major player in SaaS, particularly for CRM and business applications.&lt;br&gt;
These providers collectively control the majority of the global cloud infrastructure market, enabling scalable and on-demand computing resources for businesses worldwide.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;capital-and-operational-expenses-in-the-cloud&#34;&gt;Capital and Operational Expenses in the Cloud&lt;/h3&gt;
&lt;h4 id=&#34;definition-for-capex-and-opex-&#34;&gt;Definition for CapEx and OpEx üü•&lt;/h4&gt;
&lt;p&gt;Cloud computing transforms traditional IT cost structures by shifting expenses from &lt;strong&gt;capital expenditures (CapEx)&lt;/strong&gt;, such as purchasing servers and data centers, to &lt;strong&gt;operational expenditures (OpEx)&lt;/strong&gt;, where users pay only for the resources they consume.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cluster Resource Management</title>
      <link>https://flecart.github.io/notes/cluster-resource-management/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cluster-resource-management/</guid>
      <description>&lt;p&gt;We need to find an efficient and effective manner to allocate the resources around. This is what the resource management layer does.&lt;/p&gt;
&lt;h3 id=&#34;introduction-to-the-problem&#34;&gt;Introduction to the problem&lt;/h3&gt;
&lt;h4 id=&#34;what-is-cluster-resource-management&#34;&gt;What is Cluster Resource Management?&lt;/h4&gt;
&lt;p&gt;Most of the time, the user specifies an amount of resources, and then the cluster decides how much to allocate (but approaches like &lt;a href=&#34;https://doi.org/10.1145/2541940.2541941&#34;&gt;(Delimitrou &amp;amp; Kozyrakis 2014)&lt;/a&gt;, do it differently).
There are mainly two parts in cluster resource management:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Allocation&lt;/strong&gt;: deciding how many resources an application.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Assignment&lt;/strong&gt;: from which physical machine you can effectively put the application.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;types-of-management-architectures&#34;&gt;Types of management architectures&lt;/h4&gt;
&lt;p&gt;We mainly divide the management architectures in three ways:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Container Virtualization</title>
      <link>https://flecart.github.io/notes/container-virtualization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/container-virtualization/</guid>
      <description>&lt;h2 id=&#34;containers&#34;&gt;Containers&lt;/h2&gt;
&lt;h4 id=&#34;what-is-a-container-&#34;&gt;What is a Container üü®++&lt;/h4&gt;
&lt;p&gt;We have explored virtual machines in &lt;a href=&#34;https://flecart.github.io/notes/architettura-software-del-os#macchine-virtuali&#34;&gt;Architettura software del OS#Macchine virtuali&lt;/a&gt;.
Containers do not virtualize everything, but just the environment where the application is run. This includes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Libraries&lt;/li&gt;
&lt;li&gt;Binaries&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We can see it as a &lt;em&gt;lightweight&lt;/em&gt; VM, even if they do not offer the full level of isolation of traditional virtual machines.&lt;/p&gt;
&lt;figure class=&#34;center&#34;&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/Container Virtualization-20250226134043539.webp&#34; style=&#34;width: 100%&#34;   alt=&#34;Container Virtualization-20250226134043539&#34; title=&#34;Container Virtualization-20250226134043539&#34;/&gt;
&lt;figcaption&gt;&lt;p style=&#34;text-align:center;&#34;&gt;Image from the course slides&lt;/p&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h4 id=&#34;containers-vs-virtual-machines-vms---&#34;&gt;Containers vs. Virtual Machines (VMs) üü®&amp;ndash;&lt;/h4&gt;
&lt;p&gt;Docker is one of the most famous containerization tools, but there are many others like Podman, LXC, or Singularity. They have different roles and scopes.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Architettura software del OS</title>
      <link>https://flecart.github.io/notes/architettura-software-del-os/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/architettura-software-del-os/</guid>
      <description>&lt;p&gt;A seconda dell&amp;rsquo;utilizzatore l‚ÄôOS pu√≤ essere molte cose, come solamente l‚Äôinterfaccia se sei un programmatore, servizi (se sei un utente, ma gran parte dei servizi sono astratti e l&amp;rsquo;utente ne pu√≤ anche essere a non-conoscenza).&lt;/p&gt;
&lt;p&gt;Ma se sei un programmatore OS ti interessa capire le componenti principali dell‚ÄôOS&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Slide componenti OS alto livello
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Architettura software del OS/Untitled&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;introduzione-sui-componenti-salto&#34;&gt;Introduzione sui componenti (salto)&lt;/h2&gt;
&lt;p&gt;Questa parte la salto perch√© √® una descrizione molto generale di cosa si occupa L‚Äôos verso drivers, processi, filesystem I/O, quindi non √® molto importante&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cluster Management Policies</title>
      <link>https://flecart.github.io/notes/cluster-management-policies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cluster-management-policies/</guid>
      <description>&lt;h3 id=&#34;introduction-to-cluster-management&#34;&gt;Introduction to cluster management&lt;/h3&gt;
&lt;p&gt;How can we &lt;strong&gt;allocate&lt;/strong&gt; the resources in a cluster in an efficient manner? How can we allocate resources fairly?&lt;/p&gt;
&lt;h4 id=&#34;two-step-allocations-&#34;&gt;Two step allocations üü®++&lt;/h4&gt;
&lt;p&gt;There are two main kinds of allocation: first you need to allocate resources to a process, then allocate the process physically in the cluster.&lt;/p&gt;
&lt;h4 id=&#34;private-and-public-cluster-management-&#34;&gt;Private and public cluster management üü•++&lt;/h4&gt;
&lt;p&gt;Cluster management could be private or public.&lt;/p&gt;
&lt;p&gt;Private means every app is managing their own sub-cluster: each app receives a private, &lt;strong&gt;static&lt;/strong&gt; set of resources. Here it is easier to manage hardware for various needs.
Public means there is a big cluster, like standard third party&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
