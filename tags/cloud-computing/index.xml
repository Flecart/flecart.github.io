<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>‚òÅCloud-Computing on X. Angelo Huang&#39;s Blog</title>
    <link>https://flecart.github.io/tags/cloud-computing/</link>
    <description>Recent content in ‚òÅCloud-Computing on X. Angelo Huang&#39;s Blog</description>
    <image>
      <title>X. Angelo Huang&#39;s Blog</title>
      <url>https://flecart.github.io/images/papermod-cover.png</url>
      <link>https://flecart.github.io/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.143.1</generator>
    <language>en</language>
    <atom:link href="https://flecart.github.io/tags/cloud-computing/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Cluster Management Policies</title>
      <link>https://flecart.github.io/notes/cluster-management-policies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cluster-management-policies/</guid>
      <description>&lt;p&gt;We have resources, but need to know how to assign these to the jobs that need them. This note presents some of the most common resource management policies for cloud clusters.&lt;/p&gt;
&lt;h3 id=&#34;introduction-to-cluster-management&#34;&gt;Introduction to cluster management&lt;/h3&gt;
&lt;p&gt;How can we &lt;strong&gt;allocate&lt;/strong&gt; the resources in a cluster in an efficient manner? How can we allocate resources fairly?&lt;/p&gt;
&lt;h4 id=&#34;two-step-allocations-&#34;&gt;Two step allocations üü©&lt;/h4&gt;
&lt;p&gt;There are two main kinds of allocation: first you need to allocate resources to a process, then allocate the process physically in the cluster. We have seen an example of a working infrastructure in &lt;a href=&#34;https://flecart.github.io/notes/cluster-resource-management&#34;&gt;Cluster Resource Management&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cluster Resource Management</title>
      <link>https://flecart.github.io/notes/cluster-resource-management/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cluster-resource-management/</guid>
      <description>&lt;p&gt;We need to find an efficient and effective manner to allocate the resources around. This is what the resource management layer does.&lt;/p&gt;
&lt;h3 id=&#34;introduction-to-the-problem&#34;&gt;Introduction to the problem&lt;/h3&gt;
&lt;h4 id=&#34;what-is-cluster-resource-management-&#34;&gt;What is Cluster Resource Management? üü©&lt;/h4&gt;
&lt;p&gt;Most of the time, the user specifies an amount of resources, and then the cluster decides how much to allocate (but approaches like &lt;a href=&#34;https://doi.org/10.1145/2541940.2541941&#34;&gt;(Delimitrou &amp;amp; Kozyrakis 2014)&lt;/a&gt;, do it differently).
There are mainly two parts in cluster resource management:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Optimizations for DNN</title>
      <link>https://flecart.github.io/notes/optimizations-for-dnn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/optimizations-for-dnn/</guid>
      <description>&lt;h3 id=&#34;mixture-of-experts&#34;&gt;Mixture of Experts&lt;/h3&gt;
&lt;p&gt;There is a gate that opens a subset of the experts, and the output is the weighted sum of the outputs of the experts. The weights are computed by a gating network.
&lt;img src=&#34;https://flecart.github.io/images/notes/Optimizations for DNN-20250510123829347.webp&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;Optimizations for DNN-20250510123829347&#34;&gt;&lt;/p&gt;
&lt;p&gt;One problem is load balancing, non uniform assignment. And there is a lot of communication overhead when you place them in different devices.&lt;/p&gt;
&lt;h4 id=&#34;lora-low-rank-adaptation-&#34;&gt;LoRA: Low-Rank Adaptation üü®&lt;/h4&gt;
&lt;p&gt;We only finetune a part of the network, called &lt;strong&gt;lora adapters&lt;/strong&gt;, not the whole thing.
There are two matrices here, a matrix A and B, they are some sort of an Autoencoders, done for every Q nd V matrices in the LLM attention layer. The nice thing is that there are not many inference costs if adapters are merged post training:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Compute Express Link</title>
      <link>https://flecart.github.io/notes/compute-express-link/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/compute-express-link/</guid>
      <description>&lt;p&gt;This allows us to extend the memory hierarchy (see &lt;a href=&#34;https://flecart.github.io/notes/memoria&#34;&gt;Memoria&lt;/a&gt;) that we have today. The problem is that we have heterogeneous access patterns specifications and hardware.
One of the main trends is &lt;strong&gt;disaggregation&lt;/strong&gt;: we want to be able to scale different resources independently.&lt;/p&gt;
&lt;h4 id=&#34;introduction-to-cxl-compute-express-link&#34;&gt;Introduction to CXL (Compute Express Link)&lt;/h4&gt;
&lt;p&gt;This is a new part of the memory hierarchy.&lt;/p&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/Compute Express Link-20250518115846502.webp&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;Compute Express Link-20250518115846502&#34;&gt;
&lt;p&gt;NVM is a kind of non volatile memory that is used as a storage device that is close to the device (others are network attached or slower than network part anyways. It is persistent and has low latency. It is used in the memory hierarchy to extend the memory capacity.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Datacenter Hardware</title>
      <link>https://flecart.github.io/notes/datacenter-hardware/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/datacenter-hardware/</guid>
      <description>&lt;p&gt;We want to optimize the parts of the datacenter hardware such that the cost of operating the datacenter as a &lt;em&gt;whole&lt;/em&gt; would be lower, we need to think about it as a whole.&lt;/p&gt;
&lt;h3 id=&#34;datacenter-cpus&#34;&gt;Datacenter CPUs&lt;/h3&gt;
&lt;h4 id=&#34;different-requirements&#34;&gt;Different requirements&lt;/h4&gt;
&lt;p&gt;Hardware needs high level isolation (because it will be shared among different users).
Usually high workloads and moving a lot of data around.&lt;/p&gt;
&lt;p&gt;They have a spectrum of low and high end cores, so that if you have high parallelism you can use lower cores, while for resource intensive tasks, its better to have high end cores, especially for latency critical tasks.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Systems for Artificial Intelligence</title>
      <link>https://flecart.github.io/notes/systems-for-artificial-intelligence/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/systems-for-artificial-intelligence/</guid>
      <description>&lt;p&gt;At the time of writing, the compute requirements for machine learning models and artificial intelligence are growing at a staggering rate of 200% every 3.5 months. Interest in the area is being quantified as 10k papers per month on the topic, while dollar investments on compute (energy, cooling, sustainability of compute in general) have had a hard time keeping up with the continuous new requests.&lt;/p&gt;
&lt;figure class=&#34;center&#34;&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/Systems for Artificial Intelligence-20250429113134097.webp&#34; style=&#34;width: 100%&#34;   alt=&#34;Systems for Artificial Intelligence-20250429113134097&#34; title=&#34;Systems for Artificial Intelligence-20250429113134097&#34;/&gt;
&lt;figcaption&gt;&lt;p style=&#34;text-align:center;&#34;&gt; From &lt;a href=&#34;https://ucbrise.github.io/cs294-ai-sys-fa19/assets/lectures/lec03/03_ml-lifecycle.pdf&#34;&gt;https://ucbrise.github.io/cs294-ai-sys-fa19/assets/lectures/lec03/03_ml-lifecycle.pdf&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Green Computing</title>
      <link>https://flecart.github.io/notes/green-computing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/green-computing/</guid>
      <description>&lt;p&gt;The cloud is inefficient, and it looks like we can improve a lot on this side. Computer Science with their systems have reached &lt;em&gt;industrial scales&lt;/em&gt; and can be compared to build airports, highways and metro systems in terms of &lt;strong&gt;public infrastructure&lt;/strong&gt;, yet, due to their &lt;em&gt;immaterial&lt;/em&gt; and &lt;em&gt;intangible&lt;/em&gt; nature, the perception of these systems do not match their perceived reality by the majority of the people.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;While classical engineering designs physical objects, computer science designs virtual objects ~&lt;em&gt;Gustavo Alonso CCA Lecture 14 May 2025 ETH Z√ºrich&lt;/em&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cloud Computing Services</title>
      <link>https://flecart.github.io/notes/cloud-computing-services/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cloud-computing-services/</guid>
      <description>&lt;h2 id=&#34;cloud-computing-an-overview&#34;&gt;Cloud Computing: An Overview&lt;/h2&gt;
&lt;p&gt;Cloud shifted the paradigm from owning hardware to renting computing resources on-demand. Hardware became a service.&lt;/p&gt;
&lt;h4 id=&#34;key-players-in-the-cloud-industry-&#34;&gt;Key Players in the Cloud Industry üü®&lt;/h4&gt;
&lt;p&gt;The cloud computing market is dominated by several major providers, often referred to as the &amp;ldquo;Big Seven&amp;rdquo;, also called &lt;strong&gt;hyper-scalers&lt;/strong&gt;. They are usually not interested in making it interoperable (they prefer the lock-in).&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Amazon Web Services (AWS)&lt;/strong&gt;: The largest provider, offering a comprehensive suite of cloud services.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Microsoft Azure&lt;/strong&gt;: Known for deep integration with enterprise systems and hybrid cloud solutions.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Google Cloud Platform (GCP)&lt;/strong&gt;: Excels in data analytics, AI/ML, and Kubernetes-based solutions.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IBM Cloud&lt;/strong&gt;: Focuses on hybrid cloud and enterprise-grade AI.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Oracle Cloud&lt;/strong&gt;: Specializes in database solutions and enterprise applications.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Alibaba Cloud&lt;/strong&gt;: The leading provider in Asia, offering services similar to AWS.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Salesforce&lt;/strong&gt;: A major player in SaaS, particularly for CRM and business applications.&lt;br&gt;
These providers collectively control the majority of the global cloud infrastructure market, enabling scalable and on-demand computing resources for businesses worldwide.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;capital-and-operational-expenses-in-the-cloud&#34;&gt;Capital and Operational Expenses in the Cloud&lt;/h3&gt;
&lt;h4 id=&#34;definition-for-capex-and-opex-&#34;&gt;Definition for CapEx and OpEx üü•&lt;/h4&gt;
&lt;p&gt;Cloud computing transforms traditional IT cost structures by shifting expenses from &lt;strong&gt;capital expenditures (CapEx)&lt;/strong&gt;, such as purchasing servers and data centers, to &lt;strong&gt;operational expenditures (OpEx)&lt;/strong&gt;, where users pay only for the resources they consume.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cloud Reliability</title>
      <link>https://flecart.github.io/notes/cloud-reliability/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cloud-reliability/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Reliability is the ability of a system to remain &lt;strong&gt;operational&lt;/strong&gt; over time, i.e., to offer the service it was designed for.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Cloud Hardware and software fails. In this note, we will try to find methods to analyze and predict when components fail, and how we can prevent this problem.&lt;/p&gt;
&lt;h3 id=&#34;defining-the-vocabulary&#34;&gt;Defining the vocabulary&lt;/h3&gt;
&lt;h4 id=&#34;availability-&#34;&gt;Availability üü®++&lt;/h4&gt;
$$
\text{Availability} = \frac{\text{Uptime}}{\text{Uptime} + \text{Downtime}}
$$&lt;h4 id=&#34;mttf-mean-time-to-failure---&#34;&gt;MTTF: Mean Time To Failure üü©&amp;ndash;&lt;/h4&gt;
$$
\text{MTTF} = \frac{1}{r}
$$&lt;p&gt;
This definition does not include repair time, and assumes the failures are independent with each other.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Communication in the Cloud</title>
      <link>https://flecart.github.io/notes/communication-in-the-cloud/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/communication-in-the-cloud/</guid>
      <description>&lt;p&gt;How can we coordinate services to actually understand what they are doing, or what the user wants them to do? How to manage networks errors? This note will mainly focus on high level communication protocols to coordinate this kind of communication.&lt;/p&gt;
&lt;h2 id=&#34;remote-procedure-calls&#34;&gt;Remote Procedure Calls&lt;/h2&gt;
&lt;h3 id=&#34;history-and-basic-idea&#34;&gt;History and Basic Idea&lt;/h3&gt;
&lt;p&gt;This has been the main idea, introduced in 1984, using the idea of &lt;strong&gt;stubs&lt;/strong&gt;, see &lt;a href=&#34;https://dl.acm.org/doi/10.1145/2080.357392&#34;&gt;(Birrell &amp;amp; Nelson 1984)&lt;/a&gt;. The system basically calls the remote procedure as i&lt;em&gt;f it was local&lt;/em&gt; on the high level, but on a lower level a network request is sent.
The architecture has remained the same in these years.
It hides all the complexity in the stub (marshaling, binding and sending, without caring about the sockets and communication matters).
One problem is that it might be hiding the complexity too well. The programmer has surely an ease of programming, but design consideration should consider overloads generated by the network communication.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Queueing Theory</title>
      <link>https://flecart.github.io/notes/queueing-theory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/queueing-theory/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Queueing theory is the theory behind what happens when you have lots of jobs, scarce resources, and subsequently long queues and delays. It is literally the ‚Äútheory of queues‚Äù: what makes queues appear and how to make them go away.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This is basically what happens in clusters, where you have a limited number of workers that need to execute a number of jobs.&lt;/p&gt;
&lt;p&gt;We need some little maths to model the &lt;strong&gt;stochastic process&lt;/strong&gt; of request arrivals.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Virtual Machines</title>
      <link>https://flecart.github.io/notes/virtual-machines/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/virtual-machines/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;The fundamental idea behind a virtual machine is to abstract the hardware
of a single computer (the CPU, memory, disk drives, network interface cards,
and so forth) into several different execution environments, thereby creating
the illusion that each separate environment is running on its own private
computer. &lt;a href=&#34;https://books.google.ch/books/about/Operating_System_Concepts.html?id=FHJlDwAAQBAJ&amp;redir_esc=y&#34;&gt;(Silberschatz et al. 2018)&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Virtualization allows a single computer to host multiple virtual machines, each potentially running a completely different operating system.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;√à virtuale nel senso che la macchina virtuale ha la stessa percezione della realt√† di una macchina reale. Qualcosa che non √® la realt√† ma appare molto simile ad essa.&lt;/p&gt;</description>
    </item>
    <item>
      <title>HTTP e REST</title>
      <link>https://flecart.github.io/notes/http-e-rest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/http-e-rest/</guid>
      <description>&lt;p&gt;HTTP is the acronym for HyperText Transfer Protocol.&lt;/p&gt;
&lt;h3 id=&#34;caratteristiche-principali-3&#34;&gt;Caratteristiche principali (3)&lt;/h3&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/HTTP e REST/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/HTTP e REST/Untitled&#34;&gt;
&lt;ol&gt;
&lt;li&gt;Comunicazioni fra client e server, e quanto sono comunicate le cose si chiude la connessione e ci sono politiche di caching molto bone (tipo con i proxy)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Generico&lt;/strong&gt;: perch√© √® un protocollo utilizzato per caricare moltissime tipologie di risorse!&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Stateless&lt;/strong&gt;, ossia non vengono mantenute informazioni su scambi vecchi, in un certo modo ne abbiamo parlato in &lt;a href=&#34;https://flecart.github.io/notes/sicurezza-delle-reti&#34;&gt;Sicurezza delle reti&lt;/a&gt; quando abbiamo parlato di firewall stateless.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Solitamente possiamo intendere questo protocollo come utile per &lt;strong&gt;scambiare risorse&lt;/strong&gt; di cui abbiamo parlato in &lt;a href=&#34;https://flecart.github.io/notes/uniform-resource-identifier&#34;&gt;Uniform Resource Identifier&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cloud Storage</title>
      <link>https://flecart.github.io/notes/cloud-storage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cloud-storage/</guid>
      <description>&lt;h2 id=&#34;object-stores&#34;&gt;Object Stores&lt;/h2&gt;
&lt;h3 id=&#34;characteristics-of-cloud-systems&#34;&gt;Characteristics of Cloud Systems&lt;/h3&gt;
&lt;h4 id=&#34;object-storage-design-principles-&#34;&gt;Object storage design principles üü®++&lt;/h4&gt;
&lt;p&gt;We don&amp;rsquo;t want the hierarchy that is common in &lt;a href=&#34;https://flecart.github.io/notes/filesystem&#34;&gt;Filesystem&lt;/a&gt;s, so we need to simplify that and have these four principles:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Black-box objects&lt;/li&gt;
&lt;li&gt;Flat and global &lt;strong&gt;key-value&lt;/strong&gt; model (trivial model, easy to access, without the need to trasverse a file hierarchy).&lt;/li&gt;
&lt;li&gt;Flexible &lt;strong&gt;metadata&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Commodity hardware (the battery idea of Tesla until 2017).&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;object-storage-usages-&#34;&gt;Object storage usages üü©&lt;/h4&gt;
&lt;p&gt;Object storage are useful to store things that are usually read-intensive. Some examples are&lt;/p&gt;</description>
    </item>
    <item>
      <title>Content Delivery Networks</title>
      <link>https://flecart.github.io/notes/content-delivery-networks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/content-delivery-networks/</guid>
      <description>&lt;p&gt;CDNs are intermediary servers that replicate read intensive data to provide better performance when user requests them.
A close relative of CDNs is edge computing (e.g. gaming stations) where lots of computation is done directly close to the user.&lt;/p&gt;
&lt;h4 id=&#34;types-of-cdns---&#34;&gt;Types of CDNs üü®&amp;ndash;&lt;/h4&gt;
&lt;p&gt;Mainly three types of CDNs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Highly distributed ones.&lt;/li&gt;
&lt;li&gt;Database based ones.&lt;/li&gt;
&lt;li&gt;Ad-hoc CDNs.
&lt;img src=&#34;https://flecart.github.io/images/notes/Content Delivery Networks-20250403143719218.webp&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;Content Delivery Networks-20250403143719218&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;advantages-and-disadvantages-&#34;&gt;Advantages and disadvantages üü©&lt;/h4&gt;
&lt;p&gt;The main reason we use CDNs is to lower the value of latency: we are in fact bringing the data closer to the user.
We have much less data in length to be transmitted.
Yet we have some disadvantages too:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Redundant Array of Independent Disks</title>
      <link>https://flecart.github.io/notes/redundant-array-of-independent-disks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/redundant-array-of-independent-disks/</guid>
      <description>&lt;h3 id=&#34;introduzione-ai-redundant-array-of-indipendent-disks&#34;&gt;Introduzione ai Redundant Array of Indipendent Disks&lt;/h3&gt;
&lt;p&gt;I RAID ne abbiamo citato per la prima volta in &lt;a href=&#34;https://flecart.github.io/notes/memoria&#34;&gt;Memoria&lt;/a&gt;. Come facciamo a stare su alla velocit√† del processore se questa va a crescere in modo esponenziale? &lt;strong&gt;Parallelizzazione della ricerca!&lt;/strong&gt;. Ecco perch√© ci serve raid (oltre alla ridondanza quindi pi√π sicuro). E possono anche fallire. ‚Üí &lt;strong&gt;ammette recovery&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;E una altra cosa bella dei raid √® che sono &lt;strong&gt;hot-swappable&lt;/strong&gt; cio√® li puoi sostituire anche quando stanno runnando.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Architettura software del OS</title>
      <link>https://flecart.github.io/notes/architettura-software-del-os/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/architettura-software-del-os/</guid>
      <description>&lt;p&gt;A seconda dell&amp;rsquo;utilizzatore l‚ÄôOS pu√≤ essere molte cose, come solamente l‚Äôinterfaccia se sei un programmatore, servizi (se sei un utente, ma gran parte dei servizi sono astratti e l&amp;rsquo;utente ne pu√≤ anche essere a non-conoscenza).&lt;/p&gt;
&lt;p&gt;Ma se sei un programmatore OS ti interessa capire le componenti principali dell‚ÄôOS&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Slide componenti OS alto livello
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Architettura software del OS/Untitled&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;introduzione-sui-componenti-salto&#34;&gt;Introduzione sui componenti (salto)&lt;/h2&gt;
&lt;p&gt;Questa parte la salto perch√© √® una descrizione molto generale di cosa si occupa L‚Äôos verso drivers, processi, filesystem I/O, quindi non √® molto importante&lt;/p&gt;</description>
    </item>
    <item>
      <title>Container Virtualization</title>
      <link>https://flecart.github.io/notes/container-virtualization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/container-virtualization/</guid>
      <description>&lt;h2 id=&#34;containers&#34;&gt;Containers&lt;/h2&gt;
&lt;h4 id=&#34;what-is-a-container-&#34;&gt;What is a Container üü®++&lt;/h4&gt;
&lt;p&gt;We have explored virtual machines in &lt;a href=&#34;https://flecart.github.io/notes/architettura-software-del-os#macchine-virtuali&#34;&gt;Architettura software del OS#Macchine virtuali&lt;/a&gt;.
Containers do not virtualize everything, but just the environment where the application is run. This includes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Libraries&lt;/li&gt;
&lt;li&gt;Binaries&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We can see it as a &lt;em&gt;lightweight&lt;/em&gt; VM, even if they do not offer the full level of isolation of traditional virtual machines.&lt;/p&gt;
&lt;figure class=&#34;center&#34;&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/Container Virtualization-20250226134043539.webp&#34; style=&#34;width: 100%&#34;   alt=&#34;Container Virtualization-20250226134043539&#34; title=&#34;Container Virtualization-20250226134043539&#34;/&gt;
&lt;figcaption&gt;&lt;p style=&#34;text-align:center;&#34;&gt;Image from the course slides&lt;/p&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h4 id=&#34;containers-vs-virtual-machines-vms---&#34;&gt;Containers vs. Virtual Machines (VMs) üü®&amp;ndash;&lt;/h4&gt;
&lt;p&gt;Docker is one of the most famous containerization tools, but there are many others like Podman, LXC, or Singularity. They have different roles and scopes.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
