<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>ðŸ—„Algorithms-and-Data-Structures on X. Angelo Huang&#39;s Blog</title>
    <link>https://flecart.github.io/tags/algorithms-and-data-structures/</link>
    <description>Recent content in ðŸ—„Algorithms-and-Data-Structures on X. Angelo Huang&#39;s Blog</description>
    <image>
      <title>X. Angelo Huang&#39;s Blog</title>
      <url>https://flecart.github.io/images/papermod-cover.png</url>
      <link>https://flecart.github.io/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.143.1</generator>
    <language>en</language>
    <atom:link href="https://flecart.github.io/tags/algorithms-and-data-structures/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Alberi BST e AVL</title>
      <link>https://flecart.github.io/notes/alberi-bst-e-avl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/alberi-bst-e-avl/</guid>
      <description>&lt;h1 id=&#34;alberi-bst-e-avl&#34;&gt;Alberi BST e AVL&lt;/h1&gt;
&lt;h2 id=&#34;41-alberi-binari-di-ricerca-bst&#34;&gt;4.1 Alberi binari di ricerca (BST)&lt;/h2&gt;
&lt;p&gt;Queste sono delle varianti rispetto all&amp;rsquo;albero, descritto in modo molto sommario sopra (binario perchÃ© ogni nodo ha al massimo due figli, mentre l&amp;rsquo;albero puÃ² averne quanti se ne vuole).&lt;/p&gt;
&lt;h3 id=&#34;411-introduzione&#34;&gt;4.1.1 Introduzione&lt;/h3&gt;
&lt;p&gt;La caratteristica principale dell&amp;rsquo;albero di ricerca Ã¨ una condizione sulle chiavi (che hanno i figli).&lt;/p&gt;
&lt;p&gt;Infatti questo albero binario di ricerca si puÃ² vedere come una implementazione della struttura astratta del dizionario. (che ricordiamo, Ã¨ un struttura in cui a ogni nodo sono presenti due valori, una chiave (tute differenti) e un dato, e sono definite tre operazioni principali, possiamo vederla come interfaccia).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Algoritmi di ordinamento</title>
      <link>https://flecart.github.io/notes/algoritmi-di-ordinamento/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/algoritmi-di-ordinamento/</guid>
      <description>&lt;h2 id=&#34;61-introduzione&#34;&gt;6.1 Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;611-limportanza-del-topic&#34;&gt;6.1.1 Lâ€™importanza del topic&lt;/h3&gt;
&lt;p&gt;Gli algoritmi di ordinamento sono molto di base per la comprensione dell&amp;rsquo;ampio raggio degli algoritmi. Utilizzano l&amp;rsquo;analisi, introducono tecniche di risoluzione dei problemi computazionali come greedy, divide et impera e simile. Permettono un primo uso di astrazioni e l&amp;rsquo;analisi di sottoproblemi.&lt;/p&gt;
&lt;h3 id=&#34;612-il-problema&#34;&gt;6.1.2 Il problema&lt;/h3&gt;
&lt;p&gt;Il problema Ã¨ trovare una permutazione di un insieme di numeri iniziali tale per cui tale insieme di numeri si ordinato:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bloom Filters</title>
      <link>https://flecart.github.io/notes/bloom-filters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bloom-filters/</guid>
      <description>&lt;h3 id=&#34;how-bloom-filters-work&#34;&gt;&lt;strong&gt;How Bloom Filters Work&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;A &lt;strong&gt;Bloom filter&lt;/strong&gt; is a space-efficient probabilistic data structure used to test whether an element is &lt;strong&gt;possibly in a set&lt;/strong&gt; or &lt;strong&gt;definitely not in a set&lt;/strong&gt;. It allows for false positives but never false negatives.&lt;/p&gt;
&lt;p&gt;One example of application is the membership query in &lt;a href=&#34;https://flecart.github.io/notes/wide-column-storage/&#34;&gt;Wide Column Storage&lt;/a&gt;, HBase. They make document lookup faster by completely skipping some HFiles.&lt;/p&gt;
&lt;h3 id=&#34;structure-and-initialization&#34;&gt;Structure and Initialization&lt;/h3&gt;
&lt;p&gt;A Bloom filter consists of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;strong&gt;bit array&lt;/strong&gt; of size $m$, initialized to all &lt;strong&gt;0s&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;$k$ independent &lt;strong&gt;hash functions&lt;/strong&gt;, each mapping an input element to one of the $m$ positions in the bit array.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;common-operations&#34;&gt;Common operations&lt;/h2&gt;
&lt;h3 id=&#34;insertion-of-an-element&#34;&gt;Insertion of an Element&lt;/h3&gt;
&lt;p&gt;To insert an element $x$:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cammini</title>
      <link>https://flecart.github.io/notes/cammini/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cammini/</guid>
      <description>&lt;h2 id=&#34;11-il-cammino-minimo&#34;&gt;1.1 Il cammino minimo&lt;/h2&gt;
&lt;h3 id=&#34;111-definizione-e-caratteristiche&#34;&gt;1.1.1 Definizione e caratteristiche&lt;/h3&gt;
&lt;h3 id=&#34;112-costi-negativi&#34;&gt;1.1.2 Costi negativi&lt;/h3&gt;
&lt;p&gt;Sono cose molto brutte&lt;/p&gt;
&lt;h3 id=&#34;113-cammino-minimo-semplice&#34;&gt;1.1.3 Cammino minimo semplice&lt;/h3&gt;
&lt;h3 id=&#34;costruzione-di-cammini-minimi&#34;&gt;Costruzione di cammini minimi&lt;/h3&gt;
&lt;h2 id=&#34;12-vertici&#34;&gt;1.2 Vertici&lt;/h2&gt;
&lt;h3 id=&#34;121-definizione-distanza-fra-due-vertici&#34;&gt;1.2.1 definizione distanza fra due vertici&lt;/h3&gt;
&lt;p&gt;Costo del cammino minimo che li connette&lt;/p&gt;
&lt;h3 id=&#34;condizione-di-bellman&#34;&gt;Condizione di bellman&lt;/h3&gt;
&lt;h3 id=&#34;albero-dei-cammini-minimi&#34;&gt;Albero dei cammini minimi&lt;/h3&gt;
&lt;h2 id=&#34;rilassamento&#34;&gt;Rilassamento&lt;/h2&gt;
&lt;h3 id=&#34;definizione&#34;&gt;Definizione&lt;/h3&gt;
&lt;p&gt;Si va a vedere dove non funziona la disuguaglianza triangolare, se localmente non funziona ovvero se per esempio succede $D_{xu} + \omega(u,y) &lt; D_{xy}$ per qualche vertice all&amp;rsquo;interno del grafo, so di per certo che la distanza $D_{xy}$ non Ã¨ una distanza, quindi possiamo riassegnarla in modo che verifichi la disuguaglianza&lt;/p&gt;</description>
    </item>
    <item>
      <title>Grafi</title>
      <link>https://flecart.github.io/notes/grafi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/grafi/</guid>
      <description>&lt;h2 id=&#34;rappresentazione-e-terminologia&#34;&gt;Rappresentazione e terminologia&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Operazioni importanti&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Grafi/Untitled.png&#34; alt=&#34;image/universita/ex-notion/Grafi/Untitled&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;definizione-di-grafo&#34;&gt;Definizione di grafo&lt;/h3&gt;
&lt;p&gt;Ãˆ un insieme di nodi e di archi. (prendili da insiemi corretti)&lt;/p&gt;
&lt;h3 id=&#34;metodi-di-rappresentazione&#34;&gt;Metodi di rappresentazione&lt;/h3&gt;
&lt;h4 id=&#34;liste-di-incidenza&#34;&gt;Liste di incidenza&lt;/h4&gt;
&lt;p&gt;In pratica numero tutti gli archi e storo il valore dell&amp;rsquo;arco incidente per ogni nodo.
Diventa una tabella con una parte i nodi e l&amp;rsquo;altra gli archi. AvrÃ² dei valori -1 e 1 che marcano partenza e arrivo.
La cosa carina di questo metodo Ã¨ che puÃ² essere generalizzata anche per Ipergrafi, in cui gli archi possono avere piÃ¹ di una partenza o arrivo.
Solitamente Ã¨ memorizzato come una lista, quindi esattamente nodo partenza e arrivo per ogni edge.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Introduzione algoritmi</title>
      <link>https://flecart.github.io/notes/introduzione-algoritmi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-algoritmi/</guid>
      <description>&lt;h1 id=&#34;0-introduzione&#34;&gt;0 Introduzione&lt;/h1&gt;
&lt;h2 id=&#34;01-lalgoritmo&#34;&gt;0.1 Lâ€™algoritmo&lt;/h2&gt;
&lt;p&gt;Vogliamo cercare di creare algoritmi, ovvero soluzioni a problemi computazionali che &lt;strong&gt;non dipendono dal linguaggio&lt;/strong&gt; di programmazione.&lt;/p&gt;
&lt;h3 id=&#34;011-definizione&#34;&gt;0.1.1 Definizione&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Procedura per risolvere un problema in un numero &lt;strong&gt;finito&lt;/strong&gt; di passi (quindi un algoritmo deve finire)&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;012-origine-della-parola&#34;&gt;0.1.2 Origine della parola&lt;/h3&gt;
&lt;p&gt;Il nome &amp;ldquo;algoritmo&amp;rdquo; deriva da un nome di un matematico persiano dell 800 d.c. &lt;em&gt;Muhammad ibn Musa al-Khwarizmi&lt;/em&gt;, che latinizzato diventa &lt;em&gt;algorithmi&lt;/em&gt;, quindi i latini hanno creato la parola!&lt;/p&gt;</description>
    </item>
    <item>
      <title>k-esimo priority-q DSU</title>
      <link>https://flecart.github.io/notes/k-esimo-priority-q-dsu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/k-esimo-priority-q-dsu/</guid>
      <description>&lt;p&gt;Questo documento Ã¨ totalmente concentrato sull&amp;rsquo;analisi del problema della selezione del k-esimo elemento.&lt;/p&gt;
&lt;h2 id=&#34;71-introduzione-al-problema&#34;&gt;7.1 Introduzione al problema&lt;/h2&gt;
&lt;p&gt;Dato un array di elementi vogliamo cercare di trovare un modo efficiente per selezionare il k-esimo elemento, ossia un elemento che sia maggiore di k-1 elementi&lt;/p&gt;
&lt;h3 id=&#34;711-note-sullutilizzo&#34;&gt;7.1.1 Note sull&amp;rsquo;utilizzo&lt;/h3&gt;
&lt;p&gt;Questo algoritmo Ã¨ utile per esempio per sapere cosa displayare in una pagina di ricerca, perchÃ© per esempio posso avere blocchi di tanta roba 140k, mentre ovviamente posso selezionare solamente un blocco ristretto.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Merkle Trees</title>
      <link>https://flecart.github.io/notes/merkle-trees/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/merkle-trees/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Merkle Trees: A Fundamental Structure in Cryptography&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Merkle trees, introduced by Ralph Merkle in 1979, are a pivotal data structure in cryptographic systems. These binary hash trees enable efficient and secure verification of data integrity within distributed systems. Their design capitalizes on hash functions to reduce computational overhead, making them indispensable in blockchain and peer-to-peer networks.&lt;/p&gt;
&lt;h3 id=&#34;what-are-merkle-trees&#34;&gt;What are Merkle Trees?&lt;/h3&gt;
&lt;h4 id=&#34;structure-and-construction&#34;&gt;Structure and Construction&lt;/h4&gt;
&lt;p&gt;A Merkle tree is a rooted binary tree where:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Notazione Asintotica</title>
      <link>https://flecart.github.io/notes/notazione-asintotica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/notazione-asintotica/</guid>
      <description>&lt;h2 id=&#34;introduzione-alla-notazione-asintotica&#34;&gt;Introduzione alla notazione asintotica&lt;/h2&gt;
&lt;p&gt;Cercare di definire il tempo impiegato da una funzione per essere eseguita &lt;strong&gt;in termini di DIMENSIONE dell&amp;rsquo;input&lt;/strong&gt;. **(il numero di bit a livello basso basso)&lt;/p&gt;
&lt;p&gt;Ma abbiamo il problema di misura, in quanto dobbiamo considerare delle variabili che siano indipendenti rispetto alla macchina.&lt;/p&gt;
&lt;h3 id=&#34;caratteristiche-della-notazione&#34;&gt;Caratteristiche della notazione&lt;/h3&gt;
&lt;p&gt;Vogliamo considerare una notazione asintotica (che guarda quanto fa il comportamento verso l&amp;rsquo;infinito)&lt;/p&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Notazione Asintotica/Untitled.png&#34; alt=&#34;image/universita/ex-notion/Notazione Asintotica/Untitled&#34;&gt;
### Accesso di memoria
Ogni operazione in un processore moderno ha in generale un numero di accessi in memoria constante (solitamente abbiamo sempre un numero fissato di operandi possibile, questo significa che se un certo algoritmo ha una certa complessitÃ , resta di questa complessitÃ  anche tenendo in considerazione le operazioni di accesso di memoria).
&lt;p&gt;Questo discorso non tiene piÃ¹ se teniamo in considerazione numeri a precisione infinita, che possono avere un numero arbitrario di accessi in memoria per poter essere computato.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Relazioni di Ricorrenza</title>
      <link>https://flecart.github.io/notes/relazioni-di-ricorrenza/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/relazioni-di-ricorrenza/</guid>
      <description>&lt;h3 id=&#34;iterazione&#34;&gt;Iterazione&lt;/h3&gt;
&lt;p&gt;Questo metodo semplicemente consiste di calcolare tutte le operazioni e scriverlo con una notazione asintotica.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;slide&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Relazioni di Ricorrenza/Untitled.png&#34; alt=&#34;image/universita/ex-notion/Relazioni di Ricorrenza/Untitled&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;sostituzione-induzione&#34;&gt;Sostituzione (induzione)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;slide&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Relazioni di Ricorrenza/Untitled 1.png&#34; alt=&#34;image/universita/ex-notion/Relazioni di Ricorrenza/Untitled 1&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Analisi della relazione di ricorrenza di fibonacci&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Si puÃ² dimostrare utilizzando l&amp;rsquo;induzione che una relazione di questo tipo&lt;/p&gt;
$$
T(n) = \begin{cases}
O(1) \\
T(n-1) + T(n-2) + 1
\end{cases}
$$&lt;p&gt;Si trova che Ã¨ $O(2^n), \Omega(2^{n/2})$&lt;/p&gt;
&lt;p&gt;Analisi finale.&lt;/p&gt;
&lt;p&gt;Si puÃ² creare una stima corretta, utilizzando la formula per il calcolo di fibonacci (che dimostri facendo osservazioni su una funzione generatrice di essa, una serie infinita).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Strutture di dati elementari</title>
      <link>https://flecart.github.io/notes/strutture-di-dati-elementari/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/strutture-di-dati-elementari/</guid>
      <description>&lt;h2 id=&#34;31-introduzione&#34;&gt;3.1 Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;311-cosa-sono&#34;&gt;3.1.1 Cosa sono&lt;/h3&gt;
&lt;p&gt;Le strutture di dati si interessano solamente di &lt;strong&gt;come memorizzare i dati&lt;/strong&gt;, non necessariamente va a memorizzare un tipo di dato concreto.&lt;/p&gt;
&lt;p&gt;Quindi + sul come - sul cosa.&lt;/p&gt;
&lt;h3 id=&#34;312-prototipo-e-implementazione&#34;&gt;3.1.2 Prototipo e implementazione&lt;/h3&gt;
&lt;p&gt;Avevamo introdotto la differenza fra algoritmo e programma all&amp;rsquo;inizio del corso, andiamo ora a definire la differenza fra prototipo e implementazione:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Prototipo:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;va a fare una descrizione dei metodi che deve avere una determinata struttura di dati. Lo puoi intendere come una specie di &lt;em&gt;interfaccia&lt;/em&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Tabelle di hash</title>
      <link>https://flecart.github.io/notes/tabelle-di-hash/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/tabelle-di-hash/</guid>
      <description>&lt;h2 id=&#34;introduzione-alle-tabelle-di-hash&#34;&gt;Introduzione alle Tabelle di Hash&lt;/h2&gt;
&lt;h3 id=&#34;511-prototipo&#34;&gt;5.1.1 Prototipo&lt;/h3&gt;
&lt;p&gt;Vogliamo implementare le operazioni del prototipo dizionario presentato in &lt;a href=&#34;https://flecart.github.io/notes/strutture-di-dati-elementari/&#34;&gt;Strutture di dati elementari&lt;/a&gt;, e vogliamo fare solo queste 3 ma molto bene.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Insert O(1)&lt;/li&gt;
&lt;li&gt;Delete O(1)&lt;/li&gt;
&lt;li&gt;Search in O(1)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;La struttura dati di hash riesce a fare bene queste singole operazioni&lt;/p&gt;
&lt;p&gt;Si vedrÃ  che &lt;strong&gt;l&amp;rsquo;array&lt;/strong&gt; modificato Ã¨ il modo migliore per avere questo hash, solo generalizzando un modo per indicizzarlo che non saranno numeri (indici).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Tecniche algoritmiche</title>
      <link>https://flecart.github.io/notes/tecniche-algoritmiche/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/tecniche-algoritmiche/</guid>
      <description>&lt;p&gt;In questa nota andiamo a parlare in modo sommario (si impara probabilmente molto meglio con la pratica) di generali tipologie di approcci che esistono per affrontare problemi di tipo algoritmico.&lt;/p&gt;
&lt;h2 id=&#34;divide-et-impera&#34;&gt;Divide et impera&lt;/h2&gt;
&lt;h3 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h3&gt;
&lt;p&gt;Abbiamo giÃ  visto L&amp;rsquo;utilizzo di questa tecnica per quick e merge sort in &lt;a href=&#34;https://flecart.github.io/notes/algoritmi-di-ordinamento/&#34;&gt;Algoritmi di ordinamento&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Questa tecnica si focalizza in tre passi fondamentali:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Dividere il problema in sotto-problemi&lt;/li&gt;
&lt;li&gt;Risolvere il sotto-problema&lt;/li&gt;
&lt;li&gt;Mergiare le soluzioni di questi sotto-problemi.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Questa Ã¨ piÃ¹ una tecnica che si impara di piÃ¹ con la pratica, andremo a fare un problema che utilizza questa tecnica&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
