<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>üèõComputer-Architecture on X. Angelo Huang&#39;s Blog</title>
    <link>https://flecart.github.io/tags/computer-architecture/</link>
    <description>Recent content in üèõComputer-Architecture on X. Angelo Huang&#39;s Blog</description>
    <image>
      <title>X. Angelo Huang&#39;s Blog</title>
      <url>https://flecart.github.io/images/papermod-cover.png</url>
      <link>https://flecart.github.io/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <atom:link href="https://flecart.github.io/tags/computer-architecture/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CPU e storia degli elaboratori</title>
      <link>https://flecart.github.io/notes/cpu-e-storia-degli-elaboratori/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cpu-e-storia-degli-elaboratori/</guid>
      <description>2 Storia 2.1 0: Computer Meccanici dal 1600 a oggi
2.2 1: Computer a Valvole Principalmente i computer della seconda guerra mondiale
2.3 2: Computer a Transistor Abbattere i costi
2.4 3: Circuiti stampati Computazione parallela Multiprogrammazione (Caricamento di pi√π programmi) 2.5 4: VLSI Possibilit√† di creare tansissimi transistor
2.6 5: Computer moderni 2.6.1 Computer Ubiqui 2.6.2 Computer invisibili 2.7 Velocit√† di calcolo 2.7.1 Flops and MIPS 3 CPU La struttura moderna degli elaboratori sono basati principalmente sull&amp;rsquo;architettura di Von Neuman, l&amp;rsquo;unica differenza √® che gli elementi di questa architettura.</description>
    </item>
    <item>
      <title>Porte Logiche</title>
      <link>https://flecart.github.io/notes/porte-logiche/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/porte-logiche/</guid>
      <description>In questa nota andiamo a trattare argomenti come tabelle di verit√†. Mappe di Karnaugh. E piccolissima introduzione ai circuiti integrati.
Boole Un signor Boole ha creato le basi dell&amp;rsquo;algebra booleana su cui si basano le porte logiche dei computer moderni.
Tabelle di verit√† Le tabelle di verit√† sono sufficienti per descrivere il funzionamento di una porta logica.
Questa cosa √® possibile grazie alla limitatezza delle funzioni all&amp;rsquo;interno dell&amp;rsquo;insieme $\{0,1\}$ dominio di partenza e fine dell&amp;rsquo;algebra booleana.</description>
    </item>
    <item>
      <title>Memoria</title>
      <link>https://flecart.github.io/notes/memoria/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/memoria/</guid>
      <description>4.1 Caratteristiche della Memoria La gerarchia della memoria, pi√π si va gi√π pi√π spazio si ha, pi√π √® lento il caricamento delle informazioni
4.1.1 Catalogazione della memoria Le tipologie di memoria sono presenti a fianco.
In generale pi√π la memoria √® veloce da riprendere, pi√π √® costosa da memorizzare (c&amp;rsquo;√® poco spazio)
4.1.2 Byte e Word Il libro a pagina 74 parte con la discussione del perch√© si √® preferito evitare la BCD (Binary coded decimal, in cui i numeri da 0 a 9 erano codificato da 4 bit), per questioni di efficienza.</description>
    </item>
    <item>
      <title>Livello OS</title>
      <link>https://flecart.github.io/notes/livello-os/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/livello-os/</guid>
      <description>9.1 Caratteristiche Il sistema operativo non ha sempre avuto una interfaccia grafica.
9.1.1 In generale Principalmente √® un gestore delle risorse come il disco, la CPU, l&amp;rsquo;output e l&amp;rsquo;input.
√à qualcosa che si infrappone come interfaccia fra le applicazioni e quello che √® presente sotto.
9.1.2 Ambiti principali 9.2 Paginazione Al programma non interessa se effettivamente √® presente in memoria fisica questa quantit√† di memoria, si di solito basta sempre.</description>
    </item>
    <item>
      <title>Livello ISA</title>
      <link>https://flecart.github.io/notes/livello-isa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/livello-isa/</guid>
      <description>il livello isa √® il livallo delle istruzioni
8.1 Struttura Solitamente le istruzioni sono divise in due parti:
8.1.1 Opcode e indirizzamento Opcode
Questo opcode indica la tipologia di istruzione.
Per esempio per l&amp;rsquo;architettura HACK √® il primo bit, che indica se √® una istruzione C oppure una istruzione A.
Questo insieme poi alle altre istruzioni che definiscono cosa deve fare costituiscono OPcode.
Indirizzamento
Poi c&amp;rsquo;√® una sezione che indirizza, cio√® dice all&amp;rsquo;istruzione cosa deve prendere e dove deve salvare.</description>
    </item>
    <item>
      <title>Rappresentazione delle informazioni</title>
      <link>https://flecart.github.io/notes/rappresentazione-delle-informazioni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/rappresentazione-delle-informazioni/</guid>
      <description>6.1 Codifiche Si utilizzano codifiche, che sono delle convenzioni, qualcosa che un gruppo di umani ha deciso fosse utile darci un significato.
6.1.1 Codifica posizionale Dove $d_i$ √® il valore in posizione $i$ e $b$ √® la base
$$ \sum_{i=0}^k d_ib $$ 6.1.2 Ottale, esadecimale e binario Queste sono le codifiche principali per i computer in quanto sono comodi da visualizzare. Inoltre Ottale e esadecimale in particolare sono riassunti dei binari, cio√® sono dei sottoinsiemi che possiedono ancora tutte le caratteristiche e quindi sono comodi</description>
    </item>
    <item>
      <title>Circuiti Sequenziali</title>
      <link>https://flecart.github.io/notes/circuiti-sequenziali/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/circuiti-sequenziali/</guid>
      <description>7.1 Introduzione 7.1.1 Perch√© usarli Sono utili per mantenere delle informazioni nel tempo
7.1.2 Caratteristiche Hanno feedback cio√® ci sono degli output che tornano dentro al circuito, quindi √® molto difficile senza sapere niente cosa succede dentro
Questo circuito non √® combinatorio, che √® formalizzabile in modo deterministico con l&amp;rsquo;lgebra booleana.
7.1.3 Il Bit di memoria Questo bit ha due input, un load e un input, se il load √® attivo comincia a storare, altrimenti l&amp;rsquo;output √® sempre il bit che ha memoriazzato.</description>
    </item>
    <item>
      <title>Introduzione ad architettura</title>
      <link>https://flecart.github.io/notes/introduzione-ad-architettura/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-ad-architettura/</guid>
      <description>1.1 Il principio di astrazione/implementazione Astrazione per macchine livello n con linguaggi n.
1.2 I livelli principali di astrazione Livelli in breve
1.2.1 Livello 0 Qua √® utile indagare la
Porte Logiche in cui si indagano in un modo molto alto il funzionamento di porte
√à il livello fisico delle porte logiche e dell&amp;rsquo;ingegneria elettrica.
1.2.2 Livello 1 Link utili potrebbero essere la CPU e storia degli elaboratori
Circuiti Sequenziali Ossia la Memoria</description>
    </item>
  </channel>
</rss>
