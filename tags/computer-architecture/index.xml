<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>üèõComputer-Architecture on X. Angelo Huang&#39;s Blog</title>
    <link>https://flecart.github.io/tags/computer-architecture/</link>
    <description>Recent content in üèõComputer-Architecture on X. Angelo Huang&#39;s Blog</description>
    <image>
      <title>X. Angelo Huang&#39;s Blog</title>
      <url>https://flecart.github.io/images/papermod-cover.png</url>
      <link>https://flecart.github.io/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.143.1</generator>
    <language>en</language>
    <atom:link href="https://flecart.github.io/tags/computer-architecture/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introduzione ad architettura</title>
      <link>https://flecart.github.io/notes/introduzione-ad-architettura/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-ad-architettura/</guid>
      <description>&lt;h3 id=&#34;11-il-principio-di-astrazioneimplementazione&#34;&gt;1.1 Il principio di astrazione/implementazione&lt;/h3&gt;
&lt;p&gt;Astrazione per macchine livello n con linguaggi n.&lt;/p&gt;
&lt;h2 id=&#34;12-i-livelli-principali-di-astrazione&#34;&gt;1.2 I livelli principali di astrazione&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Livelli in breve&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Introduzione ad architettura/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Introduzione ad architettura/Untitled&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;121-livello-0&#34;&gt;1.2.1 Livello 0&lt;/h3&gt;
&lt;p&gt;Qua √® utile indagare la&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://flecart.github.io/notes/porte-logiche&#34;&gt;Porte Logiche&lt;/a&gt; in cui si indagano in un modo molto alto il funzionamento di porte&lt;/p&gt;
&lt;p&gt;√à il livello fisico delle porte logiche e dell&amp;rsquo;ingegneria elettrica.&lt;/p&gt;
&lt;h3 id=&#34;122-livello-1&#34;&gt;1.2.2 Livello 1&lt;/h3&gt;
&lt;p&gt;Link utili potrebbero essere la &lt;a href=&#34;https://flecart.github.io/notes/central-processing-unit&#34;&gt;Central Processing Unit&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Memoria</title>
      <link>https://flecart.github.io/notes/memoria/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/memoria/</guid>
      <description>&lt;h2 id=&#34;41-caratteristiche-della-memoria&#34;&gt;4.1 Caratteristiche della Memoria&lt;/h2&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Memoria/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Memoria/Untitled&#34;&gt;
&lt;p&gt;La gerarchia della memoria, pi√π si va gi√π pi√π spazio si ha, pi√π √® lento il caricamento delle informazioni&lt;/p&gt;
&lt;h3 id=&#34;411-catalogazione-della-memoria&#34;&gt;4.1.1 Catalogazione della memoria&lt;/h3&gt;
&lt;p&gt;Le tipologie di memoria sono presenti a fianco.
In generale pi√π la memoria √® veloce da riprendere, pi√π √® costosa da memorizzare (c&amp;rsquo;√® poco spazio)
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Memoria/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Memoria/Untitled 1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;412-byte-e-word&#34;&gt;4.1.2 Byte e Word&lt;/h3&gt;
&lt;p&gt;Il libro a pagina 74 parte con la discussione del perch√© si √® preferito &lt;strong&gt;evitare la BCD&lt;/strong&gt; (Binary coded decimal, in cui i numeri da 0 a 9 erano codificato da 4 bit), per questioni di efficienza.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Central Processing Unit</title>
      <link>https://flecart.github.io/notes/central-processing-unit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/central-processing-unit/</guid>
      <description>&lt;p&gt;La struttura moderna degli elaboratori sono basati principalmente sull&amp;rsquo;&lt;strong&gt;architettura di Von Neuman,&lt;/strong&gt; l&amp;rsquo;unica differenza √® che gli elementi di questa architettura.&lt;/p&gt;
&lt;h2 id=&#34;struttura-e-funzione-della-cpu&#34;&gt;Struttura e funzione della CPU&lt;/h2&gt;
&lt;p&gt;La CPU si pu√≤ dividere in tre parti principali:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Una unit√† di controllo che coordina i processi&lt;/li&gt;
&lt;li&gt;Registri che immagazzinano temporaneamente piccole quantit√† di informazioni&lt;/li&gt;
&lt;li&gt;ALU che fa i calcoli ordinategli dalla CPU&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;registri-principali&#34;&gt;Registri Principali&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Program Counter o Instruction Pointer
&lt;ul&gt;
&lt;li&gt;Contiene un pointer all&amp;rsquo;istruzione da eseguire cos√¨ lo prende dalla memoria&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Instruction Register
&lt;ul&gt;
&lt;li&gt;Contiene l&amp;rsquo;istruzione da eseguire&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Memory Address Register
&lt;ul&gt;
&lt;li&gt;Prende l&amp;rsquo;indirizzo del contenuto interessante dalla memoria&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Memory Data Register
&lt;ul&gt;
&lt;li&gt;Prende il contenuto dalla memoria&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Program Status Word
&lt;ul&gt;
&lt;li&gt;Raccoglie lo stato di esecuzione del programma, se fallisce se tutto ok oppure se ci sono errori&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;alu&#34;&gt;ALU&lt;/h3&gt;
&lt;p&gt;Aritmetic Logic Unit, √® la componente che fa i calcoli.
Per sapere cosa deve fare, √® la Control Unit che collega certe vie dai registri all&amp;rsquo;ALU.
A seconda del genere di architettura pu√≤ collegarsi direttamente in memoria (CISC) oppure sempre passando per i registri (solitamente RISC)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Circuiti Sequenziali</title>
      <link>https://flecart.github.io/notes/circuiti-sequenziali/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/circuiti-sequenziali/</guid>
      <description>&lt;h2 id=&#34;71-introduzione&#34;&gt;7.1 Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;711-perch√©-usarli&#34;&gt;7.1.1 Perch√© usarli&lt;/h3&gt;
&lt;p&gt;Sono utili per mantenere delle informazioni nel tempo&lt;/p&gt;
&lt;h3 id=&#34;712-caratteristiche&#34;&gt;7.1.2 Caratteristiche&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Hanno feedback&lt;/strong&gt; cio√® ci sono degli output che tornano dentro al circuito, quindi √® molto difficile senza sapere niente cosa succede dentro&lt;/p&gt;
&lt;p&gt;Questo circuito non √® combinatorio, che √® formalizzabile in modo deterministico con l&amp;rsquo;lgebra booleana.&lt;/p&gt;
&lt;h3 id=&#34;713-il-bit-di-memoria&#34;&gt;7.1.3 Il Bit di memoria&lt;/h3&gt;
&lt;p&gt;Questo bit ha due input, un load e un input, se il load √® attivo comincia a storare, altrimenti l&amp;rsquo;output √® sempre il bit che ha memoriazzato.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Livello ISA</title>
      <link>https://flecart.github.io/notes/livello-isa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/livello-isa/</guid>
      <description>&lt;p&gt;il livello isa √® il livello delle istruzioni&lt;/p&gt;
&lt;h2 id=&#34;81-struttura&#34;&gt;8.1 Struttura&lt;/h2&gt;
&lt;p&gt;Potremmo definire l&amp;rsquo;architettura di un elaboratore come tutte le parti del processore che una persona abbia bisogno di sapere per scrivere codice assembly.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Istruzioni possibili&lt;/li&gt;
&lt;li&gt;Registri&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Solitamente le istruzioni sono divise in due parti:&lt;/p&gt;
&lt;h3 id=&#34;811-opcode-e-indirizzamento&#34;&gt;8.1.1 Opcode e indirizzamento&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Opcode&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Questo opcode indica la tipologia di istruzione.&lt;/p&gt;
&lt;p&gt;Per esempio per l&amp;rsquo;architettura HACK √® il primo bit, che indica se √® una istruzione C oppure una istruzione A.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Livello OS</title>
      <link>https://flecart.github.io/notes/livello-os/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/livello-os/</guid>
      <description>&lt;h2 id=&#34;91-caratteristiche&#34;&gt;9.1 Caratteristiche&lt;/h2&gt;
&lt;p&gt;Il sistema operativo non ha sempre avuto una interfaccia grafica.&lt;/p&gt;
&lt;h3 id=&#34;911-in-generale&#34;&gt;9.1.1 In generale&lt;/h3&gt;
&lt;p&gt;Principalmente √® un &lt;strong&gt;gestore delle risorse&lt;/strong&gt; come il disco, la CPU, l&amp;rsquo;output e l&amp;rsquo;input.&lt;/p&gt;
&lt;p&gt;√à qualcosa che si infrappone come interfaccia fra le applicazioni e quello che √® presente sotto.&lt;/p&gt;
&lt;h3 id=&#34;912-ambiti-principali&#34;&gt;9.1.2 Ambiti principali&lt;/h3&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Livello OS/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Livello OS/Untitled&#34;&gt;
&lt;h2 id=&#34;92-paginazione&#34;&gt;9.2 Paginazione&lt;/h2&gt;
&lt;p&gt;Al programma non interessa se effettivamente √® presente in memoria fisica questa quantit√† di memoria, si di solito basta sempre.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Porte Logiche</title>
      <link>https://flecart.github.io/notes/porte-logiche/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/porte-logiche/</guid>
      <description>&lt;p&gt;In questa nota andiamo a trattare argomenti come tabelle di verit√†. Mappe di Karnaugh. E piccolissima introduzione ai circuiti integrati.&lt;/p&gt;
&lt;h2 id=&#34;boole&#34;&gt;Boole&lt;/h2&gt;
&lt;p&gt;Un signor Boole ha creato le basi dell&amp;rsquo;algebra booleana su cui si basano le porte logiche dei computer moderni.&lt;/p&gt;
&lt;h3 id=&#34;tabelle-di-verit√†&#34;&gt;Tabelle di verit√†&lt;/h3&gt;
&lt;p&gt;Le tabelle di verit√† sono sufficienti per descrivere il funzionamento di una porta logica.&lt;/p&gt;
&lt;p&gt;Questa cosa √® possibile grazie alla limitatezza delle funzioni all&amp;rsquo;interno dell&amp;rsquo;insieme $\{0,1\}$ dominio di partenza e fine dell&amp;rsquo;algebra booleana.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Rappresentazione delle informazioni</title>
      <link>https://flecart.github.io/notes/rappresentazione-delle-informazioni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/rappresentazione-delle-informazioni/</guid>
      <description>&lt;h2 id=&#34;61-codifiche&#34;&gt;6.1 Codifiche&lt;/h2&gt;
&lt;p&gt;Si utilizzano codifiche, che sono delle &lt;strong&gt;convenzioni&lt;/strong&gt;, qualcosa che un gruppo di umani ha deciso fosse utile darci un significato.&lt;/p&gt;
&lt;h3 id=&#34;611-codifica-posizionale&#34;&gt;6.1.1 Codifica posizionale&lt;/h3&gt;
&lt;p&gt;Dove $d_i$ √® il valore in posizione $i$ e $b$ √® la base&lt;/p&gt;
$$
\sum_{i=0}^k d_ib
$$&lt;h3 id=&#34;612-ottale-esadecimale-e-binario&#34;&gt;6.1.2 Ottale, esadecimale e binario&lt;/h3&gt;
&lt;p&gt;Queste sono le codifiche principali per i computer in quanto sono comodi da visualizzare. Inoltre Ottale e esadecimale in particolare sono riassunti dei binari, cio√® sono dei sottoinsiemi che possiedono ancora tutte le caratteristiche e quindi sono comodi&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
