<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>üèõComputer-Architecture on X. Angelo Huang&#39;s Blog</title>
    <link>https://flecart.github.io/tags/computer-architecture/</link>
    <description>Recent content in üèõComputer-Architecture on X. Angelo Huang&#39;s Blog</description>
    <image>
      <title>X. Angelo Huang&#39;s Blog</title>
      <url>https://flecart.github.io/images/papermod-cover.png</url>
      <link>https://flecart.github.io/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.143.1</generator>
    <language>en</language>
    <atom:link href="https://flecart.github.io/tags/computer-architecture/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Circuiti Sequenziali</title>
      <link>https://flecart.github.io/notes/circuiti-sequenziali/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/circuiti-sequenziali/</guid>
      <description>&lt;h2 id=&#34;71-introduzione&#34;&gt;7.1 Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;711-perch√©-usarli&#34;&gt;7.1.1 Perch√© usarli&lt;/h3&gt;
&lt;p&gt;Sono utili per mantenere delle informazioni nel tempo&lt;/p&gt;
&lt;h3 id=&#34;712-caratteristiche&#34;&gt;7.1.2 Caratteristiche&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Hanno feedback&lt;/strong&gt; cio√® ci sono degli output che tornano dentro al circuito, quindi √® molto difficile senza sapere niente cosa succede dentro&lt;/p&gt;
&lt;p&gt;Questo circuito non √® combinatorio, che √® formalizzabile in modo deterministico con l&amp;rsquo;lgebra booleana.&lt;/p&gt;
&lt;h3 id=&#34;713-il-bit-di-memoria&#34;&gt;7.1.3 Il Bit di memoria&lt;/h3&gt;
&lt;p&gt;Questo bit ha due input, un load e un input, se il load √® attivo comincia a storare, altrimenti l&amp;rsquo;output √® sempre il bit che ha memoriazzato.&lt;/p&gt;</description>
    </item>
    <item>
      <title>CPU e storia degli elaboratori</title>
      <link>https://flecart.github.io/notes/cpu-e-storia-degli-elaboratori/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cpu-e-storia-degli-elaboratori/</guid>
      <description>&lt;h1 id=&#34;2-storia&#34;&gt;2 Storia&lt;/h1&gt;
&lt;h2 id=&#34;21-0-computer-meccanici&#34;&gt;2.1 0: Computer Meccanici&lt;/h2&gt;
&lt;p&gt;dal 1600 a oggi&lt;/p&gt;
&lt;h2 id=&#34;22-1-computer-a-valvole&#34;&gt;2.2 1: Computer a Valvole&lt;/h2&gt;
&lt;p&gt;Principalmente i computer della seconda guerra mondiale&lt;/p&gt;
&lt;h2 id=&#34;23-2-computer-a-transistor&#34;&gt;2.3 2: Computer a Transistor&lt;/h2&gt;
&lt;p&gt;Abbattere i costi&lt;/p&gt;
&lt;h2 id=&#34;24-3-circuiti-stampati&#34;&gt;2.4 3: Circuiti stampati&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Computazione parallela&lt;/li&gt;
&lt;li&gt;Multiprogrammazione (Caricamento di pi√π programmi)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;25-4-vlsi&#34;&gt;2.5 4: VLSI&lt;/h2&gt;
&lt;p&gt;Possibilit√† di creare tansissimi transistor&lt;/p&gt;
&lt;h2 id=&#34;26-5-computer-moderni&#34;&gt;2.6 5: Computer moderni&lt;/h2&gt;
&lt;h3 id=&#34;261-computer-ubiqui&#34;&gt;2.6.1 Computer Ubiqui&lt;/h3&gt;
&lt;h3 id=&#34;262-computer-invisibili&#34;&gt;2.6.2 Computer invisibili&lt;/h3&gt;
&lt;h2 id=&#34;27-velocit√†-di-calcolo&#34;&gt;2.7 Velocit√† di calcolo&lt;/h2&gt;
&lt;h3 id=&#34;271-flops-and-mips&#34;&gt;2.7.1 Flops and MIPS&lt;/h3&gt;
&lt;h1 id=&#34;3-cpu&#34;&gt;3 CPU&lt;/h1&gt;
&lt;p&gt;La struttura moderna degli elaboratori sono basati principalmente sull&amp;rsquo;&lt;strong&gt;architettura di Von Neuman,&lt;/strong&gt; l&amp;rsquo;unica differenza √® che gli elementi di questa architettura.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Introduzione ad architettura</title>
      <link>https://flecart.github.io/notes/introduzione-ad-architettura/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-ad-architettura/</guid>
      <description>&lt;h3 id=&#34;11-il-principio-di-astrazioneimplementazione&#34;&gt;1.1 Il principio di astrazione/implementazione&lt;/h3&gt;
&lt;p&gt;Astrazione per macchine livello n con linguaggi n.&lt;/p&gt;
&lt;h2 id=&#34;12-i-livelli-principali-di-astrazione&#34;&gt;1.2 I livelli principali di astrazione&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Livelli in breve&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Introduzione ad architettura/Untitled.png&#34; alt=&#34;image/universita/ex-notion/Introduzione ad architettura/Untitled&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;121-livello-0&#34;&gt;1.2.1 Livello 0&lt;/h3&gt;
&lt;p&gt;Qua √® utile indagare la&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://flecart.github.io/notes/porte-logiche/&#34;&gt;Porte Logiche&lt;/a&gt; in cui si indagano in un modo molto alto il funzionamento di porte&lt;/p&gt;
&lt;p&gt;√à il livello fisico delle porte logiche e dell&amp;rsquo;ingegneria elettrica.&lt;/p&gt;
&lt;h3 id=&#34;122-livello-1&#34;&gt;1.2.2 Livello 1&lt;/h3&gt;
&lt;p&gt;Link utili potrebbero essere la
&lt;a href=&#34;https://flecart.github.io/notes/cpu-e-storia-degli-elaboratori/&#34;&gt;CPU e storia degli elaboratori&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Livello ISA</title>
      <link>https://flecart.github.io/notes/livello-isa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/livello-isa/</guid>
      <description>&lt;p&gt;il livello isa √® il livallo delle istruzioni&lt;/p&gt;
&lt;h2 id=&#34;81-struttura&#34;&gt;8.1 Struttura&lt;/h2&gt;
&lt;p&gt;Solitamente le istruzioni sono divise in due parti:&lt;/p&gt;
&lt;h3 id=&#34;811-opcode-e-indirizzamento&#34;&gt;8.1.1 Opcode e indirizzamento&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Opcode&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Questo opcode indica la tipologia di istruzione.&lt;/p&gt;
&lt;p&gt;Per esempio per l&amp;rsquo;architettura HACK √® il primo bit, che indica se √® una istruzione C oppure una istruzione A.&lt;/p&gt;
&lt;p&gt;Questo insieme poi alle altre istruzioni che definiscono cosa deve fare costituiscono OPcode.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Indirizzamento&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Poi c&amp;rsquo;√® una sezione che indirizza, cio√® dice all&amp;rsquo;istruzione cosa deve prendere e dove deve salvare.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Livello OS</title>
      <link>https://flecart.github.io/notes/livello-os/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/livello-os/</guid>
      <description>&lt;h2 id=&#34;91-caratteristiche&#34;&gt;9.1 Caratteristiche&lt;/h2&gt;
&lt;p&gt;Il sistema operativo non ha sempre avuto una interfaccia grafica.&lt;/p&gt;
&lt;h3 id=&#34;911-in-generale&#34;&gt;9.1.1 In generale&lt;/h3&gt;
&lt;p&gt;Principalmente √® un &lt;strong&gt;gestore delle risorse&lt;/strong&gt; come il disco, la CPU, l&amp;rsquo;output e l&amp;rsquo;input.&lt;/p&gt;
&lt;p&gt;√à qualcosa che si infrappone come interfaccia fra le applicazioni e quello che √® presente sotto.&lt;/p&gt;
&lt;h3 id=&#34;912-ambiti-principali&#34;&gt;9.1.2 Ambiti principali&lt;/h3&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Livello OS/Untitled.png&#34; alt=&#34;image/universita/ex-notion/Livello OS/Untitled&#34;&gt;
&lt;h2 id=&#34;92-paginazione&#34;&gt;9.2 Paginazione&lt;/h2&gt;
&lt;p&gt;Al programma non interessa se effettivamente √® presente in memoria fisica questa quantit√† di memoria, si di solito basta sempre.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Memoria</title>
      <link>https://flecart.github.io/notes/memoria/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/memoria/</guid>
      <description>&lt;h2 id=&#34;41-caratteristiche-della-memoria&#34;&gt;4.1 Caratteristiche della Memoria&lt;/h2&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Memoria/Untitled.png&#34; alt=&#34;image/universita/ex-notion/Memoria/Untitled&#34;&gt;
&lt;p&gt;La gerarchia della memoria, pi√π si va gi√π pi√π spazio si ha, pi√π √® lento il caricamento delle informazioni&lt;/p&gt;
&lt;h3 id=&#34;411-catalogazione-della-memoria&#34;&gt;4.1.1 Catalogazione della memoria&lt;/h3&gt;
&lt;p&gt;Le tipologie di memoria sono presenti a fianco.&lt;/p&gt;
&lt;p&gt;In generale pi√π la memoria √® veloce da riprendere, pi√π √® costosa da memorizzare (c&amp;rsquo;√® poco spazio)&lt;/p&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Memoria/Untitled 1.png&#34; alt=&#34;image/universita/ex-notion/Memoria/Untitled 1&#34;&gt;
&lt;h3 id=&#34;412-byte-e-word&#34;&gt;4.1.2 Byte e Word&lt;/h3&gt;
&lt;p&gt;Il libro a pagina 74 parte con la discussione del perch√© si √® preferito &lt;strong&gt;evitare la BCD&lt;/strong&gt; (Binary coded decimal, in cui i numeri da 0 a 9 erano codificato da 4 bit), per questioni di efficienza.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Porte Logiche</title>
      <link>https://flecart.github.io/notes/porte-logiche/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/porte-logiche/</guid>
      <description>&lt;p&gt;In questa nota andiamo a trattare argomenti come tabelle di verit√†. Mappe di Karnaugh. E piccolissima introduzione ai circuiti integrati.&lt;/p&gt;
&lt;h2 id=&#34;boole&#34;&gt;Boole&lt;/h2&gt;
&lt;p&gt;Un signor Boole ha creato le basi dell&amp;rsquo;algebra booleana su cui si basano le porte logiche dei computer moderni.&lt;/p&gt;
&lt;h3 id=&#34;tabelle-di-verit√†&#34;&gt;Tabelle di verit√†&lt;/h3&gt;
&lt;p&gt;Le tabelle di verit√† sono sufficienti per descrivere il funzionamento di una porta logica.&lt;/p&gt;
&lt;p&gt;Questa cosa √® possibile grazie alla limitatezza delle funzioni all&amp;rsquo;interno dell&amp;rsquo;insieme $\{0,1\}$ dominio di partenza e fine dell&amp;rsquo;algebra booleana.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Rappresentazione delle informazioni</title>
      <link>https://flecart.github.io/notes/rappresentazione-delle-informazioni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/rappresentazione-delle-informazioni/</guid>
      <description>&lt;h2 id=&#34;61-codifiche&#34;&gt;6.1 Codifiche&lt;/h2&gt;
&lt;p&gt;Si utilizzano codifiche, che sono delle &lt;strong&gt;convenzioni&lt;/strong&gt;, qualcosa che un gruppo di umani ha deciso fosse utile darci un significato.&lt;/p&gt;
&lt;h3 id=&#34;611-codifica-posizionale&#34;&gt;6.1.1 Codifica posizionale&lt;/h3&gt;
&lt;p&gt;Dove $d_i$ √® il valore in posizione $i$ e $b$ √® la base&lt;/p&gt;
$$
\sum_{i=0}^k d_ib
$$&lt;h3 id=&#34;612-ottale-esadecimale-e-binario&#34;&gt;6.1.2 Ottale, esadecimale e binario&lt;/h3&gt;
&lt;p&gt;Queste sono le codifiche principali per i computer in quanto sono comodi da visualizzare. Inoltre Ottale e esadecimale in particolare sono riassunti dei binari, cio√® sono dei sottoinsiemi che possiedono ancora tutte le caratteristiche e quindi sono comodi&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
