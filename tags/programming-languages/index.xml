<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Programming-Languages on X. Angelo Huang&#39;s Blog</title>
    <link>https://flecart.github.io/tags/programming-languages/</link>
    <description>Recent content in Programming-Languages on X. Angelo Huang&#39;s Blog</description>
    <image>
      <title>X. Angelo Huang&#39;s Blog</title>
      <url>https://flecart.github.io/images/papermod-cover.png</url>
      <link>https://flecart.github.io/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.143.1</generator>
    <language>en</language>
    <lastBuildDate>Thu, 30 Oct 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://flecart.github.io/tags/programming-languages/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Bytecode Verification</title>
      <link>https://flecart.github.io/notes/bytecode-verification/</link>
      <pubDate>Thu, 30 Oct 2025 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/bytecode-verification/</guid>
      <description>&lt;p&gt;Code in modern days is &lt;strong&gt;mobile&lt;/strong&gt; in the sense that it gets downloaded and executed on the fly very often.
In JVM they are usually shipped with:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Platform independent code&lt;/li&gt;
&lt;li&gt;Organized into class files.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;class-loaders&#34;&gt;Class Loaders&lt;/h4&gt;
&lt;p&gt;The class loader is the part of the JVM that takes the bytecode and interprets all the class files to make the program runnable.&lt;/p&gt;
&lt;h3 id=&#34;security-considerations&#34;&gt;Security Considerations&lt;/h3&gt;
&lt;h4 id=&#34;requirements-for-security&#34;&gt;Requirements for Security&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Mobile code cannot be trusted&lt;/li&gt;
&lt;li&gt;Code may not be type safe&lt;/li&gt;
&lt;li&gt;Code may destroy or modify data&lt;/li&gt;
&lt;li&gt;Code may expose personal information&lt;/li&gt;
&lt;li&gt;Code may crash the underlying VM&lt;/li&gt;
&lt;li&gt;Code may purposefully degrade performance (denial ofservice)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is somewhat similar to the trust relations we explored in &lt;a href=&#34;https://flecart.github.io/notes/notions-of-security&#34;&gt;Notions of Security&lt;/a&gt;.
Anyways, since the code is not trusted, we need a way to prove some of its properties.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Inheritance</title>
      <link>https://flecart.github.io/notes/inheritance/</link>
      <pubDate>Thu, 09 Oct 2025 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/inheritance/</guid>
      <description>&lt;h3 id=&#34;introduction-to-inheritance&#34;&gt;Introduction to Inheritance&lt;/h3&gt;
&lt;h4 id=&#34;difference-between-inheritance-and-subtyping&#34;&gt;Difference between Inheritance and Subtyping&lt;/h4&gt;
&lt;p&gt;We say that a subclass is inheritance and subtyping.
We have studied subtyping in &lt;a href=&#34;https://flecart.github.io/notes/typing-and-subtyping&#34;&gt;Typing and Subtyping&lt;/a&gt; and it entails mainly two things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Liskov Substitution&lt;/li&gt;
&lt;li&gt;Polymorphism of the types&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While inheritance is just the &lt;strong&gt;code reuse&lt;/strong&gt; and specialization.
Another example of code reuse can be the “has-a” relation composition, which couples two objects together.
With aggregations, we can also see &lt;strong&gt;delegation&lt;/strong&gt; calls, when you have a class, and call a method of that class.
&lt;img src=&#34;https://flecart.github.io/images/notes/Inheritance-20251009104450885.webp&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;Inheritance-20251009104450885&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Typing and Subtyping</title>
      <link>https://flecart.github.io/notes/typing-and-subtyping/</link>
      <pubDate>Thu, 25 Sep 2025 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/typing-and-subtyping/</guid>
      <description>&lt;p&gt;We first start with some design goals for the language&lt;/p&gt;
&lt;h4 id=&#34;language-design-principles&#34;&gt;Language Design Principles&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Simplicity&lt;/strong&gt; Syntax and semantics can easily be understood by users and implementers of the language
&lt;strong&gt;Expressiveness&lt;/strong&gt;: Language can (easily) express complex processes and structures, conflicting with simplicity.
&lt;strong&gt;Safety&lt;/strong&gt;: Language discourages errors and allows errors to be discovered and reported, ideally at compile time
&lt;strong&gt;Modularity&lt;/strong&gt;: Language allows modules to be type-checked and compiled separately
&lt;strong&gt;Performance&lt;/strong&gt;: Programs written in the language can be executed efficiently
&lt;strong&gt;Productivity&lt;/strong&gt;:  Language leads to low costs of writing programs like Python.
&lt;strong&gt;Backwards Compatibility&lt;/strong&gt;: Newer language versions work and interface with programs in older versions (dependency injection for examples helps for this.)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Object Orientation</title>
      <link>https://flecart.github.io/notes/object-orientation/</link>
      <pubDate>Wed, 28 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/object-orientation/</guid>
      <description>&lt;h2 id=&#34;il-tipo-di-dato-astratto&#34;&gt;Il Tipo di Dato Astratto&lt;/h2&gt;
&lt;h3 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h3&gt;
&lt;p&gt;Per questi tipi di dato non ci interessa di sapere cosa ci sia sotto (storato come bit? storato come sabbia boh), ci interessa solamente che abbia quei metodi, che possiamo in un certo senso identificare come la sua capsula, &lt;strong&gt;opaca&lt;/strong&gt; in questo caso.&lt;/p&gt;
&lt;p&gt;Quando si può andare a modificare solamente attraverso questo metodo potrei dire che sia &lt;strong&gt;safe&lt;/strong&gt; collegato alla &lt;a href=&#34;https://flecart.github.io/notes/algebra-dei-tipi&#34;&gt;Algebra dei tipi&lt;/a&gt;, nel senso che vengono soddisfatte sempre le proprietà del tipo.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Polimorfismo</title>
      <link>https://flecart.github.io/notes/polimorfismo/</link>
      <pubDate>Wed, 28 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/polimorfismo/</guid>
      <description>&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;monoforfo&#34;&gt;Monoforfo&lt;/h3&gt;
&lt;p&gt;Quando non posso utilizzare un tipo come parametro. Ossia non possiamo definire una funzione generica.&lt;/p&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Polimorfismo/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Polimorfismo/Untitled&#34;&gt;
&lt;h2 id=&#34;polimorfismo&#34;&gt;Polimorfismo&lt;/h2&gt;
&lt;p&gt;Polimorfismo, come dice il nome, significa avere tante forme, in questo caso tanti tipi. Ma avere tanti tipi non è una cosa ambigua? Questa cosa si risolve solitamente a compile time (facendo checks di sottotipo, oppure dispatch della funzione corretta).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A program part is polymorphic if it can be used for objects of several classes&lt;/p&gt;</description>
    </item>
    <item>
      <title>Classi OOP</title>
      <link>https://flecart.github.io/notes/classi-oop/</link>
      <pubDate>Fri, 26 Sep 2025 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/classi-oop/</guid>
      <description>&lt;h2 id=&#34;introduzione-a-oop&#34;&gt;Introduzione a OOP&lt;/h2&gt;
&lt;p&gt;Per la definizione di classe andare a guardare &lt;a href=&#34;https://flecart.github.io/notes/object-orientation&#34;&gt;Object Orientation&lt;/a&gt;, però lo ripeto in questa occasione, è solamente un modello su cui andare a costruire degli oggetti.&lt;/p&gt;
&lt;h3 id=&#34;capisaldi&#34;&gt;Capisaldi&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Incapsulazione (con interfaccia, base per la documentazione)&lt;/li&gt;
&lt;li&gt;Astrazione&lt;/li&gt;
&lt;li&gt;Ereditarietà&lt;/li&gt;
&lt;li&gt;Dispatch dinamico&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Inheritance to avoid code duplication&lt;/li&gt;
&lt;li&gt;Subtyping to express classification&lt;/li&gt;
&lt;li&gt;Overriding to specialize methods&lt;/li&gt;
&lt;li&gt;Dynamic binding to adapt reused algorithms&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;costruttori&#34;&gt;Costruttori&lt;/h3&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Classi OOP/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Classi OOP/Untitled&#34;&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Classi OOP/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Classi OOP/Untitled 1&#34;&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Classi OOP/Untitled 2.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Classi OOP/Untitled 2&#34;&gt;
&lt;p&gt;Il costruttore è un codice utilizzato per &lt;strong&gt;inizializzare correttamente lo stato&lt;/strong&gt; interno. Le regole sono le stesse dei metodi sovraccaricati (dinamica per la chiamata, statica per il numero dei parametri che prende in input).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Teoria dei Tipi</title>
      <link>https://flecart.github.io/notes/teoria-dei-tipi/</link>
      <pubDate>Sun, 28 Sep 2025 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/teoria-dei-tipi/</guid>
      <description>&lt;h2 id=&#34;introduzione-alla-teoria-dei-tipi&#34;&gt;Introduzione alla Teoria dei Tipi&lt;/h2&gt;
&lt;h3 id=&#34;history-of-languages-research&#34;&gt;History of Languages Research&lt;/h3&gt;
&lt;p&gt;The root of languages research are in:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;in logic and computations (even before computers!).&lt;/li&gt;
&lt;li&gt;Artificial intelligence (Lisp, constrained solvers, the original logical AI we studied in &lt;a href=&#34;https://flecart.github.io/notes/teoria-dei-tipi#russellArtificialIntelligenceModern2009&#34;&gt;(Russell &amp;amp; Norvig 2009)&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;Algebra and symbolic reasoning.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;definizione-di-tipo&#34;&gt;Definizione di Tipo&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Un metodo sintattico &lt;strong&gt;praticabile&lt;/strong&gt; per dimostrare l&amp;rsquo;assenza di determinati comportamenti del
programma, fatto classificando le unità sintattiche in base ai tipi di valore che assumono&lt;/p&gt;</description>
    </item>
    <item>
      <title>Semantica di un linguaggio</title>
      <link>https://flecart.github.io/notes/semantica-di-un-linguaggio/</link>
      <pubDate>Wed, 28 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/semantica-di-un-linguaggio/</guid>
      <description>&lt;h2 id=&#34;vincoli-sintattici-contestuali&#34;&gt;Vincoli sintattici contestuali&lt;/h2&gt;
&lt;h3 id=&#34;intro-dipendenze-da-contesto&#34;&gt;Intro: dipendenze da contesto&lt;/h3&gt;
&lt;p&gt;I vincoli sintattici non sono esprimibili tramite BNF perché dipendono dal contesto, mentre le grammatiche libere sono per definizione libere da contesto, vogliamo quindi trovare una soluzione a questo problema. Vengono usati metodi Ad-Hoc nella fase di &lt;strong&gt;analisi semantica&lt;/strong&gt; del programma.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Grammatiche dipendenti dal contesto&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Queste grammatiche sono molto più complicate (e lente) rispetto a quelle libere da contesto, quindi è poco pratico e non utilizzabile (tempo esponenziale, quindi non finisce mai).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linguaggi Deterministici e DPDA</title>
      <link>https://flecart.github.io/notes/linguaggi-deterministici-e-dpda/</link>
      <pubDate>Wed, 28 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/linguaggi-deterministici-e-dpda/</guid>
      <description>&lt;h2 id=&#34;dpda&#34;&gt;DPDA&lt;/h2&gt;
&lt;h3 id=&#34;definizione-2&#34;&gt;Definizione (2)&lt;/h3&gt;
&lt;p&gt;La definizione di DPDA è molto simile a quella trattata in &lt;a href=&#34;https://flecart.github.io/notes/linguaggi-liberi-e-pda&#34;&gt;Linguaggi liberi e PDA&lt;/a&gt;, con solo costraints sulla deterministicità, che si traducono in due condizioni:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Al massimo posso avere un risultato per ogni coppia di lettura e simbolo su stack&lt;/li&gt;
&lt;li&gt;Se ho una transizione senza leggere, posso avere solo quella&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Linguaggi Deterministici e DPDA/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Linguaggi Deterministici e DPDA/Untitled 1&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;linguaggio-libero-deterministico&#34;&gt;Linguaggio libero deterministico&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Un linguaggio è libero deterministico se esiste un PDA che lo riconosce per &lt;strong&gt;stato finale&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linguaggi liberi e PDA</title>
      <link>https://flecart.github.io/notes/linguaggi-liberi-e-pda/</link>
      <pubDate>Wed, 28 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/linguaggi-liberi-e-pda/</guid>
      <description>&lt;p&gt;In questa parte del nostro percorso nei linguaggi di programmazione proviamo ad espandere NFA e DFA in modo che possano riconoscere linguaggi come $ww^r | w \in \{a, b\}^*$ , con r maggiore o uguale a zero (r per dire che è il contrario di w) (questo linguaggio per il pumping lemma).&lt;/p&gt;
&lt;h4 id=&#34;grammatiche-libere-da-contesto&#34;&gt;Grammatiche libere da contesto&lt;/h4&gt;
$$
G = \langle \mathcal{N}, S, \Sigma, \mathcal{R} \rangle 
$$&lt;p&gt;
Dove $\mathcal{N}$ sono i non terminali, $S$ è il non terminale iniziale, $\Sigma$ sono l&amp;rsquo;alfabeto dei simboli finali e $\mathcal{R}$ le relazioni possibili.
Spesso lo scriviamo solo tramite le relazioni, perché è la forma più compatta.
I nodi di una derivazione da grammatica libera da contesto è chiamato &lt;strong&gt;costituente del linguaggio&lt;/strong&gt;. Questo è più importante in linguistica.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LR(k) e YACC</title>
      <link>https://flecart.github.io/notes/lrk-e-yacc/</link>
      <pubDate>Wed, 28 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/lrk-e-yacc/</guid>
      <description>&lt;h2 id=&#34;lrk&#34;&gt;LR(k)&lt;/h2&gt;
&lt;h3 id=&#34;grammatiche-lrk&#34;&gt;Grammatiche LR(k)&lt;/h3&gt;
&lt;p&gt;Anche in questo caso proviamo a generalizzare il concetto dei pirmi k caratteri, in modo da generalizzare in qualche senso il concetto di LR(k), quindi &lt;strong&gt;andiamo a modificare la closure&lt;/strong&gt; considerando ora first k&lt;/p&gt;
&lt;p&gt;Per ricordarti come si calcolava first k, andare a guardare &lt;a href=&#34;https://flecart.github.io/notes/top-down-parser&#34;&gt;Top-down Parser&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;il problema che poi diventa pratico riguardo questo è l&amp;rsquo;impossibilità di gestire &lt;strong&gt;stringhe lunghezza k&lt;/strong&gt; che sono una assurdità (esponenziale per la lunghezza)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Macchine Astratte</title>
      <link>https://flecart.github.io/notes/macchine-astratte/</link>
      <pubDate>Wed, 28 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/macchine-astratte/</guid>
      <description>&lt;h3 id=&#34;definizione-ed-esempi-per-macchine-astratte&#34;&gt;Definizione ed esempi per macchine astratte&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Una macchina astratta è un qualunque insieme di algoritmi e strutture di dati che permettono di memorizzare ed eseguire il linguaggio $L$, quindi una macchina astratta esiste per esguire &lt;strong&gt;il proprio linguaggio&lt;/strong&gt; (inteso come insieme finito di istruzioni primitive che riesce ad  comprendere e eseguire).&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Si può proprio dire che &lt;em&gt;esiste una simbiosi&lt;/em&gt; fra macchina e linguaggio. Si potrebbe dire che la macchina fisica è soltanto una implementazione FISICA di un linguaggio, ossia una macchina che capisce ed esegue quel linguaggio e che sia solamente un caso particolare della macchina astratta.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Nomi e Scope</title>
      <link>https://flecart.github.io/notes/nomi-e-scope/</link>
      <pubDate>Wed, 28 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/nomi-e-scope/</guid>
      <description>&lt;h2 id=&#34;i-nomi-e-oggetti&#34;&gt;I Nomi e oggetti&lt;/h2&gt;
&lt;h3 id=&#34;oggetti-denotati-e-identificatori&#34;&gt;Oggetti denotati e identificatori&lt;/h3&gt;
&lt;p&gt;I nomi sono sequenze di caratteri o numeri aka: &lt;strong&gt;token alfanumerico&lt;/strong&gt; (anche &lt;strong&gt;IDENTIFICATORE&lt;/strong&gt; (per token guardare &lt;a href=&#34;https://flecart.github.io/notes/grammatiche-regolari&#34;&gt;Grammatiche Regolari&lt;/a&gt;) utilizzate principalmente come &lt;strong&gt;Astrazione sul controllo e sui dati&lt;/strong&gt; (quindi sono cose molto più facili da ricordare rispetto il suo encoding binario o a indirizzi). Infatti utilizziamo i nomi per evitare di interessarci di informazioni come l&amp;rsquo;indirizzo di memoria del nostro dato o per creare una interfaccia con visibili solo nome della procedura e parametri.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Semplificazione grammatiche</title>
      <link>https://flecart.github.io/notes/semplificazione-grammatiche/</link>
      <pubDate>Wed, 28 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/semplificazione-grammatiche/</guid>
      <description>&lt;h2 id=&#34;gestione-del-non-determinismo&#34;&gt;Gestione del non determinismo&lt;/h2&gt;
&lt;p&gt;Il modo più facile per gestire il non determinsmo è &lt;strong&gt;semplificare le grammatiche&lt;/strong&gt; quindi andiamo a vedere metodi per fare ciò.&lt;/p&gt;
&lt;h3 id=&#34;semplificazione-grammatiche-5&#34;&gt;Semplificazione grammatiche (5)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Semplificazione grammatiche/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Semplificazione grammatiche/Untitled 1&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;No produzioni del tipo $A \to \varepsilon$ per bottom up (altrimenti va all&amp;rsquo;infinito!)&lt;/li&gt;
&lt;li&gt;No produzioni unitarie, così evito cicli in cui da A derivo sé stesso.&lt;/li&gt;
&lt;li&gt;No simboli inutili&lt;/li&gt;
&lt;li&gt;No ricorsione sinistra (divergenza per top-down)&lt;/li&gt;
&lt;li&gt;Fattorizzazione della grammatica&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;eliminazione-delel-produzioni-nulle&#34;&gt;Eliminazione delel produzioni nulle&lt;/h2&gt;
&lt;p&gt;Vogliamo creare un algoritmo utile ad eliminare le produzioni che non ci piacciono.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Top-down Parser</title>
      <link>https://flecart.github.io/notes/top-down-parser/</link>
      <pubDate>Wed, 28 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/top-down-parser/</guid>
      <description>&lt;h2 id=&#34;top-down&#34;&gt;Top-down&lt;/h2&gt;
&lt;h3 id=&#34;algoritmo-di-parsing&#34;&gt;Algoritmo di parsing&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Top-down Parser/Untitled 1&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Questo si potrebbe considerare come algoritmo classico di parsing con non determinismo. (vado avanti, ed esploro tutto, senza look ahead).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Esempio di esecuzione&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 2.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Top-down Parser/Untitled 2&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;commenti-efficienza-di-sopra&#34;&gt;Commenti efficienza di sopra&lt;/h3&gt;
&lt;p&gt;È molto inefficiente, in particolare si potrebbe trovare una compessità esponenziale del tipo&lt;/p&gt;
&lt;p&gt;$O(b^{|w|})$, con b il massimo numero di produzioni. (la produzione maggiore la espando sempre!)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide&lt;/p&gt;</description>
    </item>
    <item>
      <title>Valutazione Espressioni</title>
      <link>https://flecart.github.io/notes/valutazione-espressioni/</link>
      <pubDate>Wed, 28 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/valutazione-espressioni/</guid>
      <description>&lt;h1 id=&#34;espressioni-comandi-ricorsione&#34;&gt;Espressioni, Comandi, Ricorsione&lt;/h1&gt;
&lt;h2 id=&#34;espressioni&#34;&gt;Espressioni&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Con espressione intendiamo una entità sintattica, che una volta valutata &lt;strong&gt;ritornerà un valore&lt;/strong&gt;, oppure non termina, in questo caso si dice che la espressione è INDEFINITA.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Questa è una definizione è leggermente ambigua dato che non abbiamo una definizione precisa di valutazoine, che è fortemente dipendente dalla macchina astratta in cui viene eseguito.&lt;/p&gt;
&lt;h3 id=&#34;notazioni-sintassi-possibili-3&#34;&gt;Notazioni (sintassi possibili) (3)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Notazione infissa&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Questa è la notazione classica matematica, per cose tipo $a -b$, in cui l&amp;rsquo;operando sta nel mezzo degli operatori.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
