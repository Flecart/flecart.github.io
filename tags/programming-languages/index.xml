<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Programming-Languages on X. Angelo Huang&#39;s Blog</title>
    <link>https://flecart.github.io/tags/programming-languages/</link>
    <description>Recent content in Programming-Languages on X. Angelo Huang&#39;s Blog</description>
    <image>
      <title>X. Angelo Huang&#39;s Blog</title>
      <url>https://flecart.github.io/images/papermod-cover.png</url>
      <link>https://flecart.github.io/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.143.1</generator>
    <language>en</language>
    <atom:link href="https://flecart.github.io/tags/programming-languages/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linguaggi Deterministici e DPDA</title>
      <link>https://flecart.github.io/notes/linguaggi-deterministici-e-dpda/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/linguaggi-deterministici-e-dpda/</guid>
      <description>&lt;h2 id=&#34;dpda&#34;&gt;DPDA&lt;/h2&gt;
&lt;h3 id=&#34;definizione-2&#34;&gt;Definizione (2)&lt;/h3&gt;
&lt;p&gt;La definizione di DPDA Ã¨ molto simile a quella trattata in &lt;a href=&#34;https://flecart.github.io/notes/linguaggi-liberi-e-pda&#34;&gt;Linguaggi liberi e PDA&lt;/a&gt;, con solo costraints sulla deterministicitÃ , che si traducono in due condizioni:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Al massimo posso avere un risultato per ogni coppia di lettura e simbolo su stack&lt;/li&gt;
&lt;li&gt;Se ho una transizione senza leggere, posso avere solo quella&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Linguaggi Deterministici e DPDA/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Linguaggi Deterministici e DPDA/Untitled 1&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;linguaggio-libero-deterministico&#34;&gt;Linguaggio libero deterministico&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Un linguaggio Ã¨ libero deterministico se esiste un PDA che lo riconosce per &lt;strong&gt;stato finale&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linguaggi liberi e PDA</title>
      <link>https://flecart.github.io/notes/linguaggi-liberi-e-pda/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/linguaggi-liberi-e-pda/</guid>
      <description>&lt;p&gt;In questa parte del nostro percorso nei linguaggi di programmazione proviamo ad espandere NFA e DFA in modo che possano riconoscere linguaggi come $ww^r | w \in \{a, b\}^*$ , con r maggiore o uguale a zero (r per dire che Ã¨ il contrario di w) (questo linguaggio per il pumping lemma).&lt;/p&gt;
&lt;h4 id=&#34;grammatiche-libere-da-contesto&#34;&gt;Grammatiche libere da contesto&lt;/h4&gt;
$$
G = \langle \mathcal{N}, S, \Sigma, \mathcal{R} \rangle 
$$&lt;p&gt;
Dove $\mathcal{N}$ sono i non terminali, $S$ Ã¨ il non terminale iniziale, $\Sigma$ sono l&amp;rsquo;alfabeto dei simboli finali e $\mathcal{R}$ le relazioni possibili.
Spesso lo scriviamo solo tramite le relazioni, perchÃ© Ã¨ la forma piÃ¹ compatta.
I nodi di una derivazione da grammatica libera da contesto Ã¨ chiamato &lt;strong&gt;costituente del linguaggio&lt;/strong&gt;. Questo Ã¨ piÃ¹ importante in linguistica.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LR(k) e YACC</title>
      <link>https://flecart.github.io/notes/lrk-e-yacc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/lrk-e-yacc/</guid>
      <description>&lt;h2 id=&#34;lrk&#34;&gt;LR(k)&lt;/h2&gt;
&lt;h3 id=&#34;grammatiche-lrk&#34;&gt;Grammatiche LR(k)&lt;/h3&gt;
&lt;p&gt;Anche in questo caso proviamo a generalizzare il concetto dei pirmi k caratteri, in modo da generalizzare in qualche senso il concetto di LR(k), quindi &lt;strong&gt;andiamo a modificare la closure&lt;/strong&gt; considerando ora first k&lt;/p&gt;
&lt;p&gt;Per ricordarti come si calcolava first k, andare a guardare &lt;a href=&#34;https://flecart.github.io/notes/top-down-parser&#34;&gt;Top-down Parser&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;il problema che poi diventa pratico riguardo questo Ã¨ l&amp;rsquo;impossibilitÃ  di gestire &lt;strong&gt;stringhe lunghezza k&lt;/strong&gt; che sono una assurditÃ  (esponenziale per la lunghezza)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Macchine Astratte</title>
      <link>https://flecart.github.io/notes/macchine-astratte/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/macchine-astratte/</guid>
      <description>&lt;h3 id=&#34;definizione-ed-esempi-per-macchine-astratte&#34;&gt;Definizione ed esempi per macchine astratte&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Una macchina astratta Ã¨ un qualunque insieme di algoritmi e strutture di dati che permettono di memorizzare ed eseguire il linguaggio $L$, quindi una macchina astratta esiste per esguire &lt;strong&gt;il proprio linguaggio&lt;/strong&gt; (inteso come insieme finito di istruzioni primitive che riesce ad  comprendere e eseguire).&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Si puÃ² proprio dire che &lt;em&gt;esiste una simbiosi&lt;/em&gt; fra macchina e linguaggio. Si potrebbe dire che la macchina fisica Ã¨ soltanto una implementazione FISICA di un linguaggio, ossia una macchina che capisce ed esegue quel linguaggio e che sia solamente un caso particolare della macchina astratta.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Nomi e Scope</title>
      <link>https://flecart.github.io/notes/nomi-e-scope/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/nomi-e-scope/</guid>
      <description>&lt;h2 id=&#34;i-nomi-e-oggetti&#34;&gt;I Nomi e oggetti&lt;/h2&gt;
&lt;h3 id=&#34;oggetti-denotati-e-identificatori&#34;&gt;Oggetti denotati e identificatori&lt;/h3&gt;
&lt;p&gt;I nomi sono sequenze di caratteri o numeri aka: &lt;strong&gt;token alfanumerico&lt;/strong&gt; (anche &lt;strong&gt;IDENTIFICATORE&lt;/strong&gt; (per token guardare &lt;a href=&#34;https://flecart.github.io/notes/grammatiche-regolari&#34;&gt;Grammatiche Regolari&lt;/a&gt;) utilizzate principalmente come &lt;strong&gt;Astrazione sul controllo e sui dati&lt;/strong&gt; (quindi sono cose molto piÃ¹ facili da ricordare rispetto il suo encoding binario o a indirizzi). Infatti utilizziamo i nomi per evitare di interessarci di informazioni come l&amp;rsquo;indirizzo di memoria del nostro dato o per creare una interfaccia con visibili solo nome della procedura e parametri.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Object orientation</title>
      <link>https://flecart.github.io/notes/object-orientation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/object-orientation/</guid>
      <description>&lt;p&gt;Ripasso Prox: 10
Ripasso: May 29, 2023
Ultima modifica: May 19, 2023 10:33 AM
Primo Abbozzo: May 8, 2023 9:20 AM
Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ‘
Studi Personali: No&lt;/p&gt;
&lt;h1 id=&#34;elementi-di-ripasso&#34;&gt;Elementi di ripasso&lt;/h1&gt;
&lt;h1 id=&#34;object-orientation&#34;&gt;Object orientation&lt;/h1&gt;
&lt;h2 id=&#34;il-tipo-di-dato-astratto&#34;&gt;il tipo di dato astratto&lt;/h2&gt;
&lt;h3 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h3&gt;
&lt;p&gt;Per questi tipi di dato non ci interessa di sapere cosa ci sia sotto (storato come bit? storato come sabbia boh), ci interessa solamente che abbia quei metodi, che possiamo in un certo senso identificare come la sua capsula, &lt;strong&gt;opaca&lt;/strong&gt; in questo caso.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Polimorfismo</title>
      <link>https://flecart.github.io/notes/polimorfismo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/polimorfismo/</guid>
      <description>&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;monoforfo&#34;&gt;Monoforfo&lt;/h3&gt;
&lt;p&gt;Quando non posso utilizzare un tipo come parametro. Ossia non possiamo definire una funzione generica.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide monomorfismo&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Polimorfismo/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Polimorfismo/Untitled&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;polimorfismo&#34;&gt;Polimorfismo&lt;/h2&gt;
&lt;p&gt;Polimorfismo, come dice il nome, significa avere tante forme, in questo caso tanti tipi. Ma avere tanti tipi non Ã¨ una cosa ambigua? Questa cosa si risolve solitamente a compile time (facendo checks di sottotipo, oppure dispatch della funzione corretta).&lt;/p&gt;
&lt;h3 id=&#34;tipologie-di-polimorfismo-3&#34;&gt;Tipologie di Polimorfismo (3)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide tipologie di monomorfismo&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Polimorfismo/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Polimorfismo/Untitled 1&#34;&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ad-hoc polymorphism&lt;/strong&gt; questo Ã¨ anche chiamato overloading in cui vado a definire un nuova funzione (con lo stesso nome) che accetti il nuovo tipo di dato.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Semantica di un linguaggio</title>
      <link>https://flecart.github.io/notes/semantica-di-un-linguaggio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/semantica-di-un-linguaggio/</guid>
      <description>&lt;h2 id=&#34;vincoli-sintattici-contestuali&#34;&gt;Vincoli sintattici contestuali&lt;/h2&gt;
&lt;h3 id=&#34;intro-dipendenze-da-contesto&#34;&gt;Intro: dipendenze da contesto&lt;/h3&gt;
&lt;p&gt;I vincoli sintattici non sono esprimibili tramite BNF perchÃ© dipendono dal contesto, mentre le grammatiche libere sono per definizione libere da contesto, vogliamo quindi trovare una soluzione a questo problema. Vengono usati metodi Ad-Hoc nella fase di &lt;strong&gt;analisi semantica&lt;/strong&gt; del programma.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Grammatiche dipendenti dal contesto&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Queste grammatiche sono molto piÃ¹ complicate (e lente) rispetto a quelle libere da contesto, quindi Ã¨ poco pratico e non utilizzabile (tempo esponenziale, quindi non finisce mai).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Semplificazione grammatiche</title>
      <link>https://flecart.github.io/notes/semplificazione-grammatiche/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/semplificazione-grammatiche/</guid>
      <description>&lt;h2 id=&#34;gestione-del-non-determinismo&#34;&gt;Gestione del non determinismo&lt;/h2&gt;
&lt;p&gt;Il modo piÃ¹ facile per gestire il non determinsmo Ã¨ &lt;strong&gt;semplificare le grammatiche&lt;/strong&gt; quindi andiamo a vedere metodi per fare ciÃ².&lt;/p&gt;
&lt;h3 id=&#34;semplificazione-grammatiche-5&#34;&gt;Semplificazione grammatiche (5)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Semplificazione grammatiche/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Semplificazione grammatiche/Untitled 1&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;No produzioni del tipo $A \to \varepsilon$ per bottom up (altrimenti va all&amp;rsquo;infinito!)&lt;/li&gt;
&lt;li&gt;No produzioni unitarie, cosÃ¬ evito cicli in cui da A derivo sÃ© stesso.&lt;/li&gt;
&lt;li&gt;No simboli inutili&lt;/li&gt;
&lt;li&gt;No ricorsione sinistra (divergenza per top-down)&lt;/li&gt;
&lt;li&gt;Fattorizzazione della grammatica&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;eliminazione-delel-produzioni-nulle&#34;&gt;Eliminazione delel produzioni nulle&lt;/h2&gt;
&lt;p&gt;Vogliamo creare un algoritmo utile ad eliminare le produzioni che non ci piacciono.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Teoria dei Tipi</title>
      <link>https://flecart.github.io/notes/teoria-dei-tipi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/teoria-dei-tipi/</guid>
      <description>&lt;p&gt;Ripasso Prox: 30
Ripasso: June 6, 2023
Ultima modifica: May 14, 2023 6:13 PM
Primo Abbozzo: March 13, 2023 9:20 AM
Studi Personali: No&lt;/p&gt;
&lt;h1 id=&#34;elementi-di-ripasso&#34;&gt;Elementi di ripasso&lt;/h1&gt;
&lt;h1 id=&#34;teoria-dei-tipi&#34;&gt;Teoria dei Tipi&lt;/h1&gt;
&lt;h2 id=&#34;introduzione&#34;&gt;Introduzione&lt;/h2&gt;
&lt;h3 id=&#34;definizione&#34;&gt;Definizione&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Un metodo sintattico &lt;strong&gt;praticabile&lt;/strong&gt; per dimostrare
l&amp;rsquo;assenza di determinati comportamenti del
programma, fatto classificando le unitÃ  sintattiche in
base ai tipi di valore che assumono&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Vogliamo che fosse praticabile nel senso che effettivamente lo possiamo implementare, cioÃ¨ ci permettono di avere certe tipologie di garanzia. ma ancora Ã¨ una definizione molto ampia. E di solito si puÃ² fare una analisi statica del comportamento del programma.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Top-down Parser</title>
      <link>https://flecart.github.io/notes/top-down-parser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/top-down-parser/</guid>
      <description>&lt;h2 id=&#34;top-down&#34;&gt;Top-down&lt;/h2&gt;
&lt;h3 id=&#34;algoritmo-di-parsing&#34;&gt;Algoritmo di parsing&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 1.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Top-down Parser/Untitled 1&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Questo si potrebbe considerare come algoritmo classico di parsing con non determinismo. (vado avanti, ed esploro tutto, senza look ahead).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Esempio di esecuzione&lt;/p&gt;
  &lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 2.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Top-down Parser/Untitled 2&#34;&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;commenti-efficienza-di-sopra&#34;&gt;Commenti efficienza di sopra&lt;/h3&gt;
&lt;p&gt;Ãˆ molto inefficiente, in particolare si potrebbe trovare una compessitÃ  esponenziale del tipo&lt;/p&gt;
&lt;p&gt;$O(b^{|w|})$, con b il massimo numero di produzioni. (la produzione maggiore la espando sempre!)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Slide&lt;/p&gt;</description>
    </item>
    <item>
      <title>Valutazione Espressioni</title>
      <link>https://flecart.github.io/notes/valutazione-espressioni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/valutazione-espressioni/</guid>
      <description>&lt;h1 id=&#34;espressioni-comandi-ricorsione&#34;&gt;Espressioni, Comandi, Ricorsione&lt;/h1&gt;
&lt;h2 id=&#34;espressioni&#34;&gt;Espressioni&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Con espressione intendiamo una entitÃ  sintattica, che una volta valutata &lt;strong&gt;ritornerÃ  un valore&lt;/strong&gt;, oppure non termina, in questo caso si dice che la espressione Ã¨ INDEFINITA.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Questa Ã¨ una definizione Ã¨ leggermente ambigua dato che non abbiamo una definizione precisa di valutazoine, che Ã¨ fortemente dipendente dalla macchina astratta in cui viene eseguito.&lt;/p&gt;
&lt;h3 id=&#34;notazioni-sintassi-possibili-3&#34;&gt;Notazioni (sintassi possibili) (3)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Notazione infissa&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Questa Ã¨ la notazione classica matematica, per cose tipo $a -b$, in cui l&amp;rsquo;operando sta nel mezzo degli operatori.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
