<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>üõ°Ô∏èCybersecurity on X. Angelo Huang&#39;s Blog</title>
    <link>https://flecart.github.io/tags/%EF%B8%8Fcybersecurity/</link>
    <description>Recent content in üõ°Ô∏èCybersecurity on X. Angelo Huang&#39;s Blog</description>
    <image>
      <title>X. Angelo Huang&#39;s Blog</title>
      <url>https://flecart.github.io/images/papermod-cover.png</url>
      <link>https://flecart.github.io/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.143.1</generator>
    <language>en</language>
    <atom:link href="https://flecart.github.io/tags/%EF%B8%8Fcybersecurity/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>IPSec protocol</title>
      <link>https://flecart.github.io/notes/ipsec-protocol/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/ipsec-protocol/</guid>
      <description>&lt;p&gt;Questo √® un protocollo di sicurezza a livello Rete e non pi√π a livello socket!&lt;/p&gt;
&lt;p&gt;Perch√© vorremmo avere sicurezza a questo livello? √à una cosa troppo comune da dover mettere a livello superiore (ma solitamente viene messa a questo livello per la sicurezza, quindi non √® implementata ovunque per dire), quindi IPsec vuole facilitare l&amp;rsquo;implementazione dei principi CIA a un livello pi√π basso, in modo che sia flessibile e customization.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Notions of Security</title>
      <link>https://flecart.github.io/notes/notions-of-security/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/notions-of-security/</guid>
      <description>&lt;h2 id=&#34;ciaa-principles-of-security&#34;&gt;CIAA principles of security&lt;/h2&gt;
&lt;p&gt;We have already  outlined these principles in &lt;a href=&#34;https://flecart.github.io/notes/sicurezza-delle-reti&#34;&gt;Sicurezza delle reti&lt;/a&gt; and talked about the concepts of authentication and integrity. Here we try to deepen these concepts and delve a little bit more on the attack vectors. This note mainly focuses on the principles summarized by the acronyms CIA and AAA.&lt;/p&gt;
&lt;h3 id=&#34;confidentiality&#34;&gt;Confidentiality&lt;/h3&gt;
&lt;p&gt;This is one concerns about the secrecy of the sent message. We do not want others to be able to access and read what we are doing.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Sicurezza delle reti</title>
      <link>https://flecart.github.io/notes/sicurezza-delle-reti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/sicurezza-delle-reti/</guid>
      <description>&lt;h3 id=&#34;obiettivi-della-sicurezza--&#34;&gt;Obiettivi della sicurezza (!!!) üü©&lt;/h3&gt;
&lt;p&gt;Vogliamo creare delle reti che abbiamo certe garanzie di sicurezza, soprattutto:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Confidenzialit√†&lt;/strong&gt;, non vorremmo che il nostro messaggio sia intercettabile e leggibili da persone intermedie&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Integrit√†&lt;/strong&gt;: non vogliamo che messaggi possano essere cambiati senza intervento del sender&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Autenticazione&lt;/strong&gt;: vorremmo sapere con chi stiamo parlando, e vorremmo essere sicuri che non stiano mentendo sull‚Äôidentit√†.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sicurezza operativa&lt;/strong&gt;(Availability): vorremmo essere in grado di poter continuare a fornire il servizio (quindi non sia possibile dossare, o installare malware che modifichino il comportamento del servizio).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Questi sono stati trattati un po&amp;rsquo; in &lt;a href=&#34;https://flecart.github.io/notes/notions-of-security&#34;&gt;Notions of Security&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Sicurezza OS</title>
      <link>https://flecart.github.io/notes/sicurezza-os/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/sicurezza-os/</guid>
      <description>&lt;p&gt;Possiamo classificare tre aree generali quando si parla di sicurezza informatica:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hardware&lt;/li&gt;
&lt;li&gt;Software&lt;/li&gt;
&lt;li&gt;human-ware.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Non tratteremo in particolare esattamente come ogni campo viene declinato, per√≤ possiamo&lt;/p&gt;
&lt;p&gt;Una altra tendenza generale √® che &lt;strong&gt;pi√π √® complessa pi√π √® insicura&lt;/strong&gt;. e questo senso di insicurezza cresce in modo maggiore rispetto al lineare.&lt;/p&gt;
&lt;h3 id=&#34;security-principles&#34;&gt;Security principles&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Open Design&lt;/strong&gt; perch√© cos√¨ pu√≤ essere scrutata da pi√π persone&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Economy of mechanism&lt;/strong&gt; spiegata &lt;a href=&#34;https://flecart.github.io/notes#sistema-politica-e-meccanismi&#34;&gt;sotto&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fail-safe defaults&lt;/strong&gt; questo molto importante perch√© molti sistemi hanno dei default che possono essere exploitati.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Complete mediation&lt;/strong&gt;: cos√¨ abbiamo qualcosa che tracka tutti gli accessi, che &lt;em&gt;controlla&lt;/em&gt; gli accessi.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Least privilege&lt;/strong&gt; questo va a braccetto con il fail-safe.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Privilege separation&lt;/strong&gt; cos√¨ possiamo mettere in modo indipendente un privilegio per qualcos&amp;rsquo;altro.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;cia-properties&#34;&gt;CIA properties&lt;/h4&gt;
&lt;p&gt;Ne abbiamo parlato in modo leggermente inverso in &lt;a href=&#34;https://flecart.github.io/notes/sicurezza-delle-reti&#34;&gt;Sicurezza delle reti&lt;/a&gt; e in &lt;a href=&#34;https://flecart.github.io/notes/notions-of-security&#34;&gt;Notions of Security&lt;/a&gt;.
In questo caso sono&lt;/p&gt;</description>
    </item>
    <item>
      <title>TLS-SSL protocol</title>
      <link>https://flecart.github.io/notes/tls-ssl-protocol/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/tls-ssl-protocol/</guid>
      <description>&lt;p&gt;First time we talked about this was in &lt;a href=&#34;https://flecart.github.io/notes/sicurezza-delle-reti#protocollo-ssl&#34;&gt;Sicurezza delle reti#Protocollo SSL&lt;/a&gt; But that was a simple toy model.&lt;/p&gt;
&lt;h2 id=&#34;secure-socket-layer&#34;&gt;Secure Socket Layer&lt;/h2&gt;
&lt;p&gt;Secure socket Layer and TLS add security (see security principles in &lt;a href=&#34;https://flecart.github.io/notes/notions-of-security&#34;&gt;Notions of Security&lt;/a&gt;) on the transport layers, whereas &lt;a href=&#34;https://flecart.github.io/notes/ipsec-protocol&#34;&gt;IPSec protocol&lt;/a&gt; adds it to the network level. So this works on a higher level of abstraction following the ISO OSI framework &lt;a href=&#34;https://flecart.github.io/notes/architettura-e-livelli-1,-2#livelli-iso/osi&#34;&gt;Architettura e livelli 1, 2#Livelli ISO/OSI&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;SSL is the old version of the TLS protocol.
This provides &lt;strong&gt;integrity&lt;/strong&gt; and &lt;strong&gt;confidentiality&lt;/strong&gt; to the communication, see &lt;a href=&#34;https://flecart.github.io/notes/notions-of-security&#34;&gt;Notions of Security&lt;/a&gt;.
The main difference of SSL and TLS is that this has vulnerabilities like POODLE attack&lt;/p&gt;</description>
    </item>
    <item>
      <title>Wireless attack vectors</title>
      <link>https://flecart.github.io/notes/wireless-attack-vectors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/wireless-attack-vectors/</guid>
      <description>&lt;p&gt;In this note we will talk about some common ways to attack wireless based devices.&lt;/p&gt;
&lt;h3 id=&#34;attacking-an-automated-door&#34;&gt;Attacking an automated door&lt;/h3&gt;
&lt;p&gt;Usually these doors are opened by radio frequency keys, and can be opened easily (e.g. replay attacks, Jam the frequency)&lt;/p&gt;
&lt;h4 id=&#34;jamming&#34;&gt;Jamming&lt;/h4&gt;
&lt;p&gt;This is the easiest way to attack. Just send many signals to make a certain frequency un-usable in our space.
But with Frequency hopping this attack is solved. See &lt;a href=&#34;https://flecart.github.io/notes/tecnologia-wireless#frequency-hopping&#34;&gt;Tecnologia Wireless#Frequency Hopping&lt;/a&gt;
But this method could be easily known and observed (enables eavesdropping, against confidentiality, a principle in &lt;a href=&#34;https://flecart.github.io/notes/notions-of-security#ciaa-principles-of-security&#34;&gt;Notions of Security#CIAA principles of security&lt;/a&gt;.) if the initial seed is known.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Asymmetric Cryptography</title>
      <link>https://flecart.github.io/notes/asymmetric-cryptography/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/asymmetric-cryptography/</guid>
      <description>&lt;h2 id=&#34;public-key-encryption&#34;&gt;Public Key Encryption&lt;/h2&gt;
&lt;p&gt;We now define a formally what is a  public key encryption&lt;/p&gt;
&lt;h3 id=&#34;formal-definition-of-public-key-encryption&#34;&gt;Formal definition of Public Key Encryption&lt;/h3&gt;
&lt;p&gt;We define a 3-tuple formed as follows: $(G, E, D)$ where&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$G$ is the generator for the private and public keys, from now on identified as $(pk, sk)$ (public key and secret key)&lt;/li&gt;
&lt;li&gt;$E(pk, m)$ the encryption algorithm, that takes the $pk$ and the message in input&lt;/li&gt;
&lt;li&gt;$D(sk, c)$ the decryption algorithm, that takes the $sk$ and the ciphertext in input.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now is this definition useful? i don&amp;rsquo;t think so! We can&amp;rsquo;t create theorems for it, too general I suppose. Is it clear? yes! I think this is the usefulness of maths in many occasions, it delivers some complex information in a concise and understandable manner.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Block Ciphers</title>
      <link>https://flecart.github.io/notes/block-ciphers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/block-ciphers/</guid>
      <description>&lt;p&gt;Utilizzano blocchi per cifra invece che stream generators. $n$ bits in input and $m$ bits in output generally a key is &lt;strong&gt;expanded&lt;/strong&gt; into multiple keys, one for each rounds, and applied to a &lt;em&gt;round function&lt;/em&gt; that iterates on the $m$.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DES 56 bit&lt;/li&gt;
&lt;li&gt;3DES 56*3 bit di chiave&lt;/li&gt;
&lt;li&gt;AES che pu√≤ andare a 128, 196 o 256
Solitamente i stream ciphers studiati in &lt;a href=&#34;https://flecart.github.io/notes/otp-and-stream-ciphers&#34;&gt;OTP and Stream Ciphers&lt;/a&gt; sono pi√π veloci.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;Cipher&lt;/th&gt;
          &lt;th&gt;Speed MB/sec&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;RC4&lt;/td&gt;
          &lt;td&gt;126&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Salsa20&lt;/td&gt;
          &lt;td&gt;643&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Sosemanuk&lt;/td&gt;
          &lt;td&gt;727&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;AES&lt;/td&gt;
          &lt;td&gt;13&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;3DES&lt;/td&gt;
          &lt;td&gt;109&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;data-encryption-standard&#34;&gt;Data Encryption Standard&lt;/h3&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/Block Ciphers-20240525101348320.webp&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;Block Ciphers-20240525101348320&#34;&gt;
- 1974 da IBM su commissione di NSA (Horst Feistel designed Lucifer at IBM in early 1970)
- 1976 DES is federal standard with key-len 56 bits and block-len 64 bits.
&lt;p&gt;in quel periodo era solamente fatta dalla intelligence, non c‚Äôera bisogno di comunicazioni per il pubblico in quel periodo.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Classical Cyphers</title>
      <link>https://flecart.github.io/notes/classical-cyphers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/classical-cyphers/</guid>
      <description>&lt;h1 id=&#34;introduzione-a-crittografia&#34;&gt;Introduzione a Crittografia&lt;/h1&gt;
&lt;p&gt;al corso di crittografia di Christof Paar su Youtube, con aggiunte del corso Unibo.&lt;/p&gt;
&lt;h2 id=&#34;classifications-and-definitions&#34;&gt;Classifications and definitions&lt;/h2&gt;
&lt;p&gt;Classification nowadays as many many applications like, and it‚Äôs a increasing important field&lt;/p&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/image/universita/ex-notion/Introduzione/Untitled.png&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;image/universita/ex-notion/Introduzione/Untitled&#34;&gt;
&lt;h3 id=&#34;cryptology-2-&#34;&gt;Cryptology (2) üü©&lt;/h3&gt;
&lt;p&gt;La branca comunemente riferita come crittografia √® divisa principalmente in due campi &lt;strong&gt;crittografia e cryptanalysis&lt;/strong&gt; in cui una cerca di creare nuovi metodi per cifrare i messaggi, e l‚Äôaltro prova ad attaccare questi messaggi ritrovando il messaggio originale.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Key Exchange protocols</title>
      <link>https://flecart.github.io/notes/key-exchange-protocols/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/key-exchange-protocols/</guid>
      <description>&lt;p&gt;Metodi di key exchange&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Trusted Key parties (sono come Certificate authorities studiati in &lt;a href=&#34;https://flecart.github.io/notes/sicurezza-delle-reti&#34;&gt;Sicurezza delle reti&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Merkle Puzzles&lt;/li&gt;
&lt;li&gt;DH protocol&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;trusted-third-parties&#34;&gt;Trusted Third parties&lt;/h2&gt;
&lt;h3 id=&#34;squared-key-problem&#34;&gt;Squared Key problem&lt;/h3&gt;
&lt;p&gt;Un problema abbastanza ovvio √® che per storare le chiavi di tutti c&amp;rsquo;√® una necessit√† $O(n^{2})$ on $O(n)$ users
Se c&amp;rsquo;√® un trusted key parties il numero delle chiavi si riduce di molto, ritorna ad essere lineare!&lt;/p&gt;
&lt;h3 id=&#34;protocols&#34;&gt;Protocols&lt;/h3&gt;
&lt;h4 id=&#34;toy-exchange-protocol&#34;&gt;Toy Exchange protocolüü©&lt;/h4&gt;
&lt;p&gt;TTP = Trusted Third party (simile a quanto poi si avr√† in &lt;a href=&#34;https://flecart.github.io/notes/asymmetric-cryptography&#34;&gt;Asymmetric Cryptography&lt;/a&gt;)
&lt;img src=&#34;https://flecart.github.io/images/notes/Key Exchange protocols-20240312110014411.webp&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;Key Exchange protocols-20240312110014411&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Memory Corruption</title>
      <link>https://flecart.github.io/notes/memory-corruption/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/memory-corruption/</guid>
      <description>&lt;p&gt;First of all, we need to have a strong understanding of how a program allocates memory during its execution. See &lt;a href=&#34;https://flecart.github.io/notes/memoria&#34;&gt;Memoria&lt;/a&gt;, &lt;a href=&#34;https://flecart.github.io/notes/memoria-virtuale&#34;&gt;Memoria virtuale&lt;/a&gt; and other notes about &lt;a href=&#34;https://flecart.github.io/notes/nomi-e-scope&#34;&gt;Nomi e Scope&lt;/a&gt;, &lt;a href=&#34;https://flecart.github.io/notes/gestione-della-memoria&#34;&gt;Gestione della memoria&lt;/a&gt;.
The thing you have to remember is that&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Every new function call allocates a new block, with his local variables.&lt;/li&gt;
&lt;li&gt;How the calling parameters are stored in the stack&lt;/li&gt;
&lt;li&gt;How the heap is allocated (common heap algos are in &lt;a href=&#34;https://flecart.github.io/notes/gestione-della-memoria&#34;&gt;Gestione della memoria&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;How the stack grows (and how it can overflow it, and overwriting important data).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;common-attack-vectors&#34;&gt;Common attack vectors&lt;/h2&gt;
&lt;p&gt;We use C, as it is the easiest way to show how this could be attacked.&lt;/p&gt;</description>
    </item>
    <item>
      <title>OTP and Stream Ciphers</title>
      <link>https://flecart.github.io/notes/otp-and-stream-ciphers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/otp-and-stream-ciphers/</guid>
      <description>&lt;h3 id=&#34;xor-operation&#34;&gt;XOR operation&lt;/h3&gt;
&lt;p&gt;√à una operazione binaria abbastanza semplice  per√≤ ci sar√† importante per andare ad analizzare dei cifrari di un certo genere. Come il ONE TIME PAD che faremo fra poco in &lt;a href=&#34;https://flecart.github.io/notes/otp-and-stream-ciphers.&#34;&gt;OTP and Stream Ciphers.&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;teorema-cifratura-con-xor&#34;&gt;Teorema cifratura con XOR&lt;/h4&gt;
&lt;p&gt;Prendiamo $X$ una variabile aleatoria in $\left\{ 0,1 \right\}^{n}$ &lt;strong&gt;uniforme&lt;/strong&gt;, sia $Y$ una variabile aleatoria su uno stesso dominio come vogliamo. Tali per cui $X, Y$ siano indipendenti
Allora avremo che $C = X \oplus Y$ √® una variabile aleatoria &lt;strong&gt;uniforme&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>The Tor protocol</title>
      <link>https://flecart.github.io/notes/the-tor-protocol/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/the-tor-protocol/</guid>
      <description>&lt;h2 id=&#34;some-notes&#34;&gt;Some notes&lt;/h2&gt;
&lt;h4 id=&#34;mix-based-systems&#34;&gt;Mix-based systemsüü®&lt;/h4&gt;
&lt;p&gt;Created in 1981 by David Chaum.
Very similar to the previous one, in practice, in the end, it acts as a proxy but not only does it take and receive, but it also mixes together the packets it has received from the sources, applying its key.&lt;/p&gt;
&lt;img src=&#34;https://flecart.github.io/images/notes/Introduction to Cyber Security-20240326102655961.webp&#34; style=&#34;width: 100%&#34; class=&#34;center&#34; alt=&#34;Introduction to Cyber Security-20240326102655961&#34;&gt;
&lt;p&gt;&lt;strong&gt;Disadvantage:&lt;/strong&gt;
The public-private mixing system is very slow. For this reason, a network of nodes is established, each having a symmetric key, making it much faster.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
