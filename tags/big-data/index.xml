<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>üììBig-Data on X. Angelo Huang&#39;s Blog</title>
    <link>https://flecart.github.io/tags/big-data/</link>
    <description>Recent content in üììBig-Data on X. Angelo Huang&#39;s Blog</description>
    <image>
      <title>X. Angelo Huang&#39;s Blog</title>
      <url>https://flecart.github.io/images/papermod-cover.png</url>
      <link>https://flecart.github.io/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <atom:link href="https://flecart.github.io/tags/big-data/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Massive Parallel Processing</title>
      <link>https://flecart.github.io/notes/massive-parallel-processing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/massive-parallel-processing/</guid>
      <description>We have a group of mappers that work on dividing the keys for some reducers that actually work on that same group of data. The bottleneck is the assigning part: when mappers finish and need to handle the data to the reducers.
Introduction Common input formats You need to know well what
Shards Textual input binary, parquet and similars CSV and similars General framework We can see in the image taken from the course book [({fourny} 2024)](https://ghislainfourny.</description>
    </item>
    <item>
      <title>Wide Column Storage</title>
      <link>https://flecart.github.io/notes/wide-column-storage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/wide-column-storage/</guid>
      <description>We now start with data modelling after having dealt with the syntax in HTML e Markup and data storage methods in Cloud Storage and Distributed file systems. In this case we want the data to be denormalized (see Normalizzazione dei database) but still looking like tables.
Usage of Wide Column Storages Wide column stores were invented to provide more control over performance and in particular, in order to achieve high-throughput and low latency for objects ranging from a few bytes to about 10 MB, which are too big and numerous to be efficiently stored as so-called clobs (character large objects) or blobs (binary large objects) in a relational database system, but also too small and numerous to be efficiently accessed in a distributed file system.</description>
    </item>
    <item>
      <title>Codifica dei caratteri</title>
      <link>https://flecart.github.io/notes/codifica-dei-caratteri/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/codifica-dei-caratteri/</guid>
      <description>Introduzione sull&amp;rsquo;encoding Ossia trattiamo metodi per codificare caratteri dei linguaggi umani, come ASCII, UCS e UTF.
Digitalizzare significa encodarlo in un sistema che possa essere memorizzato su un dispositivo di memorizzazione elettronico. Ovviamente non possiamo mantenere l&amp;rsquo;informazione cos√¨ come √®, ma vogliamo memorizzarne una forma equivalente, ma pi√π facile da manipolare dal punto di vista del computer. Creiamo quindi un mapping, o anche isomorfismo tra il valore di mappatura (o encoding), solitamente un valore numerico, tra il singolo valore atomico originale e il numero.</description>
    </item>
    <item>
      <title>Cloud Storage</title>
      <link>https://flecart.github.io/notes/cloud-storage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/cloud-storage/</guid>
      <description>Paradigms of data storage ETL framework üü© This is the classical database approach: We load the data in the database and let the underlying system handle it. We won&amp;rsquo;t talk much about this but this is the general concept!
Data Lakes üü© We typically store data in the filesystem, where it is viewed simply as files. This approach works well when we only need to read the data. It&amp;rsquo;s often referred to as in situ storage because there is no need to extract the data first.</description>
    </item>
    <item>
      <title>HTTP e REST</title>
      <link>https://flecart.github.io/notes/http-e-rest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/http-e-rest/</guid>
      <description>HTTP is the acronym for HyperText Transfer Protocol.
Caratteristiche principali (3) üü® Comunicazioni fra client e server, e quanto sono comunicate le cose si chiude la connessione e ci sono politiche di caching molto bone (tipo con i proxy) Generico: perch√© √® un protocollo utilizzato per caricare moltissime tipologie di risorse! Stateless, ossia non vengono mantenute informazioni su scambi vecchi, in un certo modo ne abbiamo parlato in Sicurezza delle reti quando abbiamo parlato di firewall stateless.</description>
    </item>
    <item>
      <title>Uniform Resource Identifier</title>
      <link>https://flecart.github.io/notes/uniform-resource-identifier/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/uniform-resource-identifier/</guid>
      <description>URI Sono stata LA vera invenzione di Berners Lee accennati in Storia del web. Il problema √® avere un modo per identificare una risorsa in modo univoco sull‚Äôinternet.
Introduzione La risorsa üü© Una risorsa √® qualunque struttura che sia oggetto di scambio tra applicazioni all‚Äôinterno del World Wide Web.
Ora una risorsa pu√≤ essere qualunque cosa, non solamente solo un file! Quindi √® agnostico rispetto a contenuto oppure metodo di memorizzazione del dato, appare anche in questo ambiente importante vedere quanto siano importanti standard che permettano una comunicazione</description>
    </item>
    <item>
      <title>Structured Query Language</title>
      <link>https://flecart.github.io/notes/structured-query-language/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/structured-query-language/</guid>
      <description>Little bits of history It was invented in 1970 in Almaden (San Jose) by IBM (Don Chamberlin, Raymond Boyce worked on this) for the first relational database, called system R. Then for copyright issues it hasn&amp;rsquo;t been called SEQUEL, so they branded it as SQL.
SQL is a declarative language With declaratives language there is a separation between what I call the intentionality and the actual process. In declarative languages we just say what we want the result to be, and don&amp;rsquo;t care what the actual implementation is like.</description>
    </item>
    <item>
      <title>Normalizzazione dei database</title>
      <link>https://flecart.github.io/notes/normalizzazione-dei-database/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/normalizzazione-dei-database/</guid>
      <description>Introduzione alla normalizzazione Perch√© si normalizza? üü© Cercare di aumentare la qualit√† del nostro database, perch√© praticamente andiamo a risolvere delle anomalie possibili al nostro interno, e questo aiuta per la qualit√†.
Tipologie di anomalie (!) (4) üü®++ Ridondanze, non vorrei avere la stessa informazione espressa pi√π volte in troppi punti. Update non consistente, quando per aggiornare un singolo valore devo aggiornare moltissime altre tuple dipendenti da essa. Deletion non consistente, la presenza di certe entit√† √® strettamente dipendente da presenza di altri, nell&amp;rsquo;esempio in questione sulle slides, se elimino tutti gli utenti, elimino anche i progetti su cui hanno partecipato, mentre invece dovrebbero essere separati.</description>
    </item>
    <item>
      <title>Data Models and Validation</title>
      <link>https://flecart.github.io/notes/data-models-and-validation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/data-models-and-validation/</guid>
      <description>A data model is an abstract view over the data that hides the way it is stored physically.
The same idea from (Codd 1970) This is why we should not modify data directly, but pass though some abstraction that maintain the properties of that specific data model.
Data Models Tree view We can view all JSON and XML data, as presented in HTML and Markup, as trees. This structure is usually quite evident, as it is inherent in their design.</description>
    </item>
    <item>
      <title>Apache Spark</title>
      <link>https://flecart.github.io/notes/apache-spark/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/apache-spark/</guid>
      <description>Apache Spark This is a new framework that is faster than MapReduce. It is written in Scala and has a more functional approach to programming. Spark extends the previous MapReduce framework to a generic distributed dataflow, properly modeled as a DAG.
Resilient distributed datasets&amp;rsquo; Lifecycle Resilient distributed datasets (RDD) are the unit data blocks of Apache Spark. These blocks are created, transformed and written back into the disk.
Resilient means that they remain in memory or on disk on a ‚Äúbest effort‚Äù basis, and can be recomputed if need be.</description>
    </item>
    <item>
      <title>Introduction to Big Data</title>
      <link>https://flecart.github.io/notes/introduction-to-big-data/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduction-to-big-data/</guid>
      <description>Data Science is similar to physics: it attemps to create theories of realities based on some formalism that another science brings. For physics it was mathematics, for data science it is computer science. Data has grown expeditiously in these last years and has reached a distance that in metres is the distance to Jupiter. The galaxy is in the order of magnitude of 400 Yottametres, which has $3 \cdot 8$ zeros following after it.</description>
    </item>
    <item>
      <title>HTML e Markup</title>
      <link>https://flecart.github.io/notes/html-e-markup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/html-e-markup/</guid>
      <description>Markup Introduzione alle funzioni del markup üü© La semantica di una parola √® caratterizzata dalla mia scelta (design sul significato). Non mi dice molto, quindi proviamo a raccontare qualcosa in pi√π.
Definiamo markup ogni mezzo per rendere esplicita una particolare interpretazione di un testo.
In particolare √® un modo per esplicitare qualche significato. (un p√≤ come la punteggiatura, che da qualche altra informazione oltre le singole parole, rende pi√π chiaro l&amp;rsquo;uso del testo).</description>
    </item>
    <item>
      <title>Distributed file systems</title>
      <link>https://flecart.github.io/notes/distributed-file-systems/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/distributed-file-systems/</guid>
      <description>We want to know how to handle systems that have a large number of data. In previous lesson we have discovered how to quickly access and make Scalable systems with huge dimensions, see Cloud Storage. Object storage could store billions of files, we want to handle millions of petabyte files.
Desiderata of distributed file systems üü© In this case we have a Filesystem. In 2004 google created his own FS. With hundreds or thousands of machines the systems are practically guaranteed to fail.</description>
    </item>
  </channel>
</rss>
