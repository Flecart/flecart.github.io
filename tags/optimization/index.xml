<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>ðŸ“ˆOptimization on X. Angelo Huang&#39;s Blog</title>
    <link>https://flecart.github.io/tags/optimization/</link>
    <description>Recent content in ðŸ“ˆOptimization on X. Angelo Huang&#39;s Blog</description>
    <image>
      <title>X. Angelo Huang&#39;s Blog</title>
      <url>https://flecart.github.io/images/papermod-cover.png</url>
      <link>https://flecart.github.io/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <atom:link href="https://flecart.github.io/tags/optimization/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Tarjan e MCMF</title>
      <link>https://flecart.github.io/notes/tarjan-e-mcmf/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/tarjan-e-mcmf/</guid>
      <description>Questa sezione la tengo separata rispetto agli altri per favorire lo studio, cosÃ¬ questa roba nuova la ripasso piÃ¹ spesso, in seguito si puÃ² accorpare.
Goldberg Tarjan/Push-relabel Questo algoritmo Ã¨ importante perchÃ© introduce ragionamenti sul minimo locale che possa alla fine essere ricomposto come soluzione globale.
Questa lezione youtube lo spiega da Dio
Preflusso ðŸŸ© Slide
La parte nuova di questa cosa Ã¨ che i vincoli di bilanciamento possono diventare una disuguaglianza.</description>
    </item>
    <item>
      <title>Problemi di accoppiamento</title>
      <link>https://flecart.github.io/notes/problemi-di-accoppiamento/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/problemi-di-accoppiamento/</guid>
      <description>I problem idi accoppiamento sono abbastanza comuni per ottimizzazione a grafi. In questa serie di note andiamo a trattare brevemente i problemi principali, con un accenno veloce ad alcuni algoritmi di soluzione per esse.
Grafo bipartitoðŸŸ© Un grafo bipartito Ã¨ un insieme $(O \cup D), (A)$ di nodi e di archi. Tutti i nodi sono o fra i nodi di origine oppure fra i nodi di destinazione, e gli archi sono solamente collegati fra nodi di origine e nodi di destinazione.</description>
    </item>
    <item>
      <title>Duality Theory</title>
      <link>https://flecart.github.io/notes/duality-theory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/duality-theory/</guid>
      <description>Ãˆ una branca dell&amp;rsquo;algebra lineare che ci permette di semplificare tutti i concetti.
Intro dualitÃ ðŸŸ© &amp;lt;img src=&amp;quot;/images/notes/image/universita/ex-notion/Programmazione lineare/Untitled 8.png&amp;quot; alt=&amp;quot;image/universita/ex-notion/Programmazione lineare/Untitled 8&amp;quot;&amp;gt; Si fa una sorta di trasposta alla matrice di A. y Ã¨ pari al numero di righe di A La trasformazione al duale Ã¨ molto facile, ed Ã¨ abbastanza intuitiva una volta che capiamo che vogliamo andare a fare lâ€™upper bound.
DualitÃ  asimmetrica ðŸŸ¥+ Teorema debole di dualitÃ  ðŸŸ© Slide</description>
    </item>
    <item>
      <title>Lagrange Multipliers</title>
      <link>https://flecart.github.io/notes/lagrange-multipliers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/lagrange-multipliers/</guid>
      <description>This is also known as Lagrange Optimization or undetermined multipliers. Some of these notes are based on Appendix E of (Bishop 2006), others were found when studying bits of rational mechanics.
Let&amp;rsquo;s consider a standard linear optimization problem $$ \begin{array} \\ \min f_{0}(x) \\ \text{subject to } f_{i}(x) \leq 0 \\ h_{j}(x) = 0 \end{array} $$ Lagrangian function And let&amp;rsquo;s consider the Lagrangian function associated to this problem defined as $$ L(x, \lambda, \nu) = f_{0}(x) + \sum \lambda_{i}f_{i}(x) + \sum\nu_{j}h_{j}(x) $$ We want to say something about this function, because it is able to simplify the optimization problem a lot, but first we want to study this mathematically.</description>
    </item>
    <item>
      <title>Programmazione lineare</title>
      <link>https://flecart.github.io/notes/programmazione-lineare/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/programmazione-lineare/</guid>
      <description>Vogliamo cercare di restare nel nostro spazio delle soluzioni ammissibili, senza dover stare ad esplorare tutto, vogliamo andare a concentrarci su una parte specifica di essa. Vogliamo utilizzare una struttura fondamentale per i problemi di programmazione lineare, che Ã¨ quello con cui vogliamo andare a fare. Il fatto Ã¨ che spostandoci leggermente da un punto tra le soluzioni, possiamo gestire in modo molto semplice il modo con cui si sposta la retta dei valori.</description>
    </item>
    <item>
      <title>Simplesso e B&amp;B</title>
      <link>https://flecart.github.io/notes/simplesso-e-bb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/simplesso-e-bb/</guid>
      <description>Algoritmo del simplesso Ricerca della direzione migliore Ricerca dello step Pseudocodice Slide
B sono gli indici di partenza, poi questi vengono aggiornati
In riga 5 vado a checkare se ho direzioni di crescita possibili, se Ã¨ tutto positivo non ne ho.
in riga 6, si sceglie il piÃ¹ piccol per evitare loop.
L&amp;rsquo;idea in generale va in questo modo
Cerco di trovare il duale e confrontarlo con la x attuale Se sono uguali, allora ho trovato lâ€™ottimo ed esco Altrimenti cerco una direzione di crescita che sia anche ammissibile Continuo fino a trovare un vertice, se ho il vertice allora mi muovo lÃ¬ e riapplico, altrimenti Ã¨ illimitata, se non esiste un vertice.</description>
    </item>
    <item>
      <title>Introduzione a ottimizzazione Combinatoria</title>
      <link>https://flecart.github.io/notes/introduzione-a-ottimizzazione-combinatoria/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/introduzione-a-ottimizzazione-combinatoria/</guid>
      <description>Lâ€™ottimizzazione combinatoria Ã¨ un altro nome per la ricerca operativa. Ãˆ uno strumento utile a prendere le decisioni migliori, fatto sta che Ã¨ anche molto utile al machine learning e si potrebbe dire che ne sia una base, questa Ã¨ una cosa molto buona.
Ricerca operativa Questo Ã¨ un campo a forte impatto economico perchÃ© prova a minimizzare i costi e massimizzare i profitti.
Steps ðŸŸ©, ðŸŸ¨ Individuazione del problema (almeno riconoscere che ci sia un problema) Raccoglimento dei dati Modellizzazione del problema Ricerca di una soluzione Analisi dei risultati della soluzione La ricerca operativa si interessa principalmente degli step 3 e 4, nonostante gli steps non sempre vengono eseguiti in maniera lineare, ma câ€™Ã¨ un ciclo di feedback a riguardo.</description>
    </item>
    <item>
      <title>Reti di flusso</title>
      <link>https://flecart.github.io/notes/reti-di-flusso/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/reti-di-flusso/</guid>
      <description>Questi problemi sono una sottoclasse della programmazione lineare con variabili reali. (Alcuni riescono a riconoscere se un problema Ã¨ in questa forma, e lo risolvono in modo istantaneo se questo succede).
Un problema dei router Ã¨ un classico problema di flusso, che si risolvono con questi algoritmi polinomiali
Note introduttive Rete, terminologia ðŸŸ© Slide
Lo sai Grafi. ma andiamo a ripeterlo
Grafo def Def arco e il loro peso (discreto o continuo) Nodi Cose nuove:</description>
    </item>
    <item>
      <title>Modelizzazione</title>
      <link>https://flecart.github.io/notes/modelizzazione/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://flecart.github.io/notes/modelizzazione/</guid>
      <description>Programmazione lineare Programmazione lineare contiene alcuni algoritmi utili per risolvere certi problemi di ottimizzazione.
Introduzione Andiamo in questa sezione a definire un problema di programmazione lineare
Definizione ðŸŸ©- Variabili reali che saranno le variabili del nostro problema, sono in numero finito (eg. tutti in Rn) Funzione obiettivo che ci definisce il costo $f: \R^n \to \R$ Vincoli lineari che limitano il dominio delle variabili reali e li mettono in relazione fra di loro Se le variabili appartengono agli interi andiamo a parlare di programmazione lineare intera.</description>
    </item>
  </channel>
</rss>
