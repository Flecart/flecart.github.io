<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Mac Wifi | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="ðŸ•¸computer-networks">
<meta name="description" content="Introduzione Ricordiamo che vogliamo cercare di arbitrare lâ€™accesso al canale fisico sottostante. In questo momento andiamo ad assumere di avere giÃ  tutto lâ€™impianto di trasmissione fisica che abbiamo in Tecnologia Wireless, Modulazione wireless Fisica del Wireless.
Obiettivi: Arbitraggio del singolo canale fisico (la tesi di dottorato del prof era su collision avoidance di wifi). Sia in tempo Sia in spazio (come gestire il segnale mandato nello stesso spazio) Utilizzo minimo di energia Quality of service Adaptive behaviour (come il 6G che vuole andare ad utilizzare AI per fare predizione).">
<meta name="author" content="Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="https://flecart.github.io/notes/mac-wifi/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/mac-wifi/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>




<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>
<script type="text/javascript" async
src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>





<script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-WW6NN2QGKF', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Mac Wifi" />
<meta property="og:description" content="Introduzione Ricordiamo che vogliamo cercare di arbitrare lâ€™accesso al canale fisico sottostante. In questo momento andiamo ad assumere di avere giÃ  tutto lâ€™impianto di trasmissione fisica che abbiamo in Tecnologia Wireless, Modulazione wireless Fisica del Wireless.
Obiettivi: Arbitraggio del singolo canale fisico (la tesi di dottorato del prof era su collision avoidance di wifi). Sia in tempo Sia in spazio (come gestire il segnale mandato nello stesso spazio) Utilizzo minimo di energia Quality of service Adaptive behaviour (come il 6G che vuole andare ad utilizzare AI per fare predizione)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://flecart.github.io/notes/mac-wifi/" />
<meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png" />
<meta property="article:section" content="notes" />



<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png" />
<meta name="twitter:title" content="Mac Wifi"/>
<meta name="twitter:description" content="Introduzione Ricordiamo che vogliamo cercare di arbitrare lâ€™accesso al canale fisico sottostante. In questo momento andiamo ad assumere di avere giÃ  tutto lâ€™impianto di trasmissione fisica che abbiamo in Tecnologia Wireless, Modulazione wireless Fisica del Wireless.
Obiettivi: Arbitraggio del singolo canale fisico (la tesi di dottorato del prof era su collision avoidance di wifi). Sia in tempo Sia in spazio (come gestire il segnale mandato nello stesso spazio) Utilizzo minimo di energia Quality of service Adaptive behaviour (come il 6G che vuole andare ad utilizzare AI per fare predizione)."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Mac Wifi",
      "item": "https://flecart.github.io/notes/mac-wifi/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Mac Wifi",
  "name": "Mac Wifi",
  "description": "Introduzione Ricordiamo che vogliamo cercare di arbitrare lâ€™accesso al canale fisico sottostante. In questo momento andiamo ad assumere di avere giÃ  tutto lâ€™impianto di trasmissione fisica che abbiamo in Tecnologia Wireless, Modulazione wireless Fisica del Wireless.\nObiettivi: Arbitraggio del singolo canale fisico (la tesi di dottorato del prof era su collision avoidance di wifi). Sia in tempo Sia in spazio (come gestire il segnale mandato nello stesso spazio) Utilizzo minimo di energia Quality of service Adaptive behaviour (come il 6G che vuole andare ad utilizzare AI per fare predizione).",
  "keywords": [
    "ðŸ•¸computer-networks"
  ],
  "articleBody": "Introduzione Ricordiamo che vogliamo cercare di arbitrare lâ€™accesso al canale fisico sottostante. In questo momento andiamo ad assumere di avere giÃ  tutto lâ€™impianto di trasmissione fisica che abbiamo in Tecnologia Wireless, Modulazione wireless Fisica del Wireless.\nObiettivi: Arbitraggio del singolo canale fisico (la tesi di dottorato del prof era su collision avoidance di wifi). Sia in tempo Sia in spazio (come gestire il segnale mandato nello stesso spazio) Utilizzo minimo di energia Quality of service Adaptive behaviour (come il 6G che vuole andare ad utilizzare AI per fare predizione). Evitare segnale spaghetti o jammed Collisioni fanno sprecare energia ad entrambi (sia ricevente sia sender) bisogna trovare un metodo per fare risoluzione (controllare il sender riguardo la trasmissione, in quanto non sono in grado di trasmettere e ascoltare in modo contemporaneo) Questo si lega alla parte di arbitraggio del canale Ricordiamo che ethernet provava ad ascoltare il segnale e provare a trasmettere, si puÃ² utilizzare la stessa cosa anche qui? No, ethernet permetteva di ascolatare il segnale nel momento di generazione, mentre wifi non puÃ², perchÃ© semplicemente il segnale prodotto localmente Ã¨ molto piÃ¹ grande. Inoltre wifi ha anche bisogno di fare multiplexing sullo spazio non solo nel tempo come per lâ€™ethernet.\nAnticollisione primo tentativo Allora, in questa parte continuiamo ad analizzare un protocollo che tenti di evitare la collisione, si puÃ² utilizzare un sistema simile ad ethernet?\nRisposta negativa: non evita le collisioni Slide fenomeno\nNonostante i senders non sentano niente, câ€™Ã¨ interferenza, credo si chiami anche problema del terminale nascosto, perchÃ© non senti lâ€™interferenza (asimmetria di informazioni).\nNon arbitra niente alla fineâ€¦ Classificazione accesso multiplo MAC-WIFIðŸŸ© Senza contesa, ossia si cerca di evitare la contesa della rete wifi Centralizzati statici, con un coordinatore statico che dica quando puoi comunicare (prenotazioni registrate da un coordinatore) â†’ garanzia del servizio Costo coordinatore (centralizzato, quindi se cade cade tutto, facile da attaccare) Costo allocazione statica delle risorse. token-based chi vuole comunicare tiene solamente il token (solo che il rischio Ã¨ che si perda il token per una interferenza o simili). Content, provare a prendersi il segnale, o provare finchÃ© non ci si riesce. Probabilistico Ã¨ quello piÃ¹ sicuro dal punto di vista della sicurezza, e ha allocazione dinamica di servizi (provare a comunicare a tempi random, probabilisticamente parlando provandoci cosÃ¬ prima o poi si comunicherÃ ). Solo che ha il problema delle collissioni ,quindi sarebbe molto buono questo metodo di allocazioen dinamica con il server centrale (0 collisioni e 0tempi vuoti). Solo che il coordinatore ha un costo. â†’ reliability della comunicazione. Deterministico (mi sono distratto a configurare alacritty e non ho capito). Abbiamo un accesso probabilistico in cui si prova a comunciare nel vuoto (nel senso che non si puÃ² spegnere questa rete, nel caso della presenza di un accesso centralizzato allora si utilizza quella. (ma nessuno paga))\nAloha protocol Funzionamento in breveðŸŸ© Ãˆ stato uno dei primi protocolli radio presenti. Stiamo parlando di 1970, Abramson1970 era alle Hawaii e aveva solamente dispositivi radio a disposizione, sono le prime sperimentazioni.\nIl round trip time veniva calcolato, se non riceve lâ€™ack aspetta un tempo un pÃ² random. (il seme sarÃ  diverso, tipo lâ€™id della scheda di rete, il tempo di backoff che coincida Ã¨ abbastanza basso)\nAnalisi dominio di collisioneðŸŸ© Ci vogliamo chiedere quando Ã¨ il time frame in cui puÃ² avvenire una collisione?\nSiano due comunicanti, che devono entrambi trasmettere, se uno trasmette, quando non potrebbe trasmettere l Ã¡ltro per evitare la connessioen? Ci interessa solamente il tempo.\nLa risposta Ã¨ semplice, vogliamo solo che sia una dimensione di frame prima e una dimensione di frame dopo: tempo/slot di collisione Ã¨ due volte.\nSlide intuizione dominio di collisione\nCon questa osservazione, possiamo cambiare leggermente lâ€™algoritmo di aloha al fine di risolvere, o meglio alleviare, il problema della collisione:\nSlotted alohaðŸŸ© Lo slotted aloha permette solamente la trasmissione in certi slot di tempo, questo aiuta ad alleviare il problema della collisione:\nHa senso che la dimensione dello slot Ã¨ dimensione massima del frame con anche trasmission delay vogliamo andare a contare anche il delay della trasmissione perchÃ© altrimenti due frames possono comunque influenzarsi fra di loro durante la trasmissione.\nSlide slotted aloha\nQuindi ora il tempo di vulnerabilitÃ  Ã¨ ridotto a slot + propagation, invece che due slots (anche se solitamente pensavo che il tempo di propagazione Ã¨ maggiore? Credo dipendaâ€¦).\nCSMA Carrier sense multiple access\nIntroduzione allâ€™algoritmoðŸŸ© In questo caso il FVT (frame vulnerability time) Ã¨ due volte il propagation, perchÃ© se sono dentro a questo intervallo allora non sento il segnale dellâ€™altro, che non Ã¨ ancora arrivato. Questo valore solitamente Ã¨ molto piÃ¹ piccolo rispetto al frame size.\nSlotted CSMAðŸŸ© Alla fine molto simile questa idea allo slotted aloha, tutti possono trasmettere soltanto in certi slots di times\nThroughput comparisonðŸŸ© Vediamoc he il throughput cambia molto seguendo i protocolli (e va giÃ¹ perchÃ© ci sono troppe collisioni se provo a trasmettere troppo.\nMi serve sapere il numero di stazioni trasmittenti, una cosa che non conosco generalmente.\nMACA hidden and exposed terminals ðŸŸ© Vogliamo cercare di limitare le trasmittenti a comunicare bene con un ricevitore (sto ragionando sull esempio di ACBD in mezzo) cioÃ¨ in un caso di hidden terminal in cui due senders non si sentono fra di loro, ma il loro segnale potrebbe interferire in un certo punto.\nUn problema opposto Ã¨ il exposed terminal quando il sender Ã¨ condiviso da piÃ¹ host, un host che vorrebbe comunicare, a un host diverso, non puÃ² comunicare perchÃ© sente questo.\nRTS and CTSðŸŸ¨++ Un altro problema di hidden terminal oltre alla trasmissione su un terminale comune Ã¨ il fatto che se CB provano a comunicare a persone differenti (rispettivamente ad A e D, B non puÃ² perchÃ© sente ricevere).\nUna soluzione semplice Ã¨ semplicemente chiedere al canale ricevente se ci sono interferenze o meno. (un pacchetto breve che si chaiama RTS (request to send).) questo Ã¨ un piccolo pacchetto, potrebbe interferire, si spera che faccia molti pochi interferenze.\nIl ricevitore risponde con un CTS (clear to send) Se il cts Ã¨ ricevuto allora comincia a rispondere.\nâ†’ Non ho carrier sensing qui.\nRTS and CTS drawback Non abbiamo garanzia di comunicazione senza interferenze, questa garanzia câ€™Ã¨ solamente quando il range di comunicazione sono uguali fra di loro, un esempio in cui non funziona Ã¨ lâ€™esempio qui sotto in cui esiste una rete grande ch epossa andare a fare interferenza con tutte. MACAW Voglio ritardare il RTS in un tempo casuale in modo che non sovrappongano fra di loro. Câ€™Ã¨ carrier sensing **per gli acks, posso spedire solo quando mando RTS cosÃ¬ posso ricevere ack in silenzio. Gli altri quando sentono dovrebbero restare in silenzio.\nRTS Carrier sensing (anche questa credo sia la cosa nuova, il sistema RTS/CTS Ã¨ lo stesso di MACA) backoff (questa Ã¨ lâ€™unica cosa nuov acredo). Lâ€™unico che ha preso la RTS sarÃ  lâ€™unico a comunicare, gli altri stanno in silenzion perchÃ© sentono il canale occupato.\nSi puÃ² settare il RTS threshhol superiore alla soglia per dire che non verrÃ  mai utilizzato.\nChe Ã¨ molto simile a un coordinator function with backoff, solo che questo Ã¨ senza infrastruttura, mentre nellâ€™altro credo ci sia.\nAd hoc networks Ci sono delle cose nuove che sono delle veicole infrastructures ossia in realtÃ  non esisterebbe una infrastruttura per questa connessione, ma passa da veicolo a veicolo quindi Ã¨ una comunicazione locale. fino a un certo punto in cui alla fine si comunica con una infrastruttura. Come se le auto stesse fossero diventati dei sensori del traffico (quindi molte auto ferme riescono a dire se câ€™Ã¨ troppo traffico o meno.\nnon sono ancora diffusi questi servizi, ma stanno arrivanto, u n altro metodo Ã¨ fare unitÃ  di ricarica per i veicoli.\nCâ€™Ã¨ una trasmissione con CSMA/CA , poi câ€™Ã¨ una fase di contention in cui si potrebbero trasmettere cose e cose di altro tipo. ci otrebbero essere un sacco di rts che vadano a vuoto. Ognuna delle fasi di rts Ã¨ un passaggio indipendente in cui si rischia ancora la collisione.\nMa quando trasmette indietro potrei avere delle (la collisione :\nFast forward intra-stream in cui il RTS del nodo successivo Ã¨ interpretato dal nodo davanti come se fosse un ACK, questo risolve il problema delle interferenze (la fase di contesa non ci sarebbe piÃ¹). (câ€™Ã¨ un campo che rappresenta il tipo di questo segnale, che valga sia come ack sia come rts). Quick exchange inter-stream, se i due nodi intermedi hanno cose da scambiarsi in direzioni diverse, potrebbe essere una buonissima soluzione il fatto di scambiarsi i dati nello stesso stream di dati (dopo lâ€™ack di una direzione viene mandato il dato dellâ€™altra direzione). Se uno cade allora câ€™Ã¨ tempo vuoto e viene interpretato come autorizzazione alla trasmissione\nCarrier sensing virtuale Carrier sensing virtuale sapere che il canale sia occupato senza andare ad ascoltarlo? Appena sentono un RTS, e se sanno la lunghezza del campo di trasmissione classico (Network Allocation Vector NAV) allora sicuramente nessuno ascolta il canale.\nQuesto fa risparmiare batteria al destinatario. E trasmettere prende un sacco di energia, anche solamente andare ad ascoltare consuma.\nFAMA Voglio utilizzare una soglia adattiva oltre la quale comincio ad utilizzare il meccanismo rts/cts. Solitamente questo mi serve quando ho troppe connessioni.\nSe il frame Ã¨ minore di una soglia allor anon ha bisogno di rts/cts, altrimenti ha bisogno.\nAnche questo Ã¨ per reti ad hoc.\nCoordinator functions Ci sono principalemente due meccanismi che vanno a regolare lâ€™accesso al canale Câ€™Ã¨ lâ€™access point che fa un beacon e che rende possibile la coordinazione (cose come il nome della rete e annuncio della sua esistenza Ã¨ il beacon che sempre ogni tanto manda il beacon!).\nUna volta fatto una comunciazione coordinata dÃ  il temop alla DCF. In questo momento lâ€™AP non comunca\nPoint coordination functionðŸŸ© Slide PCF\nQuando esiste un access point che cerchi di evitare le collisioni e governi tutto la comunicazione nel canale.\nQuesta cosa Ã¨ bella perchÃ© funziona anche se muore lâ€™access point. Ma alla fine lâ€™unica cosa rimasta Ã¨ la DCF, quindi abbiamo molte piÃ¹ collisioni. (perchÃ© creare firmware era molto costoso).\nInter-Frame spaces Point, ditributed and short,, sono una ddurata di tempo in cui carrier sensing deve avere vuoto prima di poter tentare di comunicare.\nShort IFS SIFS tempo prima di autorizzare la comunicazione qualcuno che sa giÃ  che deve parlare a seconda del contesto (e dovrebbe essere solamente un unico host) Se non parte significa o che sia morto o non ci sia nessuno. E Questo Ã¨ necessario per avere un PIFS Point IFS PIFS questo Ã¨ il tempo per far parlare lâ€™access point. se nemmeno questo câ€™Ã¨ (ad esempio se lâ€™access point vuole permettere la comunicazione contesa) allora il tempo aumenta e diventa un difs. (puÃ² essere che trasmettino un polling, con lâ€™id di quello che deve andare a trasmettere). Distributed IFS DIFS Questo Ã¨ come dire un liberi tutti quindi si rientra al tempo di contesa del WIFI. Distributed coordination functionðŸŸ© Spazio RTS-CTS anche adattivo con una soglia\nTempo Ã¨ avoidance con carrier sensing, in un ambiente distribuito. In questo caso tutti provano a comunicare, finchÃ© non ci riescono.\nLo slot non Ã¨ lâ€™intero frame come in ALOHA, ma solamente il tempo di propagazione (esempio il tempo necessario per la luce in 100 metri), gli slots sono messi in questo senso. Nello slot successivo sicuramente il tentativo Ã¨ stato ricevuto.\nil backoff Ã¨ basato sul numero di questi slot vuoti che abbiamo ascoltato. E se vado a 0 allora mi metto a comunicare in modo descritto da sopra.\nIl numero degli slot dovrebbe dipendere dal numero di comunicanti questo non Ã¨ a priori definito (e non Ã¨ nemmeno possibile stimarla secondo il prof).\nGestione del back-offðŸŸ© Il backoff Ã¨ via via crescente, si potrebbe dire che sia la come la dimensione della finestra di contesa CW = contention window che Ã¨ diversa rispetto alla congestion window, perÃ² il signfiicato Ã¨ completamente diverso! Congestion trattato in Livello di trasporto serve per mandare tot frammenti allo stesso tempo senza far esplodere il router (il livello Ã¨ diverso!) mentre ora siamo a livello fisico, e si prova a comunicare localmente.\nLa cosa brutta Ã¨ che deve andare a sperimentare contesa per sapere quanta contesa ci sia! Per questo motivo si dice che non sia efficiente: se il canale Ã¨ occupato con questo metodo ci provi lo stesso e quindi vai a disturbare.\nQuando va a 0 allora io faccio proprio la tramissi contione e aspetto ack, se arrivo Ã¨ ok, altrimenti si aumenta timer nel backoff e si rifÃ . Continua finchÃ© non ce la fai.\n",
  "wordCount" : "2098",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/mac-wifi/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;Â»&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Mac Wifi
    </h1>
    <div class="post-meta">10 min&nbsp;Â·&nbsp;Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduzione" aria-label="Introduzione">Introduzione</a><ul>
                        
                <li>
                    <a href="#obiettivi" aria-label="Obiettivi:">Obiettivi:</a></li>
                <li>
                    <a href="#anticollisione-primo-tentativo" aria-label="Anticollisione primo tentativo">Anticollisione primo tentativo</a></li>
                <li>
                    <a href="#classificazione-accesso-multiplo-mac-wifi" aria-label="Classificazione accesso multiplo MAC-WIFIðŸŸ©">Classificazione accesso multiplo MAC-WIFIðŸŸ©</a></li></ul>
                </li>
                <li>
                    <a href="#aloha-protocol" aria-label="Aloha protocol">Aloha protocol</a><ul>
                        
                <li>
                    <a href="#funzionamento-in-breve" aria-label="Funzionamento in breveðŸŸ©">Funzionamento in breveðŸŸ©</a></li>
                <li>
                    <a href="#analisi-dominio-di-collisione" aria-label="Analisi dominio di collisioneðŸŸ©">Analisi dominio di collisioneðŸŸ©</a></li>
                <li>
                    <a href="#slotted-aloha" aria-label="Slotted alohaðŸŸ©">Slotted alohaðŸŸ©</a></li></ul>
                </li>
                <li>
                    <a href="#csma" aria-label="CSMA">CSMA</a><ul>
                        
                <li>
                    <a href="#introduzione-allalgoritmo" aria-label="Introduzione all&rsquo;algoritmoðŸŸ©">Introduzione all&rsquo;algoritmoðŸŸ©</a></li>
                <li>
                    <a href="#slotted-csma" aria-label="Slotted CSMAðŸŸ©">Slotted CSMAðŸŸ©</a></li>
                <li>
                    <a href="#throughput-comparison" aria-label="Throughput comparisonðŸŸ©">Throughput comparisonðŸŸ©</a></li></ul>
                </li>
                <li>
                    <a href="#maca" aria-label="MACA">MACA</a><ul>
                        
                <li>
                    <a href="#hidden-and-exposed-terminals-" aria-label="hidden and exposed terminals ðŸŸ©">hidden and exposed terminals ðŸŸ©</a></li>
                <li>
                    <a href="#rts-and-cts" aria-label="RTS and CTSðŸŸ¨&#43;&#43;">RTS and CTSðŸŸ¨++</a></li>
                <li>
                    <a href="#rts-and-cts-drawback" aria-label="RTS and CTS drawback">RTS and CTS drawback</a></li>
                <li>
                    <a href="#macaw" aria-label="MACAW">MACAW</a></li>
                <li>
                    <a href="#ad-hoc-networks" aria-label="Ad hoc networks">Ad hoc networks</a></li>
                <li>
                    <a href="#carrier-sensing-virtuale" aria-label="Carrier sensing virtuale">Carrier sensing virtuale</a></li>
                <li>
                    <a href="#fama" aria-label="FAMA">FAMA</a></li></ul>
                </li>
                <li>
                    <a href="#coordinator-functions" aria-label="Coordinator functions">Coordinator functions</a><ul>
                        
                <li>
                    <a href="#point-coordination-function" aria-label="Point coordination functionðŸŸ©">Point coordination functionðŸŸ©</a></li>
                <li>
                    <a href="#inter-frame-spaces" aria-label="Inter-Frame spaces">Inter-Frame spaces</a><ul>
                        
                <li>
                    <a href="#short-ifs" aria-label="Short IFS">Short IFS</a></li>
                <li>
                    <a href="#point-ifs" aria-label="Point IFS">Point IFS</a></li>
                <li>
                    <a href="#distributed-ifs" aria-label="Distributed IFS">Distributed IFS</a></li></ul>
                </li>
                <li>
                    <a href="#distributed-coordination-function" aria-label="Distributed coordination functionðŸŸ©">Distributed coordination functionðŸŸ©</a></li>
                <li>
                    <a href="#gestione-del-back-off" aria-label="Gestione del back-offðŸŸ©">Gestione del back-offðŸŸ©</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="introduzione">Introduzione<a hidden class="anchor" aria-hidden="true" href="#introduzione">#</a></h2>
<p>Ricordiamo che vogliamo cercare di <strong>arbitrare lâ€™accesso al canale fisico sottostante</strong>. In questo momento andiamo ad assumere di avere giÃ  tutto lâ€™impianto di trasmissione fisica che abbiamo in <a href="/notes/tecnologia-wireless/">Tecnologia Wireless</a>, <a href="/notes/modulazione-wireless/">Modulazione wireless</a> <a href="/notes/fisica-del-wireless/">Fisica del Wireless</a>.</p>
<h3 id="obiettivi">Obiettivi:<a hidden class="anchor" aria-hidden="true" href="#obiettivi">#</a></h3>
<ol>
<li>Arbitraggio del singolo canale fisico (la tesi di dottorato del prof era su collision avoidance di wifi).
<ol>
<li>Sia in tempo</li>
<li>Sia in spazio (come gestire il segnale mandato nello stesso spazio)</li>
</ol>
</li>
<li>Utilizzo minimo di energia</li>
<li>Quality of service</li>
<li>Adaptive behaviour (come il 6G che vuole andare ad utilizzare AI per fare predizione).</li>
<li>Evitare segnale spaghetti o jammed
<ol>
<li>Collisioni fanno sprecare energia ad entrambi (sia ricevente sia sender)</li>
<li>bisogna trovare un metodo per fare risoluzione (controllare il sender riguardo la trasmissione, in quanto non sono in grado di trasmettere e ascoltare in modo contemporaneo)</li>
<li>Questo si lega alla parte di arbitraggio del canale</li>
</ol>
</li>
</ol>
<p>Ricordiamo che ethernet provava ad ascoltare il segnale e provare a trasmettere, si puÃ² utilizzare la stessa cosa anche qui? No, ethernet permetteva di ascolatare il segnale nel momento di generazione, mentre wifi non puÃ², perchÃ© semplicemente il segnale prodotto localmente Ã¨ molto piÃ¹ grande. Inoltre wifi ha anche bisogno di fare multiplexing sullo <strong>spazio</strong> non solo nel tempo come per lâ€™ethernet.</p>
<h3 id="anticollisione-primo-tentativo">Anticollisione primo tentativo<a hidden class="anchor" aria-hidden="true" href="#anticollisione-primo-tentativo">#</a></h3>
<p>Allora, in questa parte continuiamo ad analizzare un protocollo che tenti di evitare la collisione, si puÃ² utilizzare un sistema simile ad ethernet?</p>
<ol>
<li>Risposta negativa: non evita le collisioni</li>
</ol>
<ul>
<li>
<p>Slide fenomeno</p>
  <img src="/images/notes/image/universita/ex-notion/Mac Wifi/Untitled.png" alt="image/universita/ex-notion/Mac Wifi/Untitled">
<p>Nonostante i senders non sentano niente, c&rsquo;Ã¨ interferenza, credo si chiami anche problema del <strong>terminale nascosto</strong>, perchÃ© non senti lâ€™interferenza (asimmetria di informazioni).</p>
</li>
</ul>
<ol>
<li>Non arbitra niente alla fineâ€¦</li>
</ol>
<h3 id="classificazione-accesso-multiplo-mac-wifi">Classificazione accesso multiplo MAC-WIFIðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#classificazione-accesso-multiplo-mac-wifi">#</a></h3>
<img src="/images/notes/image/universita/ex-notion/Mac Wifi/Untitled 1.png" alt="image/universita/ex-notion/Mac Wifi/Untitled 1">
<ol>
<li>Senza contesa, ossia si cerca di evitare la contesa della rete wifi
<ol>
<li>Centralizzati statici, con un <strong>coordinatore statico</strong> che dica quando puoi comunicare (prenotazioni registrate da un coordinatore) â†’ garanzia del servizio
<ol>
<li>Costo coordinatore (centralizzato, quindi se cade cade tutto, facile da attaccare)</li>
<li>Costo allocazione statica delle risorse.</li>
</ol>
</li>
<li><strong>token-based</strong> chi vuole comunicare tiene solamente il token (solo che il rischio Ã¨ che si perda il token per una interferenza o simili).</li>
</ol>
</li>
<li>Content, provare a prendersi il segnale, o provare finchÃ© non ci si riesce.
<ol>
<li>Probabilistico Ã¨ quello piÃ¹ sicuro dal punto di vista della sicurezza, e ha <strong>allocazione dinamica di servizi</strong> (provare a comunicare a tempi random, probabilisticamente parlando provandoci cosÃ¬ prima o poi si comunicherÃ ). Solo che ha il problema delle collissioni ,quindi sarebbe molto buono questo metodo di allocazioen dinamica con il server centrale (0 collisioni e 0tempi vuoti). Solo che il coordinatore ha un costo. â†’ reliability della comunicazione.</li>
<li>Deterministico (mi sono distratto a configurare alacritty e non ho capito).</li>
</ol>
</li>
</ol>
<p>Abbiamo un accesso probabilistico in cui si prova a comunciare nel vuoto (nel senso che non si puÃ² spegnere questa rete, nel caso della presenza di un accesso centralizzato allora si utilizza quella. (ma nessuno paga))</p>
<h2 id="aloha-protocol">Aloha protocol<a hidden class="anchor" aria-hidden="true" href="#aloha-protocol">#</a></h2>
<h3 id="funzionamento-in-breve">Funzionamento in breveðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#funzionamento-in-breve">#</a></h3>
<p>Ãˆ stato uno dei primi protocolli radio presenti. Stiamo parlando di 1970, Abramson1970 era alle Hawaii e aveva solamente dispositivi radio a disposizione, sono le prime sperimentazioni.</p>
<pre><code>&lt;img src=&quot;/images/notes/image/universita/ex-notion/Mac Wifi/Untitled 2.png&quot; alt=&quot;image/universita/ex-notion/Mac Wifi/Untitled 2&quot;&gt;
</code></pre>
<p>Il round trip time veniva calcolato, se non riceve lâ€™ack aspetta un tempo un pÃ² random. (il seme sarÃ  diverso, tipo lâ€™id della scheda di rete, il tempo di backoff che coincida Ã¨ abbastanza basso)</p>
<h3 id="analisi-dominio-di-collisione">Analisi dominio di collisioneðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#analisi-dominio-di-collisione">#</a></h3>
<p>Ci vogliamo chiedere quando Ã¨ il time frame in cui puÃ² avvenire una collisione?</p>
<p>Siano due comunicanti, che devono entrambi trasmettere, se uno trasmette, quando non potrebbe trasmettere l Ã¡ltro per evitare la connessioen? Ci interessa solamente il tempo.</p>
<p>La risposta Ã¨ semplice, vogliamo solo che sia una dimensione di frame prima e una dimensione di frame dopo: <strong>tempo/slot di collisione Ã¨ due volte</strong>.</p>
<ul>
<li>
<p>Slide intuizione dominio di collisione</p>
  <img src="/images/notes/image/universita/ex-notion/Mac Wifi/Untitled 3.png" alt="image/universita/ex-notion/Mac Wifi/Untitled 3">
</li>
</ul>
<p>Con questa osservazione, possiamo cambiare leggermente l&rsquo;algoritmo di aloha al fine di risolvere, o meglio alleviare, il problema della collisione:</p>
<h3 id="slotted-aloha">Slotted alohaðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#slotted-aloha">#</a></h3>
<p>Lo slotted aloha permette solamente la trasmissione in certi slot di tempo, questo aiuta ad alleviare il problema della collisione:</p>
<p>Ha senso che la dimensione dello slot Ã¨ <strong>dimensione massima del frame con anche trasmission delay</strong> vogliamo andare a contare anche il delay della trasmissione perchÃ© altrimenti due frames possono comunque influenzarsi fra di loro durante la trasmissione.</p>
<ul>
<li>
<p>Slide slotted aloha</p>
  <img src="/images/notes/image/universita/ex-notion/Mac Wifi/Untitled 4.png" alt="image/universita/ex-notion/Mac Wifi/Untitled 4">
</li>
</ul>
<p>Quindi ora il tempo di vulnerabilitÃ  Ã¨ ridotto a slot + propagation, invece che due slots (anche se solitamente pensavo che il tempo di propagazione Ã¨ maggiore? Credo dipendaâ€¦).</p>
<h2 id="csma">CSMA<a hidden class="anchor" aria-hidden="true" href="#csma">#</a></h2>
<p>Carrier sense multiple access</p>
<h3 id="introduzione-allalgoritmo">Introduzione all&rsquo;algoritmoðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#introduzione-allalgoritmo">#</a></h3>
<img src="/images/notes/image/universita/ex-notion/Mac Wifi/Untitled 5.png" alt="image/universita/ex-notion/Mac Wifi/Untitled 5">
<p>In questo caso il <strong>FVT</strong> (frame vulnerability time) Ã¨ due volte il propagation, perchÃ© se sono dentro a questo intervallo allora non sento il segnale dell&rsquo;altro, che non Ã¨ ancora arrivato. Questo valore solitamente Ã¨ molto piÃ¹ piccolo rispetto al frame size.</p>
<h3 id="slotted-csma">Slotted CSMAðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#slotted-csma">#</a></h3>
<p>Alla fine molto simile questa idea allo slotted aloha, tutti possono trasmettere soltanto in certi slots di times</p>
<img src="/images/notes/image/universita/ex-notion/Mac Wifi/Untitled 6.png" alt="image/universita/ex-notion/Mac Wifi/Untitled 6">
<h3 id="throughput-comparison">Throughput comparisonðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#throughput-comparison">#</a></h3>
<img src="/images/notes/image/universita/ex-notion/Mac Wifi/Untitled 7.png" alt="image/universita/ex-notion/Mac Wifi/Untitled 7">
<p>Vediamoc he il throughput cambia molto seguendo i protocolli (e va giÃ¹ perchÃ© ci sono troppe collisioni se provo a trasmettere troppo.</p>
<p>Mi serve sapere il numero di stazioni trasmittenti, una cosa che non conosco generalmente.</p>
<h2 id="maca">MACA<a hidden class="anchor" aria-hidden="true" href="#maca">#</a></h2>
<h3 id="hidden-and-exposed-terminals-">hidden and exposed terminals ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#hidden-and-exposed-terminals-">#</a></h3>
<p>Vogliamo cercare di limitare le trasmittenti a comunicare bene con un ricevitore (sto ragionando sull esempio di ACBD in mezzo) cioÃ¨ in un caso di <strong>hidden terminal</strong> in cui due senders non si sentono fra di loro, ma il loro segnale potrebbe interferire in un certo punto.</p>
<p>Un problema opposto Ã¨ il <strong>exposed terminal</strong> quando il sender Ã¨ condiviso da piÃ¹ host, un host che vorrebbe comunicare, a un host diverso, non puÃ² comunicare perchÃ© sente questo.</p>
<h3 id="rts-and-cts">RTS and CTSðŸŸ¨++<a hidden class="anchor" aria-hidden="true" href="#rts-and-cts">#</a></h3>
<img src="/images/notes/image/universita/ex-notion/Mac Wifi/Untitled 8.png" alt="image/universita/ex-notion/Mac Wifi/Untitled 8">
<p>Un altro problema di hidden terminal oltre alla trasmissione su un terminale comune Ã¨ il fatto che se CB provano a comunicare a persone differenti (rispettivamente ad A e D, B non puÃ² perchÃ© sente ricevere).</p>
<p>Una soluzione semplice Ã¨ semplicemente chiedere al canale ricevente se ci sono interferenze o meno. (un pacchetto breve che si chaiama <strong>RTS (request to send)</strong>.) questo Ã¨ un piccolo pacchetto, potrebbe interferire, si spera che faccia molti pochi interferenze.</p>
<p>Il ricevitore risponde con un <strong>CTS (clear to send</strong>) Se il cts Ã¨ ricevuto allora comincia a rispondere.</p>
<p>â†’ Non ho carrier sensing qui.</p>
<h3 id="rts-and-cts-drawback">RTS and CTS drawback<a hidden class="anchor" aria-hidden="true" href="#rts-and-cts-drawback">#</a></h3>
<p>Non abbiamo garanzia di comunicazione senza interferenze, questa garanzia c&rsquo;Ã¨ solamente quando il range di comunicazione sono uguali fra di loro, un esempio in cui non funziona Ã¨ lâ€™esempio qui sotto in cui esiste una rete grande ch epossa andare a fare interferenza con tutte.
<img src="/images/notes/image/universita/ex-notion/Mac Wifi/Untitled 9.png" alt="image/universita/ex-notion/Mac Wifi/Untitled 9"></p>
<h3 id="macaw">MACAW<a hidden class="anchor" aria-hidden="true" href="#macaw">#</a></h3>
<p>Voglio ritardare il RTS in un tempo casuale in modo che non sovrappongano fra di loro. C&rsquo;Ã¨ carrier sensing **per gli acks, posso spedire solo quando mando RTS cosÃ¬ posso ricevere ack in silenzio. Gli altri quando sentono dovrebbero restare in silenzio.</p>
<ul>
<li>RTS</li>
<li>Carrier sensing (anche questa credo sia la cosa nuova, il sistema RTS/CTS Ã¨ lo stesso di MACA)</li>
<li>backoff (questa Ã¨ lâ€™unica cosa nuov acredo).</li>
</ul>
<p>Lâ€™unico che ha preso la RTS sarÃ  lâ€™unico a comunicare, gli altri stanno in silenzion perchÃ© sentono il canale occupato.</p>
<p>Si puÃ² settare il RTS threshhol superiore alla soglia per dire che non verrÃ  mai utilizzato.</p>
<img src="/images/notes/image/universita/ex-notion/Mac Wifi/Untitled 10.png" alt="image/universita/ex-notion/Mac Wifi/Untitled 10">
<p>Che Ã¨ molto simile a un coordinator function with backoff, solo che questo Ã¨ senza infrastruttura, mentre nell&rsquo;altro credo ci sia.</p>
<h3 id="ad-hoc-networks">Ad hoc networks<a hidden class="anchor" aria-hidden="true" href="#ad-hoc-networks">#</a></h3>
<p>Ci sono delle cose nuove che sono delle <strong>veicole infrastructures</strong> ossia in realtÃ  non esisterebbe una infrastruttura per questa connessione, ma passa da veicolo a veicolo quindi Ã¨ una comunicazione locale. fino a un certo punto in cui alla fine si comunica con una infrastruttura. Come se le auto stesse fossero diventati dei sensori del traffico (quindi molte auto ferme riescono a dire se c&rsquo;Ã¨ troppo traffico o meno.</p>
<p>non sono ancora diffusi questi servizi, ma stanno arrivanto, u n altro metodo Ã¨ fare unitÃ  di ricarica per i veicoli.</p>
<p>C&rsquo;Ã¨ una trasmissione con CSMA/CA , poi c&rsquo;Ã¨ una <strong>fase di contention</strong> in cui si potrebbero trasmettere cose e cose di altro tipo. ci otrebbero essere un sacco di rts che vadano a vuoto. Ognuna delle fasi di rts Ã¨ un passaggio indipendente in cui si rischia ancora la collisione.</p>
<p>Ma quando trasmette indietro potrei avere delle (la collisione :</p>
<ol>
<li><strong>Fast forward intra-stream</strong> in cui il RTS del nodo successivo Ã¨ interpretato dal nodo davanti come se fosse un ACK, questo risolve il problema delle interferenze (la fase di contesa non ci sarebbe piÃ¹). (c&rsquo;Ã¨ un campo che rappresenta il tipo di questo segnale, che valga sia come ack sia come rts).</li>
<li><strong>Quick exchange inter-stream</strong>, se i due nodi intermedi hanno cose da scambiarsi in direzioni diverse, potrebbe essere una buonissima soluzione il fatto di scambiarsi i dati nello stesso stream di dati (dopo l&rsquo;ack di una direzione viene mandato il dato dell&rsquo;altra direzione).</li>
</ol>
<p>Se uno cade allora c&rsquo;Ã¨ tempo vuoto e viene interpretato come autorizzazione alla trasmissione</p>
<h3 id="carrier-sensing-virtuale">Carrier sensing virtuale<a hidden class="anchor" aria-hidden="true" href="#carrier-sensing-virtuale">#</a></h3>
<p>Carrier sensing <strong>virtuale</strong> sapere che il canale sia occupato senza andare ad ascoltarlo?
Appena sentono un RTS, e se sanno la lunghezza del campo di trasmissione classico (<strong>Network Allocation Vector NAV)</strong> allora sicuramente nessuno ascolta il canale.</p>
<p>Questo fa risparmiare batteria al destinatario. E trasmettere prende un sacco di energia, anche solamente andare ad ascoltare consuma.</p>
<h3 id="fama">FAMA<a hidden class="anchor" aria-hidden="true" href="#fama">#</a></h3>
<p>Voglio utilizzare una soglia <strong>adattiva</strong> oltre la quale comincio ad utilizzare il meccanismo rts/cts. Solitamente questo mi serve quando ho troppe connessioni.</p>
<p>Se il frame Ã¨ minore di una soglia allor anon ha bisogno di rts/cts, altrimenti ha bisogno.</p>
<p>Anche questo Ã¨ per reti ad hoc.</p>
<h2 id="coordinator-functions">Coordinator functions<a hidden class="anchor" aria-hidden="true" href="#coordinator-functions">#</a></h2>
<p>Ci sono principalemente <strong>due meccanismi</strong> che vanno a regolare lâ€™accesso al canale
<img src="/images/notes/image/universita/ex-notion/Mac Wifi/Untitled 11.png" alt="image/universita/ex-notion/Mac Wifi/Untitled 11"></p>
<p>Câ€™Ã¨ lâ€™access point che fa un <strong>beacon</strong> e che rende possibile la coordinazione (cose come il nome della rete e annuncio della sua esistenza Ã¨ il beacon che sempre ogni tanto manda il beacon!).</p>
<p>Una volta fatto una comunciazione coordinata dÃ  il temop alla DCF. In questo momento lâ€™AP non comunca</p>
<h3 id="point-coordination-function">Point coordination functionðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#point-coordination-function">#</a></h3>
<ul>
<li>
<p>Slide PCF</p>
  <img src="/images/notes/image/universita/ex-notion/Mac Wifi/Untitled 12.png" alt="image/universita/ex-notion/Mac Wifi/Untitled 12">
</li>
</ul>
<p>Quando esiste un access point che cerchi di evitare le collisioni e governi tutto la comunicazione nel canale.</p>
<p>Questa cosa Ã¨ bella perchÃ© funziona anche se muore l&rsquo;access point. Ma alla fine lâ€™unica cosa rimasta Ã¨ la DCF, quindi abbiamo molte piÃ¹ collisioni. (perchÃ© creare firmware era molto costoso).</p>
<h3 id="inter-frame-spaces">Inter-Frame spaces<a hidden class="anchor" aria-hidden="true" href="#inter-frame-spaces">#</a></h3>
<pre><code>&lt;img src=&quot;/images/notes/image/universita/ex-notion/Mac Wifi/Untitled 13.png&quot; alt=&quot;image/universita/ex-notion/Mac Wifi/Untitled 13&quot;&gt;
</code></pre>
<p>Point, ditributed and short,, sono una d<strong>durata di tempo in cui carrier sensing</strong> deve avere vuoto prima di poter tentare di comunicare.</p>
<h4 id="short-ifs">Short IFS<a hidden class="anchor" aria-hidden="true" href="#short-ifs">#</a></h4>
<ul>
<li>SIFS tempo prima di autorizzare la comunicazione qualcuno che sa giÃ  che deve parlare a seconda del contesto (e dovrebbe essere solamente un unico host) Se non parte significa o che sia morto o non ci sia nessuno. E Questo Ã¨ necessario per avere un PIFS</li>
</ul>
<h4 id="point-ifs">Point IFS<a hidden class="anchor" aria-hidden="true" href="#point-ifs">#</a></h4>
<ul>
<li>PIFS questo Ã¨ il tempo per far parlare <strong>l&rsquo;access point.</strong> se nemmeno questo c&rsquo;Ã¨ (ad esempio se l&rsquo;access point vuole permettere la comunicazione contesa) allora il tempo aumenta e diventa un difs. (puÃ² essere che trasmettino un polling, con l&rsquo;id di quello che deve andare a trasmettere).</li>
</ul>
<h4 id="distributed-ifs">Distributed IFS<a hidden class="anchor" aria-hidden="true" href="#distributed-ifs">#</a></h4>
<ul>
<li>DIFS Questo Ã¨ come dire un <strong>liberi tutti</strong> quindi si rientra al tempo di contesa del WIFI.</li>
</ul>
<h3 id="distributed-coordination-function">Distributed coordination functionðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#distributed-coordination-function">#</a></h3>
<img src="/images/notes/image/universita/ex-notion/Mac Wifi/Untitled 14.png" alt="image/universita/ex-notion/Mac Wifi/Untitled 14">
<p>Spazio RTS-CTS anche adattivo con una soglia</p>
<p>Tempo Ã¨ avoidance con carrier sensing, in un ambiente <strong>distribuito</strong>. In questo caso tutti provano a comunicare, finchÃ© non ci riescono.</p>
<p>Lo slot non Ã¨ l&rsquo;intero frame come in ALOHA, ma solamente il <strong>tempo di propagazione</strong> (esempio il tempo necessario per la luce in 100 metri), gli slots sono messi in questo senso. Nello slot successivo sicuramente il tentativo Ã¨ stato ricevuto.</p>
<p>il backoff Ã¨ basato sul numero di questi slot vuoti che abbiamo ascoltato. E se vado a 0 allora mi metto a comunicare in modo descritto da sopra.</p>
<p>Il numero degli slot dovrebbe dipendere dal numero di comunicanti questo non Ã¨ a priori definito (e non Ã¨ nemmeno possibile stimarla secondo il prof).</p>
<h3 id="gestione-del-back-off">Gestione del back-offðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#gestione-del-back-off">#</a></h3>
<img src="/images/notes/image/universita/ex-notion/Mac Wifi/Untitled 15.png" alt="image/universita/ex-notion/Mac Wifi/Untitled 15">
<p>Il backoff Ã¨ via via crescente, si potrebbe dire che sia la come la dimensione della finestra di contesa <strong>CW = contention window</strong> che Ã¨ diversa rispetto alla congestion window, perÃ² il signfiicato Ã¨ completamente diverso! Congestion trattato in <a href="/notes/livello-di-trasporto/">Livello di trasporto</a> serve per mandare tot frammenti allo stesso tempo senza far esplodere il router (il livello Ã¨ diverso!) mentre ora siamo a livello fisico, e si prova a comunicare localmente.</p>
<p>La cosa brutta Ã¨ che deve andare a sperimentare contesa per sapere quanta contesa ci sia! Per questo motivo si dice che non sia efficiente: se il canale Ã¨ occupato con questo metodo ci provi lo stesso e quindi vai a disturbare.</p>
<p>Quando va a 0 allora io faccio proprio la tramissi contione e aspetto ack, se arrivo Ã¨ ok, altrimenti si aumenta timer nel backoff e si rifÃ . Continua finchÃ© non ce la fai.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/computer-networks/">ðŸ•¸Computer-Networks</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Mac Wifi on x"
            href="https://x.com/intent/tweet/?text=Mac%20Wifi&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fmac-wifi%2f&amp;hashtags=%f0%9f%95%b8computer-networks">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Mac Wifi on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fmac-wifi%2f&amp;title=Mac%20Wifi&amp;summary=Mac%20Wifi&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2fmac-wifi%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Mac Wifi on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2fmac-wifi%2f&title=Mac%20Wifi">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Mac Wifi on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2fmac-wifi%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Mac Wifi on whatsapp"
            href="https://api.whatsapp.com/send?text=Mac%20Wifi%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2fmac-wifi%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Mac Wifi on telegram"
            href="https://telegram.me/share/url?text=Mac%20Wifi&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fmac-wifi%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Mac Wifi on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Mac%20Wifi&u=https%3a%2f%2fflecart.github.io%2fnotes%2fmac-wifi%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2025 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
