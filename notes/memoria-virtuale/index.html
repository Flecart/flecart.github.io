<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Memoria virtuale | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="sistemi-operativi">
<meta name="description" content="Memoria virtuale
Perché è utile la MV?
I programmi non usano tutta la memoria, ma pensano di averla tutta disponibile dal suo punto di vista. L&rsquo;idea principale è che molte zone di memoria sono inutili per lungo tempo, possono essere utilizzati per altro.

caricamento codice dinamico Per esempio anche a caricare il codice di un compilatore è diviso in fasi, se andiamo a caricare tutto, stiamo utilizzando solo un pezzo piccolo, tanta inefficienza, se una pagina contiene una parte del compilatore potrei caricare in memoria solamente le parti eseguite sul momento, giusto per fare un esempio diciamo.
Crescita dei segmenti stack, heap, ad esempio ci permette di far crescere come ci pare la stack, e anche caricare solamente le parti della stack che ci servono, e mantenere la memoria libera per altro.
Gestione degli errori. che utilizzerà i dati solamente della parte di gestione di memoria attuale diciamo.

Paginazione a richiesta
Questo è un aspetto della cache delle pagine di cui abbiamo già parlato in Livello OS.">
<meta name="author" content="
By Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="https://flecart.github.io/notes/memoria-virtuale/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f790d9af969c56c079c1ce2d5972a04486bf3d6144295d5fba319830e1e55a7a.css" integrity="sha256-95DZr5acVsB5wc4tWXKgRIa/PWFEKV1fujGYMOHlWno=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/memoria-virtuale/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>
<script type="text/javascript" async
src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>






      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-WW6NN2QGKF');
        }
      </script><meta property="og:url" content="https://flecart.github.io/notes/memoria-virtuale/">
  <meta property="og:site_name" content="X. Angelo Huang&#39;s Blog">
  <meta property="og:title" content="Memoria virtuale">
  <meta property="og:description" content="Memoria virtuale Perché è utile la MV? I programmi non usano tutta la memoria, ma pensano di averla tutta disponibile dal suo punto di vista. L’idea principale è che molte zone di memoria sono inutili per lungo tempo, possono essere utilizzati per altro.
caricamento codice dinamico Per esempio anche a caricare il codice di un compilatore è diviso in fasi, se andiamo a caricare tutto, stiamo utilizzando solo un pezzo piccolo, tanta inefficienza, se una pagina contiene una parte del compilatore potrei caricare in memoria solamente le parti eseguite sul momento, giusto per fare un esempio diciamo. Crescita dei segmenti stack, heap, ad esempio ci permette di far crescere come ci pare la stack, e anche caricare solamente le parti della stack che ci servono, e mantenere la memoria libera per altro. Gestione degli errori. che utilizzerà i dati solamente della parte di gestione di memoria attuale diciamo. Paginazione a richiesta Questo è un aspetto della cache delle pagine di cui abbiamo già parlato in Livello OS.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="notes">
    <meta property="article:tag" content="Sistemi-Operativi">
      <meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:title" content="Memoria virtuale">
<meta name="twitter:description" content="Memoria virtuale
Perché è utile la MV?
I programmi non usano tutta la memoria, ma pensano di averla tutta disponibile dal suo punto di vista. L&rsquo;idea principale è che molte zone di memoria sono inutili per lungo tempo, possono essere utilizzati per altro.

caricamento codice dinamico Per esempio anche a caricare il codice di un compilatore è diviso in fasi, se andiamo a caricare tutto, stiamo utilizzando solo un pezzo piccolo, tanta inefficienza, se una pagina contiene una parte del compilatore potrei caricare in memoria solamente le parti eseguite sul momento, giusto per fare un esempio diciamo.
Crescita dei segmenti stack, heap, ad esempio ci permette di far crescere come ci pare la stack, e anche caricare solamente le parti della stack che ci servono, e mantenere la memoria libera per altro.
Gestione degli errori. che utilizzerà i dati solamente della parte di gestione di memoria attuale diciamo.

Paginazione a richiesta
Questo è un aspetto della cache delle pagine di cui abbiamo già parlato in Livello OS.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Memoria virtuale",
      "item": "https://flecart.github.io/notes/memoria-virtuale/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Memoria virtuale",
  "name": "Memoria virtuale",
  "description": "Memoria virtuale Perché è utile la MV? I programmi non usano tutta la memoria, ma pensano di averla tutta disponibile dal suo punto di vista. L\u0026rsquo;idea principale è che molte zone di memoria sono inutili per lungo tempo, possono essere utilizzati per altro.\ncaricamento codice dinamico Per esempio anche a caricare il codice di un compilatore è diviso in fasi, se andiamo a caricare tutto, stiamo utilizzando solo un pezzo piccolo, tanta inefficienza, se una pagina contiene una parte del compilatore potrei caricare in memoria solamente le parti eseguite sul momento, giusto per fare un esempio diciamo. Crescita dei segmenti stack, heap, ad esempio ci permette di far crescere come ci pare la stack, e anche caricare solamente le parti della stack che ci servono, e mantenere la memoria libera per altro. Gestione degli errori. che utilizzerà i dati solamente della parte di gestione di memoria attuale diciamo. Paginazione a richiesta Questo è un aspetto della cache delle pagine di cui abbiamo già parlato in Livello OS.\n",
  "keywords": [
    "sistemi-operativi"
  ],
  "articleBody": "Memoria virtuale Perché è utile la MV? I programmi non usano tutta la memoria, ma pensano di averla tutta disponibile dal suo punto di vista. L’idea principale è che molte zone di memoria sono inutili per lungo tempo, possono essere utilizzati per altro.\ncaricamento codice dinamico Per esempio anche a caricare il codice di un compilatore è diviso in fasi, se andiamo a caricare tutto, stiamo utilizzando solo un pezzo piccolo, tanta inefficienza, se una pagina contiene una parte del compilatore potrei caricare in memoria solamente le parti eseguite sul momento, giusto per fare un esempio diciamo. Crescita dei segmenti stack, heap, ad esempio ci permette di far crescere come ci pare la stack, e anche caricare solamente le parti della stack che ci servono, e mantenere la memoria libera per altro. Gestione degli errori. che utilizzerà i dati solamente della parte di gestione di memoria attuale diciamo. Paginazione a richiesta Questo è un aspetto della cache delle pagine di cui abbiamo già parlato in Livello OS.\nSlide paginazione a richiesta\nin pratica nella cache è presente un bit, chiamato valid bit, che ci dice se la pagina correntemente caricata è valida o meno.\nSe non è presente una pagina valida, allora chiamiamo trap di page fault, e il pager si occupa di caricare la nuova pagina ed aggiornare la pagina vecchia.\nEsempio di demand paging\nNOTA: la memoria secondaria con questo metodo ha l’intero contenuto, in questo senso la memoria principale è utilizzata come se fosse cache.\nEsempio completo con page fault\n*ALGORITMO GENERALE DI DEMAND PAGING\nSlide demand paging\nNOTA: la cosa importante è il fatto che invalida subito la pagina scelta da sostituire. Non vorremmo che se un altro processo chieda quella pagina possa ancora scriverci o leggerci (e quindi problemi di concorrenza).\nMemoria di Swap In realtà quando un intero processo è caricato in memoria secondaria, questa parte in memoria secondaria è l’area di swap.\nMa questo metodo qui è come se fosse uno swap pigro. (se un processo è vecchio, nel senso che non utilizza la pagina per tanto tempo, è probabile che la sua memoria è messa in memoria secondaria).\nil termine swap area per indicare l’area del disco utilizzata per ospitare le pagine in memoria secondaria\nAlgoritmi di rimpiazzamento AKA Paginazione.\nObiettivo del rimpiazzamento Quando la memoria centrale è piena, come si gestisce il processo di rimpiazzamento? In che modo si decide quale sia la pagina da togliere? Su quali basi andare a valutare per fare questa decisione?\nUtilità, nel senso meno utilizzata Sarà utilizzata fra più tempo. Minimizzare il numero di page faults possibili. vorremmo evitare di togliere e rimpiazzare subito.\nNUMERO DI FRAME E PAGE FAULTS\nNon è che il numero dei frame aumenta implica che il numero di faults sia minore? Ma stranamente non è sempre così, gli algoritmi di rimpiazzamento potrebbero fare peggio se hai troppa memoria, per esempio [Algoritmi FIFO\nQuesto fenomeno è proprio studiato, ed è conosciuto nel nome di [[Anomalia di belady\nStringa di riferimenti È la sequenza degl iindirizzi di memoria al quale un processo accede durante la sua esecuzione, (ci importa solamente il numero di pagina!) Questo ci dà un criterio per valutare quanto buona è una pagina in memoria\nSlide stringa di riferimenti\nAlgoritmi FIFO Questo l’abbiamo studiato anche in [[Scheduler](/notes/algoritmi-fifo-\nquesto-fenomeno-è-proprio-studiato,-ed-è-conosciuto-nel-nome-di-[[anomalia-di-belady-\n###-stringa-di-riferimenti-\nè-la-sequenza-degl-iindirizzi-di-memoria-al-quale-un-processo-accede-durante-la-sua-esecuzione,-(ci-importa-solamente-il-numero-di-pagina!)-questo-ci-dà-un-criterio-per-valutare-quanto-buona-è-una-pagina-in-memoria\n–slide-stringa-di-riferimenti\n—-",
  "wordCount" : "1763",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/memoria-virtuale/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Memoria virtuale
    </h1>
    <div class="post-meta">Reading Time: 9 minutes&nbsp;·&nbsp;
By Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#memoria-virtuale" aria-label="Memoria virtuale">Memoria virtuale</a><ul>
                        
                <li>
                    <a href="#perch%c3%a9-%c3%a8-utile-la-mv" aria-label="Perché è utile la MV?">Perché è utile la MV?</a></li>
                <li>
                    <a href="#paginazione-a-richiesta" aria-label="Paginazione a richiesta">Paginazione a richiesta</a></li>
                <li>
                    <a href="#memoria-di-swap" aria-label="Memoria di Swap">Memoria di Swap</a></li></ul>
                </li>
                <li>
                    <a href="#algoritmi-di-rimpiazzamento" aria-label="Algoritmi di rimpiazzamento">Algoritmi di rimpiazzamento</a><ul>
                        
                <li>
                    <a href="#obiettivo-del-rimpiazzamento" aria-label="Obiettivo del rimpiazzamento">Obiettivo del rimpiazzamento</a></li>
                <li>
                    <a href="#stringa-di-riferimenti" aria-label="Stringa di riferimenti">Stringa di riferimenti</a></li>
                <li>
                    <a href="#algoritmi-fifo" aria-label="Algoritmi FIFO">Algoritmi FIFO</a></li>
                <li>
                    <a href="#anomalia-di-belady" aria-label="Anomalia di belady">Anomalia di belady</a></li>
                <li>
                    <a href="#algoritmo-min" aria-label="Algoritmo MIN">Algoritmo MIN</a></li>
                <li>
                    <a href="#least-frequently-used" aria-label="Least Frequently used">Least Frequently used</a></li></ul>
                </li>
                <li>
                    <a href="#algoritmo-di-lru" aria-label="Algoritmo di LRU">Algoritmo di LRU</a><ul>
                        
                <li>
                    <a href="#implementazione-lru" aria-label="Implementazione LRU">Implementazione LRU</a></li>
                <li>
                    <a href="#implementazione-a-stack" aria-label="Implementazione a stack">Implementazione a stack</a></li>
                <li>
                    <a href="#additional-reference-bit" aria-label="Additional reference bit">Additional reference bit</a></li></ul>
                </li>
                <li>
                    <a href="#allocazione-della-memoria-virtuale" aria-label="Allocazione della memoria virtuale">Allocazione della memoria virtuale</a><ul>
                        
                <li>
                    <a href="#tipologie-di-allocamento-3" aria-label="Tipologie di allocamento (3)">Tipologie di allocamento (3)</a></li>
                <li>
                    <a href="#thrashing" aria-label="Thrashing">Thrashing</a></li>
                <li>
                    <a href="#working-set" aria-label="Working set">Working set</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="memoria-virtuale">Memoria virtuale<a hidden class="anchor" aria-hidden="true" href="#memoria-virtuale">#</a></h2>
<h3 id="perché-è-utile-la-mv">Perché è utile la MV?<a hidden class="anchor" aria-hidden="true" href="#perché-è-utile-la-mv">#</a></h3>
<p>I programmi non usano tutta la memoria, ma pensano di averla tutta disponibile dal suo punto di vista. L&rsquo;idea principale è che molte zone di memoria sono inutili per lungo tempo, possono essere utilizzati per altro.</p>
<ul>
<li><strong>caricamento codice dinamico</strong> Per esempio anche a caricare il codice di un compilatore è diviso in fasi, se andiamo a caricare tutto, stiamo utilizzando solo un pezzo piccolo, tanta inefficienza, se una pagina contiene una parte del compilatore potrei caricare in memoria solamente le parti eseguite sul momento, giusto per fare un esempio diciamo.</li>
<li><strong>Crescita dei segmenti stack, heap</strong>, ad esempio ci permette di far crescere come ci pare la stack, e anche caricare solamente le parti della stack che ci servono, e mantenere la memoria libera per altro.</li>
<li><strong>Gestione degli errori.</strong> che utilizzerà i dati solamente della parte di gestione di memoria attuale diciamo.</li>
</ul>
<h3 id="paginazione-a-richiesta">Paginazione a richiesta<a hidden class="anchor" aria-hidden="true" href="#paginazione-a-richiesta">#</a></h3>
<p>Questo è un aspetto della cache delle pagine di cui abbiamo già parlato in <a href="/notes/livello-os">Livello OS</a>.</p>
<ul>
<li>
<p>Slide paginazione a richiesta</p>
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled">
</li>
</ul>
<p>in pratica nella cache è presente un bit, chiamato <strong>valid bit</strong>, che ci dice se la pagina correntemente caricata è valida o meno.</p>
<p>Se non è presente una pagina valida, allora chiamiamo <strong>trap di page fault</strong>, e il <strong>pager</strong> si occupa di caricare la nuova pagina ed aggiornare la pagina vecchia.</p>
<ul>
<li>
<p>Esempio di demand paging</p>
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled 1.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled 1">
</li>
</ul>
<p>NOTA: la memoria secondaria con questo metodo ha l’intero contenuto, in questo senso la memoria principale è utilizzata come se fosse cache.</p>
<ul>
<li>
<p>Esempio completo con page fault</p>
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled 2.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled 2">
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled 3.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled 3">
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled 4.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled 4">
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled 5.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled 5">
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled 6.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled 6">
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled 7.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled 7">
</li>
</ul>
<p>*ALGORITMO GENERALE DI <strong>DEMAND PAGING</strong></p>
<ul>
<li>
<p>Slide demand paging</p>
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled 8.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled 8">
</li>
</ul>
<p>NOTA: la cosa importante è il fatto che <strong>invalida subito</strong> la pagina scelta da sostituire. Non vorremmo che se un altro processo chieda quella pagina possa ancora scriverci o leggerci (e quindi problemi di concorrenza).</p>
<h3 id="memoria-di-swap">Memoria di Swap<a hidden class="anchor" aria-hidden="true" href="#memoria-di-swap">#</a></h3>
<p>In realtà quando un intero processo è caricato in memoria secondaria, questa parte in memoria secondaria è l’area di swap.</p>
<p>Ma questo metodo qui è come se fosse uno swap pigro. (se un processo è vecchio, nel senso che non utilizza la pagina per tanto tempo, è probabile che la sua memoria è messa in memoria secondaria).</p>
<blockquote>
<p>il termine swap area per indicare l&rsquo;area del disco
utilizzata per ospitare le pagine in memoria secondaria</p></blockquote>
<h2 id="algoritmi-di-rimpiazzamento">Algoritmi di rimpiazzamento<a hidden class="anchor" aria-hidden="true" href="#algoritmi-di-rimpiazzamento">#</a></h2>
<p>AKA Paginazione.</p>
<h3 id="obiettivo-del-rimpiazzamento">Obiettivo del rimpiazzamento<a hidden class="anchor" aria-hidden="true" href="#obiettivo-del-rimpiazzamento">#</a></h3>
<p>Quando la memoria centrale è piena, come si gestisce il processo di rimpiazzamento? In che modo si decide quale sia la pagina da togliere? Su quali basi andare a valutare per fare questa decisione?</p>
<ul>
<li>Utilità, nel senso meno utilizzata</li>
<li>Sarà utilizzata fra più tempo.</li>
<li>Minimizzare il numero di page faults possibili.</li>
</ul>
<p>vorremmo evitare di togliere e rimpiazzare subito.</p>
<p><strong>NUMERO DI FRAME E PAGE FAULTS</strong></p>
<p>Non è che il numero dei frame aumenta implica che il numero di faults sia minore? Ma stranamente non è sempre così, gli algoritmi di rimpiazzamento potrebbero fare peggio se hai troppa memoria, per esempio [Algoritmi FIFO</p>
<p>Questo fenomeno è proprio studiato, ed è conosciuto nel nome di [[Anomalia di belady</p>
<h3 id="stringa-di-riferimenti">Stringa di riferimenti<a hidden class="anchor" aria-hidden="true" href="#stringa-di-riferimenti">#</a></h3>
<p>È la sequenza degl iindirizzi di memoria al quale un processo accede durante la sua esecuzione, (ci importa solamente il numero di pagina!) Questo ci dà un criterio per valutare quanto buona è una pagina in memoria</p>
<ul>
<li>
<p>Slide stringa di riferimenti</p>
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled 9.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled 9">
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled 10.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled 10">
</li>
</ul>
<h3 id="algoritmi-fifo">Algoritmi FIFO<a hidden class="anchor" aria-hidden="true" href="#algoritmi-fifo">#</a></h3>
<p>Questo l&rsquo;abbiamo studiato anche in [[Scheduler](/notes/algoritmi-fifo-</p>
<p>questo-fenomeno-è-proprio-studiato,-ed-è-conosciuto-nel-nome-di-[[anomalia-di-belady-</p>
<p>###-stringa-di-riferimenti-</p>
<p>è-la-sequenza-degl-iindirizzi-di-memoria-al-quale-un-processo-accede-durante-la-sua-esecuzione,-(ci-importa-solamente-il-numero-di-pagina!)-questo-ci-dà-un-criterio-per-valutare-quanto-buona-è-una-pagina-in-memoria</p>
<p>&ndash;slide-stringa-di-riferimenti</p>
<p>&mdash;-&lt;img-src=&quot;/images/notes/image/universita/ex-notion/memoria-virtuale/untitled-9.png&quot;-style=&ldquo;width:-100%&quot;-class=&ldquo;center&rdquo;-alt=&ldquo;image/universita/ex-notion/memoria-virtuale/untitled-9&rdquo;&gt;</p>
<p>&mdash;-&lt;img-src=&quot;/images/notes/image/universita/ex-notion/memoria-virtuale/untitled-10.png&rdquo;-style=&ldquo;width:-100%&quot;-class=&ldquo;center&rdquo;-alt=&ldquo;image/universita/ex-notion/memoria-virtuale/untitled-10&rdquo;&gt;</p>
<p>###-algoritmi-fifo-</p>
<p>questo-l-abbiamo-studiato-anche-in-[[scheduler), oppure <a href="/notes/data-plane">Data Plane</a> per i routers.</p>
<p>Praticamente la pagina che dovrà uscire sarà la pagina in memoria da piu`tempo. Ma non è detto che la pagina caricata da più tempo sia anche poco utilizzata! potrebbe essere ancora utilizzata!</p>
<ul>
<li>
<p>Esempio di paginazione fifo</p>
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled 11.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled 11">
</li>
<li>
<p>Esempio paginazione 2 fifo</p>
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled 12.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled 12">
</li>
<li>
<p>Esempio brutto, di maggiori faults con aumento memori</p>
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled 13.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled 13">
</li>
</ul>
<h3 id="anomalia-di-belady">Anomalia di belady<a hidden class="anchor" aria-hidden="true" href="#anomalia-di-belady">#</a></h3>
<ul>
<li>
<p>Slide anomalia di belady</p>
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled 14.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled 14">
</li>
</ul>
<p>Un buon algoritmo di rimpiazzamento dovrebbe essere immune a questa anomalia! Perché non avrebbe senso che aggiungere memoria renda il sistema più lento!</p>
<p>In questo paragrafo: Implementazione a stack parliamo di una condizione sufficiente affinché non si verifichi questa condizione.</p>
<h3 id="algoritmo-min">Algoritmo MIN<a hidden class="anchor" aria-hidden="true" href="#algoritmo-min">#</a></h3>
<p>Questo è l&rsquo;algoritmo ottimale, ma utilizza informazioni che non abbiamo già, perché non sappiamo quando i processi accederanno a cosa. Quindi buon algoritmo in teoria (perché utilizza informazioni che non abbiamo ancora nel presente), nessun uso ora.</p>
<p>Però si può dimostrare che questo algo <strong>genera il minor numero di faults</strong>.</p>
<blockquote>
<p>Seleziona come pagina vittima una pagina che non sarà più
acceduta o la pagina che verrà acceduta nel futuro più lontano</p></blockquote>
<p>È un buon algoritmo per utilizzare come paragone di altri algoritmi reali, cioè questi reali quanto bene fanno rispetto a questo algoritmo perfetto!</p>
<ul>
<li>
<p>Slide algoritmo MIN</p>
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled 15.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled 15">
</li>
</ul>
<h3 id="least-frequently-used">Least Frequently used<a hidden class="anchor" aria-hidden="true" href="#least-frequently-used">#</a></h3>
<ul>
<li>
<p>Slide LFU</p>
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled 16.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled 16">
</li>
</ul>
<p>Ma solitamente questo, come FIFO, non è che venga utilizzata.</p>
<p>Vado a considerare il concetto di <strong>frequenza</strong>, definita in questo modo: contatore / tempo di permanenza in memoria.</p>
<h2 id="algoritmo-di-lru">Algoritmo di LRU<a hidden class="anchor" aria-hidden="true" href="#algoritmo-di-lru">#</a></h2>
<p>Per le cache, ci sono algoritmi migliori di LRU, vedere <a href="/notes/content-delivery-networks">Content Delivery Networks</a>.
Ne abbiamo parlato anche in architettura, qui <a href="/notes/paginazione-e-segmentazione">Paginazione e segmentazione</a>.</p>
<blockquote>
<p>seleziona come pagina vittima la pagina che è stata usata meno
recentemente nel passato</p></blockquote>
<p>In pratica provo a stimare l’utilizzo della pagina in base a quanti accessi abbia fatto in passato.</p>
<ul>
<li>
<p>Esempio LRU</p>
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled 17.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled 17">
</li>
</ul>
<h3 id="implementazione-lru">Implementazione LRU<a hidden class="anchor" aria-hidden="true" href="#implementazione-lru">#</a></h3>
<p>Come facciamo a capire quanto spesso è stato utilizzato una pagina? Non possiamo mica aggiungere il numero di accesso a tutte le risoluzioni MMU, deve essere implementato in hardware stesso, in MMU.</p>
<ul>
<li>
<p>Slide implementazione MMU</p>
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled 18.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled 18">
</li>
<li>
<p>Accessi in memoria in più</p>
</li>
<li>
<p>La MMU dovrebbe tenersi i timestamps e dovrebbe gestire gli overflows</p>
</li>
<li>
<p>O(n) per scandire la tabella di frame, e trovare la pagina</p>
</li>
</ul>
<p>Quindi è molto lenta, ma almeno è realizzabile.</p>
<p><strong>IMPLEMENTAZIONE A STACK</strong></p>
<p>Ossia quando accediamo una pagina, la mettiamo sopra la stack. Ma è brutto perché in hardware dovrei aggiornare 6 puntatori, che non dovrebbe essere cosa da niente, per questo non è utilizzato.</p>
<p>La cosa carina però è che avrei in cima le cose utilizzate in basso quelle meno utilizzate!</p>
<h3 id="implementazione-a-stack">Implementazione a stack<a hidden class="anchor" aria-hidden="true" href="#implementazione-a-stack">#</a></h3>
<ul>
<li>
<p>Slide definizione di algoritmi a stack</p>
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled 19.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled 19">
</li>
</ul>
<p>Si noti che la condizione è molto simile a una sufficiente per risolvere la condizione di belady, ci sta dicendo che in pratica: l’insieme delle pagine mantenute in memoria è contanuto allo stesso algoritmo con più pagine in memoria!</p>
<p>È anche una condizione sufficiente per dire: <strong>avere fage faults in meno, non più</strong>, perché contiene sempre le stesse pagine con una versione a più.</p>
<p>Per dimostrare che FIFO non è a stack, basta un esempio.</p>
<p><strong>ACCENNO DIMOSTRAZIONE LRU È STACK</strong></p>
<p>Si utilizza una dimostrazione costruttiva per induzione (altra tecnica è per assurdo). Questo lo facciamo sul tempo.</p>
<ol>
<li>Passo base: al tempo 0 la stack è vuota, non ci importa quale numero di stack, la memoria resta la stessa.</li>
<li>Supponiamo al tempo t-1 che la condizione di stack sia verificata.
Ora abbiamo due casi: non c’è abbstanza spazio, o c’è ancora spazio:
<ol>
<li>Se c’è abbastanza spazio, allora non ci cambia per un m numero di frame maggiore</li>
<li>Se non c’è abbastanza spazio, quello minore deve cambiare, dovrà scegliere uno a caso, scegliendone uno a caso allora l’insieme delle pagine è ancora incluso. Al passo successivo ancora, l’elemento che esce dovrà essere lo stesso, o comunque offsettato non di tanto credo, in pratica quello grosso elimini cose solamente eliminate già da quello piccolo!. E questa cosa con LRU l’abbiamo. Non è che ho formalizzato molto bene questa parte.</li>
</ol>
</li>
</ol>
<h3 id="additional-reference-bit">Additional reference bit<a hidden class="anchor" aria-hidden="true" href="#additional-reference-bit">#</a></h3>
<p>Andiamo ora a parlare di <strong>approssimazione di LRU</strong> perché col discorso a stack non è proprio fattibile con l’hardware attuale.</p>
<p>Quando accedo a una pagina, il bit viene messo a 1, inizialmente sono tutte 0, meglio descritta nella slide:</p>
<ul>
<li>
<p>Slide descrizione reference bit</p>
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled 20.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled 20">
</li>
</ul>
<p>basta fare shift e assegnamento! Quindi easy! Andiamo a prendere la pagina con valore minore poi.</p>
<p><strong>VARIANTE: SECOND CHANGE ALGO</strong></p>
<ul>
<li>
<p>Slide second change (storia = 1)</p>
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled 21.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled 21">
</li>
</ul>
<p>Vengono gestiti come una lista circolare, per questo motivo è anche detto <strong>algoritmo dell’orologio</strong>.</p>
<p>In pratica scandisco la lista con questo algo:</p>
<ol>
<li>Bit a 1? Allora lo metto a 0 e vado avanti</li>
<li>Bit a 0? Allora tolgo questa! E sostituisco.</li>
</ol>
<ul>
<li>
<p>Esempio di second change algo</p>
<p>Non si capisce sto esempio lol</p>
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled 22.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled 22">
</li>
</ul>
<h2 id="allocazione-della-memoria-virtuale">Allocazione della memoria virtuale<a hidden class="anchor" aria-hidden="true" href="#allocazione-della-memoria-virtuale">#</a></h2>
<h3 id="tipologie-di-allocamento-3">Tipologie di allocamento (3)<a hidden class="anchor" aria-hidden="true" href="#tipologie-di-allocamento-3">#</a></h3>
<ul>
<li>
<p>Slide allocazione</p>
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled 23.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled 23">
</li>
</ul>
<ol>
<li>Algo di allocazione: risponde alla domanda su come allocare i frame per un certo processo.</li>
<li>Allocazione globale: permetto di allocare l&rsquo;intero programma (male → thrashing)</li>
<li>Allocazione locale: il processo è a conoscenza dei propri frame, ma non è molto flessibile, di solito fanno meglio quelli globali,</li>
</ol>
<p>Praticamente fin’ora abbiamo parlato di metodi per sostituire delle pagine in caso di page faults, ma non abbiamo mai definito in che modo decidiamo quanti frames allocare a un processo, nel momento del bisogno. Allocazione globale e locale sono dei modi per fare questa decisione.</p>
<ul>
<li>Locale → implica che posso sostituire solamente i frames del mio processo, in queto senso sono poco flessibile, se qualcun’altro ha più roba che posso sottrarre converrebbe fare quello.</li>
<li>Globale → implica che posso sostituire i processi di chissivoglia.</li>
</ul>
<p>Normalmente si utilizzano anche delle euristiche per sapere quante pagine allocare: per esempio se ho troppi page faults, probabilmente il processo ha bisogno di più memoria, se ne ho troppi pochi probabilmente il processo ne ha troppa, e si può allocare ad altri.</p>
<h3 id="thrashing">Thrashing<a hidden class="anchor" aria-hidden="true" href="#thrashing">#</a></h3>
<blockquote>
<p>un processo (o un sistema) si dice che è in trashing quando spende
più tempo per la paginazione che per l&rsquo;esecuzione</p></blockquote>
<p>Questo è quindi un effetto molto brutto! Va a finire che l&rsquo;intero sistema si impalli. <strong>rubano le pagine a vicenda,</strong> l&rsquo;effetto più classico è questo:  non riescono a tenere in memoria i frame utili a breve termine (perchè altri processi chiedono frame liberi) e quindi generano page fault ogni pochi passi di avanzamento) In pratica quasi ogni operazione è un page fault.</p>
<p>Per evitare questo, massimo 2x memoria virtuale, altrimenti potrei andare in thrashing.</p>
<ul>
<li>
<p>Esempio di effetto di thrashing</p>
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled 24.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled 24">
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled 25.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled 25">
</li>
</ul>
<p>L&rsquo;efficienza cade di interi ordini di grandezza!</p>
<h3 id="working-set">Working set<a hidden class="anchor" aria-hidden="true" href="#working-set">#</a></h3>
<blockquote>
<p>si definisce working set di finestra Δ l&rsquo;insieme delle pagine accedute
nei più recenti Δ riferimenti</p></blockquote>
<p>Questo è utile per <strong>stimare se il sistema è in thrashing</strong>. Questo è utile per avere un concetto di località delle pagine, vogliamo avere una stima delle pagine attualmente utili, e utilizziamo questo per andare a decidere se una pagina è ancora utile o meno.</p>
<ul>
<li>
<p>Slide valutazione working set per thrashing</p>
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled 26.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled 26">
</li>
</ul>
<p>Se la somma di tutti i pages di cui ho bisogno nel breve è maggiore di più pagine presenti in RAM, allora sicuramente quando questa si riattiva crea page faults! Ecco il criterio per i page faults.</p>
<ul>
<li>
<p>Scelta del delta</p>
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled 27.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled 27">
</li>
</ul>
<p><em>SOLUZIONE PROPOSTA</em></p>
<p>Basta <strong>sospendere</strong> alcuni processi, in modo che alcuni terminino senza andare in troppi page faults, in modo che la somma di tutti working set stiano ancora dentro.</p>
<ul>
<li>
<p>Slide della soluzione</p>
  <img src="/images/notes/image/universita/ex-notion/Memoria virtuale/Untitled 28.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria virtuale/Untitled 28"></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/sistemi-operativi/">Sistemi-Operativi</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Memoria virtuale on x"
            href="https://x.com/intent/tweet/?text=Memoria%20virtuale&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fmemoria-virtuale%2f&amp;hashtags=sistemi-operativi">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Memoria virtuale on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fmemoria-virtuale%2f&amp;title=Memoria%20virtuale&amp;summary=Memoria%20virtuale&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2fmemoria-virtuale%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Memoria virtuale on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2fmemoria-virtuale%2f&title=Memoria%20virtuale">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Memoria virtuale on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2fmemoria-virtuale%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Memoria virtuale on whatsapp"
            href="https://api.whatsapp.com/send?text=Memoria%20virtuale%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2fmemoria-virtuale%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Memoria virtuale on telegram"
            href="https://telegram.me/share/url?text=Memoria%20virtuale&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fmemoria-virtuale%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Memoria virtuale on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Memoria%20virtuale&u=https%3a%2f%2fflecart.github.io%2fnotes%2fmemoria-virtuale%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
