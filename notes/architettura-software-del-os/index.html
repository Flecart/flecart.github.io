<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Architettura software del OS | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="sistemi-operativi, ☁cloud-computing">
<meta name="description" content="A seconda dell&rsquo;utilizzatore l’OS può essere molte cose, come solamente l’interfaccia se sei un programmatore, servizi (se sei un utente, ma gran parte dei servizi sono astratti e l&rsquo;utente ne può anche essere a non-conoscenza).
Ma se sei un programmatore OS ti interessa capire le componenti principali dell’OS

Slide componenti OS alto livello


Introduzione sui componenti (salto)
Questa parte la salto perché è una descrizione molto generale di cosa si occupa L’os verso drivers, processi, filesystem I/O, quindi non è molto importante">
<meta name="author" content="Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="https://flecart.github.io/notes/architettura-software-del-os/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/architettura-software-del-os/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>
<script type="text/javascript" async
src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>






      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-WW6NN2QGKF');
        }
      </script><meta property="og:url" content="https://flecart.github.io/notes/architettura-software-del-os/">
  <meta property="og:site_name" content="X. Angelo Huang&#39;s Blog">
  <meta property="og:title" content="Architettura software del OS">
  <meta property="og:description" content="A seconda dell’utilizzatore l’OS può essere molte cose, come solamente l’interfaccia se sei un programmatore, servizi (se sei un utente, ma gran parte dei servizi sono astratti e l’utente ne può anche essere a non-conoscenza).
Ma se sei un programmatore OS ti interessa capire le componenti principali dell’OS
Slide componenti OS alto livello Introduzione sui componenti (salto) Questa parte la salto perché è una descrizione molto generale di cosa si occupa L’os verso drivers, processi, filesystem I/O, quindi non è molto importante">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="notes">
    <meta property="article:tag" content="Sistemi-Operativi">
    <meta property="article:tag" content="☁Cloud-Computing">
      <meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:title" content="Architettura software del OS">
<meta name="twitter:description" content="A seconda dell&rsquo;utilizzatore l’OS può essere molte cose, come solamente l’interfaccia se sei un programmatore, servizi (se sei un utente, ma gran parte dei servizi sono astratti e l&rsquo;utente ne può anche essere a non-conoscenza).
Ma se sei un programmatore OS ti interessa capire le componenti principali dell’OS

Slide componenti OS alto livello


Introduzione sui componenti (salto)
Questa parte la salto perché è una descrizione molto generale di cosa si occupa L’os verso drivers, processi, filesystem I/O, quindi non è molto importante">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Architettura software del OS",
      "item": "https://flecart.github.io/notes/architettura-software-del-os/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Architettura software del OS",
  "name": "Architettura software del OS",
  "description": "A seconda dell\u0026rsquo;utilizzatore l’OS può essere molte cose, come solamente l’interfaccia se sei un programmatore, servizi (se sei un utente, ma gran parte dei servizi sono astratti e l\u0026rsquo;utente ne può anche essere a non-conoscenza).\nMa se sei un programmatore OS ti interessa capire le componenti principali dell’OS\nSlide componenti OS alto livello Introduzione sui componenti (salto) Questa parte la salto perché è una descrizione molto generale di cosa si occupa L’os verso drivers, processi, filesystem I/O, quindi non è molto importante\n",
  "keywords": [
    "sistemi-operativi", "☁cloud-computing"
  ],
  "articleBody": "A seconda dell’utilizzatore l’OS può essere molte cose, come solamente l’interfaccia se sei un programmatore, servizi (se sei un utente, ma gran parte dei servizi sono astratti e l’utente ne può anche essere a non-conoscenza).\nMa se sei un programmatore OS ti interessa capire le componenti principali dell’OS\nSlide componenti OS alto livello Introduzione sui componenti (salto) Questa parte la salto perché è una descrizione molto generale di cosa si occupa L’os verso drivers, processi, filesystem I/O, quindi non è molto importante\nGestione dei processi All’interno del SO, il processo è rappresentato come un processo control block, che in linux è in sched, parte dello scheduler dei processi. Questo è importante perché per esempio per fare una fork, non faccio altro che duplicare questa struttura e settare bene i figli e genitori.\nQuesti sono solitamente messi un un process table o forse una lista per tenerne traccia.\nSlide\nnel parliamo in Processi e thread.\nGestione memoria principale e secondaria Principale\nÈ un array temporaneo(nel senso che non è mantenuto quando viene spento il PC.), indicizzato singolarmente a differenza del secondario, che è indicizzato a blocchi,\nUna parte importante di questa parte è la gestione della memoria virtuale. Come allocare pagine di memoria, deallocarle e simili, ne parliamo in Paginazione e segmentazione\nSecondaria\nLa cosa buona è che questa memoria è permanente, efficienza (ordinare le richieste per non andare qui e lì quando si legge! minimizare tempi per seek) e partizionamento e reliability dei dischi sono problemi che interessano questa parte. Abbiamo parlato di raid in Memoria. e di nuovo in Devices OS.\nSlide\nI/O e filesystem Principalmente per IO servono driver per interagire con specifici hardware, e un sistema di comunicazione che spesso sono buffer e cache.\nSlides\nEsiste un file system virtuale che mappa a tutto (quindi alcune cose non esistono realmente sul disco, potrebbe essere una astrazione utilizzata per esempio per comunicare con i devices.\nCi sono molti filesystem, che però posso gestire in modo differente la forma che hanno sul disco, Ed è per questo che possiamo dire che esistono dei filesystem diversi.\nAnche i processi sono files, la cosa figa di questa astrazioen è che posso utilizzare gli stessi sistemi di protezione file per processi.\nStruttura dei sistemi Obiettivi di design dei SO (4) Slide obiettivi nella struttura dei sistemi (4)\nEfficienza\nModularità\nMantenibilità\nEspansibilità\nStruttura del kernel Slide riassuntiva\nIl kernel è un unico processo, parte da un main che parte da un initialize in cui raccoglie tutte le risorse del sistema, fa partire tutti i device drivers e crea il PCB del primo processo, anche chiamato init, messo poi nella queue dello scheduler come spiegato in Scheduler. Fatta una volta non è mai più eseguito quel codice di init.\nLo stato kernel è la parte a sinistra dell’immagine, quella parte blu, tutto il giallo, a destra è lo stato user.\nScheduler scegliere il processo da eseguire nello user space Il controllo è passato al processo user, che può fare traps (come fork) o fare I/O, a quel punto è rimesso a codice kernel. Tipologie di struttura OS (2) Solitamente i sistemi sono costruiti in due modi, sistemi semplici senza struttura, che praticamente c’è una prima versione, e poi viene ammassato roba senza struttura generale, fatti quando servono. Solitamente sono insieme di procedure che si chiamano fra di loro, e ben presto sono andate fuori dal loro ambito di interesse diciamo (fuori dal loro scope)\nEsempi di OS semplici:\nUn esempio è free-dos che è quanto installato su un computer senza sistema operativo.\nIn modo simile è MS-DOS, che è stato fatto per i primi personal computer, che non avevano un sistema kernel a livello hardware (non era quindi possibile fare queste protezioni).. In generale in questo ambiente un programma aveva accesso all’intera memoria, e poteva mandare in crash tutto.\nStruttura Free-DOS\nUNIX, è diviso diviso in due parti in kernel e programmi di sistemi, molto semplice, un kernel monolitico, un unico eseguibile, anche questo fu all’epoca limitato enormemente dal suo hardware, e una serie di programmi di sistema.\nDato che c’è una separazione, l’utente è separato dall’interfaccia dal codice kernel. Ma comunque il codice kernel resta vulnerabile, e potrebbe essere modificato e quindi attaccato, o cumunque vulnerabile a bug, anche colposi, distruttivi.\nStruttura UNIX\nStratificazione OS:\nLa struttura a stati è più affidabile dell’altra e rende più facile la programmazione di tale sistema, utili, la logica è la stessa presentata in Architettura e livelli 1, 2, per la divisione a stack del sistema e dei vantaggi che si hanno con questo tipo di architettura.\nEsemplificazione struttura a strati\nStrutture proposte classiche (non fatte, non importanti)\nQuesti sono rimasti accademici\nMa nella pratica questi strati sono rimasti solamente a livello accademico, perché crea overhead anche se si guadagnerebbe in manutentibilità e estensibilità e gestione, quindi molto meno efficiente, inoltre non erano ben chiare le API fra strati. Oggi c’è una forma intermedia (non c’è esattamente la gestione a strati come abbiamo per Web, ma abbiamo una divisione per componenti e responsabilità delle componenti).\nPolitiche e meccanismi La suddifivisione politiche e meccanismi è un pattern di software engineering che lo rende molto comodo da gestire.\nInvece che una gestione a strati come per le reti, abbiamo una gestione di politiche e meccanismi ossia abbiamo qualcosa che decide cosa andare a fare e qualcosa che gestisce il come farla.\nEG. un certo modo di memoria allocata per fare qualcosa, quindi indirizzare il sistema verso qualcosa, e MMU che attualmente implementa la decisione politica.\nEsempio Microkernel o MINIX:\nIl kernel è visto come il meccanismo quindi le parti di gestione e politica sono fuori dal kernel. Questo rende la struttura del SO molto mantenibile ed estendibile.\nSlide\nEsempio Mac OS ≤ 9 / Windows 9x:\nPolitiche e meccanismi sono messi tutti nel kernel, perché così imponevo un feeling unico al look and feel suo (obbligato tutti ad avere questi elementi grafici). Questo è un problema praticamente di mercato.\nQuesto era brutto perché la grafica può mandare in crash tutto il sistema. Anche se i nuovi sistemi non dovrebbero avere questo problema.\nCategorizzazione dei Kernel Monolitici Il kernel è un unico programma. Si possono creare moduli che poi vengono caricati. Il problema principale di questo tipo di kernel è che se un modulo bugga crolla l’intero sistema. Un vantaggio è che è molto efficiente perché non deve passare ad astrazioni come per lo stack, basta fare una chiamata di funzione, tanto siamo nello stesso programma. Ed è altamente modularizzabile per poter attaccare nuove funzionalità.\nIn breve:\nVantaggi:\nEfficienza Modularità e mantenibilità (non devo ricompilare tutto, basta runtime). Svantaggio:\nUn modulo può mandare in crash tutto, perché è eseguito nello stesso spazio del kernel.\nSlide\nEsempi sono Linux o BSD.\nMicrokernel L’obiettivo del microkernle è isolare solamente le funzionalità essenziali e tenere solo quelli, tutto il resto interagisce con esso con system call (un esempio è il filesystem che potrebbe essere fuori dal kernel, e avrebbe syscall leggermente diverse rispetto a quelle di linux, per aprire un file allora si chiederebbe a questo processo in user space, che poi fa altre richeste per kernel space)\nBisogna fare un messaggio, la syscall diventano Send! Che sarebbe unico modo per raggiungere il processo che offre il servizio che mi serve.\nVantaggi:\nAltissima modularità e mantenibilità del sistema e semplice da realizzare Assenza di danni di sistema, perché moduli e kernel sono eseguiti in spazio differente. Sicuro e affidabile per la divisione (non ho propagazione di errori e guasti) Molto portabile, che ho solo il microkernel. Svantaggio:\nFortemente Inefficienza rispetto al monolitico, che devo fare message passing e comunicazione.\nSlide di comparazione\nKernel Ibridi Sono dei microkernel modificati, con qualcosa in più forse (aziende per pubblicizzarsi dicevano di avere microkernel, ma con un ibridone, mettendo le cose inefficienti del microkernel dentro il kernel).\nEsempio windows\nCi sono diversi server, che fanno parte di un sottosistema d’ambiente che è in grado di emulare certe cose (sono nascoste le syscall reali del sistema così).\nIl codice per un certo ambiente funziona anche nel sottosistema, un esempio è un WSL.\nLa parte grafica importante per fare i videogiochi, è dentro il kernel, questo ad esempio per MACOS, perché volevano imporre la grafica simile\nMacchine virtuali Vedi Virtual Machines.\n",
  "wordCount" : "1372",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/architettura-software-del-os/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Architettura software del OS
    </h1>
    <div class="post-meta">7 min&nbsp;·&nbsp;Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduzione-sui-componenti-salto" aria-label="Introduzione sui componenti (salto)">Introduzione sui componenti (salto)</a><ul>
                        
                <li>
                    <a href="#gestione-dei-processi" aria-label="Gestione dei processi">Gestione dei processi</a></li>
                <li>
                    <a href="#gestione-memoria-principale-e-secondaria" aria-label="Gestione memoria principale e secondaria">Gestione memoria principale e secondaria</a></li>
                <li>
                    <a href="#io-e-filesystem" aria-label="I/O e filesystem">I/O e filesystem</a></li></ul>
                </li>
                <li>
                    <a href="#struttura-dei-sistemi" aria-label="Struttura dei sistemi">Struttura dei sistemi</a><ul>
                        
                <li>
                    <a href="#obiettivi-di-design-dei-so-4" aria-label="Obiettivi di design dei SO (4)">Obiettivi di design dei SO (4)</a></li>
                <li>
                    <a href="#struttura-del-kernel" aria-label="Struttura del kernel">Struttura del kernel</a></li>
                <li>
                    <a href="#tipologie-di-struttura-os-2" aria-label="Tipologie di struttura OS (2)">Tipologie di struttura OS (2)</a></li>
                <li>
                    <a href="#politiche-e-meccanismi" aria-label="Politiche e meccanismi">Politiche e meccanismi</a></li>
                <li>
                    <a href="#categorizzazione-dei-kernel" aria-label="Categorizzazione dei Kernel">Categorizzazione dei Kernel</a><ul>
                        
                <li>
                    <a href="#monolitici" aria-label="Monolitici">Monolitici</a></li>
                <li>
                    <a href="#microkernel" aria-label="Microkernel">Microkernel</a></li>
                <li>
                    <a href="#kernel-ibridi" aria-label="Kernel Ibridi">Kernel Ibridi</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#macchine-virtuali" aria-label="Macchine virtuali">Macchine virtuali</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>A seconda dell&rsquo;utilizzatore l’OS può essere molte cose, come solamente l’interfaccia se sei un programmatore, servizi (se sei un utente, ma gran parte dei servizi sono astratti e l&rsquo;utente ne può anche essere a non-conoscenza).</p>
<p>Ma se sei un programmatore OS ti interessa capire le componenti principali dell’OS</p>
<ul>
<li>Slide componenti OS alto livello
<img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled"></li>
</ul>
<h2 id="introduzione-sui-componenti-salto">Introduzione sui componenti (salto)<a hidden class="anchor" aria-hidden="true" href="#introduzione-sui-componenti-salto">#</a></h2>
<p>Questa parte la salto perché è una descrizione molto generale di cosa si occupa L’os verso drivers, processi, filesystem I/O, quindi non è molto importante</p>
<h3 id="gestione-dei-processi">Gestione dei processi<a hidden class="anchor" aria-hidden="true" href="#gestione-dei-processi">#</a></h3>
<p>All&rsquo;interno del SO, il processo è rappresentato come un <strong>processo control block</strong>, che in linux è in <strong>sched</strong>, parte dello scheduler dei processi. Questo è importante perché per esempio per fare una fork, non faccio altro che duplicare questa struttura e settare bene i figli e genitori.</p>
<p>Questi sono solitamente messi un un <strong>process table</strong> o forse una lista per tenerne traccia.</p>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 1.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 1">
</li>
</ul>
<p>nel parliamo in <a href="/notes/processi-e-thread">Processi e thread</a>.</p>
<h3 id="gestione-memoria-principale-e-secondaria">Gestione memoria principale e secondaria<a hidden class="anchor" aria-hidden="true" href="#gestione-memoria-principale-e-secondaria">#</a></h3>
<p><strong>Principale</strong></p>
<p>È un array temporaneo(nel senso che non è mantenuto quando viene spento il PC.), indicizzato singolarmente a differenza del secondario, che è indicizzato a blocchi,</p>
<p>Una parte importante di questa parte è la gestione della memoria virtuale. Come allocare pagine di memoria, deallocarle e simili, ne parliamo in <a href="/notes/paginazione-e-segmentazione">Paginazione e segmentazione</a></p>
<p><strong>Secondaria</strong></p>
<p>La cosa buona è che questa memoria è permanente, efficienza (ordinare le richieste per non andare qui e lì quando si legge! <strong>minimizare tempi per seek</strong>) e partizionamento e reliability dei dischi sono problemi che interessano questa parte. Abbiamo parlato di raid in <a href="/notes/memoria">Memoria</a>. e di nuovo in <a href="/notes/devices-os">Devices OS</a>.</p>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 2.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 2">
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 3.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 3">
</li>
</ul>
<h3 id="io-e-filesystem">I/O e filesystem<a hidden class="anchor" aria-hidden="true" href="#io-e-filesystem">#</a></h3>
<p>Principalmente per IO servono driver per interagire con specifici hardware, e un sistema di comunicazione che spesso sono buffer e cache.</p>
<ul>
<li>
<p>Slides</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 4.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 4">
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 5.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 5">
</li>
</ul>
<p>Esiste un <strong>file system virtuale</strong> che mappa a tutto (quindi alcune cose non esistono realmente sul disco, potrebbe essere una astrazione utilizzata per esempio per comunicare con i devices.</p>
<p>Ci sono molti filesystem, che però posso gestire in modo differente la forma che hanno sul disco, Ed è per questo che possiamo dire che esistono dei filesystem diversi.</p>
<p>Anche i processi sono files, la cosa figa di questa astrazioen è che posso utilizzare gli stessi sistemi di protezione file per processi.</p>
<h2 id="struttura-dei-sistemi">Struttura dei sistemi<a hidden class="anchor" aria-hidden="true" href="#struttura-dei-sistemi">#</a></h2>
<h3 id="obiettivi-di-design-dei-so-4">Obiettivi di design dei SO (4)<a hidden class="anchor" aria-hidden="true" href="#obiettivi-di-design-dei-so-4">#</a></h3>
<ul>
<li>
<p>Slide obiettivi nella struttura dei sistemi (4)</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 6.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 6">
</li>
<li>
<p>Efficienza</p>
</li>
<li>
<p>Modularità</p>
</li>
<li>
<p>Mantenibilità</p>
</li>
<li>
<p>Espansibilità</p>
</li>
</ul>
<h3 id="struttura-del-kernel">Struttura del kernel<a hidden class="anchor" aria-hidden="true" href="#struttura-del-kernel">#</a></h3>
<ul>
<li>
<p>Slide riassuntiva</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 7.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 7">
</li>
</ul>
<p>Il kernel è un unico processo, parte da un main che parte da un initialize in cui raccoglie tutte le risorse del sistema, fa partire tutti i device drivers e crea il PCB del primo processo, anche chiamato <strong>init</strong>, messo poi nella queue dello scheduler come spiegato in <a href="/notes/scheduler">Scheduler</a>. Fatta una volta non è mai più eseguito quel codice di init.</p>
<p>Lo stato kernel è la parte a sinistra dell’immagine, quella parte blu, tutto il giallo, a destra è lo stato user.</p>
<ol>
<li>Scheduler scegliere il processo da eseguire nello user space</li>
<li>Il controllo è passato al processo user, che può fare traps (come fork) o fare I/O, a quel punto è rimesso a codice kernel.</li>
</ol>
<h3 id="tipologie-di-struttura-os-2">Tipologie di struttura OS (2)<a hidden class="anchor" aria-hidden="true" href="#tipologie-di-struttura-os-2">#</a></h3>
<p>Solitamente i sistemi sono costruiti in due modi, sistemi <strong>semplici senza struttura</strong>, che praticamente c&rsquo;è una prima versione, e poi viene ammassato roba senza struttura generale, fatti quando servono. Solitamente sono insieme di procedure che si chiamano fra di loro, e ben presto sono andate fuori dal loro ambito di interesse diciamo (fuori dal loro scope)</p>
<p><strong>Esempi di OS semplici:</strong></p>
<p>Un esempio è <strong>free-dos</strong> che è quanto installato su un computer senza sistema operativo.</p>
<p>In modo simile è MS-DOS, che è stato fatto per i primi personal computer, che non avevano un sistema kernel a livello hardware (non era quindi possibile fare queste protezioni).. In generale in questo ambiente un programma aveva accesso all&rsquo;intera memoria, e poteva mandare in crash tutto.</p>
<ul>
<li>
<p>Struttura Free-DOS</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 8.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 8">
</li>
</ul>
<p>UNIX, è diviso diviso in due parti in kernel e programmi di sistemi, molto semplice, un kernel monolitico, un unico eseguibile, anche questo fu all’epoca limitato enormemente dal suo hardware, e una serie di programmi di sistema.</p>
<p>Dato che c&rsquo;è una separazione, l’utente è separato dall’interfaccia dal codice kernel. Ma comunque il codice kernel resta vulnerabile, e potrebbe essere modificato e quindi attaccato, o cumunque vulnerabile a bug, anche colposi, distruttivi.</p>
<ul>
<li>
<p>Struttura UNIX</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 9.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 9">
</li>
</ul>
<p><strong>Stratificazione OS:</strong></p>
<p>La <strong>struttura a stati</strong> è più affidabile dell&rsquo;altra e rende più facile la programmazione di tale sistema, utili, la logica è la stessa presentata in <a href="/notes/architettura-e-livelli-1,-2">Architettura e livelli 1, 2</a>, per la divisione a stack del sistema e dei vantaggi che si hanno con questo tipo di architettura.</p>
<ul>
<li>
<p>Esemplificazione struttura a strati</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 10.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 10">
</li>
<li>
<p>Strutture proposte classiche (non fatte, non importanti)</p>
<p>Questi sono <strong>rimasti accademici</strong></p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 11.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 11">
</li>
</ul>
<p>Ma nella pratica questi strati sono rimasti solamente a livello accademico, perché <strong>crea overhead</strong> anche se si guadagnerebbe in manutentibilità e estensibilità e gestione, quindi molto meno efficiente, inoltre non erano ben chiare le API fra strati. Oggi c&rsquo;è una forma intermedia (non c&rsquo;è esattamente la gestione a strati come abbiamo per Web, ma abbiamo una divisione per componenti e responsabilità delle componenti).</p>
<h3 id="politiche-e-meccanismi">Politiche e meccanismi<a hidden class="anchor" aria-hidden="true" href="#politiche-e-meccanismi">#</a></h3>
<p>La suddifivisione politiche e meccanismi è un pattern di software engineering che lo rende molto comodo da gestire.</p>
<p>Invece che una gestione a strati come per le reti, abbiamo una gestione di <strong>politiche e meccanismi</strong> ossia abbiamo qualcosa che decide cosa andare a fare e qualcosa che gestisce il come farla.</p>
<p>EG. un certo modo di memoria allocata per fare qualcosa, quindi indirizzare il sistema verso qualcosa, e MMU che attualmente implementa la decisione politica.</p>
<p><strong>Esempio Microkernel o MINIX:</strong></p>
<p>Il kernel è visto come il meccanismo quindi le parti di gestione e politica sono fuori dal kernel. Questo rende la struttura del SO molto mantenibile ed estendibile.</p>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 12.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 12">
</li>
</ul>
<p><strong>Esempio Mac OS ≤ 9 / Windows 9x:</strong></p>
<p>Politiche e meccanismi sono messi tutti nel kernel, perché così imponevo un feeling unico al look and feel suo (obbligato tutti ad avere questi elementi grafici). Questo è un problema praticamente di mercato.</p>
<p>Questo era brutto perché la grafica può mandare in crash tutto il sistema. Anche se i nuovi sistemi non dovrebbero avere questo problema.</p>
<h3 id="categorizzazione-dei-kernel">Categorizzazione dei Kernel<a hidden class="anchor" aria-hidden="true" href="#categorizzazione-dei-kernel">#</a></h3>
<h4 id="monolitici">Monolitici<a hidden class="anchor" aria-hidden="true" href="#monolitici">#</a></h4>
<p>Il kernel è un unico programma. Si possono creare moduli che poi vengono caricati. Il problema principale di questo tipo di kernel è che se un modulo bugga crolla l&rsquo;intero sistema. Un vantaggio è che è molto efficiente perché non deve passare ad astrazioni come per lo stack, basta fare una chiamata di funzione, tanto siamo nello stesso programma. Ed è altamente modularizzabile per poter attaccare nuove funzionalità.</p>
<p>In breve:</p>
<p>Vantaggi:</p>
<ul>
<li>Efficienza</li>
<li>Modularità e mantenibilità (non devo ricompilare tutto, basta runtime).</li>
</ul>
<p>Svantaggio:</p>
<ul>
<li>
<p>Un modulo può mandare in crash tutto, perché è eseguito nello stesso spazio del kernel.</p>
</li>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 13.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 13">
</li>
</ul>
<p>Esempi sono Linux o BSD.</p>
<h4 id="microkernel">Microkernel<a hidden class="anchor" aria-hidden="true" href="#microkernel">#</a></h4>
<p>L’obiettivo del microkernle è isolare solamente le funzionalità essenziali e tenere solo quelli, tutto il resto interagisce con esso con system call (un esempio è il filesystem che potrebbe essere fuori dal kernel, e avrebbe syscall leggermente diverse rispetto a quelle di linux, per aprire un file allora si chiederebbe a questo processo in user space, che poi fa altre richeste per kernel space)</p>
<p>Bisogna fare un messaggio, la syscall diventano Send! Che sarebbe unico modo per raggiungere il processo che offre il servizio che mi serve.</p>
<p>Vantaggi:</p>
<ul>
<li>Altissima modularità e mantenibilità del sistema e semplice da realizzare</li>
<li>Assenza di danni di sistema, perché moduli e kernel sono eseguiti in spazio differente.</li>
<li>Sicuro e affidabile per la divisione (non ho propagazione di errori e guasti)</li>
<li>Molto portabile, che ho solo il microkernel.</li>
</ul>
<p>Svantaggio:</p>
<ul>
<li>
<p>Fortemente Inefficienza rispetto al monolitico, che devo fare message passing e comunicazione.</p>
</li>
<li>
<p>Slide di comparazione</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 14.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 14">
</li>
</ul>
<h4 id="kernel-ibridi">Kernel Ibridi<a hidden class="anchor" aria-hidden="true" href="#kernel-ibridi">#</a></h4>
<p>Sono dei microkernel modificati, con qualcosa in più forse (aziende per pubblicizzarsi dicevano di avere microkernel, ma con un ibridone, mettendo le cose inefficienti del microkernel dentro il kernel).</p>
<ul>
<li>
<p>Esempio windows</p>
<p>Ci sono diversi server, che fanno parte di un sottosistema d’ambiente che è in grado di emulare certe cose (sono nascoste le syscall reali del sistema così).</p>
<p>Il codice per un certo ambiente funziona anche nel sottosistema, un esempio è un WSL.</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 15.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 15">
<p>La parte grafica importante per fare i videogiochi, è dentro il kernel, questo ad esempio per MACOS, perché volevano imporre la grafica simile</p>
</li>
</ul>
<h2 id="macchine-virtuali">Macchine virtuali<a hidden class="anchor" aria-hidden="true" href="#macchine-virtuali">#</a></h2>
<p>Vedi <a href="/notes/virtual-machines">Virtual Machines</a>.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/sistemi-operativi/">Sistemi-Operativi</a></li>
      <li><a href="https://flecart.github.io/tags/cloud-computing/">☁Cloud-Computing</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Architettura software del OS on x"
            href="https://x.com/intent/tweet/?text=Architettura%20software%20del%20OS&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-software-del-os%2f&amp;hashtags=sistemi-operativi%2c%e2%98%81cloud-computing">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Architettura software del OS on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-software-del-os%2f&amp;title=Architettura%20software%20del%20OS&amp;summary=Architettura%20software%20del%20OS&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-software-del-os%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Architettura software del OS on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-software-del-os%2f&title=Architettura%20software%20del%20OS">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Architettura software del OS on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-software-del-os%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Architettura software del OS on whatsapp"
            href="https://api.whatsapp.com/send?text=Architettura%20software%20del%20OS%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-software-del-os%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Architettura software del OS on telegram"
            href="https://telegram.me/share/url?text=Architettura%20software%20del%20OS&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-software-del-os%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Architettura software del OS on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Architettura%20software%20del%20OS&u=https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-software-del-os%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
