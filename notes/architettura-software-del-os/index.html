<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Architettura software del OS | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="sistemi-operativi">
<meta name="description" content="A seconda dell&rsquo;utilizzatore lâ€™OS puÃ² essere molte cose, come solamente lâ€™interfaccia se sei un programmatore, servizi (se sei un utente, ma gran parte dei servizi sono astratti e l&rsquo;utente ne puÃ² anche essere a non-conoscenza).
Ma se sei un programmatore OS ti interessa capire le componenti principali dellâ€™OS
Slide componenti OS alto livello Introduzione sui componenti (salto) Questa parte la salto perchÃ© Ã¨ una descrizione molto generale di cosa si occupa Lâ€™os verso drivers, processi, filesystem I/O, quindi non Ã¨ molto importante">
<meta name="author" content="Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="https://flecart.github.io/notes/architettura-software-del-os/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/architettura-software-del-os/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>




<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>
<script type="text/javascript" async
src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>





<script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-WW6NN2QGKF', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Architettura software del OS" />
<meta property="og:description" content="A seconda dell&rsquo;utilizzatore lâ€™OS puÃ² essere molte cose, come solamente lâ€™interfaccia se sei un programmatore, servizi (se sei un utente, ma gran parte dei servizi sono astratti e l&rsquo;utente ne puÃ² anche essere a non-conoscenza).
Ma se sei un programmatore OS ti interessa capire le componenti principali dellâ€™OS
Slide componenti OS alto livello Introduzione sui componenti (salto) Questa parte la salto perchÃ© Ã¨ una descrizione molto generale di cosa si occupa Lâ€™os verso drivers, processi, filesystem I/O, quindi non Ã¨ molto importante" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://flecart.github.io/notes/architettura-software-del-os/" />
<meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png" />
<meta property="article:section" content="notes" />



<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png" />
<meta name="twitter:title" content="Architettura software del OS"/>
<meta name="twitter:description" content="A seconda dell&rsquo;utilizzatore lâ€™OS puÃ² essere molte cose, come solamente lâ€™interfaccia se sei un programmatore, servizi (se sei un utente, ma gran parte dei servizi sono astratti e l&rsquo;utente ne puÃ² anche essere a non-conoscenza).
Ma se sei un programmatore OS ti interessa capire le componenti principali dellâ€™OS
Slide componenti OS alto livello Introduzione sui componenti (salto) Questa parte la salto perchÃ© Ã¨ una descrizione molto generale di cosa si occupa Lâ€™os verso drivers, processi, filesystem I/O, quindi non Ã¨ molto importante"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Architettura software del OS",
      "item": "https://flecart.github.io/notes/architettura-software-del-os/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Architettura software del OS",
  "name": "Architettura software del OS",
  "description": "A seconda dell\u0026rsquo;utilizzatore lâ€™OS puÃ² essere molte cose, come solamente lâ€™interfaccia se sei un programmatore, servizi (se sei un utente, ma gran parte dei servizi sono astratti e l\u0026rsquo;utente ne puÃ² anche essere a non-conoscenza).\nMa se sei un programmatore OS ti interessa capire le componenti principali dellâ€™OS\nSlide componenti OS alto livello Introduzione sui componenti (salto) Questa parte la salto perchÃ© Ã¨ una descrizione molto generale di cosa si occupa Lâ€™os verso drivers, processi, filesystem I/O, quindi non Ã¨ molto importante",
  "keywords": [
    "sistemi-operativi"
  ],
  "articleBody": "A seconda dellâ€™utilizzatore lâ€™OS puÃ² essere molte cose, come solamente lâ€™interfaccia se sei un programmatore, servizi (se sei un utente, ma gran parte dei servizi sono astratti e lâ€™utente ne puÃ² anche essere a non-conoscenza).\nMa se sei un programmatore OS ti interessa capire le componenti principali dellâ€™OS\nSlide componenti OS alto livello Introduzione sui componenti (salto) Questa parte la salto perchÃ© Ã¨ una descrizione molto generale di cosa si occupa Lâ€™os verso drivers, processi, filesystem I/O, quindi non Ã¨ molto importante\nGestione dei processi Allâ€™interno del SO, il processo Ã¨ rappresentato come un processo control block, che in linux Ã¨ in sched, parte dello scheduler dei processi. Questo Ã¨ importante perchÃ© per esempio per fare una fork, non faccio altro che duplicare questa struttura e settare bene i figli e genitori.\nQuesti sono solitamente messi un un process table o forse una lista per tenerne traccia.\nSlide\nnel parliamo in Processi e thread.\nGestione memoria principale e secondaria Principale\nÃˆ un array temporaneo(nel senso che non Ã¨ mantenuto quando viene spento il PC.), indicizzato singolarmente a differenza del secondario, che Ã¨ indicizzato a blocchi,\nUna parte importante di questa parte Ã¨ la gestione della memoria virtuale. Come allocare pagine di memoria, deallocarle e simili, ne parliamo in Paginazione e segmentazione\nSecondaria\nLa cosa buona Ã¨ che questa memoria Ã¨ permanente, efficienza (ordinare le richieste per non andare qui e lÃ¬ quando si legge! minimizare tempi per seek) e partizionamento e reliability dei dischi sono problemi che interessano questa parte. Abbiamo parlato di raid in Memoria. e di nuovo in Devices OS.\nSlide\nI/O e filesystem Principalmente per IO servono driver per interagire con specifici hardware, e un sistema di comunicazione che spesso sono buffer e cache.\nSlides\nEsiste un file system virtuale che mappa a tutto (quindi alcune cose non esistono realmente sul disco, potrebbe essere una astrazione utilizzata per esempio per comunicare con i devices.\nCi sono molti filesystem, che perÃ² posso gestire in modo differente la forma che hanno sul disco, Ed Ã¨ per questo che possiamo dire che esistono dei filesystem diversi.\nAnche i processi sono files, la cosa figa di questa astrazioen Ã¨ che posso utilizzare gli stessi sistemi di protezione file per processi.\nStruttura dei sistemi Obiettivi di design dei SO (4) ðŸŸ¨ Slide obiettivi nella struttura dei sistemi (4)\nEfficienza\nModularitÃ \nMantenibilitÃ \nEspansibilitÃ \nStruttura del kernel ðŸŸ© Slide riassuntiva\nIl kernel Ã¨ un unico processo, parte da un main che parte da un initialize in cui raccoglie tutte le risorse del sistema, fa partire tutti i device drivers e crea il PCB del primo processo, anche chiamato init, messo poi nella queue dello scheduler come spiegato in Scheduler. Fatta una volta non Ã¨ mai piÃ¹ eseguito quel codice di init.\nLo stato kernel Ã¨ la parte a sinistra dellâ€™immagine, quella parte blu, tutto il giallo, a destra Ã¨ lo stato user.\nScheduler scegliere il processo da eseguire nello user space Il controllo Ã¨ passato al processo user, che puÃ² fare traps (come fork) o fare I/O, a quel punto Ã¨ rimesso a codice kernel. Tipologie di struttura OS (2) ðŸŸ¨++ Solitamente i sistemi sono costruiti in due modi, sistemi semplici senza struttura, che praticamente câ€™Ã¨ una prima versione, e poi viene ammassato roba senza struttura generale, fatti quando servono. Solitamente sono insieme di procedure che si chiamano fra di loro, e ben presto sono andate fuori dal loro ambito di interesse diciamo (fuori dal loro scope)\nEsempi di OS semplici:\nUn esempio Ã¨ free-dos che Ã¨ quanto installato su un computer senza sistema operativo.\nIn modo simile Ã¨ MS-DOS, che Ã¨ stato fatto per i primi personal computer, che non avevano un sistema kernel a livello hardware (non era quindi possibile fare queste protezioni).. In generale in questo ambiente un programma aveva accesso allâ€™intera memoria, e poteva mandare in crash tutto.\nStruttura Free-DOS\nUNIX, Ã¨ diviso diviso in due parti in kernel e programmi di sistemi, molto semplice, un kernel monolitico, un unico eseguibile, anche questo fu allâ€™epoca limitato enormemente dal suo hardware, e una serie di programmi di sistema.\nDato che câ€™Ã¨ una separazione, lâ€™utente Ã¨ separato dallâ€™interfaccia dal codice kernel. Ma comunque il codice kernel resta vulnerabile, e potrebbe essere modificato e quindi attaccato, o cumunque vulnerabile a bug, anche colposi, distruttivi.\nStruttura UNIX\nStratificazione OS:\nLa struttura a stati Ã¨ piÃ¹ affidabile dellâ€™altra e rende piÃ¹ facile la programmazione di tale sistema, utili, la logica Ã¨ la stessa presentata in Architettura e livelli 1, 2, per la divisione a stack del sistema e dei vantaggi che si hanno con questo tipo di architettura.\nEsemplificazione struttura a strati\nStrutture proposte classiche (non fatte, non importanti)\nQuesti sono rimasti accademici\nMa nella pratica questi strati sono rimasti solamente a livello accademico, perchÃ© crea overhead anche se si guadagnerebbe in manutentibilitÃ  e estensibilitÃ  e gestione, quindi molto meno efficiente, inoltre non erano ben chiare le API fra strati. Oggi câ€™Ã¨ una forma intermedia (non câ€™Ã¨ esattamente la gestione a strati come abbiamo per Web, ma abbiamo una divisione per componenti e responsabilitÃ  delle componenti).\nPolitiche e meccanismi ðŸŸ© La suddifivisione politiche e meccanismi Ã¨ un pattern di software engineering che lo rende molto comodo da gestire.\nInvece che una gestione a strati come per le reti, abbiamo una gestione di politiche e meccanismi ossia abbiamo qualcosa che decide cosa andare a fare e qualcosa che gestisce il come farla.\nEG. un certo modo di memoria allocata per fare qualcosa, quindi indirizzare il sistema verso qualcosa, e MMU che attualmente implementa la decisione politica.\nEsempio Microkernel o MINIX:\nIl kernel Ã¨ visto come il meccanismo quindi le parti di gestione e politica sono fuori dal kernel. Questo rende la struttura del SO molto mantenibile ed estendibile.\nSlide\nEsempio Mac OS â‰¤ 9 / Windows 9x:\nPolitiche e meccanismi sono messi tutti nel kernel, perchÃ© cosÃ¬ imponevo un feeling unico al look and feel suo (obbligato tutti ad avere questi elementi grafici). Questo Ã¨ un problema praticamente di mercato.\nQuesto era brutto perchÃ© la grafica puÃ² mandare in crash tutto il sistema. Anche se i nuovi sistemi non dovrebbero avere questo problema.\nCategorizzazione dei Kernel (3) ðŸŸ¨â€” Monolitici:\nIl kernel Ã¨ un unico programma. Si possono creare moduli che poi vengono caricati. Il problema principale di questo tipo di kernel Ã¨ che se un modulo bugga crolla lâ€™intero sistema. Un vantaggio Ã¨ che Ã¨ molto efficiente perchÃ© non deve passare ad astrazioni come per lo stack, basta fare una chiamata di funzione, tanto siamo nello stesso programma. Ed Ã¨ altamente modularizzabile per poter attaccare nuove funzionalitÃ .\nIn breve:\nVantaggi\nEfficienza ModularitÃ  e mantenibilitÃ  (non devo ricompilare tutto, basta runtime). Svantaggio\nUn modulo puÃ² mandare in crash tutto, perchÃ© Ã¨ eseguito nello stesso spazio del kernel.\nSlide\nEsempi sono Linux o BSD.\nMicrokernel:\nLâ€™obiettivo del microkernle Ã¨ isolare solamente le funzionalitÃ  essenziali e tenere solo quelli, tutto il resto interagisce con esso con system call (un esempio Ã¨ il filesystem che potrebbe essere fuori dal kernel, e avrebbe syscall leggermente diverse rispetto a quelle di linux, per aprire un file allora si chiederebbe a questo processo in user space, che poi fa altre richeste per kernel space)\nBisogna fare un messaggio, la syscall diventano Send! Che sarebbe unico modo per raggiungere il processo che offre il servizio che mi serve.\nVantaggi: ðŸŸ¥\nAltissima modularitÃ  e mantenibilitÃ  del sistema e semplice da realizzare Assenza di danni di sistema, perchÃ© moduli e kernel sono eseguiti in spazio differente. Sicuro e affidabile per la divisione (non ho propagazione di errori e guasti) Molto portabile, che ho solo il microkernel. Svantaggio:\nFortemente Inefficienza rispetto al monolitico, che devo fare message passing e comunicazione.\nSlide di comparazione\nKernel Ibridi\nSono dei microkernel modificati, con qualcosa in piÃ¹ forse (aziende per pubblicizzarsi dicevano di avere microkernel, ma con un ibridone, mettendo le cose inefficienti del microkernel dentro il kernel).\nEsempio windows\nCi sono diversi server, che fanno parte di un sottosistema dâ€™ambiente che Ã¨ in grado di emulare certe cose (sono nascoste le syscall reali del sistema cosÃ¬).\nIl codice per un certo ambiente funziona anche nel sottosistema, un esempio Ã¨ un WSL.\nLa parte grafica importante per fare i videogiochi, Ã¨ dentro il kernel, questo ad esempio per MACOS, perchÃ© volevano imporre la grafica simile\nMacchine virtuali Virtualization allows a single computer to host multiple virtual machines, each poten- tially running a completely different operating system.\nÃˆ virtuale nel senso che la macchina virtuale ha la stessa percezione della realtÃ  di una macchina reale. Qualcosa che non Ã¨ la realtÃ  ma appare molto simile ad essa.\nStoricamente parlando le macchine virtuali erano un primo approccio al multitasking.\nLâ€™idea principale Ã¨ creare un sistema che possa apparire al sistema operativo come hardware, in questo modo posso utilizzare un programma per emulare un altro sistema operativo. Ãˆ hypervisor, VMM (virtual machine monitor).\nOvviamente ho uno fortissimo svantaggio in velocitÃ , perchÃ© la simulazione software Ã¨ molto meno efficiente della simulazione hardware. Un collegamento carino Ã¨ con strange loops, una macchina che sia abbastanza espressiva da poter emulare sÃ© stesso.\nAnalisi vantaggi svantaggi ðŸŸ¨ Slide\nPosso avere sistemi operativi differenti sulla stessa macchina o SO, quindi posso sperimentarli senza installarli veramente.\nPosso simulare architetture differenti, e quindi supporre di avere istruzioni differenti di architettura altra!\nSO monotask in sistemi multitask???\nMaggiore sicurezza a bug software, Ã¨ efficienza energetica\nSvantaggi:\nfortemente inefficiente Difficile condividere risorse fra una macchina virtuale o allâ€™altra. Livello processo o sistema ðŸŸ© Le macchine virtuali di cui abbiamo parlato ora virtualizzano solamente lâ€™hardware, cioÃ¨ fa finta di avere un sistema hardware???\nMentre altre macchine virtuali provano a virtualizzare a livello di ABI (application binary interface) (che Ã¨ livello di processo).\nMacchina virtuale a livello di processo (process VM): permette ad un programma di essere eseguito allo stesso modo su qualsiasi piattaforma. Viene eseguita come una normale applicazione allâ€™interno di un SO ospite e supporta un singolo processo. Il suo scopo Ã¨ fornire un ambiente indipendente dalla piattaforma hardware e dal SO ospite. Vengono virtualizzati sia lâ€™hardware che il sistema operativo. Macchina virtuale a livello di sistema (system VM): permette lâ€™esecuzione di un completo SO, anche con un ISA diverso da quello della macchina reale. Viene virtualizzato esclusivamente e completamente lâ€™hardware Differenza type 1 and 2 hypervisors\ntype 1 hypervisor and a type 2 hypervisor is that a type 2 makes uses of a host operating system and its file system to create processes, store files, and so on. A type 1 hypervisor has no underlying support and must perform all these functions itself (it runs on the bare metal, come se fosse lui stesso un sistema operativo, Ã¨ infatti un sistema operativo che non fa altro che fare sistemi operativi!)\nQemu ðŸŸ© qemu Ã¨ un traduttore dinamico come se fosse un compilatore fra una architettura in una altra, fatta a runtime (quindi Ã¨ un interprete, tipo 10x piÃ¹ lento rispetto esecuzione normale, ma un ordine di grandezza piÃ¹ veloce rispetto altri emulatori).\nCon qemu posso anche dire al processo emulato di utilizzare il mio stesso kernel, nel caso che condivida lâ€™architettura, questo rende la cosa molto piÃ¹ veloce del normale! e.g. KVM (che Ã¨ il nome dellâ€™Hypervisor per linux). Questo Ã¨ anche una tipologia di type-2-hypervisor perchÃ© attingo al kernel della macchina ospite per fare funzionare piÃ¹ in fretta, e non faccio simulazione sistema totale.\nUtile o per runnare programmi per architettura differente (in questo senso program VM), oppure per emulare un sistema operativo dentro un sistema operativo\nComando per caricare una macchina virtuale con qemu e utilizzare KVM\nsenza vga, non starebbe sullo schermo senza quella flag.\nhda gli specifica il file con cui emulare il disco, k il layout del keyboard\nm Ã¨ la memoria ram\nmonitor Ã¨ per poter mandare interrupt dal terminale in cui ho lanciato il mio comando di emulazione.\nQuando installa prima Ã¨ installato nella RAM disk, e poi viene utilizzato per lâ€™installazione vera e propria.\nXEN ðŸŸ© XEN Ã¨ hypervisor livello 1 (SO che permette di fare altri SO virtuali), e utilizzare paravirtualizzazione (si fanno trap and emulate principalmente) , e utilizza una gestione diversa dei drivers che possiede, ossia il Domain0 possiede tutti i drivers fisici (le interazioni con i device le manda alla macchina 0, perchÃ© per restare un sistema operativo semplice non riesce a gestire sistemi operativi).\nParavirtualizzatione\nIn questo caso il SO virtuale Ã¨ a conoscenza che esiste un hypervisor quindi puÃ² fare delle hypercall per eseguire delle istruzioni sensitive, e in generale Ã¨ un approccio piÃ¹ veloce invece della virtualizzazione totale di cui abbiamo parlato prima.\nEsempio di maggiore efficienza\nPer il type 2 hypervisor il SO installato pensa veramente di stare in una macchina sÃ©, quindi fa cose per minimizzare i seek del disco ma in questo caso non deve fare veramente seek, quindi Ã¨ meno efficiente, facendo una assunzione errata.\nSi utilizzano paravirtualizzazione, ossia devices virtuali piÃ¹ efficienti per questa cosa, ed effettivamente non assumo di stare utilizzando device fisici, ma sono a conoscenza di utilizzare device virtuali, e posso fare ottimizzazioni del caso (che non so quali siano forse per il disco non faccio cose strane per il seek ad esempio).\nIl problema Ã¨ che essendo a conoscenza, dovrei fare il mio SO in modo che sia compatibile con le hyper all offerte dall hypervisor\nParametrizzazione SO ðŸŸ© Essendo libero linux, Ã¨ molto comodo poter cambiare alcuni parametri e poi ricompilare il kernel seguendo quei parametri. Tanto Ã¨ tutto open source, quindi si potrebbe fare. Questo permette al kernel di essere molto portabile.\nUna cosa molto importante da capire Ã¨ che il kernel Ã¨ una cosa diversa della distribuzione, il kernel Ã¨ il primo programma che viene caricato dal bootloader e carica il FS e tutto il resto (quindi le cose iniziali), il secondo sono tutte le utility per il kernel che lo rendono utilizzabile da un utente normale.\nComando runnato per la emulazione kernel/distribuzione\nSlide parametrizzazione ++ portabilitÃ  (che deve runnare per hardware differentI)\nIstruzioni di virtualizzazione ðŸŸ¥ Abbiamo aggiunto delle istruzioni di emulazione come VMX ON, VMX OFF, VMLAUNCH, VMRETURN in cui il processore sa di stare emulando, e quindi Ã¨ piÃ¹ veloce perchÃ© esegue lâ€™istruzione in altro modo, forse con istruzione nativa. Pagina wiki\nfa pensare di essere in kernel mode, ma non Ã¨ in kernel mode, Ã¨ come se stesse in un livello di priviliegio intermedio.\nVMLAUNCH\nQueste sono quelle principali istruzioni che permettono la virtualizzazioen a livello software, il fatto che rende lâ€™esecuzione molto piÃ¹ veloce, quindi invece di simulare tutto sopra il sistema operativo attuale (e syscalls attuali) posso accedere ad istruzioni hardware molto piÃ¹ veloci.\nMemoria Virtuale (non fare) Câ€™Ã¨ una MMU del sistema operativo che mappa alla VM fisica, che si deve basare allâ€™indirizzo logico, che deve essere risolto dalla MMU reale fino ad avere un indirizzo fisico.\nMINI SCHEMA\n",
  "wordCount" : "2461",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/architettura-software-del-os/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;Â»&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Architettura software del OS
    </h1>
    <div class="post-meta">12 min&nbsp;Â·&nbsp;Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduzione-sui-componenti-salto" aria-label="Introduzione sui componenti (salto)">Introduzione sui componenti (salto)</a><ul>
                        
                <li>
                    <a href="#gestione-dei-processi" aria-label="Gestione dei processi">Gestione dei processi</a></li>
                <li>
                    <a href="#gestione-memoria-principale-e-secondaria" aria-label="Gestione memoria principale e secondaria">Gestione memoria principale e secondaria</a></li>
                <li>
                    <a href="#io-e-filesystem" aria-label="I/O e filesystem">I/O e filesystem</a></li></ul>
                </li>
                <li>
                    <a href="#struttura-dei-sistemi" aria-label="Struttura dei sistemi">Struttura dei sistemi</a><ul>
                        
                <li>
                    <a href="#obiettivi-di-design-dei-so-4-" aria-label="Obiettivi di design dei SO (4) ðŸŸ¨">Obiettivi di design dei SO (4) ðŸŸ¨</a></li>
                <li>
                    <a href="#struttura-del-kernel-" aria-label="Struttura del kernel ðŸŸ©">Struttura del kernel ðŸŸ©</a></li>
                <li>
                    <a href="#tipologie-di-struttura-os-2-" aria-label="Tipologie di struttura OS (2) ðŸŸ¨&#43;&#43;">Tipologie di struttura OS (2) ðŸŸ¨++</a></li>
                <li>
                    <a href="#politiche-e-meccanismi-" aria-label="Politiche e meccanismi ðŸŸ©">Politiche e meccanismi ðŸŸ©</a></li>
                <li>
                    <a href="#categorizzazione-dei-kernel-3-" aria-label="Categorizzazione dei Kernel (3) ðŸŸ¨â€”">Categorizzazione dei Kernel (3) ðŸŸ¨â€”</a></li></ul>
                </li>
                <li>
                    <a href="#macchine-virtuali" aria-label="Macchine virtuali">Macchine virtuali</a><ul>
                        
                <li>
                    <a href="#analisi-vantaggi-svantaggi-" aria-label="Analisi vantaggi svantaggi ðŸŸ¨">Analisi vantaggi svantaggi ðŸŸ¨</a></li>
                <li>
                    <a href="#livello-processo-o-sistema-" aria-label="Livello processo o sistema ðŸŸ©">Livello processo o sistema ðŸŸ©</a></li>
                <li>
                    <a href="#qemu-" aria-label="Qemu ðŸŸ©">Qemu ðŸŸ©</a></li>
                <li>
                    <a href="#xen-" aria-label="XEN ðŸŸ©">XEN ðŸŸ©</a></li>
                <li>
                    <a href="#parametrizzazione-so-" aria-label="Parametrizzazione SO ðŸŸ©">Parametrizzazione SO ðŸŸ©</a></li>
                <li>
                    <a href="#istruzioni-di-virtualizzazione-" aria-label="Istruzioni di virtualizzazione ðŸŸ¥">Istruzioni di virtualizzazione ðŸŸ¥</a></li>
                <li>
                    <a href="#memoria-virtuale-non-fare" aria-label="Memoria Virtuale (non fare)">Memoria Virtuale (non fare)</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>A seconda dell&rsquo;utilizzatore lâ€™OS puÃ² essere molte cose, come solamente lâ€™interfaccia se sei un programmatore, servizi (se sei un utente, ma gran parte dei servizi sono astratti e l&rsquo;utente ne puÃ² anche essere a non-conoscenza).</p>
<p>Ma se sei un programmatore OS ti interessa capire le componenti principali dellâ€™OS</p>
<ul>
<li>Slide componenti OS alto livello
<img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled.png" alt="image/universita/ex-notion/Architettura software del OS/Untitled"></li>
</ul>
<h2 id="introduzione-sui-componenti-salto">Introduzione sui componenti (salto)<a hidden class="anchor" aria-hidden="true" href="#introduzione-sui-componenti-salto">#</a></h2>
<p>Questa parte la salto perchÃ© Ã¨ una descrizione molto generale di cosa si occupa Lâ€™os verso drivers, processi, filesystem I/O, quindi non Ã¨ molto importante</p>
<h3 id="gestione-dei-processi">Gestione dei processi<a hidden class="anchor" aria-hidden="true" href="#gestione-dei-processi">#</a></h3>
<p>All&rsquo;interno del SO, il processo Ã¨ rappresentato come un <strong>processo control block</strong>, che in linux Ã¨ in <strong>sched</strong>, parte dello scheduler dei processi. Questo Ã¨ importante perchÃ© per esempio per fare una fork, non faccio altro che duplicare questa struttura e settare bene i figli e genitori.</p>
<p>Questi sono solitamente messi un un <strong>process table</strong> o forse una lista per tenerne traccia.</p>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 1.png" alt="image/universita/ex-notion/Architettura software del OS/Untitled 1">
</li>
</ul>
<p>nel parliamo in <a href="/notes/processi-e-thread/">Processi e thread</a>.</p>
<h3 id="gestione-memoria-principale-e-secondaria">Gestione memoria principale e secondaria<a hidden class="anchor" aria-hidden="true" href="#gestione-memoria-principale-e-secondaria">#</a></h3>
<p><strong>Principale</strong></p>
<p>Ãˆ un array temporaneo(nel senso che non Ã¨ mantenuto quando viene spento il PC.), indicizzato singolarmente a differenza del secondario, che Ã¨ indicizzato a blocchi,</p>
<p>Una parte importante di questa parte Ã¨ la gestione della memoria virtuale. Come allocare pagine di memoria, deallocarle e simili, ne parliamo in <a href="/notes/paginazione-e-segmentazione/">Paginazione e segmentazione</a></p>
<p><strong>Secondaria</strong></p>
<p>La cosa buona Ã¨ che questa memoria Ã¨ permanente, efficienza (ordinare le richieste per non andare qui e lÃ¬ quando si legge! <strong>minimizare tempi per seek</strong>) e partizionamento e reliability dei dischi sono problemi che interessano questa parte. Abbiamo parlato di raid in <a href="/notes/memoria/">Memoria</a>. e di nuovo in <a href="/notes/devices-os/">Devices OS</a>.</p>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 2.png" alt="image/universita/ex-notion/Architettura software del OS/Untitled 2">
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 3.png" alt="image/universita/ex-notion/Architettura software del OS/Untitled 3">
</li>
</ul>
<h3 id="io-e-filesystem">I/O e filesystem<a hidden class="anchor" aria-hidden="true" href="#io-e-filesystem">#</a></h3>
<p>Principalmente per IO servono driver per interagire con specifici hardware, e un sistema di comunicazione che spesso sono buffer e cache.</p>
<ul>
<li>
<p>Slides</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 4.png" alt="image/universita/ex-notion/Architettura software del OS/Untitled 4">
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 5.png" alt="image/universita/ex-notion/Architettura software del OS/Untitled 5">
</li>
</ul>
<p>Esiste un <strong>file system virtuale</strong> che mappa a tutto (quindi alcune cose non esistono realmente sul disco, potrebbe essere una astrazione utilizzata per esempio per comunicare con i devices.</p>
<p>Ci sono molti filesystem, che perÃ² posso gestire in modo differente la forma che hanno sul disco, Ed Ã¨ per questo che possiamo dire che esistono dei filesystem diversi.</p>
<p>Anche i processi sono files, la cosa figa di questa astrazioen Ã¨ che posso utilizzare gli stessi sistemi di protezione file per processi.</p>
<h2 id="struttura-dei-sistemi">Struttura dei sistemi<a hidden class="anchor" aria-hidden="true" href="#struttura-dei-sistemi">#</a></h2>
<h3 id="obiettivi-di-design-dei-so-4-">Obiettivi di design dei SO (4) ðŸŸ¨<a hidden class="anchor" aria-hidden="true" href="#obiettivi-di-design-dei-so-4-">#</a></h3>
<ul>
<li>
<p>Slide obiettivi nella struttura dei sistemi (4)</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 6.png" alt="image/universita/ex-notion/Architettura software del OS/Untitled 6">
</li>
<li>
<p>Efficienza</p>
</li>
<li>
<p>ModularitÃ </p>
</li>
<li>
<p>MantenibilitÃ </p>
</li>
<li>
<p>EspansibilitÃ </p>
</li>
</ul>
<h3 id="struttura-del-kernel-">Struttura del kernel ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#struttura-del-kernel-">#</a></h3>
<ul>
<li>
<p>Slide riassuntiva</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 7.png" alt="image/universita/ex-notion/Architettura software del OS/Untitled 7">
</li>
</ul>
<p>Il kernel Ã¨ un unico processo, parte da un main che parte da un initialize in cui raccoglie tutte le risorse del sistema, fa partire tutti i device drivers e crea il PCB del primo processo, anche chiamato <strong>init</strong>, messo poi nella queue dello scheduler come spiegato in <a href="/notes/scheduler/">Scheduler</a>. Fatta una volta non Ã¨ mai piÃ¹ eseguito quel codice di init.</p>
<p>Lo stato kernel Ã¨ la parte a sinistra dellâ€™immagine, quella parte blu, tutto il giallo, a destra Ã¨ lo stato user.</p>
<ol>
<li>Scheduler scegliere il processo da eseguire nello user space</li>
<li>Il controllo Ã¨ passato al processo user, che puÃ² fare traps (come fork) o fare I/O, a quel punto Ã¨ rimesso a codice kernel.</li>
</ol>
<h3 id="tipologie-di-struttura-os-2-">Tipologie di struttura OS (2) ðŸŸ¨++<a hidden class="anchor" aria-hidden="true" href="#tipologie-di-struttura-os-2-">#</a></h3>
<p>Solitamente i sistemi sono costruiti in due modi, sistemi <strong>semplici senza struttura</strong>, che praticamente c&rsquo;Ã¨ una prima versione, e poi viene ammassato roba senza struttura generale, fatti quando servono. Solitamente sono insieme di procedure che si chiamano fra di loro, e ben presto sono andate fuori dal loro ambito di interesse diciamo (fuori dal loro scope)</p>
<p><strong>Esempi di OS semplici:</strong></p>
<p>Un esempio Ã¨ <strong>free-dos</strong> che Ã¨ quanto installato su un computer senza sistema operativo.</p>
<p>In modo simile Ã¨ MS-DOS, che Ã¨ stato fatto per i primi personal computer, che non avevano un sistema kernel a livello hardware (non era quindi possibile fare queste protezioni).. In generale in questo ambiente un programma aveva accesso all&rsquo;intera memoria, e poteva mandare in crash tutto.</p>
<ul>
<li>
<p>Struttura Free-DOS</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 8.png" alt="image/universita/ex-notion/Architettura software del OS/Untitled 8">
</li>
</ul>
<p>UNIX, Ã¨ diviso diviso in due parti in kernel e programmi di sistemi, molto semplice, un kernel monolitico, un unico eseguibile, anche questo fu allâ€™epoca limitato enormemente dal suo hardware, e una serie di programmi di sistema.</p>
<p>Dato che c&rsquo;Ã¨ una separazione, lâ€™utente Ã¨ separato dallâ€™interfaccia dal codice kernel. Ma comunque il codice kernel resta vulnerabile, e potrebbe essere modificato e quindi attaccato, o cumunque vulnerabile a bug, anche colposi, distruttivi.</p>
<ul>
<li>
<p>Struttura UNIX</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 9.png" alt="image/universita/ex-notion/Architettura software del OS/Untitled 9">
</li>
</ul>
<p><strong>Stratificazione OS:</strong></p>
<p>La <strong>struttura a stati</strong> Ã¨ piÃ¹ affidabile dell&rsquo;altra e rende piÃ¹ facile la programmazione di tale sistema, utili, la logica Ã¨ la stessa presentata in <a href="/notes/architettura-e-livelli-1-2/">Architettura e livelli 1, 2</a>, per la divisione a stack del sistema e dei vantaggi che si hanno con questo tipo di architettura.</p>
<ul>
<li>
<p>Esemplificazione struttura a strati</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 10.png" alt="image/universita/ex-notion/Architettura software del OS/Untitled 10">
</li>
<li>
<p>Strutture proposte classiche (non fatte, non importanti)</p>
<p>Questi sono <strong>rimasti accademici</strong></p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 11.png" alt="image/universita/ex-notion/Architettura software del OS/Untitled 11">
</li>
</ul>
<p>Ma nella pratica questi strati sono rimasti solamente a livello accademico, perchÃ© <strong>crea overhead</strong> anche se si guadagnerebbe in manutentibilitÃ  e estensibilitÃ  e gestione, quindi molto meno efficiente, inoltre non erano ben chiare le API fra strati. Oggi c&rsquo;Ã¨ una forma intermedia (non c&rsquo;Ã¨ esattamente la gestione a strati come abbiamo per Web, ma abbiamo una divisione per componenti e responsabilitÃ  delle componenti).</p>
<h3 id="politiche-e-meccanismi-">Politiche e meccanismi ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#politiche-e-meccanismi-">#</a></h3>
<p>La suddifivisione politiche e meccanismi Ã¨ un pattern di software engineering che lo rende molto comodo da gestire.</p>
<p>Invece che una gestione a strati come per le reti, abbiamo una gestione di <strong>politiche e meccanismi</strong> ossia abbiamo qualcosa che decide cosa andare a fare e qualcosa che gestisce il come farla.</p>
<p>EG. un certo modo di memoria allocata per fare qualcosa, quindi indirizzare il sistema verso qualcosa, e MMU che attualmente implementa la decisione politica.</p>
<p><strong>Esempio Microkernel o MINIX:</strong></p>
<p>Il kernel Ã¨ visto come il meccanismo quindi le parti di gestione e politica sono fuori dal kernel. Questo rende la struttura del SO molto mantenibile ed estendibile.</p>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 12.png" alt="image/universita/ex-notion/Architettura software del OS/Untitled 12">
</li>
</ul>
<p><strong>Esempio Mac OS â‰¤ 9 / Windows 9x:</strong></p>
<p>Politiche e meccanismi sono messi tutti nel kernel, perchÃ© cosÃ¬ imponevo un feeling unico al look and feel suo (obbligato tutti ad avere questi elementi grafici). Questo Ã¨ un problema praticamente di mercato.</p>
<p>Questo era brutto perchÃ© la grafica puÃ² mandare in crash tutto il sistema. Anche se i nuovi sistemi non dovrebbero avere questo problema.</p>
<h3 id="categorizzazione-dei-kernel-3-">Categorizzazione dei Kernel (3) ðŸŸ¨â€”<a hidden class="anchor" aria-hidden="true" href="#categorizzazione-dei-kernel-3-">#</a></h3>
<p><strong>Monolitici:</strong></p>
<p>Il kernel Ã¨ un unico programma. Si possono creare moduli che poi vengono caricati. Il problema principale di questo tipo di kernel Ã¨ che se un modulo bugga crolla l&rsquo;intero sistema. Un vantaggio Ã¨ che Ã¨ molto efficiente perchÃ© non deve passare ad astrazioni come per lo stack, basta fare una chiamata di funzione, tanto siamo nello stesso programma. Ed Ã¨ altamente modularizzabile per poter attaccare nuove funzionalitÃ .</p>
<p>In breve:</p>
<p>Vantaggi</p>
<ul>
<li>Efficienza</li>
<li>ModularitÃ  e mantenibilitÃ  (non devo ricompilare tutto, basta runtime).</li>
</ul>
<p>Svantaggio</p>
<ul>
<li>
<p>Un modulo puÃ² mandare in crash tutto, perchÃ© Ã¨ eseguito nello stesso spazio del kernel.</p>
</li>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 13.png" alt="image/universita/ex-notion/Architettura software del OS/Untitled 13">
</li>
</ul>
<p>Esempi sono Linux o BSD.</p>
<p><strong>Microkernel:</strong></p>
<p>Lâ€™obiettivo del microkernle Ã¨ isolare solamente le funzionalitÃ  essenziali e tenere solo quelli, tutto il resto interagisce con esso con system call (un esempio Ã¨ il filesystem che potrebbe essere fuori dal kernel, e avrebbe syscall leggermente diverse rispetto a quelle di linux, per aprire un file allora si chiederebbe a questo processo in user space, che poi fa altre richeste per kernel space)</p>
<p>Bisogna fare un messaggio, la syscall diventano Send! Che sarebbe unico modo per raggiungere il processo che offre il servizio che mi serve.</p>
<p>Vantaggi: ðŸŸ¥</p>
<ul>
<li>Altissima modularitÃ  e mantenibilitÃ  del sistema e semplice da realizzare</li>
<li>Assenza di danni di sistema, perchÃ© moduli e kernel sono eseguiti in spazio differente.</li>
<li>Sicuro e affidabile per la divisione (non ho propagazione di errori e guasti)</li>
<li>Molto portabile, che ho solo il microkernel.</li>
</ul>
<p>Svantaggio:</p>
<ul>
<li>
<p>Fortemente Inefficienza rispetto al monolitico, che devo fare message passing e comunicazione.</p>
</li>
<li>
<p>Slide di comparazione</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 14.png" alt="image/universita/ex-notion/Architettura software del OS/Untitled 14">
</li>
</ul>
<p><strong>Kernel Ibridi</strong></p>
<p>Sono dei microkernel modificati, con qualcosa in piÃ¹ forse (aziende per pubblicizzarsi dicevano di avere microkernel, ma con un ibridone, mettendo le cose inefficienti del microkernel dentro il kernel).</p>
<ul>
<li>
<p>Esempio windows</p>
<p>Ci sono diversi server, che fanno parte di un sottosistema dâ€™ambiente che Ã¨ in grado di emulare certe cose (sono nascoste le syscall reali del sistema cosÃ¬).</p>
<p>Il codice per un certo ambiente funziona anche nel sottosistema, un esempio Ã¨ un WSL.</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 15.png" alt="image/universita/ex-notion/Architettura software del OS/Untitled 15">
<p>La parte grafica importante per fare i videogiochi, Ã¨ dentro il kernel, questo ad esempio per MACOS, perchÃ© volevano imporre la grafica simile</p>
</li>
</ul>
<h2 id="macchine-virtuali">Macchine virtuali<a hidden class="anchor" aria-hidden="true" href="#macchine-virtuali">#</a></h2>
<blockquote>
<p>Virtualization allows a single computer to host multiple virtual machines, each poten-
tially running a completely different operating system.</p>
</blockquote>
<p>Ãˆ virtuale nel senso che la macchina virtuale ha la stessa percezione della realtÃ  di una macchina reale. Qualcosa che non Ã¨ la realtÃ  ma appare molto simile ad essa.</p>
<p>Storicamente parlando le macchine virtuali erano un primo approccio al multitasking.</p>
<p>Lâ€™idea principale Ã¨ creare un sistema che possa apparire al sistema operativo come hardware, in questo modo posso utilizzare un programma per emulare un altro sistema operativo. Ãˆ <strong>hypervisor, VMM (virtual machine monitor)</strong>.</p>
<p>Ovviamente ho uno fortissimo svantaggio in velocitÃ , perchÃ© la simulazione software Ã¨ molto meno efficiente della simulazione hardware. Un collegamento carino Ã¨ con strange loops, una macchina che sia abbastanza espressiva da poter emulare sÃ© stesso.</p>
<h3 id="analisi-vantaggi-svantaggi-">Analisi vantaggi svantaggi ðŸŸ¨<a hidden class="anchor" aria-hidden="true" href="#analisi-vantaggi-svantaggi-">#</a></h3>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 16.png" alt="image/universita/ex-notion/Architettura software del OS/Untitled 16">
</li>
<li>
<p>Posso avere sistemi operativi differenti sulla stessa macchina o SO, quindi posso sperimentarli senza installarli veramente.</p>
</li>
<li>
<p>Posso simulare architetture differenti, e quindi supporre di avere istruzioni differenti di architettura altra!</p>
</li>
<li>
<p>SO monotask in sistemi multitask???</p>
</li>
<li>
<p>Maggiore sicurezza a bug software, Ã¨ efficienza energetica</p>
</li>
</ul>
<p><strong>Svantaggi</strong>:</p>
<ol>
<li>fortemente inefficiente</li>
<li>Difficile condividere risorse fra una macchina virtuale o allâ€™altra.</li>
</ol>
<h3 id="livello-processo-o-sistema-">Livello processo o sistema ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#livello-processo-o-sistema-">#</a></h3>
<p>Le macchine virtuali di cui abbiamo parlato ora virtualizzano solamente lâ€™hardware, cioÃ¨ fa finta di avere un sistema hardware???</p>
<p>Mentre altre macchine virtuali provano a virtualizzare a livello di ABI (application binary interface) (che Ã¨ livello di processo).</p>
<ul>
<li>Macchina virtuale a livello di processo (<strong>process VM)</strong>: permette ad un programma di essere eseguito allo stesso modo su qualsiasi piattaforma.
Viene eseguita come una normale applicazione allâ€™interno di un SO ospite e supporta un singolo processo. Il suo scopo Ã¨ fornire un ambiente indipendente dalla piattaforma hardware e dal SO ospite. Vengono virtualizzati sia lâ€™hardware che il sistema operativo.</li>
<li>Macchina virtuale a livello di sistema (<strong>system VM</strong>): permette l&rsquo;esecuzione di un completo SO, anche con un ISA diverso da quello della macchina reale. Viene virtualizzato esclusivamente e completamente lâ€™hardware</li>
</ul>
<p><strong>Differenza type 1 and 2 hypervisors</strong></p>
<p>type 1 hypervisor and a type 2 hypervisor is that a type 2 makes uses of a host operating system and its file system to create processes, store files, and so on. A type 1 hypervisor has no underlying support and must perform all these functions itself (it runs on the bare metal, come se fosse lui stesso un sistema operativo, Ã¨ infatti un sistema operativo che non fa altro che fare sistemi operativi!)</p>
<h3 id="qemu-">Qemu ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#qemu-">#</a></h3>
<p><strong>qemu</strong> Ã¨ un traduttore dinamico come se fosse un compilatore fra una architettura in una altra, fatta a runtime (quindi Ã¨ un interprete, tipo 10x piÃ¹ lento rispetto esecuzione normale, ma un ordine di grandezza piÃ¹ veloce rispetto altri emulatori).</p>
<p>Con qemu posso anche dire al processo emulato di utilizzare il mio stesso kernel, nel caso che condivida l&rsquo;architettura, questo rende la cosa molto piÃ¹ veloce del normale! e.g. KVM (che Ã¨ il nome dellâ€™Hypervisor per linux). Questo Ã¨ anche una tipologia di <strong>type-2-hypervisor</strong> perchÃ© attingo al kernel della macchina ospite per fare funzionare piÃ¹ in fretta, e non faccio simulazione sistema totale.</p>
<p>Utile o per runnare programmi per architettura differente (in questo senso program VM), oppure per emulare un sistema operativo dentro un sistema operativo</p>
<ul>
<li>
<p>Comando per caricare una macchina virtuale con qemu e utilizzare KVM</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 17.png" alt="image/universita/ex-notion/Architettura software del OS/Untitled 17">
<p>senza vga, non starebbe sullo schermo senza quella flag.</p>
<p>hda gli specifica il file con cui emulare il disco, k il layout del keyboard</p>
<p>m Ã¨ la memoria ram</p>
<p>monitor Ã¨ per poter mandare interrupt dal terminale in cui ho lanciato il mio comando di emulazione.</p>
<p>Quando installa prima Ã¨ installato nella RAM disk, e poi viene utilizzato per lâ€™installazione vera e propria.</p>
</li>
</ul>
<h3 id="xen-">XEN ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#xen-">#</a></h3>
<p>XEN Ã¨ hypervisor livello 1 (SO che permette di fare altri SO virtuali), e utilizzare paravirtualizzazione (si fanno trap and emulate principalmente) , e utilizza una gestione diversa dei drivers che possiede, ossia il <strong>Domain0</strong> possiede tutti i drivers fisici (le interazioni con i device le manda alla macchina 0, perchÃ© per restare un sistema operativo semplice non riesce a gestire sistemi operativi).</p>
<p><strong>Paravirtualizzatione</strong></p>
<p>In questo caso il SO virtuale Ã¨ a conoscenza che esiste un hypervisor quindi puÃ² fare delle <strong>hypercall</strong> per eseguire delle istruzioni sensitive, e in generale Ã¨ un approccio piÃ¹ veloce invece della virtualizzazione totale di cui abbiamo parlato prima.</p>
<p><strong>Esempio di maggiore efficienza</strong></p>
<p>Per il type 2 hypervisor il SO installato pensa veramente di stare in una macchina sÃ©, quindi fa cose per minimizzare i seek del disco ma in questo caso non deve fare veramente seek, quindi Ã¨ meno efficiente, facendo una assunzione errata.</p>
<p>Si utilizzano paravirtualizzazione, ossia devices virtuali piÃ¹ efficienti per questa cosa, ed effettivamente non assumo di stare utilizzando device fisici, ma sono a conoscenza di utilizzare device virtuali, e posso fare ottimizzazioni del caso (che non so quali siano forse per il disco non faccio cose strane per il seek ad esempio).</p>
<p>Il problema Ã¨ che essendo a conoscenza, dovrei fare il mio SO in modo che sia compatibile con le hyper all offerte dall hypervisor</p>
<h3 id="parametrizzazione-so-">Parametrizzazione SO ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#parametrizzazione-so-">#</a></h3>
<p>Essendo libero linux, Ã¨ molto comodo poter cambiare alcuni parametri e poi <strong>ricompilare il kernel seguendo quei parametri</strong>. Tanto Ã¨ tutto open source, quindi si potrebbe fare. Questo permette al kernel di essere molto portabile.</p>
<p>Una cosa molto importante da capire Ã¨ che <strong>il kernel Ã¨ una cosa diversa della distribuzione</strong>, il kernel Ã¨ il primo programma che viene caricato dal bootloader e carica il FS e tutto il resto (quindi le cose iniziali), il secondo sono tutte le utility per il kernel che lo rendono utilizzabile da un utente normale.</p>
<ul>
<li>
<p>Comando runnato per la emulazione kernel/distribuzione</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 18.png" alt="image/universita/ex-notion/Architettura software del OS/Untitled 18">
</li>
<li>
<p>Slide parametrizzazione ++ portabilitÃ  (che deve runnare per hardware differentI)</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 19.png" alt="image/universita/ex-notion/Architettura software del OS/Untitled 19">
</li>
</ul>
<h3 id="istruzioni-di-virtualizzazione-">Istruzioni di virtualizzazione ðŸŸ¥<a hidden class="anchor" aria-hidden="true" href="#istruzioni-di-virtualizzazione-">#</a></h3>
<p>Abbiamo aggiunto delle istruzioni di emulazione come <code>VMX ON, VMX OFF, VMLAUNCH, VMRETURN</code>  in cui il processore sa di stare emulando, e quindi Ã¨ piÃ¹ veloce perchÃ© esegue l&rsquo;istruzione in altro modo, forse con istruzione nativa. Pagina <a href="https://en.wikipedia.org/wiki/X86_virtualization">wiki</a></p>
<p>fa pensare di essere in kernel mode, ma non Ã¨ in kernel mode, Ã¨ come se stesse in un livello di priviliegio intermedio.</p>
<p>VMLAUNCH</p>
<p>Queste sono quelle principali istruzioni che permettono la virtualizzazioen a livello software, il fatto che rende l&rsquo;esecuzione molto piÃ¹ veloce, quindi invece di simulare tutto sopra il sistema operativo attuale (e syscalls attuali) posso accedere ad istruzioni hardware molto piÃ¹ veloci.</p>
<h3 id="memoria-virtuale-non-fare">Memoria Virtuale (non fare)<a hidden class="anchor" aria-hidden="true" href="#memoria-virtuale-non-fare">#</a></h3>
<p>C&rsquo;Ã¨ una MMU del sistema operativo che mappa alla VM fisica, che si deve basare all&rsquo;indirizzo logico, che deve essere risolto dalla MMU reale fino ad avere un indirizzo fisico.</p>
<img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 20.png" alt="image/universita/ex-notion/Architettura software del OS/Untitled 20">
<p>MINI SCHEMA</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/sistemi-operativi/">Sistemi-Operativi</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Architettura software del OS on x"
            href="https://x.com/intent/tweet/?text=Architettura%20software%20del%20OS&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-software-del-os%2f&amp;hashtags=sistemi-operativi">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Architettura software del OS on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-software-del-os%2f&amp;title=Architettura%20software%20del%20OS&amp;summary=Architettura%20software%20del%20OS&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-software-del-os%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Architettura software del OS on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-software-del-os%2f&title=Architettura%20software%20del%20OS">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Architettura software del OS on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-software-del-os%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Architettura software del OS on whatsapp"
            href="https://api.whatsapp.com/send?text=Architettura%20software%20del%20OS%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-software-del-os%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Architettura software del OS on telegram"
            href="https://telegram.me/share/url?text=Architettura%20software%20del%20OS&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-software-del-os%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Architettura software del OS on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Architettura%20software%20del%20OS&u=https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-software-del-os%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
