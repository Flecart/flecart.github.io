<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Architettura software del OS | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="sistemi-operativi, ‚òÅcloud-computing">
<meta name="description" content="A seconda dell&rsquo;utilizzatore l‚ÄôOS pu√≤ essere molte cose, come solamente l‚Äôinterfaccia se sei un programmatore, servizi (se sei un utente, ma gran parte dei servizi sono astratti e l&rsquo;utente ne pu√≤ anche essere a non-conoscenza).
Ma se sei un programmatore OS ti interessa capire le componenti principali dell‚ÄôOS

Slide componenti OS alto livello


Introduzione sui componenti (salto)
Questa parte la salto perch√© √® una descrizione molto generale di cosa si occupa L‚Äôos verso drivers, processi, filesystem I/O, quindi non √® molto importante">
<meta name="author" content="Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="https://flecart.github.io/notes/architettura-software-del-os/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/architettura-software-del-os/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>
<script type="text/javascript" async
src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>






      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-WW6NN2QGKF');
        }
      </script><meta property="og:url" content="https://flecart.github.io/notes/architettura-software-del-os/">
  <meta property="og:site_name" content="X. Angelo Huang&#39;s Blog">
  <meta property="og:title" content="Architettura software del OS">
  <meta property="og:description" content="A seconda dell‚Äôutilizzatore l‚ÄôOS pu√≤ essere molte cose, come solamente l‚Äôinterfaccia se sei un programmatore, servizi (se sei un utente, ma gran parte dei servizi sono astratti e l‚Äôutente ne pu√≤ anche essere a non-conoscenza).
Ma se sei un programmatore OS ti interessa capire le componenti principali dell‚ÄôOS
Slide componenti OS alto livello Introduzione sui componenti (salto) Questa parte la salto perch√© √® una descrizione molto generale di cosa si occupa L‚Äôos verso drivers, processi, filesystem I/O, quindi non √® molto importante">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="notes">
    <meta property="article:tag" content="Sistemi-Operativi">
    <meta property="article:tag" content="‚òÅCloud-Computing">
      <meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:title" content="Architettura software del OS">
<meta name="twitter:description" content="A seconda dell&rsquo;utilizzatore l‚ÄôOS pu√≤ essere molte cose, come solamente l‚Äôinterfaccia se sei un programmatore, servizi (se sei un utente, ma gran parte dei servizi sono astratti e l&rsquo;utente ne pu√≤ anche essere a non-conoscenza).
Ma se sei un programmatore OS ti interessa capire le componenti principali dell‚ÄôOS

Slide componenti OS alto livello


Introduzione sui componenti (salto)
Questa parte la salto perch√© √® una descrizione molto generale di cosa si occupa L‚Äôos verso drivers, processi, filesystem I/O, quindi non √® molto importante">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Architettura software del OS",
      "item": "https://flecart.github.io/notes/architettura-software-del-os/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Architettura software del OS",
  "name": "Architettura software del OS",
  "description": "A seconda dell\u0026rsquo;utilizzatore l‚ÄôOS pu√≤ essere molte cose, come solamente l‚Äôinterfaccia se sei un programmatore, servizi (se sei un utente, ma gran parte dei servizi sono astratti e l\u0026rsquo;utente ne pu√≤ anche essere a non-conoscenza).\nMa se sei un programmatore OS ti interessa capire le componenti principali dell‚ÄôOS\nSlide componenti OS alto livello Introduzione sui componenti (salto) Questa parte la salto perch√© √® una descrizione molto generale di cosa si occupa L‚Äôos verso drivers, processi, filesystem I/O, quindi non √® molto importante\n",
  "keywords": [
    "sistemi-operativi", "‚òÅcloud-computing"
  ],
  "articleBody": "A seconda dell‚Äôutilizzatore l‚ÄôOS pu√≤ essere molte cose, come solamente l‚Äôinterfaccia se sei un programmatore, servizi (se sei un utente, ma gran parte dei servizi sono astratti e l‚Äôutente ne pu√≤ anche essere a non-conoscenza).\nMa se sei un programmatore OS ti interessa capire le componenti principali dell‚ÄôOS\nSlide componenti OS alto livello Introduzione sui componenti (salto) Questa parte la salto perch√© √® una descrizione molto generale di cosa si occupa L‚Äôos verso drivers, processi, filesystem I/O, quindi non √® molto importante\nGestione dei processi All‚Äôinterno del SO, il processo √® rappresentato come un processo control block, che in linux √® in sched, parte dello scheduler dei processi. Questo √® importante perch√© per esempio per fare una fork, non faccio altro che duplicare questa struttura e settare bene i figli e genitori.\nQuesti sono solitamente messi un un process table o forse una lista per tenerne traccia.\nSlide\nnel parliamo in Processi e thread.\nGestione memoria principale e secondaria Principale\n√à un array temporaneo(nel senso che non √® mantenuto quando viene spento il PC.), indicizzato singolarmente a differenza del secondario, che √® indicizzato a blocchi,\nUna parte importante di questa parte √® la gestione della memoria virtuale. Come allocare pagine di memoria, deallocarle e simili, ne parliamo in Paginazione e segmentazione\nSecondaria\nLa cosa buona √® che questa memoria √® permanente, efficienza (ordinare le richieste per non andare qui e l√¨ quando si legge! minimizare tempi per seek) e partizionamento e reliability dei dischi sono problemi che interessano questa parte. Abbiamo parlato di raid in Memoria. e di nuovo in Devices OS.\nSlide\nI/O e filesystem Principalmente per IO servono driver per interagire con specifici hardware, e un sistema di comunicazione che spesso sono buffer e cache.\nSlides\nEsiste un file system virtuale che mappa a tutto (quindi alcune cose non esistono realmente sul disco, potrebbe essere una astrazione utilizzata per esempio per comunicare con i devices.\nCi sono molti filesystem, che per√≤ posso gestire in modo differente la forma che hanno sul disco, Ed √® per questo che possiamo dire che esistono dei filesystem diversi.\nAnche i processi sono files, la cosa figa di questa astrazioen √® che posso utilizzare gli stessi sistemi di protezione file per processi.\nStruttura dei sistemi Obiettivi di design dei SO (4) üü® Slide obiettivi nella struttura dei sistemi (4)\nEfficienza\nModularit√†\nMantenibilit√†\nEspansibilit√†\nStruttura del kernel üü© Slide riassuntiva\nIl kernel √® un unico processo, parte da un main che parte da un initialize in cui raccoglie tutte le risorse del sistema, fa partire tutti i device drivers e crea il PCB del primo processo, anche chiamato init, messo poi nella queue dello scheduler come spiegato in Scheduler. Fatta una volta non √® mai pi√π eseguito quel codice di init.\nLo stato kernel √® la parte a sinistra dell‚Äôimmagine, quella parte blu, tutto il giallo, a destra √® lo stato user.\nScheduler scegliere il processo da eseguire nello user space Il controllo √® passato al processo user, che pu√≤ fare traps (come fork) o fare I/O, a quel punto √® rimesso a codice kernel. Tipologie di struttura OS (2) üü®++ Solitamente i sistemi sono costruiti in due modi, sistemi semplici senza struttura, che praticamente c‚Äô√® una prima versione, e poi viene ammassato roba senza struttura generale, fatti quando servono. Solitamente sono insieme di procedure che si chiamano fra di loro, e ben presto sono andate fuori dal loro ambito di interesse diciamo (fuori dal loro scope)\nEsempi di OS semplici:\nUn esempio √® free-dos che √® quanto installato su un computer senza sistema operativo.\nIn modo simile √® MS-DOS, che √® stato fatto per i primi personal computer, che non avevano un sistema kernel a livello hardware (non era quindi possibile fare queste protezioni).. In generale in questo ambiente un programma aveva accesso all‚Äôintera memoria, e poteva mandare in crash tutto.\nStruttura Free-DOS\nUNIX, √® diviso diviso in due parti in kernel e programmi di sistemi, molto semplice, un kernel monolitico, un unico eseguibile, anche questo fu all‚Äôepoca limitato enormemente dal suo hardware, e una serie di programmi di sistema.\nDato che c‚Äô√® una separazione, l‚Äôutente √® separato dall‚Äôinterfaccia dal codice kernel. Ma comunque il codice kernel resta vulnerabile, e potrebbe essere modificato e quindi attaccato, o cumunque vulnerabile a bug, anche colposi, distruttivi.\nStruttura UNIX\nStratificazione OS:\nLa struttura a stati √® pi√π affidabile dell‚Äôaltra e rende pi√π facile la programmazione di tale sistema, utili, la logica √® la stessa presentata in Architettura e livelli 1, 2, per la divisione a stack del sistema e dei vantaggi che si hanno con questo tipo di architettura.\nEsemplificazione struttura a strati\nStrutture proposte classiche (non fatte, non importanti)\nQuesti sono rimasti accademici\nMa nella pratica questi strati sono rimasti solamente a livello accademico, perch√© crea overhead anche se si guadagnerebbe in manutentibilit√† e estensibilit√† e gestione, quindi molto meno efficiente, inoltre non erano ben chiare le API fra strati. Oggi c‚Äô√® una forma intermedia (non c‚Äô√® esattamente la gestione a strati come abbiamo per Web, ma abbiamo una divisione per componenti e responsabilit√† delle componenti).\nPolitiche e meccanismi üü© La suddifivisione politiche e meccanismi √® un pattern di software engineering che lo rende molto comodo da gestire.\nInvece che una gestione a strati come per le reti, abbiamo una gestione di politiche e meccanismi ossia abbiamo qualcosa che decide cosa andare a fare e qualcosa che gestisce il come farla.\nEG. un certo modo di memoria allocata per fare qualcosa, quindi indirizzare il sistema verso qualcosa, e MMU che attualmente implementa la decisione politica.\nEsempio Microkernel o MINIX:\nIl kernel √® visto come il meccanismo quindi le parti di gestione e politica sono fuori dal kernel. Questo rende la struttura del SO molto mantenibile ed estendibile.\nSlide\nEsempio Mac OS ‚â§ 9 / Windows 9x:\nPolitiche e meccanismi sono messi tutti nel kernel, perch√© cos√¨ imponevo un feeling unico al look and feel suo (obbligato tutti ad avere questi elementi grafici). Questo √® un problema praticamente di mercato.\nQuesto era brutto perch√© la grafica pu√≤ mandare in crash tutto il sistema. Anche se i nuovi sistemi non dovrebbero avere questo problema.\nCategorizzazione dei Kernel Monolitici Il kernel √® un unico programma. Si possono creare moduli che poi vengono caricati. Il problema principale di questo tipo di kernel √® che se un modulo bugga crolla l‚Äôintero sistema. Un vantaggio √® che √® molto efficiente perch√© non deve passare ad astrazioni come per lo stack, basta fare una chiamata di funzione, tanto siamo nello stesso programma. Ed √® altamente modularizzabile per poter attaccare nuove funzionalit√†.\nIn breve:\nVantaggi:\nEfficienza Modularit√† e mantenibilit√† (non devo ricompilare tutto, basta runtime). Svantaggio:\nUn modulo pu√≤ mandare in crash tutto, perch√© √® eseguito nello stesso spazio del kernel.\nSlide\nEsempi sono Linux o BSD.\nMicrokernel L‚Äôobiettivo del microkernle √® isolare solamente le funzionalit√† essenziali e tenere solo quelli, tutto il resto interagisce con esso con system call (un esempio √® il filesystem che potrebbe essere fuori dal kernel, e avrebbe syscall leggermente diverse rispetto a quelle di linux, per aprire un file allora si chiederebbe a questo processo in user space, che poi fa altre richeste per kernel space)\nBisogna fare un messaggio, la syscall diventano Send! Che sarebbe unico modo per raggiungere il processo che offre il servizio che mi serve.\nVantaggi:\nAltissima modularit√† e mantenibilit√† del sistema e semplice da realizzare Assenza di danni di sistema, perch√© moduli e kernel sono eseguiti in spazio differente. Sicuro e affidabile per la divisione (non ho propagazione di errori e guasti) Molto portabile, che ho solo il microkernel. Svantaggio:\nFortemente Inefficienza rispetto al monolitico, che devo fare message passing e comunicazione.\nSlide di comparazione\nKernel Ibridi Sono dei microkernel modificati, con qualcosa in pi√π forse (aziende per pubblicizzarsi dicevano di avere microkernel, ma con un ibridone, mettendo le cose inefficienti del microkernel dentro il kernel).\nEsempio windows\nCi sono diversi server, che fanno parte di un sottosistema d‚Äôambiente che √® in grado di emulare certe cose (sono nascoste le syscall reali del sistema cos√¨).\nIl codice per un certo ambiente funziona anche nel sottosistema, un esempio √® un WSL.\nLa parte grafica importante per fare i videogiochi, √® dentro il kernel, questo ad esempio per MACOS, perch√© volevano imporre la grafica simile\nMacchine virtuali The fundamental idea behind a virtual machine is to abstract the hardware of a single computer (the CPU, memory, disk drives, network interface cards, and so forth) into several different execution environments, thereby creating the illusion that each separate environment is running on its own private computer. (Silberschatz et al. 2018).\nVirtualization allows a single computer to host multiple virtual machines, each potentially running a completely different operating system.\n√à virtuale nel senso che la macchina virtuale ha la stessa percezione della realt√† di una macchina reale. Qualcosa che non √® la realt√† ma appare molto simile ad essa.\nStoricamente parlando le macchine virtuali erano un primo approccio al multitasking.\nL‚Äôidea principale √® creare un sistema che possa apparire al sistema operativo come hardware, in questo modo posso utilizzare un programma per emulare un altro sistema operativo. √à hypervisor, VMM (virtual machine monitor).\nOvviamente ho uno fortissimo svantaggio in velocit√†, perch√© la simulazione software √® molto meno efficiente della simulazione hardware. Un collegamento carino √® con (Hofstadter 2007), una macchina che sia abbastanza espressiva da poter emulare s√© stesso.\nAnalisi vantaggi svantaggi üü® Posso avere sistemi operativi differenti sulla stessa macchina o SO, quindi posso sperimentarli senza installarli veramente. Posso simulare architetture differenti, e quindi supporre di avere istruzioni differenti di architettura altra! SO monotask in sistemi multitask. Maggiore sicurezza a bug software, √® efficienza energetica. Svantaggi:\nfortemente inefficiente Peso in pi√π sia sulla memoria Context Switch molto frequenti che lo rendono pi√π lento I/O lento. Difficile condividere risorse fra una macchina virtuale o all‚Äôaltra. Desiderata per virtualizzazione Chiamiamo le propriet√† di partizionamento:\nCondividere le risorse della stessa macchina Isolare le macchine diverse, in modo che non possano influenzarsi a livello software, in modo da creare la giusta simulazione, esattamente come macchine fisiche reali, che non possono comunicare fra di loro. E la incapsulazione, con controllo completo di checkpointing, migrazione e replay. Nel caso di servizi cloud, avere queste desiderata rende possibile andare a copiare i dati in giro e riprendere l‚Äôesecuzione in un altro hardware, vedere Cloud Computing Services.\nDesiderata principale:\nEfficienza: la virtualizzazione non deve essere troppo lenta, altrimenti non ha senso. Compatibilit√†: deve essere compatibile con il software esistente (deve eseguire allo stesso modo in macchina virtualizzata o meno). Isolamento: le macchine virtuali devono essere isolate fra di loro. Virtualizzazione di Popek and Goldberg Nel 1974 Popek e Goldberg hanno definito i requisiti per la virtualizzazione, che sono:\nDevono esistere una modilit√† kernel and user. Tutte le istruzioni sensibili devono essere istruzioni privilegiate. Le istruzioni sensibili sono quelle che cambiano lo stato a livello hardware (allocazioni, mappature) Le istruzioni privilegiate sono quelle che usano trap. Al tempo il processore Intel x86 non era virtualizzabile, perch√© certe istruzioni sensibili (sensitive) non aveva istruzioni privilegiate, e quindi non poteva essere virtualizzato. Per esempio il registro %cs conteneva il livello di privilegio, e non poteva essere virtualizzato (esempio se OS pusha quel registro sulla stack, si dovrebbe aspettare il massimo livello di privilegio), dato che il VMM non poteva catturare la trap ed emulare l‚Äôistruzione, non era possibile virtualizzare questa operazione. Per questo usiamo binary translation per questo, ma impatta leggermente la velocit√† di esecuzione.\nLivello processo o sistema üü© Le macchine virtuali di cui abbiamo parlato ora virtualizzano solamente l‚Äôhardware, cio√® fa finta di avere un sistema hardware.\nMentre altre macchine virtuali provano a virtualizzare a livello di ABI (application binary interface) (che √® livello di processo).\nMacchina virtuale a livello di processo (process VM): permette ad un programma di essere eseguito allo stesso modo su qualsiasi piattaforma. Un esempio di questo √® la macchina virtuale di Java. Viene eseguita come una normale applicazione all‚Äôinterno di un SO ospite e supporta un singolo processo. Il suo scopo √® fornire un ambiente indipendente dalla piattaforma hardware e dal SO ospite. Vengono virtualizzati sia l‚Äôhardware che il sistema operativo. Macchina virtuale a livello di sistema (system VM): permette l‚Äôesecuzione di un completo SO, anche con un ISA diverso da quello della macchina reale. Viene virtualizzato esclusivamente e completamente l‚Äôhardware. Differenza type 1 and 2 hypervisors type 1 hypervisor and a type 2 hypervisor is that a type 2 makes uses of a host operating system and its file system to create processes, store files, and so on. A type 1 hypervisor has no underlying support and must perform all these functions itself (it runs on the bare metal, come se fosse lui stesso un sistema operativo, √® infatti un sistema operativo che non fa altro che fare sistemi operativi!)\nEsistono anche type 0 hypervisors che sono direttamente supporto per macchine virtuali fatte a livello hardware. Esempi di questo sono IBM LPARs and Oracle LDOMs.\nVirtual Machine Monitor Questo √® quello che viene chiamato anche type 1 hypervisor. √à un sistema operativo che gestisce altri sistemi operativi che eseguono sopra di esso. Chi sta sopra pensa di possedere l‚Äôintero hardware, mentre in realt√† √® la VMM che prova a tradurre o mandare di sotto.\nVirtualizzatori In questa sezione introduciamo alcuni eventi di virtualizzatori.\nQemu üü© qemu √® un traduttore dinamico come se fosse un compilatore fra una architettura in una altra, fatta a runtime (quindi √® un interprete, tipo 10x pi√π lento rispetto esecuzione normale, ma un ordine di grandezza pi√π veloce rispetto altri emulatori).\nCon qemu posso anche dire al processo emulato di utilizzare il mio stesso kernel, nel caso che condivida l‚Äôarchitettura, questo rende la cosa molto pi√π veloce del normale! e.g. KVM (che √® il nome dell‚ÄôHypervisor per linux). Questo √® anche una tipologia di type-2-hypervisor perch√© attingo al kernel della macchina ospite per fare funzionare pi√π in fretta, e non faccio simulazione sistema totale.\nUtile o per runnare programmi per architettura differente (in questo senso program VM), oppure per emulare un sistema operativo dentro un sistema operativo.\nComando per caricare una macchina virtuale con qemu e utilizzare KVM senza vga, non starebbe sullo schermo senza quella flag. hda gli specifica il file con cui emulare il disco, k il layout del keyboard m √® la memoria ram monitor √® per poter mandare interrupt dal terminale in cui ho lanciato il mio comando di emulazione. Quando installa prima √® installato nella RAM disk, e poi viene utilizzato per l‚Äôinstallazione vera e propria.\nXEN üü© XEN √® hypervisor livello 1 (SO che permette di fare altri SO virtuali), e utilizzare paravirtualizzazione (si fanno trap and emulate principalmente) , e utilizza una gestione diversa dei drivers che possiede, ossia il Domain0 possiede tutti i drivers fisici (le interazioni con i device le manda alla macchina 0, perch√© per restare un sistema operativo semplice non riesce a gestire sistemi operativi).\nEsempio di maggiore efficienza\nPer il type 2 hypervisor il SO installato pensa veramente di stare in una macchina s√©, quindi fa cose per minimizzare i seek del disco ma in questo caso non deve fare veramente seek, quindi √® meno efficiente, facendo una assunzione errata.\nSi utilizzano paravirtualizzazione, ossia devices virtuali pi√π efficienti per questa cosa, ed effettivamente non assumo di stare utilizzando device fisici, ma sono a conoscenza di utilizzare device virtuali, e posso fare ottimizzazioni del caso (che non so quali siano forse per il disco non faccio cose strane per il seek ad esempio).\nIl problema √® che essendo a conoscenza, dovrei fare il mio SO in modo che sia compatibile con le hyper all offerte dall hypervisor\nImplementazione della Virtualizzazione Metodi di virtualizzazione Possiamo considerare tre metodi principali di virtualizzazione:\nSimulazione via software sull‚Äôhost (molto molto lento, tipo 100x volte pi√π lento) Un esempio √® QEMU in full emulation. Esecuzione diretta Trap and emulate in cui il VMM intercetta il trap ed esegue l‚Äôistruzione equivalente Emulazione con supporto hardware come con le estensioni Intel VT-x e AMD-V. Questo √® il metodo pi√π utilizzato oggi giorno. Vedi sezione di istruzioni di virtualizzazione. Add Virtual Machine Control Structure (VMCS) che decide quali istruzioni fanno VMexit, e quando si pu√≤ cambiare queste informazioni con VMread or write e simili, consentendo all‚Äôhypervisor di controllare il comportamento della VM. Dynamic binary translation Necessario quando l‚Äôhardware non √® totalmente virtualizzabile, quindi introduce delle istruzioni di emulazione in pi√π. Paravirtualizzazione In questo caso il SO virtuale √® a conoscenza che esiste un hypervisor quindi pu√≤ fare delle hypercall per eseguire delle istruzioni sensitive, e in generale √® un approccio pi√π veloce invece della virtualizzazione totale di cui abbiamo parlato prima. Per√≤ bisogna essere a conoscenza del hypervisor. Quindi andiamo a modificare parti del SO in modo da tenere in considerazione l‚Äôesistenza dell‚Äôhypervisor, rende pi√π veloce, per√≤ bisogna andare a modificare il SO stesso, per ogni SO. Un esempio √® XEN. Parametrizzazione SO üü© Questo non √® proprio un metodo di virtualizzazione di un Sistema Operativo, ma un modo per modificare leggermente alcuni sistemi operativi.\nEssendo libero linux, √® molto comodo poter cambiare alcuni parametri e poi ricompilare il kernel seguendo quei parametri. Tanto √® tutto open source, quindi si potrebbe fare. Questo permette al kernel di essere molto portabile.\nUna cosa molto importante da capire √® che il kernel √® una cosa diversa della distribuzione, il kernel √® il primo programma che viene caricato dal bootloader e carica il FS e tutto il resto (quindi le cose iniziali), il secondo sono tutte le utility per il kernel che lo rendono utilizzabile da un utente normale.\nComando runnato per la emulazione kernel/distribuzione\nSlide parametrizzazione ++ portabilit√† (che deve runnare per hardware differentI)\nIstruzioni di virtualizzazione üü• Abbiamo aggiunto delle istruzioni di emulazione come VMX ON, VMX OFF, VMLAUNCH, VMRETURN in cui il processore sa di stare emulando, e quindi √® pi√π veloce perch√© esegue l‚Äôistruzione in altro modo, forse con istruzione nativa. Pagina wiki fa pensare di essere in kernel mode, ma non √® in kernel mode, √® come se stesse in un livello di priviliegio intermedio.\nVMLAUNCH\nQueste sono quelle principali istruzioni che permettono la virtualizzazioen a livello software, il fatto che rende l‚Äôesecuzione molto pi√π veloce, quindi invece di simulare tutto sopra il sistema operativo attuale (e syscalls attuali) posso accedere ad istruzioni hardware molto pi√π veloci.\nMemoria Virtuale C‚Äô√® una MMU del sistema operativo che mappa alla VM fisica, che si deve basare all‚Äôindirizzo logico, che deve essere risolto dalla MMU reale fino ad avere un indirizzo fisico.\n#### Shadow Page Tables Permettono di evitare l‚Äôutilizzo di Shadow page tables, che sono il remapping della pagine virtuali con le pagine fisiche. Ci sono esattamente lo stesso numero di pagine nei sistemi operativi virtuali con il numero di pagine nel shadow page table. Esiste molto overhead di memoria per quanto riguarda questa parte.\nExtended Page Tables Abbiamo in pratica una sezione di traduzione in pi√π per mapparlo a EPT (Extended Page Tables), che mappa le pagine virtuali con le pagine fisiche, e quindi non c‚Äô√® overhead di memoria, e quindi √® molto pi√π efficiente in comparazione con le shadow page tables.\nVirtualizzazione di I/O Problemi di virtualizzazione I/O Si ricorda in Devices OS che solitamente questi usano Direct Memory Access per scrivere per il sistema operativo, per√≤ questo spesso non √® possibile e bisogna fare qualche interrupt virtuale per risolvere questo problema. Possiamo\nPara virtualizzare l‚Äôinterfaccia del device Emulare il device I/O. Single Root I/O Virtualization SR-IOV enables hardware-assisted virtualization by partitioning a single PCIe device into multiple Virtual Functions (VFs), which can be assigned directly to virtual machines (VMs) or containers. This reduces overhead caused by traditional software-based I/O virtualization.\nKey Components of SR-IOV:\nPhysical Function (PF) The main PCIe function, fully featured, controlled by the host OS (hypervisor). Manages and configures the Virtual Functions. Virtual Functions (VFs) Lightweight PCIe functions with limited resources, assigned to VMs or containers. Each VM gets direct access to a VF, bypassing the hypervisor for performance gains. References [1] Hofstadter ‚ÄúI Am a Strange Loop‚Äù Basic Books 2007\n[2] Silberschatz et al. ‚ÄúOperating System Concepts‚Äù Wiley 2018\n",
  "wordCount" : "3334",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/architettura-software-del-os/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;¬ª&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Architettura software del OS
    </h1>
    <div class="post-meta">16 min&nbsp;¬∑&nbsp;Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul><ul>
                <li>
                    <a href="#introduzione-sui-componenti-salto" aria-label="Introduzione sui componenti (salto)">Introduzione sui componenti (salto)</a><ul>
                        
                <li>
                    <a href="#gestione-dei-processi" aria-label="Gestione dei processi">Gestione dei processi</a></li>
                <li>
                    <a href="#gestione-memoria-principale-e-secondaria" aria-label="Gestione memoria principale e secondaria">Gestione memoria principale e secondaria</a></li>
                <li>
                    <a href="#io-e-filesystem" aria-label="I/O e filesystem">I/O e filesystem</a></li></ul>
                </li>
                <li>
                    <a href="#struttura-dei-sistemi" aria-label="Struttura dei sistemi">Struttura dei sistemi</a><ul>
                        
                <li>
                    <a href="#obiettivi-di-design-dei-so-4-" aria-label="Obiettivi di design dei SO (4) üü®">Obiettivi di design dei SO (4) üü®</a></li>
                <li>
                    <a href="#struttura-del-kernel-" aria-label="Struttura del kernel üü©">Struttura del kernel üü©</a></li>
                <li>
                    <a href="#tipologie-di-struttura-os-2-" aria-label="Tipologie di struttura OS (2) üü®&#43;&#43;">Tipologie di struttura OS (2) üü®++</a></li>
                <li>
                    <a href="#politiche-e-meccanismi-" aria-label="Politiche e meccanismi üü©">Politiche e meccanismi üü©</a></li>
                <li>
                    <a href="#categorizzazione-dei-kernel" aria-label="Categorizzazione dei Kernel">Categorizzazione dei Kernel</a><ul>
                        
                <li>
                    <a href="#monolitici" aria-label="Monolitici">Monolitici</a></li>
                <li>
                    <a href="#microkernel" aria-label="Microkernel">Microkernel</a></li>
                <li>
                    <a href="#kernel-ibridi" aria-label="Kernel Ibridi">Kernel Ibridi</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#macchine-virtuali" aria-label="Macchine virtuali">Macchine virtuali</a><ul>
                        
                <li>
                    <a href="#analisi-vantaggi-svantaggi-" aria-label="Analisi vantaggi svantaggi üü®">Analisi vantaggi svantaggi üü®</a><ul>
                        
                <li>
                    <a href="#desiderata-per-virtualizzazione" aria-label="Desiderata per virtualizzazione">Desiderata per virtualizzazione</a></li>
                <li>
                    <a href="#virtualizzazione-di-popek-and-goldberg" aria-label="Virtualizzazione di Popek and Goldberg">Virtualizzazione di Popek and Goldberg</a></li></ul>
                </li>
                <li>
                    <a href="#livello-processo-o-sistema-" aria-label="Livello processo o sistema üü©">Livello processo o sistema üü©</a><ul>
                        
                <li>
                    <a href="#differenza-type-1-and-2-hypervisors" aria-label="Differenza type 1 and 2 hypervisors">Differenza type 1 and 2 hypervisors</a></li>
                <li>
                    <a href="#virtual-machine-monitor" aria-label="Virtual Machine Monitor">Virtual Machine Monitor</a></li></ul>
                </li>
                <li>
                    <a href="#virtualizzatori" aria-label="Virtualizzatori">Virtualizzatori</a><ul>
                        
                <li>
                    <a href="#qemu-" aria-label="Qemu üü©">Qemu üü©</a></li>
                <li>
                    <a href="#xen-" aria-label="XEN üü©">XEN üü©</a></li></ul>
                </li>
                <li>
                    <a href="#implementazione-della-virtualizzazione" aria-label="Implementazione della Virtualizzazione">Implementazione della Virtualizzazione</a><ul>
                        
                <li>
                    <a href="#metodi-di-virtualizzazione" aria-label="Metodi di virtualizzazione">Metodi di virtualizzazione</a></li>
                <li>
                    <a href="#parametrizzazione-so-" aria-label="Parametrizzazione SO üü©">Parametrizzazione SO üü©</a></li>
                <li>
                    <a href="#istruzioni-di-virtualizzazione-" aria-label="Istruzioni di virtualizzazione üü•">Istruzioni di virtualizzazione üü•</a></li></ul>
                </li>
                <li>
                    <a href="#memoria-virtuale" aria-label="Memoria Virtuale">Memoria Virtuale</a><ul>
                        
                <li>
                    <a href="#extended-page-tables" aria-label="Extended Page Tables">Extended Page Tables</a></li></ul>
                </li>
                <li>
                    <a href="#virtualizzazione-di-io" aria-label="Virtualizzazione di I/O">Virtualizzazione di I/O</a><ul>
                        
                <li>
                    <a href="#problemi-di-virtualizzazione-io" aria-label="Problemi di virtualizzazione I/O">Problemi di virtualizzazione I/O</a></li>
                <li>
                    <a href="#single-root-io-virtualization" aria-label="Single Root I/O Virtualization">Single Root I/O Virtualization</a></li></ul>
                </li></ul>
                </li></ul>
                    
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>A seconda dell&rsquo;utilizzatore l‚ÄôOS pu√≤ essere molte cose, come solamente l‚Äôinterfaccia se sei un programmatore, servizi (se sei un utente, ma gran parte dei servizi sono astratti e l&rsquo;utente ne pu√≤ anche essere a non-conoscenza).</p>
<p>Ma se sei un programmatore OS ti interessa capire le componenti principali dell‚ÄôOS</p>
<ul>
<li>Slide componenti OS alto livello
<img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled"></li>
</ul>
<h2 id="introduzione-sui-componenti-salto">Introduzione sui componenti (salto)<a hidden class="anchor" aria-hidden="true" href="#introduzione-sui-componenti-salto">#</a></h2>
<p>Questa parte la salto perch√© √® una descrizione molto generale di cosa si occupa L‚Äôos verso drivers, processi, filesystem I/O, quindi non √® molto importante</p>
<h3 id="gestione-dei-processi">Gestione dei processi<a hidden class="anchor" aria-hidden="true" href="#gestione-dei-processi">#</a></h3>
<p>All&rsquo;interno del SO, il processo √® rappresentato come un <strong>processo control block</strong>, che in linux √® in <strong>sched</strong>, parte dello scheduler dei processi. Questo √® importante perch√© per esempio per fare una fork, non faccio altro che duplicare questa struttura e settare bene i figli e genitori.</p>
<p>Questi sono solitamente messi un un <strong>process table</strong> o forse una lista per tenerne traccia.</p>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 1.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 1">
</li>
</ul>
<p>nel parliamo in <a href="/notes/processi-e-thread">Processi e thread</a>.</p>
<h3 id="gestione-memoria-principale-e-secondaria">Gestione memoria principale e secondaria<a hidden class="anchor" aria-hidden="true" href="#gestione-memoria-principale-e-secondaria">#</a></h3>
<p><strong>Principale</strong></p>
<p>√à un array temporaneo(nel senso che non √® mantenuto quando viene spento il PC.), indicizzato singolarmente a differenza del secondario, che √® indicizzato a blocchi,</p>
<p>Una parte importante di questa parte √® la gestione della memoria virtuale. Come allocare pagine di memoria, deallocarle e simili, ne parliamo in <a href="/notes/paginazione-e-segmentazione">Paginazione e segmentazione</a></p>
<p><strong>Secondaria</strong></p>
<p>La cosa buona √® che questa memoria √® permanente, efficienza (ordinare le richieste per non andare qui e l√¨ quando si legge! <strong>minimizare tempi per seek</strong>) e partizionamento e reliability dei dischi sono problemi che interessano questa parte. Abbiamo parlato di raid in <a href="/notes/memoria">Memoria</a>. e di nuovo in <a href="/notes/devices-os">Devices OS</a>.</p>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 2.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 2">
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 3.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 3">
</li>
</ul>
<h3 id="io-e-filesystem">I/O e filesystem<a hidden class="anchor" aria-hidden="true" href="#io-e-filesystem">#</a></h3>
<p>Principalmente per IO servono driver per interagire con specifici hardware, e un sistema di comunicazione che spesso sono buffer e cache.</p>
<ul>
<li>
<p>Slides</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 4.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 4">
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 5.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 5">
</li>
</ul>
<p>Esiste un <strong>file system virtuale</strong> che mappa a tutto (quindi alcune cose non esistono realmente sul disco, potrebbe essere una astrazione utilizzata per esempio per comunicare con i devices.</p>
<p>Ci sono molti filesystem, che per√≤ posso gestire in modo differente la forma che hanno sul disco, Ed √® per questo che possiamo dire che esistono dei filesystem diversi.</p>
<p>Anche i processi sono files, la cosa figa di questa astrazioen √® che posso utilizzare gli stessi sistemi di protezione file per processi.</p>
<h2 id="struttura-dei-sistemi">Struttura dei sistemi<a hidden class="anchor" aria-hidden="true" href="#struttura-dei-sistemi">#</a></h2>
<h3 id="obiettivi-di-design-dei-so-4-">Obiettivi di design dei SO (4) üü®<a hidden class="anchor" aria-hidden="true" href="#obiettivi-di-design-dei-so-4-">#</a></h3>
<ul>
<li>
<p>Slide obiettivi nella struttura dei sistemi (4)</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 6.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 6">
</li>
<li>
<p>Efficienza</p>
</li>
<li>
<p>Modularit√†</p>
</li>
<li>
<p>Mantenibilit√†</p>
</li>
<li>
<p>Espansibilit√†</p>
</li>
</ul>
<h3 id="struttura-del-kernel-">Struttura del kernel üü©<a hidden class="anchor" aria-hidden="true" href="#struttura-del-kernel-">#</a></h3>
<ul>
<li>
<p>Slide riassuntiva</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 7.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 7">
</li>
</ul>
<p>Il kernel √® un unico processo, parte da un main che parte da un initialize in cui raccoglie tutte le risorse del sistema, fa partire tutti i device drivers e crea il PCB del primo processo, anche chiamato <strong>init</strong>, messo poi nella queue dello scheduler come spiegato in <a href="/notes/scheduler">Scheduler</a>. Fatta una volta non √® mai pi√π eseguito quel codice di init.</p>
<p>Lo stato kernel √® la parte a sinistra dell‚Äôimmagine, quella parte blu, tutto il giallo, a destra √® lo stato user.</p>
<ol>
<li>Scheduler scegliere il processo da eseguire nello user space</li>
<li>Il controllo √® passato al processo user, che pu√≤ fare traps (come fork) o fare I/O, a quel punto √® rimesso a codice kernel.</li>
</ol>
<h3 id="tipologie-di-struttura-os-2-">Tipologie di struttura OS (2) üü®++<a hidden class="anchor" aria-hidden="true" href="#tipologie-di-struttura-os-2-">#</a></h3>
<p>Solitamente i sistemi sono costruiti in due modi, sistemi <strong>semplici senza struttura</strong>, che praticamente c&rsquo;√® una prima versione, e poi viene ammassato roba senza struttura generale, fatti quando servono. Solitamente sono insieme di procedure che si chiamano fra di loro, e ben presto sono andate fuori dal loro ambito di interesse diciamo (fuori dal loro scope)</p>
<p><strong>Esempi di OS semplici:</strong></p>
<p>Un esempio √® <strong>free-dos</strong> che √® quanto installato su un computer senza sistema operativo.</p>
<p>In modo simile √® MS-DOS, che √® stato fatto per i primi personal computer, che non avevano un sistema kernel a livello hardware (non era quindi possibile fare queste protezioni).. In generale in questo ambiente un programma aveva accesso all&rsquo;intera memoria, e poteva mandare in crash tutto.</p>
<ul>
<li>
<p>Struttura Free-DOS</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 8.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 8">
</li>
</ul>
<p>UNIX, √® diviso diviso in due parti in kernel e programmi di sistemi, molto semplice, un kernel monolitico, un unico eseguibile, anche questo fu all‚Äôepoca limitato enormemente dal suo hardware, e una serie di programmi di sistema.</p>
<p>Dato che c&rsquo;√® una separazione, l‚Äôutente √® separato dall‚Äôinterfaccia dal codice kernel. Ma comunque il codice kernel resta vulnerabile, e potrebbe essere modificato e quindi attaccato, o cumunque vulnerabile a bug, anche colposi, distruttivi.</p>
<ul>
<li>
<p>Struttura UNIX</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 9.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 9">
</li>
</ul>
<p><strong>Stratificazione OS:</strong></p>
<p>La <strong>struttura a stati</strong> √® pi√π affidabile dell&rsquo;altra e rende pi√π facile la programmazione di tale sistema, utili, la logica √® la stessa presentata in <a href="/notes/architettura-e-livelli-1,-2">Architettura e livelli 1, 2</a>, per la divisione a stack del sistema e dei vantaggi che si hanno con questo tipo di architettura.</p>
<ul>
<li>
<p>Esemplificazione struttura a strati</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 10.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 10">
</li>
<li>
<p>Strutture proposte classiche (non fatte, non importanti)</p>
<p>Questi sono <strong>rimasti accademici</strong></p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 11.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 11">
</li>
</ul>
<p>Ma nella pratica questi strati sono rimasti solamente a livello accademico, perch√© <strong>crea overhead</strong> anche se si guadagnerebbe in manutentibilit√† e estensibilit√† e gestione, quindi molto meno efficiente, inoltre non erano ben chiare le API fra strati. Oggi c&rsquo;√® una forma intermedia (non c&rsquo;√® esattamente la gestione a strati come abbiamo per Web, ma abbiamo una divisione per componenti e responsabilit√† delle componenti).</p>
<h3 id="politiche-e-meccanismi-">Politiche e meccanismi üü©<a hidden class="anchor" aria-hidden="true" href="#politiche-e-meccanismi-">#</a></h3>
<p>La suddifivisione politiche e meccanismi √® un pattern di software engineering che lo rende molto comodo da gestire.</p>
<p>Invece che una gestione a strati come per le reti, abbiamo una gestione di <strong>politiche e meccanismi</strong> ossia abbiamo qualcosa che decide cosa andare a fare e qualcosa che gestisce il come farla.</p>
<p>EG. un certo modo di memoria allocata per fare qualcosa, quindi indirizzare il sistema verso qualcosa, e MMU che attualmente implementa la decisione politica.</p>
<p><strong>Esempio Microkernel o MINIX:</strong></p>
<p>Il kernel √® visto come il meccanismo quindi le parti di gestione e politica sono fuori dal kernel. Questo rende la struttura del SO molto mantenibile ed estendibile.</p>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 12.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 12">
</li>
</ul>
<p><strong>Esempio Mac OS ‚â§ 9 / Windows 9x:</strong></p>
<p>Politiche e meccanismi sono messi tutti nel kernel, perch√© cos√¨ imponevo un feeling unico al look and feel suo (obbligato tutti ad avere questi elementi grafici). Questo √® un problema praticamente di mercato.</p>
<p>Questo era brutto perch√© la grafica pu√≤ mandare in crash tutto il sistema. Anche se i nuovi sistemi non dovrebbero avere questo problema.</p>
<h3 id="categorizzazione-dei-kernel">Categorizzazione dei Kernel<a hidden class="anchor" aria-hidden="true" href="#categorizzazione-dei-kernel">#</a></h3>
<h4 id="monolitici">Monolitici<a hidden class="anchor" aria-hidden="true" href="#monolitici">#</a></h4>
<p>Il kernel √® un unico programma. Si possono creare moduli che poi vengono caricati. Il problema principale di questo tipo di kernel √® che se un modulo bugga crolla l&rsquo;intero sistema. Un vantaggio √® che √® molto efficiente perch√© non deve passare ad astrazioni come per lo stack, basta fare una chiamata di funzione, tanto siamo nello stesso programma. Ed √® altamente modularizzabile per poter attaccare nuove funzionalit√†.</p>
<p>In breve:</p>
<p>Vantaggi:</p>
<ul>
<li>Efficienza</li>
<li>Modularit√† e mantenibilit√† (non devo ricompilare tutto, basta runtime).</li>
</ul>
<p>Svantaggio:</p>
<ul>
<li>
<p>Un modulo pu√≤ mandare in crash tutto, perch√© √® eseguito nello stesso spazio del kernel.</p>
</li>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 13.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 13">
</li>
</ul>
<p>Esempi sono Linux o BSD.</p>
<h4 id="microkernel">Microkernel<a hidden class="anchor" aria-hidden="true" href="#microkernel">#</a></h4>
<p>L‚Äôobiettivo del microkernle √® isolare solamente le funzionalit√† essenziali e tenere solo quelli, tutto il resto interagisce con esso con system call (un esempio √® il filesystem che potrebbe essere fuori dal kernel, e avrebbe syscall leggermente diverse rispetto a quelle di linux, per aprire un file allora si chiederebbe a questo processo in user space, che poi fa altre richeste per kernel space)</p>
<p>Bisogna fare un messaggio, la syscall diventano Send! Che sarebbe unico modo per raggiungere il processo che offre il servizio che mi serve.</p>
<p>Vantaggi:</p>
<ul>
<li>Altissima modularit√† e mantenibilit√† del sistema e semplice da realizzare</li>
<li>Assenza di danni di sistema, perch√© moduli e kernel sono eseguiti in spazio differente.</li>
<li>Sicuro e affidabile per la divisione (non ho propagazione di errori e guasti)</li>
<li>Molto portabile, che ho solo il microkernel.</li>
</ul>
<p>Svantaggio:</p>
<ul>
<li>
<p>Fortemente Inefficienza rispetto al monolitico, che devo fare message passing e comunicazione.</p>
</li>
<li>
<p>Slide di comparazione</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 14.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 14">
</li>
</ul>
<h4 id="kernel-ibridi">Kernel Ibridi<a hidden class="anchor" aria-hidden="true" href="#kernel-ibridi">#</a></h4>
<p>Sono dei microkernel modificati, con qualcosa in pi√π forse (aziende per pubblicizzarsi dicevano di avere microkernel, ma con un ibridone, mettendo le cose inefficienti del microkernel dentro il kernel).</p>
<ul>
<li>
<p>Esempio windows</p>
<p>Ci sono diversi server, che fanno parte di un sottosistema d‚Äôambiente che √® in grado di emulare certe cose (sono nascoste le syscall reali del sistema cos√¨).</p>
<p>Il codice per un certo ambiente funziona anche nel sottosistema, un esempio √® un WSL.</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 15.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 15">
<p>La parte grafica importante per fare i videogiochi, √® dentro il kernel, questo ad esempio per MACOS, perch√© volevano imporre la grafica simile</p>
</li>
</ul>
<h2 id="macchine-virtuali">Macchine virtuali<a hidden class="anchor" aria-hidden="true" href="#macchine-virtuali">#</a></h2>
<blockquote>
<p>The fundamental idea behind a virtual machine is to abstract the hardware
of a single computer (the CPU, memory, disk drives, network interface cards,
and so forth) into several different execution environments, thereby creating
the illusion that each separate environment is running on its own private
computer. <a href="https://books.google.ch/books/about/Operating_System_Concepts.html?id=FHJlDwAAQBAJ&redir_esc=y">(Silberschatz et al. 2018)</a>.</p></blockquote>
<blockquote>
<p>Virtualization allows a single computer to host multiple virtual machines, each potentially running a completely different operating system.</p></blockquote>
<p>√à virtuale nel senso che la macchina virtuale ha la stessa percezione della realt√† di una macchina reale. Qualcosa che non √® la realt√† ma appare molto simile ad essa.</p>
<p>Storicamente parlando le macchine virtuali erano un primo approccio al multitasking.</p>
<p>L‚Äôidea principale √® creare un sistema che possa apparire al sistema operativo come hardware, in questo modo posso utilizzare un programma per emulare un altro sistema operativo. √à <strong>hypervisor, VMM (virtual machine monitor)</strong>.</p>
<p>Ovviamente ho uno fortissimo svantaggio in velocit√†, perch√© la simulazione software √® molto meno efficiente della simulazione hardware. Un collegamento carino √® con <a href="https://psycnet.apa.org/record/2007-01197-000">(Hofstadter 2007)</a>, una macchina che sia abbastanza espressiva da poter emulare s√© stesso.</p>
<h3 id="analisi-vantaggi-svantaggi-">Analisi vantaggi svantaggi üü®<a hidden class="anchor" aria-hidden="true" href="#analisi-vantaggi-svantaggi-">#</a></h3>
<img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 16.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 16">
<ul>
<li>Posso avere sistemi operativi differenti sulla stessa macchina o SO, quindi posso sperimentarli senza installarli veramente.</li>
<li>Posso simulare architetture differenti, e quindi supporre di avere istruzioni differenti di architettura altra!</li>
<li>SO monotask in sistemi multitask.</li>
<li>Maggiore sicurezza a bug software, √® efficienza energetica.</li>
</ul>
<p><strong>Svantaggi</strong>:</p>
<ol>
<li>fortemente inefficiente
<ol>
<li>Peso in pi√π sia sulla memoria</li>
<li>Context Switch molto frequenti che lo rendono pi√π lento</li>
<li>I/O lento.</li>
</ol>
</li>
<li>Difficile condividere risorse fra una macchina virtuale o all&rsquo;altra.</li>
</ol>
<h4 id="desiderata-per-virtualizzazione">Desiderata per virtualizzazione<a hidden class="anchor" aria-hidden="true" href="#desiderata-per-virtualizzazione">#</a></h4>
<p>Chiamiamo le propriet√† di <strong>partizionamento</strong>:</p>
<ul>
<li><strong>Condividere</strong> le risorse della stessa macchina</li>
<li><strong>Isolare</strong> le macchine diverse, in modo che non possano influenzarsi a livello software, in modo da creare la giusta simulazione, esattamente come macchine fisiche reali, che non possono comunicare fra di loro.</li>
</ul>
<p>E la <strong>incapsulazione</strong>, con controllo completo di checkpointing, migrazione e replay.
Nel caso di servizi cloud, avere queste desiderata rende possibile andare a copiare i dati in giro e riprendere l&rsquo;esecuzione in un altro hardware, vedere <a href="/notes/cloud-computing-services">Cloud Computing Services</a>.</p>
<p><strong>Desiderata principale</strong>:</p>
<ul>
<li><strong>Efficienza</strong>: la virtualizzazione non deve essere troppo lenta, altrimenti non ha senso.</li>
<li><strong>Compatibilit√†</strong>: deve essere compatibile con il software esistente (deve eseguire allo stesso modo in macchina virtualizzata o meno).</li>
<li><strong>Isolamento</strong>: le macchine virtuali devono essere isolate fra di loro.</li>
</ul>
<h4 id="virtualizzazione-di-popek-and-goldberg">Virtualizzazione di Popek and Goldberg<a hidden class="anchor" aria-hidden="true" href="#virtualizzazione-di-popek-and-goldberg">#</a></h4>
<p>Nel 1974 Popek e Goldberg hanno definito i requisiti per la virtualizzazione, che sono:</p>
<ul>
<li>Devono esistere una modilit√† kernel and user.</li>
<li>Tutte le istruzioni sensibili devono essere istruzioni <strong>privilegiate</strong>.
<ul>
<li>Le istruzioni sensibili sono quelle che cambiano lo stato a livello hardware (allocazioni, mappature)</li>
<li>Le istruzioni privilegiate sono quelle che usano trap.</li>
</ul>
</li>
</ul>
<p>Al tempo il processore Intel x86 non era virtualizzabile, perch√© certe istruzioni sensibili (sensitive) non aveva istruzioni privilegiate, e quindi non poteva essere virtualizzato.
Per esempio il registro %cs conteneva il livello di privilegio, e non poteva essere virtualizzato (esempio se OS pusha quel registro sulla stack, si dovrebbe aspettare il massimo livello di privilegio), dato che il VMM non poteva catturare la trap ed emulare l&rsquo;istruzione, non era possibile virtualizzare questa operazione.
Per questo usiamo binary translation per questo, ma impatta leggermente la velocit√† di esecuzione.</p>
<h3 id="livello-processo-o-sistema-">Livello processo o sistema üü©<a hidden class="anchor" aria-hidden="true" href="#livello-processo-o-sistema-">#</a></h3>
<p>Le macchine virtuali di cui abbiamo parlato ora virtualizzano solamente l‚Äôhardware, cio√® fa finta di avere un sistema hardware.</p>
<p>Mentre altre macchine virtuali provano a virtualizzare a livello di ABI (application binary interface) (che √® livello di processo).</p>
<ul>
<li>Macchina virtuale a livello di processo (<strong>process VM)</strong>: permette ad un programma di essere eseguito allo stesso modo su qualsiasi piattaforma. Un esempio di questo √® la macchina virtuale di Java.
Viene eseguita come una normale applicazione all&rsquo;interno di un SO ospite e supporta un singolo processo. Il suo scopo √® fornire un ambiente indipendente dalla piattaforma hardware e dal SO ospite. Vengono virtualizzati sia l‚Äôhardware che il sistema operativo.</li>
<li>Macchina virtuale a livello di sistema (<strong>system VM</strong>): permette l&rsquo;esecuzione di un completo SO, anche con un ISA diverso da quello della macchina reale. Viene virtualizzato esclusivamente e completamente <strong>l‚Äôhardware</strong>.</li>
</ul>
<h4 id="differenza-type-1-and-2-hypervisors">Differenza type 1 and 2 hypervisors<a hidden class="anchor" aria-hidden="true" href="#differenza-type-1-and-2-hypervisors">#</a></h4>
<p>type 1 hypervisor and a type 2 hypervisor is that a type 2 makes uses of a host operating system and its file system to create processes, store files, and so on. A type 1 hypervisor has no underlying support and must perform all these functions itself (it runs on the bare metal, come se fosse lui stesso un sistema operativo, √® infatti un sistema operativo che non fa altro che fare sistemi operativi!)</p>
<p>Esistono anche type 0 hypervisors che sono direttamente supporto per macchine virtuali fatte a livello hardware. Esempi di questo sono IBM LPARs and Oracle LDOMs.</p>
<h4 id="virtual-machine-monitor">Virtual Machine Monitor<a hidden class="anchor" aria-hidden="true" href="#virtual-machine-monitor">#</a></h4>
<p>Questo √® quello che viene chiamato anche type 1 hypervisor. √à un sistema operativo che gestisce altri sistemi operativi che eseguono sopra di esso. Chi sta sopra pensa di possedere l&rsquo;intero hardware, mentre in realt√† √® la VMM che prova a tradurre o mandare di sotto.</p>
<h3 id="virtualizzatori">Virtualizzatori<a hidden class="anchor" aria-hidden="true" href="#virtualizzatori">#</a></h3>
<p>In questa sezione introduciamo alcuni eventi di virtualizzatori.</p>
<h4 id="qemu-">Qemu üü©<a hidden class="anchor" aria-hidden="true" href="#qemu-">#</a></h4>
<p><strong>qemu</strong> √® un traduttore dinamico come se fosse un compilatore fra una architettura in una altra, fatta a runtime (quindi √® un interprete, tipo 10x pi√π lento rispetto esecuzione normale, ma un ordine di grandezza pi√π veloce rispetto altri emulatori).</p>
<p>Con qemu posso anche dire al processo emulato di utilizzare il mio stesso kernel, nel caso che condivida l&rsquo;architettura, questo rende la cosa molto pi√π veloce del normale! e.g. KVM (che √® il nome dell‚ÄôHypervisor per linux). Questo √® anche una tipologia di <strong>type-2-hypervisor</strong> perch√© attingo al kernel della macchina ospite per fare funzionare pi√π in fretta, e non faccio simulazione sistema totale.</p>
<p>Utile o per runnare programmi per architettura differente (in questo senso program VM), oppure per emulare un sistema operativo dentro un sistema operativo.</p>
<ul>
<li>
<p>Comando per caricare una macchina virtuale con qemu e utilizzare KVM
<img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 17.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 17"></p>
<p>senza vga, non starebbe sullo schermo senza quella flag.
hda gli specifica il file con cui emulare il disco, k il layout del keyboard
m √® la memoria ram
monitor √® per poter mandare interrupt dal terminale in cui ho lanciato il mio comando di emulazione.
Quando installa prima √® installato nella RAM disk, e poi viene utilizzato per l‚Äôinstallazione vera e propria.</p>
</li>
</ul>
<h4 id="xen-">XEN üü©<a hidden class="anchor" aria-hidden="true" href="#xen-">#</a></h4>
<p>XEN √® hypervisor livello 1 (SO che permette di fare altri SO virtuali), e utilizzare paravirtualizzazione (si fanno trap and emulate principalmente) , e utilizza una gestione diversa dei drivers che possiede, ossia il <strong>Domain0</strong> possiede tutti i drivers fisici (le interazioni con i device le manda alla macchina 0, perch√© per restare un sistema operativo semplice non riesce a gestire sistemi operativi).</p>
<p><strong>Esempio di maggiore efficienza</strong></p>
<p>Per il type 2 hypervisor il SO installato pensa veramente di stare in una macchina s√©, quindi fa cose per minimizzare i seek del disco ma in questo caso non deve fare veramente seek, quindi √® meno efficiente, facendo una assunzione errata.</p>
<p>Si utilizzano paravirtualizzazione, ossia devices virtuali pi√π efficienti per questa cosa, ed effettivamente non assumo di stare utilizzando device fisici, ma sono a conoscenza di utilizzare device virtuali, e posso fare ottimizzazioni del caso (che non so quali siano forse per il disco non faccio cose strane per il seek ad esempio).</p>
<p>Il problema √® che essendo a conoscenza, dovrei fare il mio SO in modo che sia compatibile con le hyper all offerte dall hypervisor</p>
<h3 id="implementazione-della-virtualizzazione">Implementazione della Virtualizzazione<a hidden class="anchor" aria-hidden="true" href="#implementazione-della-virtualizzazione">#</a></h3>
<h4 id="metodi-di-virtualizzazione">Metodi di virtualizzazione<a hidden class="anchor" aria-hidden="true" href="#metodi-di-virtualizzazione">#</a></h4>
<p>Possiamo considerare tre metodi principali di virtualizzazione:</p>
<ul>
<li>Simulazione via software sull&rsquo;host (molto molto lento, tipo 100x volte pi√π lento)
<ul>
<li>Un esempio √® QEMU in full emulation.</li>
</ul>
</li>
<li>Esecuzione diretta
<ul>
<li>Trap and emulate in cui il VMM intercetta il trap ed esegue l&rsquo;istruzione equivalente</li>
<li>Emulazione con supporto hardware
<ul>
<li>come con le estensioni <strong>Intel VT-x</strong> e <strong>AMD-V</strong>.</li>
<li>Questo √® il metodo pi√π utilizzato oggi giorno.</li>
<li>Vedi sezione di istruzioni di virtualizzazione.</li>
<li>Add <strong>Virtual Machine Control Structure</strong> (VMCS) che decide quali istruzioni fanno VMexit, e quando si pu√≤ cambiare queste informazioni con VMread or write e simili, consentendo all‚Äôhypervisor di controllare il comportamento della VM.</li>
</ul>
</li>
<li>Dynamic binary translation
<ul>
<li>Necessario quando l&rsquo;hardware non √® totalmente virtualizzabile, quindi introduce delle istruzioni di emulazione in pi√π.</li>
</ul>
</li>
</ul>
</li>
<li>Paravirtualizzazione
<ul>
<li>In questo caso il SO virtuale √® a conoscenza che esiste un hypervisor quindi pu√≤ fare delle <strong>hypercall</strong> per eseguire delle istruzioni sensitive, e in generale √® un approccio pi√π veloce invece della virtualizzazione totale di cui abbiamo parlato prima. Per√≤ bisogna essere a conoscenza del hypervisor.</li>
<li>Quindi andiamo a modificare parti del SO in modo da tenere in considerazione l‚Äôesistenza dell‚Äôhypervisor, rende pi√π veloce, per√≤ bisogna andare a modificare il SO stesso, per ogni SO.</li>
<li>Un esempio √® XEN.</li>
</ul>
</li>
</ul>
<h4 id="parametrizzazione-so-">Parametrizzazione SO üü©<a hidden class="anchor" aria-hidden="true" href="#parametrizzazione-so-">#</a></h4>
<p>Questo non √® proprio un metodo di virtualizzazione di un Sistema Operativo, ma un modo per modificare leggermente alcuni sistemi operativi.</p>
<p>Essendo libero linux, √® molto comodo poter cambiare alcuni parametri e poi <strong>ricompilare il kernel seguendo quei parametri</strong>. Tanto √® tutto open source, quindi si potrebbe fare. Questo permette al kernel di essere molto portabile.</p>
<p>Una cosa molto importante da capire √® che <strong>il kernel √® una cosa diversa della distribuzione</strong>, il kernel √® il primo programma che viene caricato dal bootloader e carica il FS e tutto il resto (quindi le cose iniziali), il secondo sono tutte le utility per il kernel che lo rendono utilizzabile da un utente normale.</p>
<ul>
<li>
<p>Comando runnato per la emulazione kernel/distribuzione</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 18.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 18">
</li>
<li>
<p>Slide parametrizzazione ++ portabilit√† (che deve runnare per hardware differentI)</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 19.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 19">
</li>
</ul>
<h4 id="istruzioni-di-virtualizzazione-">Istruzioni di virtualizzazione üü•<a hidden class="anchor" aria-hidden="true" href="#istruzioni-di-virtualizzazione-">#</a></h4>
<p>Abbiamo aggiunto delle istruzioni di emulazione come <code>VMX ON, VMX OFF, VMLAUNCH, VMRETURN</code>  in cui il processore sa di stare emulando, e quindi √® pi√π veloce perch√© esegue l&rsquo;istruzione in altro modo, forse con istruzione nativa. Pagina <a href="https://en.wikipedia.org/wiki/X86_virtualization">wiki</a>
fa pensare di essere in kernel mode, ma non √® in kernel mode, √® come se stesse in un livello di priviliegio intermedio.</p>
<p>VMLAUNCH</p>
<p>Queste sono quelle principali istruzioni che permettono la virtualizzazioen a livello software, il fatto che rende l&rsquo;esecuzione molto pi√π veloce, quindi invece di simulare tutto sopra il sistema operativo attuale (e syscalls attuali) posso accedere ad istruzioni hardware molto pi√π veloci.</p>
<h3 id="memoria-virtuale">Memoria Virtuale<a hidden class="anchor" aria-hidden="true" href="#memoria-virtuale">#</a></h3>
<p>C&rsquo;√® una MMU del sistema operativo che mappa alla VM fisica, che si deve basare all&rsquo;indirizzo logico, che deve essere risolto dalla MMU reale fino ad avere un indirizzo fisico.</p>
<img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 20.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 20">
#### Shadow Page Tables
<p>Permettono di evitare l&rsquo;utilizzo di <strong>Shadow page tables</strong>, che sono il remapping della pagine virtuali con le pagine fisiche.
Ci sono esattamente lo stesso numero di pagine nei sistemi operativi virtuali con il numero di pagine nel shadow page table.
Esiste molto overhead di memoria per quanto riguarda questa parte.</p>
<h4 id="extended-page-tables">Extended Page Tables<a hidden class="anchor" aria-hidden="true" href="#extended-page-tables">#</a></h4>
<p>Abbiamo in pratica una sezione di traduzione in pi√π per mapparlo a EPT (Extended Page Tables), che mappa le pagine virtuali con le pagine fisiche, e quindi non c&rsquo;√® overhead di memoria, e quindi √® molto pi√π efficiente in comparazione con le shadow page tables.</p>
<img src="/images/notes/Architettura software del OS-20250226132408095.webp" style="width: 100%" class="center" alt="Architettura software del OS-20250226132408095">
<h3 id="virtualizzazione-di-io">Virtualizzazione di I/O<a hidden class="anchor" aria-hidden="true" href="#virtualizzazione-di-io">#</a></h3>
<h4 id="problemi-di-virtualizzazione-io">Problemi di virtualizzazione I/O<a hidden class="anchor" aria-hidden="true" href="#problemi-di-virtualizzazione-io">#</a></h4>
<p>Si ricorda  in <a href="/notes/devices-os">Devices OS</a> che solitamente questi usano Direct Memory Access per scrivere per il sistema operativo, per√≤ questo spesso non √® possibile e bisogna fare qualche interrupt virtuale per risolvere questo problema.
Possiamo</p>
<ul>
<li>Para virtualizzare l&rsquo;interfaccia del device</li>
<li>Emulare il device I/O.</li>
</ul>
<h4 id="single-root-io-virtualization">Single Root I/O Virtualization<a hidden class="anchor" aria-hidden="true" href="#single-root-io-virtualization">#</a></h4>
<p>SR-IOV enables <strong>hardware-assisted virtualization</strong> by partitioning a single PCIe device into multiple <strong>Virtual Functions (VFs)</strong>, which can be assigned directly to virtual machines (VMs) or containers. This reduces overhead caused by traditional software-based I/O virtualization.</p>
<p><strong>Key Components of SR-IOV:</strong></p>
<ol>
<li><strong>Physical Function (PF)</strong>
<ul>
<li>The main PCIe function, fully featured, controlled by the host OS (hypervisor).</li>
<li>Manages and configures the Virtual Functions.</li>
</ul>
</li>
<li><strong>Virtual Functions (VFs)</strong>
<ul>
<li>Lightweight PCIe functions with limited resources, assigned to VMs or containers.</li>
<li>Each VM gets direct access to a VF, bypassing the hypervisor for performance gains.</li>
</ul>
</li>
</ol>
<h1 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h1>
<p>[1] Hofstadter <a href="https://psycnet.apa.org/record/2007-01197-000">‚ÄúI Am a Strange Loop‚Äù</a> Basic Books 2007</p>
<p>[2] Silberschatz et al. <a href="https://books.google.ch/books/about/Operating_System_Concepts.html?id=FHJlDwAAQBAJ&redir_esc=y">‚ÄúOperating System Concepts‚Äù</a> Wiley 2018</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/sistemi-operativi/">Sistemi-Operativi</a></li>
      <li><a href="https://flecart.github.io/tags/cloud-computing/">‚òÅCloud-Computing</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Architettura software del OS on x"
            href="https://x.com/intent/tweet/?text=Architettura%20software%20del%20OS&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-software-del-os%2f&amp;hashtags=sistemi-operativi%2c%e2%98%81cloud-computing">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Architettura software del OS on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-software-del-os%2f&amp;title=Architettura%20software%20del%20OS&amp;summary=Architettura%20software%20del%20OS&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-software-del-os%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Architettura software del OS on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-software-del-os%2f&title=Architettura%20software%20del%20OS">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Architettura software del OS on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-software-del-os%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Architettura software del OS on whatsapp"
            href="https://api.whatsapp.com/send?text=Architettura%20software%20del%20OS%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-software-del-os%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Architettura software del OS on telegram"
            href="https://telegram.me/share/url?text=Architettura%20software%20del%20OS&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-software-del-os%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Architettura software del OS on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Architettura%20software%20del%20OS&u=https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-software-del-os%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span> ¬∑ 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
