<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Time and Space Complexity | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="theoretical-computer-science">
<meta name="description" content="In this note we explore a theme of time and space complexity. Those are cardinal themes in Theoretical CS.
Time -&gt; execution step bounds on algorithms
Space -&gt; the cells visited by a Turing Machine when executed.
Introduction to Time Complexity
This note will build upon know techniques of algorithms analysis explained in Notazione Asintotica.
We will need big-$O$ notation and $o$ notation.
L&rsquo;idea √® che il problema di decisione √® decidibile se limito la lunghezza del teorema.
Simile al numero di Chaitin, che non √® computabile, ma √® approssimabile quanto si vuole. In un certo senso √® computabile.
The general idea is to ask how the function $\varphi$ that maps the longest $n$ proof to the number of steps of computation behaves.">
<meta name="author" content="Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="https://flecart.github.io/notes/time-and-space-complexity/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/time-and-space-complexity/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>
<script type="text/javascript" async
src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>






      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-WW6NN2QGKF');
        }
      </script><meta property="og:url" content="https://flecart.github.io/notes/time-and-space-complexity/">
  <meta property="og:site_name" content="X. Angelo Huang&#39;s Blog">
  <meta property="og:title" content="Time and Space Complexity">
  <meta property="og:description" content="In this note we explore a theme of time and space complexity. Those are cardinal themes in Theoretical CS. Time -&gt; execution step bounds on algorithms Space -&gt; the cells visited by a Turing Machine when executed.
Introduction to Time Complexity This note will build upon know techniques of algorithms analysis explained in Notazione Asintotica. We will need big-$O$ notation and $o$ notation. L‚Äôidea √® che il problema di decisione √® decidibile se limito la lunghezza del teorema. Simile al numero di Chaitin, che non √® computabile, ma √® approssimabile quanto si vuole. In un certo senso √® computabile. The general idea is to ask how the function $\varphi$ that maps the longest $n$ proof to the number of steps of computation behaves.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="notes">
    <meta property="article:tag" content="Theoretical-Computer-Science">
      <meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:title" content="Time and Space Complexity">
<meta name="twitter:description" content="In this note we explore a theme of time and space complexity. Those are cardinal themes in Theoretical CS.
Time -&gt; execution step bounds on algorithms
Space -&gt; the cells visited by a Turing Machine when executed.
Introduction to Time Complexity
This note will build upon know techniques of algorithms analysis explained in Notazione Asintotica.
We will need big-$O$ notation and $o$ notation.
L&rsquo;idea √® che il problema di decisione √® decidibile se limito la lunghezza del teorema.
Simile al numero di Chaitin, che non √® computabile, ma √® approssimabile quanto si vuole. In un certo senso √® computabile.
The general idea is to ask how the function $\varphi$ that maps the longest $n$ proof to the number of steps of computation behaves.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Time and Space Complexity",
      "item": "https://flecart.github.io/notes/time-and-space-complexity/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Time and Space Complexity",
  "name": "Time and Space Complexity",
  "description": "In this note we explore a theme of time and space complexity. Those are cardinal themes in Theoretical CS. Time -\u0026gt; execution step bounds on algorithms Space -\u0026gt; the cells visited by a Turing Machine when executed.\nIntroduction to Time Complexity This note will build upon know techniques of algorithms analysis explained in Notazione Asintotica. We will need big-$O$ notation and $o$ notation. L\u0026rsquo;idea √® che il problema di decisione √® decidibile se limito la lunghezza del teorema. Simile al numero di Chaitin, che non √® computabile, ma √® approssimabile quanto si vuole. In un certo senso √® computabile. The general idea is to ask how the function $\\varphi$ that maps the longest $n$ proof to the number of steps of computation behaves.\n",
  "keywords": [
    "theoretical-computer-science"
  ],
  "articleBody": "In this note we explore a theme of time and space complexity. Those are cardinal themes in Theoretical CS. Time -\u003e execution step bounds on algorithms Space -\u003e the cells visited by a Turing Machine when executed.\nIntroduction to Time Complexity This note will build upon know techniques of algorithms analysis explained in Notazione Asintotica. We will need big-$O$ notation and $o$ notation. L‚Äôidea √® che il problema di decisione √® decidibile se limito la lunghezza del teorema. Simile al numero di Chaitin, che non √® computabile, ma √® approssimabile quanto si vuole. In un certo senso √® computabile. The general idea is to ask how the function $\\varphi$ that maps the longest $n$ proof to the number of steps of computation behaves.\nRobustness of the notion of time complexityüü® The notion of ‚Äúcomputational steps‚Äù used to measure the time complexity varies along\nComputational models definition of computational steps The code of the input and output (not always binary, for example big numbers are not fixed size). Influence of the Computational Model In Complexity Theory the choice of the formal model influences the complexity class of the model! This is different from the argument from computational theory of the Church Turing Thesis, where it asserts that a function is computable in every computational model. See 7.7 in (Sipser 2012).\nMulti-tape vs single-tape TM It can be proved that every $t(n)$ time multi-tape TM can be simulated by a $t^{2}(n)$ single tape TM. See Theorem 7.8 of (Sipser 2012).\nThe Time Complexity Class Definition of the Time Complexity Classüü© Languages that are decidable in $O(t(n))$ time are part of this class, denoted as $TIME(t(n))$. With $t : \\mathbb{N} \\to \\mathbb{R}^{+}$.\nAnother way to understand this is that if a algorithms terminates in at most $t(n)$ steps then it belongs to this class.\nPolynomial Complexity Classüü© $$ P = \\bigcup_{i \\geq 1} TIME(n^{i}) $$ This is defined as the class of the reasonable efficiency programs. NOTE: this is invariant with respect to the chosen coding system (if an algorithm is still in P, then it will remain in P even if you change code scheme).\nP is invariant for all models of computation that are polynomially equivalent to the deterministic single-tape Turing machine, and P roughly corresponds to the class of problems that are realistically solvable on a computer. $$ EXP = \\bigcup_{i \\geq 1} TIME(2^{n^{i}}) $$ See later.\nPATH is in Püü© We can prove that the language $\\left\\{ \\langle G, s, t \\rangle \\mid G \\text{ is a graph that has a route from } s \\text{ to } t \\right\\}$ is in $P$ class. (Just use Grafi#BFS or Grafi#DFS).\nNOTE: we have worked assuming that the algorithm worked on the nodes, but usually TM work with bits, the thing is that there is a polynomial algo that converts that nodes into binary format, so it is not much of a big deal.\nOverview of problems in $P$ Exponential Complexity Classüü© $$ EXP = \\bigcup_{i\\geq 1} TIME(2^{n^{i}}) $$ This class is common of the algorithms that use backtracking, for example Costraint Satisfaction Problems. Or just brute-force search all the branches.\nNon-deterministic Complexity Class Let $N$ be a non-deterministic decider (which means that the TM will halt on every computation branch) then we have that a problem is in this complexity class, called $NTIME$ if the running time cost $f: \\mathbb{N} \\to \\mathbb{N}$ is bounded by that (longest computational branch). The difference with #Polynomial Complexity Class is that here we consider the length of a single branch, but we explore everything at the same time!\nQuindi\n$$ NP = \\bigcup_{i\\geq 1} NTIME(n^{k}) $$Simulation by Deterministic TM We can prove that every TM in NP can be simulated by a deterministic machine in $2^{Ot(n)}$ time, where $t(n)$ is the complexity class of the TM. The intuition is easy, just try every possible computational branch, and see for the result. We then observe that $NP \\subseteq EXP$ but this is not so useful.\nClique problem See Common problems in Theoretical CS#The Clique problem for description of the problem.\nNP algorithm Just\nSelect a subset of nodes from $G$. Do it non deterministically. Verify if this subset is a complete graph. If yes add it to the solution set. We can prove that this is correct, and it works, but it is a non deterministic algorithm, so it isn‚Äôt easily simulated by deterministic algorithms, even though we proved in Estensioni di Turing e altre macchine that from the computability point of view it is the same.\nVerifiable Given input the graph, and a subset, we need to\nFor each node in the subset, check if it is linked to each other. Return the previous truth result. So easy. Other NP-complete problems If you have some time, you should give a proof for each problem (poly-reduction from sat)\nVertex Cover Hamiltonian paths Undirected Hamiltonian paths Subset-sum Verifiability Def: verifiability $$ w \\in A \\iff \\exists c : M \\text{ accepts } \\langle w, c \\rangle $$ If $M$ is polynomial then we say that this is polynomially verifiable. We can prove that this notion is equivalent for $NP$ complexity classes. We also require that $c$ is of polynomial length.\nTh: Verifiability = NPüü© From a philosophical point of view, if a problem is in NP, we can just guess a solution, or just do brute force. There is no classical algorithmical solution that solves it, or a constructive proof for it.\n$\\leftarrow$: let‚Äôs suppose we have a $M$ that decides non deterministically that language. On input $\\langle w, c \\rangle$ we run $M(w)$ and if it accepts, return true if the branch is good. ($c$ guides us about what non-deterministic branch to choose).\n$\\to$ : let‚Äôs assume we have a polynomial verifier, we need to build a TM that decides it non deterministically in polynomial time. choose non deterministically a certificate $c$ the encodes the path of the non-deterministic computation. If this accepts then accept!\nPhilosophical thoughts on P vs NP Intuitively we can have this intuition: The class of problems in $P$ is the class of problems were you need to come up with a solution by yourself. The class of problems in $NP$ is the class of problems were you just need to verify if a given solution is valid. From a personal human point of view this clearly seem to indicate that the two classes are different. But we have no proof.\nIf P were equal to NP, then the world would be a profoundly different place than we usually assume it to be. There would be no special value in ‚Äúcreative leaps‚Äù, no fundamental gap between solving a problem and recognizing the solution once it‚Äôs found. Everyone who could appreciate a symphony would be Mozart; Everyone who could follow a step-by-step argument would be Gauss.\n‚Äì Prof. Scott Aaronson, 2006\nSpace complexity terminology Def: space complexity Given a $\\mathcal{M}$ Turing Machine that halts on every input, then his space complexity is a function $t : \\mathbb{N} \\to \\mathbb{N}$ such that $t(n)$ is the maximum number of cells visited by $\\mathcal{M}$ on inputs of length $n$. We can say something very similar for the non-deterministic TM, se way that its space complexity is the maximum number of tape cells visited on a single computational branch.\nDef: Space complexity Class We define the space complexity class $SPACE(t(n))$ as all languages decidable by a TM in $O(t(n))$ space. Analogously the $NSPACE(t(n))$ complexity class is defined. We use a non-deterministic TM here.\n$$ P \\subseteq NP \\subseteq PSPACE = NPSPACE \\subseteq EXPTIME $$ The last subset is given by an observation that a TM that uses $f(n)$ space (PSPACE) cannot have more than $f(n)2^{O(f(n))}$ computational steps before looping. Def: PSPACE and NPSPACE $$ PSPACE = \\bigcup_{k}SPACE(n^{k}) $$$$ NPSPACE = \\bigcup_{k} NSPACE(n^{k}) $$Def: PSPACE-completeness We say that $L$ is PSPACE-complete if it is $\\in PSPACE$ and every other $L' \\in PSPACE$ is poly-reducible to it.\nTh: $NP \\in PSPACE$ In order to prove this we prove that $SAT \\in PSPACE$ because as it is $NP-complete$ every NP problem can be reduced to $SAT$ and so it is in $PSPACE$. For more about SAT see Common problems in Theoretical CS#The SAT problem.\nProof of SAT in PSPACE We note that the simple algorithm that just enumerates all possible assignments is in $PSPACE$. Consider this algorithm: For all assignments for the input boolean formula do:\nAssign it and verify in poly-time if it is ok. If ok return true else continue until every assignment is used. We note that just $O(m)$ space is used, where $m$ is the number of terms. All the computation could be done in polynomial space, so the problem is in PSPACE. $\\square$. References [1] Sipser ‚ÄúIntroduction to the Theory of Computation‚Äù Cengage Learning 2012\n",
  "wordCount" : "1461",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/time-and-space-complexity/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;¬ª&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Time and Space Complexity
    </h1>
    <div class="post-meta">7 min&nbsp;¬∑&nbsp;Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul><ul>
                <li>
                    <a href="#introduction-to-time-complexity" aria-label="Introduction to Time Complexity">Introduction to Time Complexity</a><ul>
                        
                <li>
                    <a href="#robustness-of-the-notion-of-time-complexity" aria-label="Robustness of the notion of time complexityüü®">Robustness of the notion of time complexityüü®</a></li>
                <li>
                    <a href="#influence-of-the-computational-model" aria-label="Influence of the Computational Model">Influence of the Computational Model</a><ul>
                        
                <li>
                    <a href="#multi-tape-vs-single-tape-tm" aria-label="Multi-tape vs single-tape TM">Multi-tape vs single-tape TM</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#the-time-complexity-class" aria-label="The Time Complexity Class">The Time Complexity Class</a><ul>
                        
                <li>
                    <a href="#definition-of-the-time-complexity-class" aria-label="Definition of the Time Complexity Classüü©">Definition of the Time Complexity Classüü©</a></li>
                <li>
                    <a href="#polynomial-complexity-class" aria-label="Polynomial Complexity Classüü©">Polynomial Complexity Classüü©</a><ul>
                        
                <li>
                    <a href="#path-is-in-p" aria-label="PATH is in Püü©">PATH is in Püü©</a></li>
                <li>
                    <a href="#overview-of-problems-in-p" aria-label="Overview of problems in $P$">Overview of problems in $P$</a></li></ul>
                </li>
                <li>
                    <a href="#exponential-complexity-class" aria-label="Exponential Complexity Classüü©">Exponential Complexity Classüü©</a></li>
                <li>
                    <a href="#non-deterministic-complexity-class" aria-label="Non-deterministic Complexity Class">Non-deterministic Complexity Class</a><ul>
                        
                <li>
                    <a href="#simulation-by-deterministic-tm" aria-label="Simulation by Deterministic TM">Simulation by Deterministic TM</a></li>
                <li>
                    <a href="#clique-problem" aria-label="Clique problem">Clique problem</a></li>
                <li>
                    <a href="#other-np-complete-problems" aria-label="Other NP-complete problems">Other NP-complete problems</a></li></ul>
                </li>
                <li>
                    <a href="#verifiability" aria-label="Verifiability">Verifiability</a><ul>
                        
                <li>
                    <a href="#def-verifiability" aria-label="Def: verifiability">Def: verifiability</a></li>
                <li>
                    <a href="#th-verifiability--np" aria-label="Th: Verifiability = NPüü©">Th: Verifiability = NPüü©</a></li>
                <li>
                    <a href="#philosophical-thoughts-on-p-vs-np" aria-label="Philosophical thoughts on P vs NP">Philosophical thoughts on P vs NP</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#space-complexity-terminology" aria-label="Space complexity terminology">Space complexity terminology</a><ul>
                        
                <li>
                    <a href="#def-space-complexity" aria-label="Def: space complexity">Def: space complexity</a></li>
                <li>
                    <a href="#def-space-complexity-class" aria-label="Def: Space complexity Class">Def: Space complexity Class</a></li>
                <li>
                    <a href="#def-pspace-and-npspace" aria-label="Def: PSPACE and NPSPACE">Def: PSPACE and NPSPACE</a></li>
                <li>
                    <a href="#def-pspace-completeness" aria-label="Def: PSPACE-completeness">Def: PSPACE-completeness</a></li></ul>
                </li>
                <li>
                    <a href="#th-np-in-pspace" aria-label="Th: $NP \in PSPACE$">Th: $NP \in PSPACE$</a><ul>
                        <ul>
                        
                <li>
                    <a href="#proof-of-sat-in-pspace" aria-label="Proof of SAT in PSPACE">Proof of SAT in PSPACE</a></li></ul>
                    </ul>
                </li></ul>
                    
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>In this note we explore a theme of time and space complexity. Those are cardinal themes in Theoretical CS.
Time -&gt; execution step bounds on algorithms
Space -&gt; the cells visited by a <a href="/notes/la-macchina-di-turing">Turing Machine</a> when executed.</p>
<h2 id="introduction-to-time-complexity">Introduction to Time Complexity<a hidden class="anchor" aria-hidden="true" href="#introduction-to-time-complexity">#</a></h2>
<p>This note will build upon know techniques of algorithms analysis explained in <a href="/notes/notazione-asintotica">Notazione Asintotica</a>.
We will need big-$O$ notation and $o$ notation.
L&rsquo;idea √® che il problema di decisione √® decidibile se limito la lunghezza del teorema.
Simile al <a href="https://en.wikipedia.org/wiki/Chaitin%27s_constant">numero di Chaitin</a>, che non √® computabile, ma √® approssimabile quanto si vuole. In un certo senso √® computabile.
The general idea is to ask how the function $\varphi$ that maps the longest $n$ proof to the number of steps of computation behaves.</p>
<h3 id="robustness-of-the-notion-of-time-complexity">Robustness of the notion of time complexityüü®<a hidden class="anchor" aria-hidden="true" href="#robustness-of-the-notion-of-time-complexity">#</a></h3>
<p>The notion of &ldquo;computational steps&rdquo; used to measure the time complexity varies along</p>
<ul>
<li>Computational models</li>
<li>definition of computational steps</li>
<li>The code of the input and output (not always binary, for example big numbers are not fixed size).</li>
</ul>
<h3 id="influence-of-the-computational-model">Influence of the Computational Model<a hidden class="anchor" aria-hidden="true" href="#influence-of-the-computational-model">#</a></h3>
<p>In Complexity Theory <strong>the choice of the formal model</strong> influences the complexity class of the model!
This is different from the argument from computational theory of the <a href="/notes/la-macchina-di-turing#tesi-di-church-turing">Church Turing Thesis</a>, where it asserts that a function is computable in every computational model. See 7.7 in <a href="https://books.google.it/books/about/Introduction_to_the_Theory_of_Computatio.html?id=P3f6CAAAQBAJ">(Sipser 2012)</a>.</p>
<h4 id="multi-tape-vs-single-tape-tm">Multi-tape vs single-tape TM<a hidden class="anchor" aria-hidden="true" href="#multi-tape-vs-single-tape-tm">#</a></h4>
<p>It can be proved that every $t(n)$ time multi-tape TM can be simulated by a $t^{2}(n)$ single tape TM. See Theorem 7.8 of <a href="https://books.google.it/books/about/Introduction_to_the_Theory_of_Computatio.html?id=P3f6CAAAQBAJ">(Sipser 2012)</a>.</p>
<h2 id="the-time-complexity-class">The Time Complexity Class<a hidden class="anchor" aria-hidden="true" href="#the-time-complexity-class">#</a></h2>
<h3 id="definition-of-the-time-complexity-class">Definition of the Time Complexity Classüü©<a hidden class="anchor" aria-hidden="true" href="#definition-of-the-time-complexity-class">#</a></h3>
<blockquote>
<p>Languages that are decidable in $O(t(n))$ time are part of this class, denoted as $TIME(t(n))$.  With $t : \mathbb{N} \to \mathbb{R}^{+}$.</p></blockquote>
<p>Another way to understand this is that if a algorithms <strong>terminates</strong> in at most $t(n)$ steps then it belongs to this class.</p>
<h3 id="polynomial-complexity-class">Polynomial Complexity Classüü©<a hidden class="anchor" aria-hidden="true" href="#polynomial-complexity-class">#</a></h3>
$$
P = \bigcup_{i \geq 1} TIME(n^{i})
$$<p>
This is defined as the class of the <strong>reasonable</strong> efficiency programs.
NOTE: this is invariant with respect to the chosen coding system (if an algorithm is still in P, then it will remain in P even if you change code scheme).</p>
<ol>
<li>P is invariant for all models of computation that are polynomially equivalent to the deterministic single-tape Turing machine, and</li>
<li>P roughly corresponds to the class of problems that are realistically solvable on a computer.</li>
</ol>
$$
EXP = \bigcup_{i \geq 1} TIME(2^{n^{i}})
$$<p>
See later.</p>
<h4 id="path-is-in-p">PATH is in Püü©<a hidden class="anchor" aria-hidden="true" href="#path-is-in-p">#</a></h4>
<p>We can prove that the language
$\left\{ \langle G, s, t \rangle \mid G \text{ is a graph that has a route from } s \text{ to } t \right\}$
is in $P$ class. (Just use <a href="/notes/grafi#bfs">Grafi#BFS</a> or <a href="/notes/grafi#dfs">Grafi#DFS</a>).</p>
<p>NOTE: we have worked assuming that the algorithm worked on the nodes, but usually TM work with bits, the thing is that there is a polynomial algo that converts that nodes into binary format, so it is not much of a big deal.</p>
<h4 id="overview-of-problems-in-p">Overview of problems in $P$<a hidden class="anchor" aria-hidden="true" href="#overview-of-problems-in-p">#</a></h4>
<img src="/images/notes/Time Complexity-20240321132710013.webp" style="width: 100%" class="center" alt="Time Complexity-20240321132710013">
<h3 id="exponential-complexity-class">Exponential Complexity Classüü©<a hidden class="anchor" aria-hidden="true" href="#exponential-complexity-class">#</a></h3>
$$
EXP = \bigcup_{i\geq 1} TIME(2^{n^{i}})
$$<p>
This class is common of the algorithms that use backtracking, for example Costraint Satisfaction Problems. Or just brute-force search all the branches.</p>
<h3 id="non-deterministic-complexity-class">Non-deterministic Complexity Class<a hidden class="anchor" aria-hidden="true" href="#non-deterministic-complexity-class">#</a></h3>
<p>Let $N$ be a non-deterministic decider (which means that the TM will halt on every computation branch) then we have that a problem is in this complexity class, called $NTIME$ if the running time cost $f: \mathbb{N} \to \mathbb{N}$ is bounded by that (longest computational branch).
The difference with <a href="/notes#polynomial-complexity-class">#Polynomial Complexity Class</a> is that here we consider the length of a single branch, but we explore everything at the same time!</p>
<img src="/images/notes/Time Complexity-20240314134202678.webp" style="width: 100%" class="center" alt="Time Complexity-20240314134202678">
<p>Quindi</p>
$$
NP = \bigcup_{i\geq 1} NTIME(n^{k})
$$<h4 id="simulation-by-deterministic-tm">Simulation by Deterministic TM<a hidden class="anchor" aria-hidden="true" href="#simulation-by-deterministic-tm">#</a></h4>
<p>We can prove that every TM in NP can be simulated by a deterministic machine in $2^{Ot(n)}$ time, where $t(n)$ is the complexity class of the TM. The intuition is easy, just try <em>every possible computational branch</em>, and see for the result.
We then observe that $NP \subseteq EXP$ but this is not so useful.</p>
<h4 id="clique-problem">Clique problem<a hidden class="anchor" aria-hidden="true" href="#clique-problem">#</a></h4>
<p>See <a href="/notes/common-problems-in-theoretical-cs#the-clique-problem">Common problems in Theoretical CS#The Clique problem</a> for description of the problem.</p>
<p><strong>NP algorithm</strong>
Just</p>
<ol>
<li>Select a subset of nodes from $G$. Do it non deterministically.</li>
<li>Verify if this subset is a complete graph. If yes add it to the solution set.</li>
</ol>
<p>We can prove that this is correct, and it works, but it is a non deterministic algorithm, so it isn&rsquo;t easily simulated by deterministic algorithms, even though we proved in <a href="/notes/estensioni-di-turing-e-altre-macchine">Estensioni di Turing e altre macchine</a> that from the computability point of view it is the same.</p>
<p><strong>Verifiable</strong>
Given input the graph, and a subset, we need to</p>
<ol>
<li>For each node in the subset, check if it is linked to each other.</li>
<li>Return the previous truth result.
So easy.</li>
</ol>
<h4 id="other-np-complete-problems">Other NP-complete problems<a hidden class="anchor" aria-hidden="true" href="#other-np-complete-problems">#</a></h4>
<p>If you have some time, you should give a proof for each problem (poly-reduction from sat)</p>
<ul>
<li>Vertex Cover</li>
<li>Hamiltonian paths</li>
<li>Undirected Hamiltonian paths</li>
<li>Subset-sum</li>
</ul>
<h3 id="verifiability">Verifiability<a hidden class="anchor" aria-hidden="true" href="#verifiability">#</a></h3>
<h4 id="def-verifiability">Def: verifiability<a hidden class="anchor" aria-hidden="true" href="#def-verifiability">#</a></h4>
$$
w \in A \iff \exists c : M \text{ accepts } \langle w, c \rangle 
$$<p>
If $M$ is polynomial then we say that this is <strong>polynomially verifiable</strong>. We can prove that this notion is equivalent for $NP$ complexity classes.
We also require that $c$ is of <em>polynomial length</em>.</p>
<h4 id="th-verifiability--np">Th: Verifiability = NPüü©<a hidden class="anchor" aria-hidden="true" href="#th-verifiability--np">#</a></h4>
<p>From a philosophical point of view, if a problem is in NP, we can just guess a solution, or just do brute force. There is no classical algorithmical solution that solves it, or a constructive proof for it.</p>
<p>$\leftarrow$: let&rsquo;s suppose we have a $M$ that decides non deterministically that language.
On input $\langle w, c \rangle$ we run $M(w)$ and if it accepts, return true if the branch is good. ($c$ guides us about what non-deterministic branch to choose).</p>
<p>$\to$ : let&rsquo;s assume we have a polynomial verifier, we need to build a TM that decides it non deterministically in polynomial time.
choose non deterministically a certificate $c$ the encodes the path of the non-deterministic computation. If this accepts then accept!</p>
<h4 id="philosophical-thoughts-on-p-vs-np">Philosophical thoughts on P vs NP<a hidden class="anchor" aria-hidden="true" href="#philosophical-thoughts-on-p-vs-np">#</a></h4>
<p>Intuitively we can have this intuition:
The class of problems in $P$ is the class of problems were you need to come up with a solution by yourself.
The class of problems in $NP$ is the class of problems were you just need to <strong>verify</strong> if a given solution is valid.
From a personal human point of view this clearly seem to indicate that the two classes are <em>different</em>. But we have no proof.</p>
<blockquote>
<p>If P were equal to NP, then the world would be a profoundly different place than we usually assume it to be. There would be no special value in ‚Äúcreative leaps‚Äù, no fundamental gap between solving a problem and recognizing the solution once it‚Äôs found. Everyone who could appreciate a symphony would be Mozart; Everyone who could follow a step-by-step argument would be Gauss.</p>
<p><em>‚Äì Prof. Scott Aaronson, 2006</em></p></blockquote>
<h2 id="space-complexity-terminology">Space complexity terminology<a hidden class="anchor" aria-hidden="true" href="#space-complexity-terminology">#</a></h2>
<h3 id="def-space-complexity">Def: space complexity<a hidden class="anchor" aria-hidden="true" href="#def-space-complexity">#</a></h3>
<p>Given a $\mathcal{M}$ Turing Machine that halts on every input, then his space complexity is a function $t : \mathbb{N} \to \mathbb{N}$ such that $t(n)$ is the <strong>maximum</strong> number of cells visited by $\mathcal{M}$ on inputs of length $n$.
We can say something very similar for the <em>non-deterministic TM</em>, se way that its space complexity is the <strong>maximum</strong> number of tape cells visited on a single computational branch.</p>
<h3 id="def-space-complexity-class">Def: Space complexity Class<a hidden class="anchor" aria-hidden="true" href="#def-space-complexity-class">#</a></h3>
<p>We define the <strong>space complexity class</strong> $SPACE(t(n))$ as all languages decidable by a TM in $O(t(n))$ space.
Analogously the $NSPACE(t(n))$ complexity class is defined. We use a non-deterministic TM here.</p>
$$
P \subseteq NP \subseteq PSPACE = NPSPACE \subseteq  EXPTIME
$$<p>
The last subset is given by an observation that a TM that uses $f(n)$ space (PSPACE) cannot have more than $f(n)2^{O(f(n))}$ computational steps before looping.
<img src="/images/notes/Time and Space Complexity-20240518095235181.webp" style="width: 100%" class="center" alt="Time and Space Complexity-20240518095235181"></p>
<h3 id="def-pspace-and-npspace">Def: PSPACE and NPSPACE<a hidden class="anchor" aria-hidden="true" href="#def-pspace-and-npspace">#</a></h3>
$$
PSPACE = \bigcup_{k}SPACE(n^{k})
$$$$
NPSPACE = \bigcup_{k} NSPACE(n^{k})
$$<h3 id="def-pspace-completeness">Def: PSPACE-completeness<a hidden class="anchor" aria-hidden="true" href="#def-pspace-completeness">#</a></h3>
<p>We say that $L$ is PSPACE-complete if it is $\in PSPACE$ and every other $L' \in PSPACE$ is <a href="/notes/cook-levin-and-savitch#poly-reduction">poly-reducible</a> to it.</p>
<h2 id="th-np-in-pspace">Th: $NP \in PSPACE$<a hidden class="anchor" aria-hidden="true" href="#th-np-in-pspace">#</a></h2>
<p>In order to prove this we prove that $SAT \in PSPACE$ because as it is $NP-complete$ every NP problem can be reduced to $SAT$ and so it is in $PSPACE$.
For more about SAT see <a href="/notes/common-problems-in-theoretical-cs#the-sat-problem">Common problems in Theoretical CS#The SAT problem</a>.</p>
<h4 id="proof-of-sat-in-pspace">Proof of SAT in PSPACE<a hidden class="anchor" aria-hidden="true" href="#proof-of-sat-in-pspace">#</a></h4>
<p>We note that the simple algorithm that just enumerates all possible assignments is in $PSPACE$.
Consider this algorithm:
For all assignments for the input boolean formula do:</p>
<ol>
<li>Assign it and verify in poly-time if it is ok.</li>
<li>If ok return true else continue until every assignment is used.
We note that just $O(m)$ space is used, where $m$ is the number of terms. All the computation could be done in polynomial space, so the problem is in PSPACE. $\square$.</li>
</ol>
<h1 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h1>
<p>[1] Sipser <a href="https://books.google.it/books/about/Introduction_to_the_Theory_of_Computatio.html?id=P3f6CAAAQBAJ">‚ÄúIntroduction to the Theory of Computation‚Äù</a> Cengage Learning 2012</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/theoretical-computer-science/">Theoretical-Computer-Science</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Time and Space Complexity on x"
            href="https://x.com/intent/tweet/?text=Time%20and%20Space%20Complexity&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2ftime-and-space-complexity%2f&amp;hashtags=theoretical-computer-science">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Time and Space Complexity on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2ftime-and-space-complexity%2f&amp;title=Time%20and%20Space%20Complexity&amp;summary=Time%20and%20Space%20Complexity&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2ftime-and-space-complexity%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Time and Space Complexity on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2ftime-and-space-complexity%2f&title=Time%20and%20Space%20Complexity">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Time and Space Complexity on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2ftime-and-space-complexity%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Time and Space Complexity on whatsapp"
            href="https://api.whatsapp.com/send?text=Time%20and%20Space%20Complexity%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2ftime-and-space-complexity%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Time and Space Complexity on telegram"
            href="https://telegram.me/share/url?text=Time%20and%20Space%20Complexity&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2ftime-and-space-complexity%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Time and Space Complexity on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Time%20and%20Space%20Complexity&u=https%3a%2f%2fflecart.github.io%2fnotes%2ftime-and-space-complexity%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span> ¬∑ 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
