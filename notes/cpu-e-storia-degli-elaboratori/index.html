<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>CPU e storia degli elaboratori | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="no-tags">
<meta name="description" content="Ripasso Prox: 40 Ripasso: December 23, 2021 Ultima modifica: February 23, 2023 6:18 PM Primo Abbozzo: September 26, 2021 2:22 PM Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ— Studi Personali: No
Elementi di ripasso Dubbi vecchi Le tappe principali dell&rsquo;evoluzione del computer fino ai giorni moderni Capire bene la differenza fra CISC e RISC, in particolare il significato di microprogrammazione Capire bene la differenza fra parallelismo livello processore e livello istruzione, SIMD e MIMD Prefetch istruzioni Come funziona la predizione dei salti.">
<meta name="author" content="Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="flecart.github.io/notes/cpu-e-storia-degli-elaboratori/">
<link crossorigin="anonymous" href="flecart.github.io/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="flecart.github.io/notes/cpu-e-storia-degli-elaboratori/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>


<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-WW6NN2QGKF', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="CPU e storia degli elaboratori" />
<meta property="og:description" content="Ripasso Prox: 40 Ripasso: December 23, 2021 Ultima modifica: February 23, 2023 6:18 PM Primo Abbozzo: September 26, 2021 2:22 PM Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ— Studi Personali: No
Elementi di ripasso Dubbi vecchi Le tappe principali dell&rsquo;evoluzione del computer fino ai giorni moderni Capire bene la differenza fra CISC e RISC, in particolare il significato di microprogrammazione Capire bene la differenza fra parallelismo livello processore e livello istruzione, SIMD e MIMD Prefetch istruzioni Come funziona la predizione dei salti." />
<meta property="og:type" content="article" />
<meta property="og:url" content="flecart.github.io/notes/cpu-e-storia-degli-elaboratori/" />
<meta property="og:image" content="flecart.github.io/images/papermod-cover.png" />
<meta property="article:section" content="notes" />



<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="flecart.github.io/images/papermod-cover.png" />
<meta name="twitter:title" content="CPU e storia degli elaboratori"/>
<meta name="twitter:description" content="Ripasso Prox: 40 Ripasso: December 23, 2021 Ultima modifica: February 23, 2023 6:18 PM Primo Abbozzo: September 26, 2021 2:22 PM Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ— Studi Personali: No
Elementi di ripasso Dubbi vecchi Le tappe principali dell&rsquo;evoluzione del computer fino ai giorni moderni Capire bene la differenza fra CISC e RISC, in particolare il significato di microprogrammazione Capire bene la differenza fra parallelismo livello processore e livello istruzione, SIMD e MIMD Prefetch istruzioni Come funziona la predizione dei salti."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "CPU e storia degli elaboratori",
      "item": "flecart.github.io/notes/cpu-e-storia-degli-elaboratori/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CPU e storia degli elaboratori",
  "name": "CPU e storia degli elaboratori",
  "description": "Ripasso Prox: 40 Ripasso: December 23, 2021 Ultima modifica: February 23, 2023 6:18 PM Primo Abbozzo: September 26, 2021 2:22 PM Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ— Studi Personali: No\nElementi di ripasso Dubbi vecchi Le tappe principali dell\u0026rsquo;evoluzione del computer fino ai giorni moderni Capire bene la differenza fra CISC e RISC, in particolare il significato di microprogrammazione Capire bene la differenza fra parallelismo livello processore e livello istruzione, SIMD e MIMD Prefetch istruzioni Come funziona la predizione dei salti.",
  "keywords": [
    "no-tags"
  ],
  "articleBody": "Ripasso Prox: 40 Ripasso: December 23, 2021 Ultima modifica: February 23, 2023 6:18 PM Primo Abbozzo: September 26, 2021 2:22 PM Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ— Studi Personali: No\nElementi di ripasso Dubbi vecchi Le tappe principali dellâ€™evoluzione del computer fino ai giorni moderni Capire bene la differenza fra CISC e RISC, in particolare il significato di microprogrammazione Capire bene la differenza fra parallelismo livello processore e livello istruzione, SIMD e MIMD Prefetch istruzioni Come funziona la predizione dei salti. December 14, 2021 3:43 PM\n2 Storia 2.1 0: Computer Meccanici dal 1600 a oggi\n2.2 1: Computer a Valvole Principalmente i computer della seconda guerra mondiale\n2.3 2: Computer a Transistor Abbattere i costi\n2.4 3: Circuiti stampati Computazione parallela Multiprogrammazione (Caricamento di piÃ¹ programmi) 2.5 4: VLSI PossibilitÃ  di creare tansissimi transistor\n2.6 5: Computer moderni 2.6.1 Computer Ubiqui 2.6.2 Computer invisibili 2.7 VelocitÃ  di calcolo 2.7.1 Flops and MIPS 3 CPU La struttura moderna degli elaboratori sono basati principalmente sullâ€™architettura di Von Neuman, lâ€™unica differenza Ã¨ che gli elementi di questa architettura.\n3.1 Struttura e funzione della CPU La CPU si puÃ² dividere in tre parti principali:\nUna unitÃ  di controllo che coordina i processi Registri che immagazzinano temporaneamente piccole quantitÃ  di informazioni ALU che fa i calcoli ordinategli dalla CPU 3.1.1 Registri Principali Program Counter o Instruction Pointer Contiene un pointer allâ€™istruzione da eseguire cosÃ¬ lo prende dalla memoria Instruction Register Contiene lâ€™istruzione da eseguire Memory Address Register Prende lâ€™indirizzo del contenuto interessante dalla memoria Memory Data Register Prende il contenuto dalla memoria Program Status Word Raccoglie lo stato di esecuzione del programma, se fallisce se tutto ok oppure se ci sono errori 3.1.2 ALU Aritmetic Logic Unit, Ã¨ la componente che fa i calcoli.\nPer sapere cosa deve fare, Ã¨ la Control Unit che collega certe vie dai registri allâ€™ALU.\nA seconda del genere di architettura puÃ² collegarsi direttamente in memoria (CISC) oppure sempre passando per i registri (solitamente RISC)\n3.1.3 Central Control Unit Il processore che decide cosa fare, se chiedere qualche altro pezzo dalla memoria seguendo il processo FDE Fetch Decode, Execute, oppure Scrivere qualcosa in memoria e cose simili.\n3.2 Filosofie Architetturali Complex Instructions Set Computer and Reduced Instructions Set Computer definiscono delle filosofie di architettura degli elaboratori differenti.\n3.2.1 CISC e microprogrammazione Utilizza una interpretazione che credo sia cosa a cui il prof. ha riferito come microprogrammazione, ovvero una programmazione delle istruzioni a livello molto basso.\nQuesto livello di interpretazione rallentava la macchina, perchÃ© non era direttamente eseguito sullâ€™hardware. Inoltre la tendenza ad accedere direttamente la memoria **rendeva questo modello a volte imprevedibile in termini di tempo\nEsempio di microprogramma\nChiaro che se questo interamente fosse considerato una istruzione, ci sarebbe un alto bisogno di cicli di clock (diventarebbe in generale piÃ¹ lento).\n3.2.2 RISC e peculiaritÃ  Una delle peculiaritÃ  principali delle architetture RISC Ã¨ il numero ridotto di istruzioni necessarie (che perÃ² erano molto veloci perchÃ© girava direttamente sullâ€™hardware).\nInoltre ha introdotto un sistema load store con cui affacciarsi alla memoria.\n3.2.3 Alcuni confronti La filosofia attuale Ã¨ la RISC, perÃ² a causa della grande presenza di elaboratori CISC, si Ã¨ preferito creare architetture ibride che comprendano entrambi: presenza di istruzioni complesse che vengano eseguite su istruzioni harware di RISC. â†’ Minore ciclo di Clock e quindi maggiore velocitÃ .\nLa differenza principale Ã¨ che CISC possiede istruzioni complesse molte dei quali vanno ad accedere la memoria (la parte lenta del processo) invece la RISC possiede soltanto i comandi load and store per accedere alla memoria, il resto delle istruzioni opera allâ€™interno del microprocessore.\n3.3 VelocitÃ  CPU 3.3.1 Clock e Data Path Cycle Il significato di clock Ã¨ spiegato molto meglio nella sezione dei Circuiti Sequenziali\nClock Ã¨ tempo per lâ€™istruzione piÃ¹ corta, se fosse ancora piÃ¹ corta Ã¨ molto probabile che la CPU verrebbe indotta in errori molto comuni per cui il computer non funzionerebbe piÃ¹ (un istruzione viene eseguita quando il precedente non Ã¨ ancora finito).\nUna Data Path Cycle Ã¨ lâ€™intero processo che comporta lettura dai registri, calcolo e registrazione del risultato\n3.3.2 Aumentare la velocitÃ  Ci sono delle soluzioni per rendere la CPU piÃ¹ veloce:\nMigliori reti elettriche (agli informatici non interessa) Overclocking (per un pÃ²) Memoria cache (spesso in RISC) Multi-core Pipelining Parallelismo Esattamente come una linea di assemblaggio di fabbrica, possiamo definire alcune parti per processi specifici. 3.4 Parallelismo Circa 3-4 volte piÃ¹ veloce e poco costoso per crearlo, in quanto i pezzi sono efficienti, con pipeline di 5 sotto câ€™Ã¨ bisogno di una sola ALU a differenza di 5 per avere funzionalitÃ  simili.\n3.4.1 Pipelining Spesso alcune istruzioni sono ottimizzate in termini di tempo nel caso sia presente la pipeline o meno, per cui Ã¨ interessante poter averlo a mente. Parallelismo livello istruzione\nEsempio:\n5 step.\nCarica lâ€™istruzione Interpreta lâ€™istruzione Fetch dei dati necessari Esecuzione dopo aver ricevuto i dati Scrittura del risultato. Ogni singola istruzione passa ogni volta secondo questa pipeline, che lavorano in parallelo, velocizzando il CHIP.\n3.4.2 Multicore ~ SIMD \u0026 MIMD Ci sono dei computer moderni che contengono molteplici CPU uguali a quanto descritti in 3.1.1\nSIMD\nSingle instruction-stream multiple data-stream *Istruzioni a dati diversi: Tutte le CPU hanno lo stesso stream di dati (magari elaborazione immagini, un qualcosa di ripetitivo su stessa cosa)\nSi guadagna in control unit, unica, fetch unica.\nEsistono anche i processori vettoriali.\nDi solito questo genere di architettura sono utili per istruzioni uguali a dati diversi come lâ€™elaborazione di un immagine\nMIMD\nLa differenza dal precedente Ã¨ che lâ€™istruction stream Ã¨ multiplo, ma un pÃ² piÃ¹ costoso perchÃ© ci sono molte CPU complete.\nAvere troppe CPU su una memoria condivisa non andrebbe bene, perchÃ© si dovrebbero aspettare. Meglio avere una rete fra CPU per cose grosse.\nCioÃ¨ se collegassi troppe CPU, probabilmente lâ€™unico bus andrebbe in stallo perchÃ© tutti cercherebbero ad accedere alla stessa memoria, e le CPU dovrebbero attendersi fra di loro, cosa non buona per la performance.\n3.4.3 Rete di Computer Una soluzione che si solito viene utilizzata dalle grandi aziende o comunque chi possiede le risorse Ã¨ la costruzione di grandi reti di calcolatori che possano operare allâ€™unisono, o comunque con certo criterio. Dovrebbero essere un sacco di CPU separate che comunicano con un computer centrale che agisce come da UnitÃ  di Controllo.\nDi solito Multi-core e reti di computer sono conosiderati parallelismo a livello processore\nLe redi di computer sono solitamente facili da costruire ma difficile da programmare, mentre invece un multicore Ã¨ difficile da costruire ma facile da programmare.\nInvece il pipelining Ã¨ considerato un parallelismo a livello istruzione.\n3.4.4 Prefetch-istruzioni Questa cosa Ã¨ molto simile al prefetch della Memoria cache.\nInstruction Fetch Unit sono elementi di Hardware che caricano lâ€™istruzione successiva nel momento in cui la presente Ã¨ in esecuzione.\nQuesto avviene perchÃ© il caricamento dellâ€™istruzione Ã¨ spesso molto lenta.\nQuesta instruction cache prefecht puÃ² essere implementata a due livelli, Hardware o software.\n3.4.5 Pipeline (e salti) Esempio di pipeline\nLâ€™esempio fatto qui Ã¨ giÃ  considerabile come un primo passo di Pipeline, in cui molteplici passi possono essere fatti allo stesso momento dentro la CPU.\nSolamente la prima esecuzione servono 5-7 clock (a differenza delle parti), quindi basta un ciclo di clock per la fase piÃ¹ lunga per essere sicuri, ecco che riusciamo a completare lâ€™istruzione in modo molto piÃ¹ veloce.\nSe una singola istruzione dovrebbe fare tutto, saremmo costretti a tenere un clock molto elevato e il computer nel complesso sarebbe molto lento.\nSalti\nSe faccio un salto allora câ€™Ã¨ un buco nel pipeline, ossia cose nel pipeline che non eseguono (perchÃ© devo saltare), cioÃ¨ fetch e decode di certe istruzioni non mi devono servire.\n(ho decodato una istruzione) ma nel frattempo ho giÃ  caricato 4 e 5 che non mi servono!\n3.4.6 Predizione di salti Possiamo utilizzare certe euristiche (ragionamenti caso per caso) per predire alcuni salti.\nSalti allâ€™indietro\nSi possono prevedere per cicli while e for dei salti allâ€™indietro.\nPer salti incondizionati si puÃ² mettere una instruzione NOP in modo che faccia salti incondizionati senza sprecare istruzioni.\nEsempio data race (read after write)\nAX = 0\nBX = 0\nDX = 0\nAX = DX + 1\nBX = AX - 1\nfetch a decode a, fetch b leggo DX (a) , decode b DX + 1 (a), leggo AX (b) MA STO LEGGENDO TROPPO PRESTO! Quindi devo chiudere AX ed aspettare che AX venga scritto\nA volte, tipico dei processori CISC, si tende a eseguire minicomandi in ordine diverso perchÃ© ritenuti piÃ¹ efficienti, quindi si mischia un pÃ², proprio come intendi per combinatorio e la fai.\nEntra cisc ma esegue risc.\nEsiste una BPUÂ (Branch Prediction Unit), che cerca di predire lâ€™esito di un salto, come spiegato in questa pagina di wiki e una BTP (Branch Target Predictor) che controlla le istruzioni nel ramo di arrivo (qui). Questi sono le componenti principali che determinano la predizione dei salti.\nIn alternativa si mettono dei NOP. o di arrivo (qui). Questi sono le componenti principali che determinano la predizione dei salti.\nIn alternativa si mettono dei NOP.\n",
  "wordCount" : "1497",
  "inLanguage": "en",
  "image": "flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "flecart.github.io/notes/cpu-e-storia-degli-elaboratori/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="flecart.github.io/flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="flecart.github.io/">Home</a>&nbsp;Â»&nbsp;<a href="flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      CPU e storia degli elaboratori
    </h1>
    <div class="post-meta">8 min&nbsp;Â·&nbsp;Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#elementi-di-ripasso" aria-label="Elementi di ripasso">Elementi di ripasso</a></li>
                <li>
                    <a href="#2-storia" aria-label="2 Storia">2 Storia</a><ul>
                        
                <li>
                    <a href="#21-0-computer-meccanici" aria-label="2.1 0: Computer Meccanici">2.1 0: Computer Meccanici</a></li>
                <li>
                    <a href="#22-1-computer-a-valvole" aria-label="2.2 1: Computer a Valvole">2.2 1: Computer a Valvole</a></li>
                <li>
                    <a href="#23-2-computer-a-transistor" aria-label="2.3 2: Computer a Transistor">2.3 2: Computer a Transistor</a></li>
                <li>
                    <a href="#24-3-circuiti-stampati" aria-label="2.4 3: Circuiti stampati">2.4 3: Circuiti stampati</a></li>
                <li>
                    <a href="#25-4-vlsi" aria-label="2.5 4: VLSI">2.5 4: VLSI</a></li>
                <li>
                    <a href="#26-5-computer-moderni" aria-label="2.6 5: Computer moderni">2.6 5: Computer moderni</a><ul>
                        
                <li>
                    <a href="#261-computer-ubiqui" aria-label="2.6.1 Computer Ubiqui">2.6.1 Computer Ubiqui</a></li>
                <li>
                    <a href="#262-computer-invisibili" aria-label="2.6.2 Computer invisibili">2.6.2 Computer invisibili</a></li></ul>
                </li>
                <li>
                    <a href="#27-velocit%c3%a0-di-calcolo" aria-label="2.7 VelocitÃ  di calcolo">2.7 VelocitÃ  di calcolo</a><ul>
                        
                <li>
                    <a href="#271-flops-and-mips" aria-label="2.7.1 Flops and MIPS">2.7.1 Flops and MIPS</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#3-cpu" aria-label="3 CPU">3 CPU</a><ul>
                        
                <li>
                    <a href="#31-struttura-e-funzione-della-cpu" aria-label="3.1 Struttura e funzione della CPU">3.1 Struttura e funzione della CPU</a><ul>
                        
                <li>
                    <a href="#311-registri-principali" aria-label="3.1.1 Registri Principali">3.1.1 Registri Principali</a></li>
                <li>
                    <a href="#312-alu" aria-label="3.1.2 ALU">3.1.2 ALU</a></li>
                <li>
                    <a href="#313-central-control-unit" aria-label="3.1.3 Central Control Unit">3.1.3 Central Control Unit</a></li></ul>
                </li>
                <li>
                    <a href="#32-filosofie-architetturali" aria-label="3.2 Filosofie Architetturali">3.2 Filosofie Architetturali</a><ul>
                        
                <li>
                    <a href="#321-cisc-e-microprogrammazione" aria-label="3.2.1 CISC e microprogrammazione">3.2.1 CISC e microprogrammazione</a></li>
                <li>
                    <a href="#322-risc-e-peculiarit%c3%a0" aria-label="3.2.2 RISC e peculiaritÃ ">3.2.2 RISC e peculiaritÃ </a></li>
                <li>
                    <a href="#323-alcuni-confronti" aria-label="3.2.3 Alcuni confronti">3.2.3 Alcuni confronti</a></li></ul>
                </li>
                <li>
                    <a href="#33-velocit%c3%a0-cpu" aria-label="3.3 VelocitÃ  CPU">3.3 VelocitÃ  CPU</a><ul>
                        
                <li>
                    <a href="#331-clock-e-data-path-cycle" aria-label="3.3.1 Clock e Data Path Cycle">3.3.1 Clock e Data Path Cycle</a></li>
                <li>
                    <a href="#332-aumentare-la-velocit%c3%a0" aria-label="3.3.2 Aumentare la velocitÃ ">3.3.2 Aumentare la velocitÃ </a></li></ul>
                </li>
                <li>
                    <a href="#34-parallelismo" aria-label="3.4 Parallelismo">3.4 Parallelismo</a><ul>
                        
                <li>
                    <a href="#341-pipelining" aria-label="3.4.1 Pipelining">3.4.1 Pipelining</a></li>
                <li>
                    <a href="#342-multicore--simd--mimd" aria-label="3.4.2 Multicore ~ SIMD &amp; MIMD">3.4.2 Multicore ~ SIMD &amp; MIMD</a></li>
                <li>
                    <a href="#343-rete-di-computer" aria-label="3.4.3 Rete di Computer">3.4.3 Rete di Computer</a></li>
                <li>
                    <a href="#344-prefetch-istruzioni" aria-label="3.4.4 Prefetch-istruzioni">3.4.4 Prefetch-istruzioni</a></li>
                <li>
                    <a href="#345-pipeline-e-salti" aria-label="3.4.5 Pipeline (e salti)">3.4.5 Pipeline (e salti)</a></li>
                <li>
                    <a href="#346-predizione-di-salti" aria-label="3.4.6 Predizione di salti">3.4.6 Predizione di salti</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Ripasso Prox: 40
Ripasso: December 23, 2021
Ultima modifica: February 23, 2023 6:18 PM
Primo Abbozzo: September 26, 2021 2:22 PM
Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ—
Studi Personali: No</p>
<h1 id="elementi-di-ripasso">Elementi di ripasso<a hidden class="anchor" aria-hidden="true" href="#elementi-di-ripasso">#</a></h1>
<ul>
<li>Dubbi vecchi
<ul>
<li>Le tappe principali dell&rsquo;evoluzione del computer fino ai giorni moderni</li>
<li>Capire bene la differenza fra CISC e RISC, in particolare il significato di microprogrammazione</li>
<li>Capire bene la differenza fra parallelismo livello processore e livello istruzione, SIMD e MIMD</li>
<li>Prefetch istruzioni</li>
<li>Come funziona la predizione dei salti.</li>
</ul>
</li>
</ul>
<p>December 14, 2021 3:43 PM</p>
<h1 id="2-storia">2 Storia<a hidden class="anchor" aria-hidden="true" href="#2-storia">#</a></h1>
<h2 id="21-0-computer-meccanici">2.1 0: Computer Meccanici<a hidden class="anchor" aria-hidden="true" href="#21-0-computer-meccanici">#</a></h2>
<p>dal 1600 a oggi</p>
<h2 id="22-1-computer-a-valvole">2.2 1: Computer a Valvole<a hidden class="anchor" aria-hidden="true" href="#22-1-computer-a-valvole">#</a></h2>
<p>Principalmente i computer della seconda guerra mondiale</p>
<h2 id="23-2-computer-a-transistor">2.3 2: Computer a Transistor<a hidden class="anchor" aria-hidden="true" href="#23-2-computer-a-transistor">#</a></h2>
<p>Abbattere i costi</p>
<h2 id="24-3-circuiti-stampati">2.4 3: Circuiti stampati<a hidden class="anchor" aria-hidden="true" href="#24-3-circuiti-stampati">#</a></h2>
<ul>
<li>Computazione parallela</li>
<li>Multiprogrammazione (Caricamento di piÃ¹ programmi)</li>
</ul>
<h2 id="25-4-vlsi">2.5 4: VLSI<a hidden class="anchor" aria-hidden="true" href="#25-4-vlsi">#</a></h2>
<p>PossibilitÃ  di creare tansissimi transistor</p>
<h2 id="26-5-computer-moderni">2.6 5: Computer moderni<a hidden class="anchor" aria-hidden="true" href="#26-5-computer-moderni">#</a></h2>
<h3 id="261-computer-ubiqui">2.6.1 Computer Ubiqui<a hidden class="anchor" aria-hidden="true" href="#261-computer-ubiqui">#</a></h3>
<h3 id="262-computer-invisibili">2.6.2 Computer invisibili<a hidden class="anchor" aria-hidden="true" href="#262-computer-invisibili">#</a></h3>
<h2 id="27-velocitÃ -di-calcolo">2.7 VelocitÃ  di calcolo<a hidden class="anchor" aria-hidden="true" href="#27-velocitÃ -di-calcolo">#</a></h2>
<h3 id="271-flops-and-mips">2.7.1 Flops and MIPS<a hidden class="anchor" aria-hidden="true" href="#271-flops-and-mips">#</a></h3>
<h1 id="3-cpu">3 CPU<a hidden class="anchor" aria-hidden="true" href="#3-cpu">#</a></h1>
<p>La struttura moderna degli elaboratori sono basati principalmente sull&rsquo;<strong>architettura di Von Neuman,</strong> l&rsquo;unica differenza Ã¨ che gli elementi di questa architettura.</p>
<h2 id="31-struttura-e-funzione-della-cpu">3.1 Struttura e funzione della CPU<a hidden class="anchor" aria-hidden="true" href="#31-struttura-e-funzione-della-cpu">#</a></h2>
<p>La CPU si puÃ² dividere in tre parti principali:</p>
<ul>
<li>Una unitÃ  di controllo che coordina i processi</li>
<li>Registri che immagazzinano temporaneamente piccole quantitÃ  di informazioni</li>
<li>ALU che fa i calcoli ordinategli dalla CPU</li>
</ul>
<h3 id="311-registri-principali">3.1.1 Registri Principali<a hidden class="anchor" aria-hidden="true" href="#311-registri-principali">#</a></h3>
<ul>
<li>Program Counter o Instruction Pointer
<ul>
<li>Contiene un pointer all&rsquo;istruzione da eseguire cosÃ¬ lo prende dalla memoria</li>
</ul>
</li>
<li>Instruction Register
<ul>
<li>Contiene l&rsquo;istruzione da eseguire</li>
</ul>
</li>
<li>Memory Address Register
<ul>
<li>Prende l&rsquo;indirizzo del contenuto interessante dalla memoria</li>
</ul>
</li>
<li>Memory Data Register
<ul>
<li>Prende il contenuto dalla memoria</li>
</ul>
</li>
<li>Program Status Word
<ul>
<li>Raccoglie lo stato di esecuzione del programma, se fallisce se tutto ok oppure se ci sono errori</li>
</ul>
</li>
</ul>
<h3 id="312-alu">3.1.2 ALU<a hidden class="anchor" aria-hidden="true" href="#312-alu">#</a></h3>
<p>Aritmetic Logic Unit, Ã¨ la componente che fa i calcoli.</p>
<p>Per sapere cosa deve fare, Ã¨ la Control Unit che collega certe vie dai registri all&rsquo;ALU.</p>
<p>A seconda del genere di architettura puÃ² collegarsi direttamente in memoria (CISC) oppure sempre passando per i registri (solitamente RISC)</p>
<h3 id="313-central-control-unit">3.1.3 Central Control Unit<a hidden class="anchor" aria-hidden="true" href="#313-central-control-unit">#</a></h3>
<p>Il processore che decide cosa fare, se chiedere qualche altro pezzo dalla memoria seguendo il processo <strong>FDE</strong> Fetch Decode, Execute, oppure Scrivere qualcosa in memoria e cose simili.</p>
<img src="/images/notes/image/universita/ex-notion/CPU e storia degli elaboratori/Untitled.png" alt="image/universita/ex-notion/CPU e storia degli elaboratori/Untitled">
<h2 id="32-filosofie-architetturali">3.2 Filosofie Architetturali<a hidden class="anchor" aria-hidden="true" href="#32-filosofie-architetturali">#</a></h2>
<p>Complex Instructions Set Computer and Reduced Instructions Set Computer definiscono delle filosofie di architettura degli elaboratori differenti.</p>
<h3 id="321-cisc-e-microprogrammazione">3.2.1 CISC e microprogrammazione<a hidden class="anchor" aria-hidden="true" href="#321-cisc-e-microprogrammazione">#</a></h3>
<p>Utilizza una <strong>interpretazione</strong> che credo sia cosa a cui il prof. ha riferito come microprogrammazione, ovvero una programmazione delle istruzioni a livello molto basso.</p>
<p>Questo livello di interpretazione rallentava la macchina, perchÃ© non era direttamente eseguito sull&rsquo;hardware. Inoltre la tendenza ad accedere direttamente la memoria **rendeva questo modello a volte imprevedibile in termini di tempo</p>
<ul>
<li>
<p>Esempio di microprogramma</p>
  <img src="/images/notes/image/universita/ex-notion/CPU e storia degli elaboratori/Untitled 1.png" alt="image/universita/ex-notion/CPU e storia degli elaboratori/Untitled 1">
<p>Chiaro che se questo interamente fosse considerato una istruzione, ci sarebbe un alto bisogno di cicli di clock (diventarebbe in generale piÃ¹ lento).</p>
</li>
</ul>
<h3 id="322-risc-e-peculiaritÃ ">3.2.2 RISC e peculiaritÃ <a hidden class="anchor" aria-hidden="true" href="#322-risc-e-peculiaritÃ ">#</a></h3>
<p>Una delle peculiaritÃ  principali delle architetture RISC Ã¨ il numero ridotto di istruzioni necessarie (che perÃ² erano molto veloci perchÃ© girava direttamente sull&rsquo;hardware).</p>
<p>Inoltre ha introdotto un sistema <strong>load store</strong> con cui affacciarsi alla memoria.</p>
<img src="/images/notes/image/universita/ex-notion/CPU e storia degli elaboratori/Untitled 2.png" alt="image/universita/ex-notion/CPU e storia degli elaboratori/Untitled 2">
<h3 id="323-alcuni-confronti">3.2.3 Alcuni confronti<a hidden class="anchor" aria-hidden="true" href="#323-alcuni-confronti">#</a></h3>
<p>La filosofia attuale Ã¨ la RISC, perÃ² a causa della grande presenza di elaboratori CISC, si Ã¨ preferito <strong>creare architetture ibride</strong> che comprendano entrambi: presenza di istruzioni complesse che vengano eseguite su istruzioni harware di RISC. â†’ Minore ciclo di Clock e quindi maggiore velocitÃ .</p>
<p>La differenza principale Ã¨ che <strong>CISC possiede istruzioni complesse</strong> molte dei quali vanno ad accedere la memoria (la parte lenta del processo) invece la <strong>RISC</strong> possiede soltanto i comandi load and store per accedere alla memoria, il resto delle istruzioni opera all&rsquo;interno del microprocessore.</p>
<h2 id="33-velocitÃ -cpu">3.3 VelocitÃ  CPU<a hidden class="anchor" aria-hidden="true" href="#33-velocitÃ -cpu">#</a></h2>
<h3 id="331-clock-e-data-path-cycle">3.3.1 Clock e Data Path Cycle<a hidden class="anchor" aria-hidden="true" href="#331-clock-e-data-path-cycle">#</a></h3>
<p>Il significato di clock Ã¨ spiegato molto meglio nella sezione dei <a href="//notes/circuiti-sequenziali">Circuiti Sequenziali</a></p>
<p><strong>Clock</strong> Ã¨ tempo per l&rsquo;istruzione piÃ¹ corta, se fosse ancora piÃ¹ corta Ã¨ molto probabile che la CPU verrebbe indotta in errori molto comuni per cui il computer non funzionerebbe piÃ¹ (un istruzione viene eseguita quando il precedente non Ã¨ ancora finito).</p>
<p>Una <strong>Data Path Cycle</strong> Ã¨ l&rsquo;intero processo che comporta lettura dai registri, calcolo e registrazione del risultato</p>
<h3 id="332-aumentare-la-velocitÃ ">3.3.2 Aumentare la velocitÃ <a hidden class="anchor" aria-hidden="true" href="#332-aumentare-la-velocitÃ ">#</a></h3>
<p>Ci sono delle soluzioni per rendere la CPU piÃ¹ veloce:</p>
<ul>
<li>Migliori reti elettriche (agli informatici non interessa)</li>
<li>Overclocking (per un pÃ²)</li>
<li>Memoria cache (spesso in RISC)</li>
<li>Multi-core</li>
<li>Pipelining
<ul>
<li>Parallelismo
<ul>
<li>Esattamente come una linea di assemblaggio di fabbrica, possiamo definire alcune parti per processi specifici.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="34-parallelismo">3.4 Parallelismo<a hidden class="anchor" aria-hidden="true" href="#34-parallelismo">#</a></h2>
<p>Circa 3-4 volte piÃ¹ veloce e poco costoso per crearlo, in quanto i pezzi sono efficienti, con pipeline di 5 sotto c&rsquo;Ã¨ bisogno di una sola ALU a differenza di 5 per avere funzionalitÃ  simili.</p>
<h3 id="341-pipelining">3.4.1 Pipelining<a hidden class="anchor" aria-hidden="true" href="#341-pipelining">#</a></h3>
<p>Spesso alcune istruzioni sono ottimizzate in termini di tempo nel caso sia presente la pipeline o meno, per cui Ã¨ interessante poter averlo a mente. Parallelismo livello istruzione</p>
<p><strong>Esempio:</strong></p>
<p>5 step.</p>
<ol>
<li>Carica l&rsquo;istruzione</li>
<li>Interpreta l&rsquo;istruzione</li>
<li>Fetch dei dati necessari</li>
<li>Esecuzione dopo aver ricevuto i dati</li>
<li>Scrittura del risultato.</li>
</ol>
<p>Ogni singola istruzione passa ogni volta secondo questa <strong>pipeline</strong>, che lavorano in parallelo, velocizzando il CHIP.</p>
<h3 id="342-multicore--simd--mimd">3.4.2 Multicore ~ SIMD &amp; MIMD<a hidden class="anchor" aria-hidden="true" href="#342-multicore--simd--mimd">#</a></h3>
<p>Ci sono dei computer moderni che contengono molteplici CPU uguali a quanto descritti in 3.1.1</p>
<p><strong>SIMD</strong></p>
<p><em>Single instruction-stream multiple data-stream</em>
*<em>Istruzioni a dati diversi:</em> Tutte le CPU hanno lo stesso stream di dati (magari elaborazione immagini, un qualcosa di ripetitivo su stessa cosa)</p>
<p>Si guadagna in control unit, unica, fetch unica.</p>
<p>Esistono anche i processori vettoriali.</p>
<img src="/images/notes/image/universita/ex-notion/CPU e storia degli elaboratori/Untitled 3.png" alt="image/universita/ex-notion/CPU e storia degli elaboratori/Untitled 3">
<p>Di solito questo genere di architettura sono utili per istruzioni uguali a dati diversi come l&rsquo;elaborazione di un immagine</p>
<p><strong>MIMD</strong></p>
<p>La differenza dal precedente Ã¨ che l&rsquo;istruction stream Ã¨ multiplo, ma un pÃ² piÃ¹ costoso perchÃ© ci sono molte CPU complete.</p>
<p>Avere troppe CPU su una memoria condivisa non andrebbe bene, perchÃ© si dovrebbero aspettare. Meglio avere una rete fra CPU per cose grosse.</p>
<img src="/images/notes/image/universita/ex-notion/CPU e storia degli elaboratori/Untitled 4.png" alt="image/universita/ex-notion/CPU e storia degli elaboratori/Untitled 4">
<p>CioÃ¨ se collegassi troppe CPU, probabilmente <strong>l&rsquo;unico bus andrebbe in stallo</strong> perchÃ© tutti cercherebbero ad accedere alla stessa memoria, e le CPU dovrebbero attendersi fra di loro, cosa non buona per la performance.</p>
<h3 id="343-rete-di-computer">3.4.3 Rete di Computer<a hidden class="anchor" aria-hidden="true" href="#343-rete-di-computer">#</a></h3>
<p>Una soluzione che si solito viene utilizzata dalle grandi aziende o comunque chi possiede le risorse Ã¨ la costruzione di grandi reti di calcolatori che possano operare all&rsquo;unisono, o comunque con certo criterio. Dovrebbero essere un sacco di CPU separate che comunicano con un computer centrale che agisce come da UnitÃ  di Controllo.</p>
<p>Di solito Multi-core e reti di computer sono conosiderati <strong>parallelismo a livello processore</strong></p>
<p>Le redi di computer sono solitamente facili da costruire ma difficile da programmare, mentre invece un multicore Ã¨ difficile da costruire ma facile da programmare.</p>
<p>Invece il pipelining Ã¨ considerato un <strong>parallelismo a livello istruzione</strong>.</p>
<h3 id="344-prefetch-istruzioni">3.4.4 Prefetch-istruzioni<a hidden class="anchor" aria-hidden="true" href="#344-prefetch-istruzioni">#</a></h3>
<p>Questa cosa Ã¨ molto simile al prefetch della <a href="//notes/memoria">Memoria</a> cache.</p>
<p><strong>Instruction Fetch Unit</strong> sono elementi di Hardware che caricano l&rsquo;istruzione successiva nel momento in cui la presente Ã¨ in esecuzione.</p>
<p>Questo avviene perchÃ© il caricamento dell&rsquo;istruzione Ã¨ spesso molto lenta.</p>
<p>Questa instruction cache prefecht puÃ² essere implementata a due livelli, Hardware o software.</p>
<img src="/images/notes/image/universita/ex-notion/CPU e storia degli elaboratori/Untitled 5.png" alt="image/universita/ex-notion/CPU e storia degli elaboratori/Untitled 5">
<h3 id="345-pipeline-e-salti">3.4.5 Pipeline (e salti)<a hidden class="anchor" aria-hidden="true" href="#345-pipeline-e-salti">#</a></h3>
<img src="/images/notes/image/universita/ex-notion/CPU e storia degli elaboratori/Untitled 6.png" alt="image/universita/ex-notion/CPU e storia degli elaboratori/Untitled 6">
<p>Esempio di pipeline</p>
<p>L&rsquo;esempio fatto <a href="//notes/qui">qui</a> Ã¨ giÃ  considerabile come un primo passo di Pipeline, in cui molteplici passi possono essere fatti allo stesso momento dentro la CPU.</p>
<p>Solamente la prima esecuzione servono 5-7 clock (a differenza delle parti), quindi basta un ciclo di clock per la fase piÃ¹ lunga per essere sicuri, ecco che riusciamo a completare l&rsquo;istruzione in modo molto piÃ¹ veloce.</p>
<p>Se una singola istruzione dovrebbe fare tutto, saremmo costretti a tenere un clock molto elevato e il computer nel complesso sarebbe molto lento.</p>
<p><strong>Salti</strong></p>
<p>Se faccio un salto allora c&rsquo;Ã¨ un buco nel pipeline, ossia cose nel pipeline che non eseguono (perchÃ© devo saltare), cioÃ¨ fetch e decode di certe istruzioni non mi devono servire.</p>
<p>(ho decodato una istruzione) ma nel frattempo ho giÃ  caricato 4 e 5 che non mi servono!</p>
<h3 id="346-predizione-di-salti">3.4.6 Predizione di salti<a hidden class="anchor" aria-hidden="true" href="#346-predizione-di-salti">#</a></h3>
<p>Possiamo utilizzare certe euristiche (ragionamenti caso per caso) per predire alcuni salti.</p>
<p><strong>Salti all&rsquo;indietro</strong></p>
<p>Si possono prevedere per cicli while e for dei salti all&rsquo;indietro.</p>
<p>Per salti incondizionati si puÃ² mettere una <strong>instruzione NOP</strong> in modo che faccia salti incondizionati senza sprecare istruzioni.</p>
<ul>
<li>
<p>Esempio data race (read after write)</p>
<p>AX = 0</p>
<p>BX = 0</p>
<p>DX = 0</p>
<p>AX = DX + 1</p>
<p>BX = AX - 1</p>
<ol>
<li>fetch a</li>
<li>decode a, fetch b</li>
<li>leggo DX (a) , decode b</li>
<li>DX + 1 (a), leggo AX (b) MA STO LEGGENDO TROPPO PRESTO!</li>
</ol>
<p>Quindi devo chiudere AX ed aspettare che AX venga scritto</p>
</li>
</ul>
<p>A volte, tipico dei processori CISC, si tende a eseguire minicomandi in ordine diverso perchÃ© ritenuti piÃ¹ efficienti, quindi si mischia un pÃ², proprio come intendi per combinatorio e la fai.</p>
<p>Entra cisc ma esegue risc.</p>
<hr>
<p>Esiste una <strong>BPU</strong>Â (<em>Branch Prediction Unit</em>), che cerca di predire l&rsquo;esito di un salto, come spiegato <a href="https://it.wikipedia.org/wiki/Predizione_delle_diramazioni">in questa pagina di wiki</a> e una <strong>BTP</strong> (<em>Branch Target Predictor)</em>  che controlla le istruzioni nel ramo di arrivo (<a href="https://it.wikipedia.org/wiki/Branch_target_predictor">qui</a>). Questi sono le componenti principali che determinano la predizione dei salti.</p>
<p>In alternativa si mettono dei NOP.
o di arrivo (<a href="https://it.wikipedia.org/wiki/Branch_target_predictor">qui</a>). Questi sono le componenti principali che determinano la predizione dei salti.</p>
<p>In alternativa si mettono dei NOP.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="flecart.github.io/tags/no-tags/">No-Tags</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share CPU e storia degli elaboratori on x"
            href="https://x.com/intent/tweet/?text=CPU%20e%20storia%20degli%20elaboratori&amp;url=flecart.github.io%2fnotes%2fcpu-e-storia-degli-elaboratori%2f&amp;hashtags=no-tags">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share CPU e storia degli elaboratori on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=flecart.github.io%2fnotes%2fcpu-e-storia-degli-elaboratori%2f&amp;title=CPU%20e%20storia%20degli%20elaboratori&amp;summary=CPU%20e%20storia%20degli%20elaboratori&amp;source=flecart.github.io%2fnotes%2fcpu-e-storia-degli-elaboratori%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share CPU e storia degli elaboratori on reddit"
            href="https://reddit.com/submit?url=flecart.github.io%2fnotes%2fcpu-e-storia-degli-elaboratori%2f&title=CPU%20e%20storia%20degli%20elaboratori">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share CPU e storia degli elaboratori on facebook"
            href="https://facebook.com/sharer/sharer.php?u=flecart.github.io%2fnotes%2fcpu-e-storia-degli-elaboratori%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share CPU e storia degli elaboratori on whatsapp"
            href="https://api.whatsapp.com/send?text=CPU%20e%20storia%20degli%20elaboratori%20-%20flecart.github.io%2fnotes%2fcpu-e-storia-degli-elaboratori%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share CPU e storia degli elaboratori on telegram"
            href="https://telegram.me/share/url?text=CPU%20e%20storia%20degli%20elaboratori&amp;url=flecart.github.io%2fnotes%2fcpu-e-storia-degli-elaboratori%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share CPU e storia degli elaboratori on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=CPU%20e%20storia%20degli%20elaboratori&u=flecart.github.io%2fnotes%2fcpu-e-storia-degli-elaboratori%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
