<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Livello di Rete | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="no-tags">
<meta name="description" content="Ripasso Prox: 50 Ripasso: June 14, 2023 Ultima modifica: May 13, 2023 11:59 PM Primo Abbozzo: October 12, 2022 9:50 AM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Reti di Reti Le parti importanti per questo sono Data Plane e Control Plane (che ha saltato quasi tutto, ma almeno dijkstra lo dovresti fare bene)
Introduzione (puoi skippare 🟩) La puoi skipppare perché tratta in modo molto generare parti che saranno trattati in modo più approfondito in seguito.">
<meta name="author" content="Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="https://flecart.github.io/notes/livello-di-rete/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/livello-di-rete/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>




<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>
<script type="text/javascript" async
src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>





<script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-WW6NN2QGKF', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Livello di Rete" />
<meta property="og:description" content="Ripasso Prox: 50 Ripasso: June 14, 2023 Ultima modifica: May 13, 2023 11:59 PM Primo Abbozzo: October 12, 2022 9:50 AM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Reti di Reti Le parti importanti per questo sono Data Plane e Control Plane (che ha saltato quasi tutto, ma almeno dijkstra lo dovresti fare bene)
Introduzione (puoi skippare 🟩) La puoi skipppare perché tratta in modo molto generare parti che saranno trattati in modo più approfondito in seguito." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://flecart.github.io/notes/livello-di-rete/" />
<meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png" />
<meta property="article:section" content="notes" />



<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png" />
<meta name="twitter:title" content="Livello di Rete"/>
<meta name="twitter:description" content="Ripasso Prox: 50 Ripasso: June 14, 2023 Ultima modifica: May 13, 2023 11:59 PM Primo Abbozzo: October 12, 2022 9:50 AM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Reti di Reti Le parti importanti per questo sono Data Plane e Control Plane (che ha saltato quasi tutto, ma almeno dijkstra lo dovresti fare bene)
Introduzione (puoi skippare 🟩) La puoi skipppare perché tratta in modo molto generare parti che saranno trattati in modo più approfondito in seguito."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Livello di Rete",
      "item": "https://flecart.github.io/notes/livello-di-rete/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Livello di Rete",
  "name": "Livello di Rete",
  "description": "Ripasso Prox: 50 Ripasso: June 14, 2023 Ultima modifica: May 13, 2023 11:59 PM Primo Abbozzo: October 12, 2022 9:50 AM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No\nReti di Reti Le parti importanti per questo sono Data Plane e Control Plane (che ha saltato quasi tutto, ma almeno dijkstra lo dovresti fare bene)\nIntroduzione (puoi skippare 🟩) La puoi skipppare perché tratta in modo molto generare parti che saranno trattati in modo più approfondito in seguito.",
  "keywords": [
    "no-tags"
  ],
  "articleBody": "Ripasso Prox: 50 Ripasso: June 14, 2023 Ultima modifica: May 13, 2023 11:59 PM Primo Abbozzo: October 12, 2022 9:50 AM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No\nReti di Reti Le parti importanti per questo sono Data Plane e Control Plane (che ha saltato quasi tutto, ma almeno dijkstra lo dovresti fare bene)\nIntroduzione (puoi skippare 🟩) La puoi skipppare perché tratta in modo molto generare parti che saranno trattati in modo più approfondito in seguito. La parte importante forse è il riassunto di cosa faccia questo livello.\nDiscussione rete locale globale Slide\nNo, non è possible creare una connessione globale utilizzando le tecnologie locali, come hub, switch e simili, perché causerebbe flooding e impedirebbe scalabilità e crescita dinamica che è classica della rete\nSe i milioni di calcolatori oggi connessi a Internet fossero tutti organizzati secondo i protocolli e gli schemi visti finora per le reti locali, la comunicazione tra due calcolatori su Internet richiederebbe di passare per migliaia di calcolatori intermedi, switch, bridge, segmenti di rete, ognuno dei quali aggiungerebbe ritardi di gestione, complessità, rischi di errore. Il problema dell’instradamento dei frame (routing), ovvero il decidere da che parte o su che segmento deve essere inoltrato un frame per raggiungere il destinatario finale, richiederebbe in ogni dispositivo una lista completa (tabella di instradamento) di tutti gli indirizzi MAC dei dispositivi nel mondo, con a fianco l’indicazione della direzione di inoltro. Ovviamente questo limiterebbe in modo critico la scalabilità e la crescita di Internet. Inoltre causerebbe flooding perché praticamente ogni pacchetto di ogni computer rete di internet dovrebbe passare da ogni computer.\nUna soluzione semplice consiste nell’elezione di un rappresentante per ogni rete locale X (e indichiamo con la rete sotto di essa come dominio di rete locale) (il router di X), incaricato di ricevere tutti i pacchetti dati destinati a uno dei calcolatori della rete locale (es. mac1 di X, mac2 di X, ecc.). Ricevuti i pacchetti destinati alla rete locale, il router potrebbe occuparsi di recapitare alla rete locale i pacchetti, come se si trattasse di un frame a livello MAC/LLC destinato all’indirizzo MAC del destinatario. Allo stesso modo, ogni router dovrebbe farsi carico di inoltrare tutti i pacchetti uscenti dalla propria rete locale, verso i router delle reti di destinazione. Per rispettare le direttive dettate dallo standard ISO/OSI, il livello di indirizzamento e la gestione dell’instradamento dei pacchetti tra i router vengono gestiti al terzo livello (rete) della gerarchia dei protocolli di Internet.\nPer ciò che riguarda i router, tuttavia, lo scambio diretto tra router di pacchetti destinati alle rispettive reti locali potrebbe ridurre molto la complessità dell’instradamento. I router comunicano quindi attraverso collegamenti dati molto veloci, dette dorsali (backbone). Ogni router deve ricordare in una tabella di instradamento (forwarding table) solo quale sia il primo router intermedio per raggiungere ogni altro router. La visione del sistema al terzo livello (Rete) da parte dei router è quindi simile alla visione che appare a destra nella figura. Si nota come tutti i dettagli delle reti locali siano di fatto nascosti dai router a questo livello.\nIl router deve avere una mappa fra gli indirizzi IP e i mac!\nObiettivi generali del livello (6) (!) 🟥+ Sintassi\nStruttura gerarchica fra dominio e host (per facilitare l’invio) Busta a livello arancione, terzo livello. Semantica\nFrammentazione dei dati Questa parte non è più esistente per gli IPv6, perché è un overhead in più che non si vuole dare ai router Si occupa solamente di inviare. Un motivo per cui succede è l’efficienza, tenere in memoria questa cosa è molto costosa. I router devono solamente tritare pacchetti! Forwarding dei pacchetti, inoltramento dei pacchetti O ricezione del pacchetto se è giusto. Non si occupa di affidabilità del trasporto (di cui si occupa il livello mac e trasporto) Hardware (operazionale credo)\nDispositivi fisici di questo livello, come i router (quindi tabelle di instradamento e protocollo di instradamento e aggiornamento) Protocollo di rete Slide1\nSlide2\nIn questa parte iniziamo ad analizzare il concetto di rete globale, ossia non è più locale!\nIl livello rete di Internet si basa sul protocollo IP (Internet Protocol). Il protocollo IP definisce un nuovo schema di indirizzamento globale e gerarchico, che permette di identificare univocamente tutti i dispositivi di rete e allo stesso tempo la loro rete locale di appartenenza. Gli indirizzi usati permettono di identificare intere reti locali come un riferimento singolo nella gestione dell’instradamento dei pacchetti. Questo fatto semplifica molto la visione della rete che appare al livello Rete. Al protocollo IP, si possono associare protocolli di instradamento dei pacchetti dal mittente al destinatario finale (forwarding), originando servizi di trasmissione a pacchetto di tipo connectionless. Il protocollo IP richiede l’adozione di nuovi dispositivi amministratori dell’inoltro dei pacchetti a livello Rete, detti router.\nRouter I router sono forniti di tabelle di instradamento che illustrano la topologia della rete vista al livello dei router stessi (quindi non è necessario conoscere gli indirizzi dei calcolatori di una LAN al di fuori della LAN stessa. I router devono implementare protocolli di aggiornamento delle tabelle di instradamento (detti protocolli di routing). Ulteriore compito dei router è la gestione della frammentazione dei dati da spedire nei pacchetti, e la creazione della busta di livello rete con gli indirizzi del router mittente e destinatario di ogni pacchetto inoltrato.\nSono improntate alla efficienza! Principalmente è solo hardware che è in grado di far arrivare e partire un pacchetto a ogni ciclo di clock.\nNon self-similar 🟩 Si è tentato di cercare di predire i dati futuri pensando a quanti dati ho ora. Ma si è scoperto che non è proprio possibile, perché ci sono dei burst di richieste, dipendenti dalle richieste delle singole applicazione, per questo motivo sembra che sia un sistema caotico (esempio della farfalla). Principalmente perché questo è dipendente dai media (es. youtube).\nIndirizzo IP Gli indirizzi IP sono una nuova specie di indirizzi rispetto al MAC, necessari per il Protocollo omonimo;\nHeader IP 🟨++ Slide del formato IP\nQuesto è il bellissimo pacchetto di livello trasporto 🙂. NOTA: vedi che contiene il pacchetto dello stato superiore.\nVersion sono 4 bit per la versione. Dimensione dell’header in byte (che il campo options lo rendere variabile). Il campo Type of Service, o TOS, definisce il valore di priorità, di cui abbiamo parlato Scheduling dei routers (3+) 🟩. Che è principalmente utilizzato in internet due (basta un router che non lo sia e fa droppare le garanzie). (solitamente è ignorato). 16 bit per la lunghezza, quindi al massimo posso mandare 65k nel payload. L’identificazion di 16 + cose bits è per capire la targa, meglio per la frammentazione (quel sistema per spezzattare file lunghi e inviarli a pezzetti), sono ricomposti a destinazione, il router lo ignora 🙂, l’ultimo ha flag a 0, e offset più lungo Time to live è una cosa che viene decrementata ad ogni router e viene dropatto il pacchetto se vado a 0 Upper layer è il protocollo di livello 4 da utilizzare. Per verificare se non ci sono stati errori di trasmissione. (Che è molto facile da manipolare, però buono per errori a caso di trasmissione). Alcune opzioni tipo la rotta da prendere (tipo i router da visitare), itmestamp, La cosa è che questa parte è variabile.\nC’è un overhead di 40 bytes!.\nFrammentazione e Reassembly 🟩 Per questa parte concetti importanti da comprendere sono:\nPerché si fa frammetnazione (MTU) e perché si riassembla solamente alla fine. Campi dell’header IP utili alla frammentazione e perché vengono utilizzati. Non ha molto senso fare reassembly in mezzo, perché il pacchetto potrebbe fare una altra strada, sono indipendenti una volta spediti.\npoi si potrebbero fare fragmentation anche in un router intermedio, si potrebbero fare fragmentation ancora dopo! Frammentazione è necessaria se il pacchetto è più grande del MTU Maximum Transfer Unit.\nSlide esempio di fragmentazione\nStruttura IPv4 🟩 Un indirizzo IPv4 è un valore espresso su 32 bit (4 Byte), e può essere espresso anche come sequenza di 4 valori decimali, separati da punto. Ogni valore decimale può essere compreso tra i valori 0 e 255. Un esempio di indirizzo IP valido è (130.136.250.1).\nOgni indirizzo IP è sempre composto da due parti:\nnumero della rete IP alla quale appartiene la scheda (network number), numero dell’interfaccia di rete (host number) all’interno della rete IP. Esistono dei numeri speciali per ogni rete:\nHost tutti 0 e tutti 1\nTutti 0 → indica la rete stessa Tutti 1 → indica l’indirizzo di broadcast Datagramma IPv6 Slide IPv6\nIL nextheader dice il protocollo che sta sopra, stesso di upper level di sopra\nIl campo priority è siile al Type of service, ci da la priorità del flusso di dati Flow label identifica il flusso di dati (infatti non c’è la frammentazione), anche se non è ben definito il concetto di flusso. Hop limit è la stessa cosa del time to live. Flow label (questo è molto importante!, se il flusso identifica una comunicazione, non ho bisogno di indirizzi sorgente, finale, porta etc., per questo motivo posso compattare le informazioni!) Struttura delle reti Univocità e statico/dinamico 🟩 Slide\nEsempio slide\nAttualmente usati si riferiscono al protocollo IP versione 4, (IPv4). Un indirizzo IP viene associato a una e una sola (univoca) interfaccia di rete (scheda di rete). Potrebbe essere contemporaneamente identificato da più di un indirizzo IP nel caso in cui ci siano più interfaccie di rete (e più MAC). Se l’associazione univoca tra indirizzo MAC dell’interfaccia di rete e l’indirizzo IP rimane sempre lo stesso, allora si parla di IP statico. In caso contrario, se può cambiare l’associazione MAC-IP a seconda di vari fattori, si parla di IP dinamico. (cambio da dove mi connetto!).\nQuando è statico è utile quando stiamo ad offrire dei servizi, così non devo fare aggiornamenti, i computer sanno che strada devono fare per raggiungere un certo computer.\nClassi di rete 🟩 Sono definite tre classi di reti IP, che si differenziano sulla base del numero massimo di host supportabili. Il valore dell’indirizzo IP determina la classe della rete: A,B,C (vedere figura).\nLe reti di classe A sono al massimo 126 e ognuna può contenere fino a oltre 16 milioni di host. Per le reti di classe A, il byte di indirizzo più significativo (a sinistra) ha sempre il primo bit uguale a zero, e può assumere i valori da 1 a 126 (network number) rispetto ai 128 valori possibili. I tre byte rimanenti possono assumere oltre 16 milioni di combinazioni, ognuna associabile a un host della rete. 0XXXXXXX.xxxxxxxx.xxxxxxxx.xxxxxxxx\nUna nota particolare è l’indirizzo 127 che è un indirizzo di loopback perché fa finta di uscire, e poi all’ultimo rientra. Questo indirizzo è utile per testare protocolli di rete.\nLe reti di classe B sono al massimo 16.382 e ognuna può contenere fino a oltre 64.000 host. Per le reti di classe B, il network number è dato dai due byte di indirizzo più significativi (a sinistra), che hanno sempre i primi due bit uguali alla coppia (uno,zero). I network number di classe B possono assumere i valori da 128.0. a 191.255. I due byte rimanenti (host number) possono assumere oltre 64.000 combinazioni, ognuna associabile a un host della rete.\nforma di 10XXXXXX.XXXXXXXX.xxxxxxxx.xxxxxxxx\nLe reti di classe C sono oltre 2 milioni, e ognuna può contenere fino a 254 host. Per le reti di classe C, i tre byte di indirizzo più significativi (a sinistra) rappresentano il network number, e hanno sempre i primi tre bit uguali alla terna (uno,uno,zero). I network number di classe C possono assumere i valori da 192.0.0 a 223.255.255. Il byte rimanente (host number) può assumere 254 combinazioni utili, su 256 possibili, ognuna associabile a un host della rete.\n110XXXXX.XXXXXXXX.XXXXXXXX.xxxxxxxx\nConvenzione l’ultimo IP disponibile per l’Host di solito è dato al Router.\nSottoreti e netmask !!! (3) 🟩 Slide\nLa figura mostra a sinistra uno schema gerarchico di strutturazione di una rete di classe B. A partire dall’alto troviamo il router principale (default router) della rete 130.136, il cui indirizzo IP è nell’esempio 130.136.0.254. Alla rete 130.136 appartengono anche tre router subordinati, con IP 130.136.1.254, 130.136.2.254, 130.136.3.254 rispettivamente amministratori delle sottoreti (130.136.1.), (130.136.2.) e (130.136.3.).\nNetmask\nIl Netmask identifica nelle zone in cui è settato 1 l’indirizzo di rete e sottorete, dove è 0 l’indirizzo di host. Quindi ci dice ìl modo con cui si interpreta un byte di rete. Obbligatoriamente deve essere in questa forma (\n$1^n0^m: n + m = 32$ se vogliamo utilizzare una sintassi più famigliare da Linguaggi di programmazione).\nIl concetto di creare sottoreti si può riassumere in frazionare l’host in altre due parti che rappresentano l’indirizzo di sottorete e l’host. Queste sono nuove componenti logiche.\nFacendo questa operazione abbiamo $nreti \\times(nhost - 1)$ , mentre prima era $nhostgrosso$ . Alla fine se si svolge questo calcolo sono stesso numero di host, (magari perdo nreti numero di host per i router, però la ho gerarchizzata meglio).\nEsiste una notazione molto più carina per i netmask che è il CIDR (Classless Interdomain ROuting) in pratica stai dicendo quanti bit sono messi a 1\nCreazione sottoreti\nIn questo modo è possibile creare una gerarchia di sottoreti, ognuna delle quali è amministrata da un router (il default router). Esempio: data la rete di classe B 130.136. per semplicità decidiamo di considerare possibili 256 sottoreti: netmask 255.255.255.0.\nIl numero della sottorete è quindi fornito dai primi tre byte dell’indirizzo IP, es. 130.136.1. è la sottorete 1, 130.136.2. è la sottorete 2, mentre ad esempio 130.136.1.22 è l’host 22 della sottorete 1, 130.136.3.48 è l’host 48 della sottorete 3, e così via. (quindi un router sottorete ora prende IP del genere 130.136.1.254, perché indica la sottorete 1 della rete di classe B che si possiede).\nPer istruire ogni router subordinato sulla dimensione e sull’interpretazione degli indirizzi IP da amministrare, ogni router subordinato deve essere fornito di una maschera di rete (netmask), evidenziata a destra.\nElementi fondamentali per il Protocollo IP\nSenza questi tre elementi il protocollo IP non funziona proprio. Quindi è la prima cosa da fare per configurarlo.\nMaschera di rete Indirizzo IP Indirizzo default di router (il primo router sopra la gerarchia, che è a chi mandare quando non so a chi mandare). (può essere che con dispositivi stupidi abbiamo solamente l’indirizzo del router). La maschera di rete serve per capire\nNetmask\nIn particolare rileviamo qui 2 funzionalità principali per questo netmask:\nDire quanti subnet esistono, oltre alla rete principale Far sapere all’host a quale rete appartiene È quindi una quantità fondamentale per configurare la regte\nClassless Inter Domain Routing 🟩 Questo nuovo modo per fare netmask (nuovo rispetto gli anni 80) è un modo per avere tagli di rete più efficienti, nel senso che se prima la C non bastava, ti davano una B( Renzone a unibo ha avuto in questo modo una classe B). Ora possono avere molta più disponibilità per i tagli negli indirizzi di rete. Questa cosa permette anche un concetto di supernetting. (in cui ho un insieme condiguo di classi più piccole, e così mi creo una rete maggiore, più grosso delle classi, così ho maggiore dinamicità).\nEsempio forwarding dei Pacchetti\nSlide\nSlide esempio\nLa figura mostra un esempio di instradamento su rete IP. Esistono tre router Ry, Rz e Rk rispettivamente amministratori delle reti (140.217.), (190.89.), e (130.136.). Il router Ry è connesso a Rz, e Rz è connesso a Rk. Tale informazione risulta dalle tabelle di instradamento di Ry, Rz, Rk. La rete del router Ry include due sottoreti (140.217.1.) e (140.217.2), amministrate dai rispettivi default router 140.217.1.254 e 140.217.2.254 . La rete del router Rk include tre sottoreti (130.136.1.), (130.136.2.) e (130.136.3.), amministrate dai rispettivi default router 130.136.1.254, 130.136.2.254 e 130.136.3.254 . Un pacchetto IP spedito dall’host 140.217.2.10 all’host 130.136.2.33 deve compiere il seguente tragitto: passa per il default router di sottorete 140.217.2.254 che, notando che il destinatario non appartiene alla sottorete, lo inoltra al default router del livello superiore di rete: 140.217.0.254. Il default router di rete controlla la propria tabella di forwarding e scopre che per raggiungere la destinazione il pacchetto deve essere inoltrato al router intermedio 190.89.0.254. Il router intermedio riceve il pacchetto, verifica la propria tabella di forwarding, scopre che il prossimo destinatario intermedio è il router 130.136.0.254, al quale inoltra il pacchetto. Il router 130.136.2.254 riceve il pacchetto e verifica che appartiene alla propria rete, inoltrando quindi il pacchetto internamente. Il router di sottorete 130.136.2.254 riceve il pacchetto e scopre che appartiene alla propria sottorete, inoltrando il pacchetto internamente. Finalmente, l’host 130.136.2.33 riceve il pacchetto a lui destinato. Si possono notare alcuni aspetti importanti: malgrado il numero elevato di host che potrebbero essere parte del sistema considerato, il processo di instradamento permane molto semplice, composto da piccole e semplici operazioni di base. Le tabelle di instradamento sono limitate agli elementi che agiscono allo stesso livello, e quindi l**’instradamento è gerarchico**.\nRouting 🟨 Si parlerà molto meglio del routing in Data Plane e Control Plane\nSlide\nIl problema del routing può essere definito come il problema di mantenere l’aggiornamento delle tabelle di forwarding in tutti i router della rete. Questo problema può essere a volte molto complesso, a causa di frequenti modifiche forzate dei cammini per i pacchetti in rete. Le cause di tali modifiche possono essere dovute a molti fattori, ad esempio: la mobilità degli host in reti senza fili, guasti di mezzi trasmissivi, interruzione delle linee, guasti di router, nuove politiche e accordi per lo scambio dei dati tra gestori di dorsali e sistemi autonomi.\nUn sistema autonomo (AS) è sinonimo di una grossa rete, o una collezione di reti, soggetta a una comune politica di amministrazione. Gli accordi commerciali tra gestori di AS possono modificare i cammini consentiti per lo scambio dei pacchetti di dati. Per realizzare un parallelo intuitivo, gli AS si comportano come nazioni che permettano o meno il passaggio di pacchetti, analoghi a voli aerei, sul loro suolo nazionale. Ogni volta che si verifica uno dei problemi citati, esistono router che hanno indicazioni errate nelle loro tabelle di forwarding. Tutto ciò può causare la perdita di pacchetti, oppure può determinare un disordine nell’arrivo di pacchetti che hanno seguito strade diverse. Ecco quindi una causa del servizio connectionless ottenuto dal livello rete basato solo sul protocollo IP. I router hanno bisogno di aggiornare al più presto le loro tabelle, per evitare malfunzionamenti del servizio.\nIn pratica fanno lo stesso modo per decidere dove mandare, cioè hanno lo stesso protocollo, ma dato che si trovano in parti diverse avranno poi tabelle di instradamento diverse.\nla Core network è molto veloce nel trovare il percorso giusto (è molto più fisso, e sa più o meno dove mandare le cose).\nI protocolli di routing hanno la funzione di richiedere e scambiare informazioni per trovare cammini alternativi (idealmente il cammino migliore tra le possibili alternative), tra mittenti e destinatari dei pacchetti, e consentire quindi l’aggiornamento delle tabelle di forwarding. A puro titolo informativo, si citano alcune sigle di protocolli di routing adottati in Internet: Routing Information Protocol (RIP), Open Shortest Path First (OSPF), Border Gateway protocol (BGP). Questi algoritmi sono tutti utilizzati in locale. La cosa brutta è che il cammino ottimo cambia nel tempo (anche nell’ordine dei secondi), quindi gli algoritmi si devono abituare dinamicamente a questi nuovi dati.\nNote sistemi distribuiti o centralizzati\nIl centralizzato è bello perché è chiaro a chi chiedere per andare poi a mandare il pacchetto dove si vuole, il problema è che se il nodo centrale fallisce, cade l’intera rete.\nDistribuito è bello perché risolve il problema del single point of failure però dall’altra parte ogni nodo non ha una visione globale quindi non può fare altro che andare a massimizzare localmente, che spesso non è la cosa migliore.\nWikipedia sui sistemi autonomi\nLink, in pratica singola autorità amministrativa è la parola chiave.\nProtocolli basati su IP Protocollo ICMP (6) 🟨+ Slide\nICMP (Internet Control Message Protocol) è un protocollo standard definito per supportare i messaggi di controllo per la gestione della rete al livello 3. ICMP viene usato da semplici host, da router e persino da gateway (router speciali con ulteriori funzioni) per scambiare informazioni utili alla gestione del livello Rete. Le informazioni scambiate sono trasferite sotto forma di pacchetti IP. Utile per stabilire una sintomatologia dei problemi di reti.\nAlcuni esempi di messaggi ICMP che possono essere scambiati indicano, ad esempio:\nsituazioni di rete di destinazione irraggiungibile (possibile sintomo di problemi di routing, o di rottura di un router). In questo caso può convenire andare a cercare il problema di rete, che può essere fisico, e fixarlo in questo modo rete di destinazione sconosciuta (possibile sintomo di indirizzo IP di rete male specificato) In questo caso il router non sa a chi mandare, quindi alcuni fix sono 1. aggiornare tabelle di instradamento, o provare altre strade. Ossia nessuno conosce l’indirizzo della rete locale host di destinazione non raggiungibile (possibile sintomo che l’host sia spento o il cavo di connessione sia male collegato). Questo è un problema che non ci riguarda, quindi probabile che l’host si sia sconesso. Per questo significa che la rete è conosciuta!, quindi problema di rete locale!. host di destinazione sconosciuto (possibile sintomo di host number del’indirizzo IP male specificato, malgrado la rete indicata esista e sia raggiungibile). problemi con indirizzo IP protocollo richiesto non disponibile (sintomo di un tentativo di dialogo tra dispositivi male configurati, che non forniscono i servizi richiesti). (come se stessi provando ad accedere a un servizio in una porta sbagliata, o versione IP sbagliata o simili). ricerca di cammino alternativo (può essere usato per risolvere i problemi di routing). Anche chi riceve il messaggio, può rispondere in modo preinpostato a quelle richieste. (e dato che è preimpostato non c’è bisogno di avere un frame grosso!).\nApplicazioni su ICMP (2) 🟩 Slide\nLe applicazioni sono utilizzate solitamente per la verifica delle cause o del semplice sospetto di problemi di rete. L’applicazione PING permette di testare la connessione tra due host: eseguendo il comando “ping ",
  "wordCount" : "5430",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/livello-di-rete/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Livello di Rete
    </h1>
    <div class="post-meta">26 min&nbsp;·&nbsp;Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#reti-di-reti" aria-label="Reti di Reti">Reti di Reti</a><ul>
                        
                <li>
                    <a href="#introduzione-puoi-skippare-" aria-label="Introduzione (puoi skippare 🟩)">Introduzione (puoi skippare 🟩)</a><ul>
                        
                <li>
                    <a href="#discussione-rete-locale-globale" aria-label="Discussione rete locale globale">Discussione rete locale globale</a></li>
                <li>
                    <a href="#obiettivi-generali-del-livello-6--" aria-label="Obiettivi generali del livello (6) (!) 🟥&#43;">Obiettivi generali del livello (6) (!) 🟥+</a></li>
                <li>
                    <a href="#protocollo-di-rete" aria-label="Protocollo di rete">Protocollo di rete</a></li>
                <li>
                    <a href="#router" aria-label="Router">Router</a></li>
                <li>
                    <a href="#non-self-similar-" aria-label="Non self-similar 🟩">Non self-similar 🟩</a></li></ul>
                </li>
                <li>
                    <a href="#indirizzo-ip" aria-label="Indirizzo IP">Indirizzo IP</a><ul>
                        
                <li>
                    <a href="#header-ip-" aria-label="Header IP 🟨&#43;&#43;">Header IP 🟨++</a></li>
                <li>
                    <a href="#frammentazione-e-reassembly-" aria-label="Frammentazione e Reassembly 🟩">Frammentazione e Reassembly 🟩</a></li>
                <li>
                    <a href="#struttura-ipv4-" aria-label="Struttura IPv4 🟩">Struttura IPv4 🟩</a></li>
                <li>
                    <a href="#datagramma-ipv6" aria-label="Datagramma IPv6">Datagramma IPv6</a></li></ul>
                </li>
                <li>
                    <a href="#struttura-delle-reti" aria-label="Struttura delle reti">Struttura delle reti</a><ul>
                        
                <li>
                    <a href="#univocit%c3%a0-e-staticodinamico-" aria-label="Univocità e statico/dinamico 🟩">Univocità e statico/dinamico 🟩</a></li>
                <li>
                    <a href="#classi-di-rete-" aria-label="Classi di rete 🟩">Classi di rete 🟩</a></li>
                <li>
                    <a href="#sottoreti-e-netmask--3-" aria-label="Sottoreti e netmask !!! (3) 🟩">Sottoreti e netmask !!! (3) 🟩</a></li>
                <li>
                    <a href="#classless-inter-domain-routing-" aria-label="Classless Inter Domain Routing 🟩">Classless Inter Domain Routing 🟩</a></li>
                <li>
                    <a href="#routing-" aria-label="Routing 🟨">Routing 🟨</a></li></ul>
                </li>
                <li>
                    <a href="#protocolli-basati-su-ip" aria-label="Protocolli basati su IP">Protocolli basati su IP</a><ul>
                        
                <li>
                    <a href="#protocollo-icmp-6-" aria-label="Protocollo ICMP (6) 🟨&#43;">Protocollo ICMP (6) 🟨+</a></li>
                <li>
                    <a href="#applicazioni-su-icmp-2-" aria-label="Applicazioni su ICMP (2) 🟩">Applicazioni su ICMP (2) 🟩</a></li>
                <li>
                    <a href="#protocollo-arp-e-rarp-" aria-label="Protocollo ARP e RARP 🟩">Protocollo ARP e RARP 🟩</a></li>
                <li>
                    <a href="#protocolo-dhcp--" aria-label="Protocolo DHCP 🟩-">Protocolo DHCP 🟩-</a></li>
                <li>
                    <a href="#ipv6-e-tunnelling-" aria-label="IPv6 e tunnelling 🟩">IPv6 e tunnelling 🟩</a></li>
                <li>
                    <a href="#nat" aria-label="NAT">NAT</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#cose-vecchie" aria-label="Cose vecchie">Cose vecchie</a><ul>
                        <ul>
                        
                <li>
                    <a href="#confronto-col-mac" aria-label="Confronto col MAC">Confronto col MAC</a></li>
                <li>
                    <a href="#caratteristiche-ip-3" aria-label="Caratteristiche IP (3)">Caratteristiche IP (3)</a></li>
                <li>
                    <a href="#indirizzamento-ip" aria-label="Indirizzamento IP">Indirizzamento IP</a></li>
                <li>
                    <a href="#classi-di-rete" aria-label="Classi di rete">Classi di rete</a></li></ul>
                    
                <li>
                    <a href="#router-1" aria-label="Router">Router</a><ul>
                        
                <li>
                    <a href="#tabelle-e-protocollo-di-instradamento" aria-label="Tabelle e protocollo di instradamento">Tabelle e protocollo di instradamento</a></li>
                <li>
                    <a href="#protocollo-di-routing" aria-label="Protocollo di routing">Protocollo di routing</a></li>
                <li>
                    <a href="#cidr-classless-inter-domain-routing" aria-label="CIDR Classless Inter Domain Routing">CIDR Classless Inter Domain Routing</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Ripasso Prox: 50
Ripasso: June 14, 2023
Ultima modifica: May 13, 2023 11:59 PM
Primo Abbozzo: October 12, 2022 9:50 AM
Stato: 🌕🌕🌕🌕🌗
Studi Personali: No</p>
<h1 id="reti-di-reti">Reti di Reti<a hidden class="anchor" aria-hidden="true" href="#reti-di-reti">#</a></h1>
<p>Le parti importanti per questo sono <a href="/notes/data-plane/">Data Plane</a> e <a href="/notes/control-plane/">Control Plane</a> (che ha saltato quasi tutto, ma almeno dijkstra lo dovresti fare bene)</p>
<h2 id="introduzione-puoi-skippare-">Introduzione (puoi skippare 🟩)<a hidden class="anchor" aria-hidden="true" href="#introduzione-puoi-skippare-">#</a></h2>
<p>La puoi skipppare perché tratta in modo molto generare parti che saranno trattati in modo più approfondito in seguito. La parte importante forse è il riassunto di cosa faccia questo livello.</p>
<h3 id="discussione-rete-locale-globale">Discussione rete locale globale<a hidden class="anchor" aria-hidden="true" href="#discussione-rete-locale-globale">#</a></h3>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Livello di Rete/Untitled.png" alt="image/universita/ex-notion/Livello di Rete/Untitled">
</li>
</ul>
<blockquote>
<p>No, non è possible creare una connessione globale utilizzando le tecnologie locali, come hub, switch e simili, perché causerebbe <strong>flooding</strong> e impedirebbe scalabilità e crescita dinamica che è classica della rete</p>
</blockquote>
<p>Se i milioni di calcolatori oggi connessi a Internet fossero tutti organizzati secondo i protocolli e gli schemi visti finora per le reti locali, la comunicazione tra due calcolatori su Internet richiederebbe di passare per migliaia di calcolatori intermedi, switch, bridge, segmenti di rete, ognuno dei quali aggiungerebbe ritardi di gestione, complessità, rischi di errore. Il <strong>problema dell’instradamento</strong> dei frame (routing), ovvero il decidere da che parte o su che segmento deve essere inoltrato un frame per raggiungere il destinatario finale, richiederebbe in ogni dispositivo una lista completa (tabella di instradamento) di tutti gli indirizzi MAC dei dispositivi nel mondo, con a fianco l’indicazione della direzione di inoltro. Ovviamente questo limiterebbe in modo <em>critico</em> la scalabilità e la crescita di Internet. Inoltre <strong>causerebbe flooding</strong> perché praticamente ogni pacchetto di ogni computer rete di internet dovrebbe passare da ogni computer.</p>
<p>Una soluzione semplice consiste nell’elezione di un <strong>rappresentante per ogni rete locale</strong> X (e indichiamo con la rete sotto di essa come <strong>dominio di rete locale</strong>) (il router di X), incaricato di ricevere tutti i pacchetti dati destinati a uno dei calcolatori della rete locale (es. mac1 di X, mac2 di X, ecc.). Ricevuti i pacchetti destinati alla rete locale, il router potrebbe occuparsi di recapitare alla rete locale i pacchetti, come se si trattasse di un frame a livello
MAC/LLC destinato all’indirizzo MAC del destinatario. Allo stesso modo, ogni router dovrebbe farsi carico di inoltrare tutti i pacchetti uscenti dalla propria rete locale, verso i router delle reti di destinazione. Per rispettare le direttive dettate dallo standard ISO/OSI, il livello di indirizzamento e la gestione dell’instradamento dei pacchetti tra i router vengono gestiti al terzo livello (rete) della gerarchia dei protocolli di Internet.</p>
<p>Per ciò che riguarda i router, tuttavia, lo scambio diretto tra router di pacchetti destinati alle rispettive reti locali potrebbe ridurre molto la complessità dell’instradamento. I router comunicano quindi attraverso collegamenti dati molto veloci, dette <strong>dorsali (backbone)</strong>. Ogni router deve ricordare in una <strong>tabella di instradamento (forwarding table)</strong> solo quale sia il primo router
intermedio per raggiungere ogni altro router. La visione del sistema al terzo livello (Rete) da parte dei router è quindi simile alla visione che appare a destra nella figura. Si nota come tutti i dettagli delle reti locali siano di fatto nascosti dai router a questo livello.</p>
<p>Il router deve avere una mappa fra gli indirizzi IP e i mac!</p>
<h3 id="obiettivi-generali-del-livello-6--">Obiettivi generali del livello (6) (!) 🟥+<a hidden class="anchor" aria-hidden="true" href="#obiettivi-generali-del-livello-6--">#</a></h3>
<p><strong>Sintassi</strong></p>
<ol>
<li>Struttura gerarchica fra dominio e host (per facilitare l’invio)</li>
<li>Busta a livello arancione, terzo livello.</li>
</ol>
<p><strong>Semantica</strong></p>
<ol>
<li>Frammentazione dei dati
<ol>
<li>Questa parte non è più esistente per gli IPv6, perché è un overhead in più che non si vuole dare ai router</li>
</ol>
</li>
<li>Si occupa <strong>solamente di inviare</strong>. Un motivo per cui succede è l’efficienza, tenere in memoria questa cosa è molto costosa. I router devono solamente tritare pacchetti!
<ol>
<li>Forwarding dei pacchetti, inoltramento dei pacchetti</li>
<li>O ricezione del pacchetto se è giusto.</li>
<li>Non si occupa di affidabilità del trasporto (di cui si occupa il livello mac e trasporto)</li>
</ol>
</li>
</ol>
<p><strong>Hardware (operazionale credo)</strong></p>
<ol>
<li>Dispositivi fisici di questo livello, come i router (quindi tabelle di instradamento e protocollo di instradamento e aggiornamento)</li>
</ol>
<h3 id="protocollo-di-rete">Protocollo di rete<a hidden class="anchor" aria-hidden="true" href="#protocollo-di-rete">#</a></h3>
<ul>
<li>
<p>Slide1</p>
  <img src="/images/notes/image/universita/ex-notion/Livello di Rete/Untitled 1.png" alt="image/universita/ex-notion/Livello di Rete/Untitled 1">
</li>
<li>
<p>Slide2</p>
  <img src="/images/notes/image/universita/ex-notion/Livello di Rete/Untitled 2.png" alt="image/universita/ex-notion/Livello di Rete/Untitled 2">
</li>
</ul>
<p>In questa parte iniziamo ad analizzare il concetto di <strong>rete globale</strong>, ossia non è più locale!</p>
<p>Il livello rete di Internet si basa sul protocollo IP (Internet Protocol). Il protocollo IP definisce un nuovo schema di indirizzamento globale e gerarchico, che permette di <strong>identificare univocamente</strong> tutti i dispositivi di rete e allo stesso tempo la loro rete locale di appartenenza. Gli indirizzi usati permettono di identificare intere reti locali come un riferimento singolo nella gestione dell’instradamento dei pacchetti. Questo fatto semplifica molto la visione della rete che appare al livello Rete. Al protocollo IP, si possono associare <strong>protocolli di instradamento</strong> dei pacchetti dal mittente al destinatario finale (forwarding), originando servizi di trasmissione a pacchetto di tipo connectionless. Il protocollo IP richiede l’adozione di nuovi dispositivi amministratori dell’inoltro dei pacchetti a livello Rete, detti router.</p>
<h3 id="router">Router<a hidden class="anchor" aria-hidden="true" href="#router">#</a></h3>
<p>I router sono forniti di <strong>tabelle di instradamento</strong> che illustrano la topologia della rete vista al livello dei router stessi (quindi non è necessario conoscere gli indirizzi dei calcolatori di una LAN al di fuori della LAN stessa. I router devono implementare protocolli di aggiornamento delle tabelle di instradamento (detti protocolli di routing). Ulteriore compito dei router è la <strong>gestione della frammentazione dei dati</strong> da spedire nei pacchetti, e la creazione della busta di livello rete con gli indirizzi del router mittente e destinatario di ogni pacchetto inoltrato.</p>
<p>Sono improntate alla efficienza! Principalmente è solo hardware che è in grado di far arrivare e partire un pacchetto a ogni ciclo di clock.</p>
<h3 id="non-self-similar-">Non self-similar 🟩<a hidden class="anchor" aria-hidden="true" href="#non-self-similar-">#</a></h3>
<p>Si è tentato di cercare di predire i dati futuri pensando a quanti dati ho ora. Ma si è scoperto che non è proprio possibile, perché ci sono dei <strong>burst</strong> di richieste, dipendenti dalle richieste delle singole applicazione, per questo motivo sembra che sia un sistema caotico (esempio della farfalla). Principalmente perché questo è dipendente dai media (es. youtube).</p>
<h2 id="indirizzo-ip">Indirizzo IP<a hidden class="anchor" aria-hidden="true" href="#indirizzo-ip">#</a></h2>
<blockquote>
<p>Gli indirizzi IP sono una nuova specie di indirizzi rispetto al MAC, necessari per il Protocollo omonimo;</p>
</blockquote>
<h3 id="header-ip-">Header IP 🟨++<a hidden class="anchor" aria-hidden="true" href="#header-ip-">#</a></h3>
<ul>
<li>
<p>Slide del formato IP</p>
  <img src="/images/notes/image/universita/ex-notion/Livello di Rete/Untitled 3.png" alt="image/universita/ex-notion/Livello di Rete/Untitled 3">
</li>
</ul>
<p>Questo è il bellissimo pacchetto di livello trasporto 🙂. NOTA: vedi che contiene il pacchetto dello stato superiore.</p>
<ol>
<li>Version sono 4 bit per la versione.</li>
<li>Dimensione dell&rsquo;header in byte (che il campo options lo rendere variabile).</li>
<li>Il campo Type of Service, o TOS, definisce il <strong>valore di priorità</strong>, di cui abbiamo parlato <a href="/notes/scheduling-dei-routers-%283+%29-%F0%9F%9F%A9">Scheduling dei routers (3+) 🟩</a>. Che è principalmente utilizzato in internet due (basta un router che  non lo sia e fa droppare le garanzie). (solitamente è ignorato).</li>
<li>16 bit per la lunghezza, quindi al massimo posso mandare 65k nel payload.</li>
<li>L’identificazion di 16 + cose bits è per capire la targa, meglio per la frammentazione (quel sistema per spezzattare file lunghi e inviarli a pezzetti), sono ricomposti a destinazione, il router lo ignora 🙂, l&rsquo;ultimo ha flag a 0, e offset più lungo</li>
<li>Time to live è una cosa che viene decrementata ad ogni router e viene dropatto il pacchetto se vado a 0</li>
<li>Upper layer è il protocollo di livello 4 da utilizzare.</li>
<li>Per verificare se non ci sono stati errori di trasmissione. (Che è molto facile da manipolare, però buono per errori a caso di trasmissione).</li>
</ol>
<p>Alcune opzioni tipo la rotta da prendere (tipo i router da visitare), itmestamp,  La cosa è che questa parte è variabile.</p>
<p>C&rsquo;è un over<strong>head di 40 bytes!</strong>.</p>
<h3 id="frammentazione-e-reassembly-">Frammentazione e Reassembly 🟩<a hidden class="anchor" aria-hidden="true" href="#frammentazione-e-reassembly-">#</a></h3>
<p>Per questa parte concetti importanti da comprendere sono:</p>
<ol>
<li>Perché si fa frammetnazione (MTU) e perché si riassembla solamente alla fine.</li>
<li>Campi dell’header IP utili alla frammentazione e perché vengono utilizzati.</li>
</ol>
<p>Non ha molto senso fare reassembly in mezzo, perché il pacchetto potrebbe fare una altra strada, sono indipendenti una volta spediti.</p>
<ul>
<li>poi si potrebbero fare fragmentation anche in un router intermedio, si potrebbero fare fragmentation ancora dopo!</li>
</ul>
<p>Frammentazione è necessaria se il pacchetto è più grande del <strong>MTU Maximum Transfer Unit.</strong></p>
<ul>
<li>
<p>Slide esempio di fragmentazione</p>
  <img src="/images/notes/image/universita/ex-notion/Livello di Rete/Untitled 4.png" alt="image/universita/ex-notion/Livello di Rete/Untitled 4">
</li>
</ul>
<h3 id="struttura-ipv4-">Struttura IPv4 🟩<a hidden class="anchor" aria-hidden="true" href="#struttura-ipv4-">#</a></h3>
<p>Un indirizzo IPv4 è un valore espresso su <strong>32 bit (4 Byte)</strong>, e può essere espresso anche come sequenza di 4 valori decimali, separati da punto. Ogni valore decimale può essere compreso tra i valori 0 e 255. Un esempio di indirizzo IP valido è (130.136.250.1).</p>
<p>Ogni indirizzo IP è sempre composto da due parti:</p>
<ol>
<li>numero della rete IP alla quale appartiene la scheda (<strong>network number</strong>),</li>
<li>numero dell’interfaccia di rete (<strong>host number</strong>) all’interno della rete IP.</li>
</ol>
<p>Esistono dei numeri speciali per ogni rete:</p>
<p>Host tutti 0 e tutti 1</p>
<ul>
<li>Tutti 0 → indica la rete stessa</li>
<li>Tutti 1 → indica l’indirizzo di broadcast</li>
</ul>
<h3 id="datagramma-ipv6">Datagramma IPv6<a hidden class="anchor" aria-hidden="true" href="#datagramma-ipv6">#</a></h3>
<ul>
<li>
<p>Slide IPv6</p>
  <img src="/images/notes/image/universita/ex-notion/Livello di Rete/Untitled 5.png" alt="image/universita/ex-notion/Livello di Rete/Untitled 5">
</li>
</ul>
<p>IL nextheader dice il protocollo che sta sopra, stesso di upper level di sopra</p>
<ul>
<li>Il campo priority è siile al Type of service, ci da la priorità del flusso di dati</li>
<li>Flow label identifica il flusso di dati (infatti non c’è la frammentazione), anche se non è ben definito il concetto di flusso.</li>
<li>Hop limit è la stessa cosa del time to live.</li>
<li>Flow label (questo è molto importante!, se il flusso identifica una comunicazione, non ho bisogno di indirizzi sorgente, finale, porta etc., per questo motivo posso compattare le informazioni!)</li>
</ul>
<h2 id="struttura-delle-reti">Struttura delle reti<a hidden class="anchor" aria-hidden="true" href="#struttura-delle-reti">#</a></h2>
<h3 id="univocità-e-staticodinamico-">Univocità e statico/dinamico 🟩<a hidden class="anchor" aria-hidden="true" href="#univocità-e-staticodinamico-">#</a></h3>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Livello di Rete/Untitled 6.png" alt="image/universita/ex-notion/Livello di Rete/Untitled 6">
</li>
<li>
<p>Esempio slide</p>
  <img src="/images/notes/image/universita/ex-notion/Livello di Rete/Untitled 7.png" alt="image/universita/ex-notion/Livello di Rete/Untitled 7">
</li>
</ul>
<p>Attualmente usati si riferiscono al protocollo IP versione 4, (IPv4). Un indirizzo IP viene associato a una e una sola (<strong>univoca</strong>) interfaccia di rete (scheda di rete). Potrebbe essere contemporaneamente identificato da più di un indirizzo IP nel caso in cui ci siano più interfaccie di rete (e più MAC). Se l’associazione univoca tra indirizzo MAC dell’interfaccia di rete e l’indirizzo IP rimane sempre lo stesso, allora si parla di I<strong>P statico</strong>. In caso contrario, se può cambiare l’associazione MAC-IP a seconda di vari fattori, si parla di <strong>IP dinamico</strong>. (cambio da dove mi connetto!).</p>
<p>Quando è statico è utile quando stiamo ad offrire dei servizi, così non devo fare aggiornamenti, i computer sanno che strada devono fare per raggiungere un certo computer.</p>
<h3 id="classi-di-rete-">Classi di rete 🟩<a hidden class="anchor" aria-hidden="true" href="#classi-di-rete-">#</a></h3>
<p>Sono definite tre classi di reti IP, che si differenziano sulla base del numero massimo di host supportabili. Il valore dell’indirizzo IP determina la classe della rete: A,B,C (vedere figura).</p>
<p>Le reti di <strong>classe A</strong> sono al massimo 126 e ognuna può contenere fino a oltre 16 milioni di host. Per le reti di classe A, il byte di indirizzo più significativo (a sinistra) ha sempre il primo bit uguale a zero, e può assumere i valori da 1 a 126 (network number) rispetto ai 128 valori possibili. I tre byte rimanenti possono assumere oltre 16 milioni di combinazioni, ognuna associabile a un host della rete. 0XXXXXXX.xxxxxxxx.xxxxxxxx.xxxxxxxx</p>
<p>Una nota particolare è l&rsquo;indirizzo 127 che è un indirizzo di <strong>loopback</strong> perché fa finta di uscire, e poi all’ultimo rientra. Questo indirizzo è utile per testare protocolli di rete.</p>
<p>Le reti di <strong>classe B</strong> sono al massimo 16.382 e ognuna può contenere fino a oltre 64.000 host. Per le reti di classe B, il network number è dato dai due byte di indirizzo più significativi (a sinistra), che hanno sempre i primi due bit uguali alla coppia (uno,zero). I network number di classe B possono assumere i valori da 128.0. a 191.255. I due byte rimanenti (host number) possono assumere oltre 64.000 combinazioni, ognuna associabile a un host della rete.</p>
<p>forma di 10XXXXXX.XXXXXXXX.xxxxxxxx.xxxxxxxx</p>
<p>Le reti di <strong>classe C</strong> sono oltre 2 milioni, e ognuna può contenere fino a 254 host. Per le reti di classe C, i tre byte di indirizzo più significativi (a sinistra) rappresentano il network number, e hanno sempre i primi tre bit uguali alla terna (uno,uno,zero). I network number di classe C possono assumere i valori da 192.0.0 a 223.255.255. Il byte rimanente (host number) può assumere 254 combinazioni utili, su 256 possibili, ognuna associabile a un host della rete.</p>
<p>110XXXXX.XXXXXXXX.XXXXXXXX.xxxxxxxx</p>
<p><strong>Convenzione</strong> l’ultimo IP disponibile per l’Host di solito è dato al Router.</p>
<h3 id="sottoreti-e-netmask--3-">Sottoreti e netmask !!! (3) 🟩<a hidden class="anchor" aria-hidden="true" href="#sottoreti-e-netmask--3-">#</a></h3>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Livello di Rete/Untitled 8.png" alt="image/universita/ex-notion/Livello di Rete/Untitled 8">
<p>La figura mostra a sinistra uno schema gerarchico di strutturazione di una rete di classe B. A partire dall’alto troviamo il router principale (default router) della rete 130.136, il cui indirizzo IP è nell’esempio 130.136.0.254. Alla rete 130.136 appartengono anche tre router subordinati, con IP 130.136.1.254, 130.136.2.254, 130.136.3.254 rispettivamente amministratori delle sottoreti (130.136.1.), (130.136.2.) e (130.136.3.).</p>
</li>
</ul>
<p><strong>Netmask</strong></p>
<p>Il Netmask identifica nelle zone in cui è settato 1 l&rsquo;indirizzo di rete e sottorete, dove è 0 l’indirizzo di host. Quindi ci dice ìl modo con cui si interpreta un byte di rete. <strong>Obbligatoriamente</strong> deve essere in questa forma (</p>
$1^n0^m: n + m = 32$
<p> se vogliamo utilizzare una sintassi più famigliare da Linguaggi di programmazione).</p>
<p>Il concetto di creare sottoreti si può riassumere in <strong>frazionare</strong> l’host in altre due parti che rappresentano l’indirizzo di sottorete e l’host. Queste sono nuove <strong>componenti logiche</strong>.</p>
<p>Facendo questa operazione abbiamo </p>
$nreti \times(nhost - 1)$
<p>, mentre prima era  </p>
$nhostgrosso$
<p>. Alla fine se si svolge questo calcolo sono stesso numero di host, (magari perdo nreti numero di host per i router, però la ho gerarchizzata meglio).</p>
<p>Esiste una notazione molto più carina per i netmask che è il <strong>CIDR</strong> (Classless Interdomain ROuting) in pratica stai dicendo quanti bit sono messi a 1</p>
<p><strong>Creazione sottoreti</strong></p>
<p>In questo modo è possibile creare <strong>una gerarchia di sottoreti</strong>, ognuna delle quali è amministrata da un router (il default router). Esempio: data la rete di classe B 130.136. per semplicità decidiamo di considerare possibili 256 sottoreti: netmask 255.255.255.0.</p>
<p>Il numero della sottorete è quindi fornito dai primi tre byte dell’indirizzo IP, es. 130.136.1. è la sottorete 1, 130.136.2. è la sottorete 2, mentre ad esempio 130.136.1.22 è l’host 22 della sottorete 1, 130.136.3.48 è l’host 48 della sottorete 3, e così via. (quindi un router sottorete ora prende IP del genere 130.136.1.254, perché indica la sottorete 1 della rete di classe B che si possiede).</p>
<p>Per istruire ogni router subordinato sulla dimensione e sull’interpretazione degli indirizzi IP da amministrare, ogni router subordinato deve essere fornito di una maschera di rete (netmask), evidenziata a destra.</p>
<p><strong>Elementi fondamentali per il Protocollo IP</strong></p>
<p>Senza questi tre elementi il protocollo IP non funziona proprio. Quindi è la prima cosa da fare per configurarlo.</p>
<ol>
<li>Maschera di rete</li>
<li>Indirizzo IP</li>
<li>Indirizzo default di router (il primo router sopra la gerarchia, che è a chi mandare quando non so a chi mandare). (può essere che con dispositivi stupidi abbiamo solamente l’indirizzo del router).</li>
</ol>
<p>La maschera di rete serve per capire</p>
<p><strong>Netmask</strong></p>
<p>In particolare rileviamo qui 2 funzionalità principali per questo netmask:</p>
<ol>
<li>Dire quanti subnet esistono, oltre alla rete principale</li>
<li>Far sapere all’host a quale rete appartiene</li>
</ol>
<p>È quindi una quantità fondamentale per configurare la regte</p>
<h3 id="classless-inter-domain-routing-">Classless Inter Domain Routing 🟩<a hidden class="anchor" aria-hidden="true" href="#classless-inter-domain-routing-">#</a></h3>
<p>Questo nuovo modo per fare netmask (nuovo rispetto gli anni 80) è un modo per avere tagli di rete più efficienti, nel senso che se prima la C non bastava, ti davano una B( Renzone a unibo ha avuto in questo modo una classe B). Ora possono avere molta più disponibilità per i tagli negli indirizzi di rete. Questa cosa permette anche un concetto di <strong>supernetting</strong>. (in cui ho un insieme condiguo di classi più piccole, e così mi creo una rete maggiore, più grosso delle classi, così ho maggiore dinamicità).</p>
<p><strong>Esempio forwarding dei Pacchetti</strong></p>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Livello di Rete/Untitled 9.png" alt="image/universita/ex-notion/Livello di Rete/Untitled 9">
</li>
<li>
<p>Slide esempio</p>
  <img src="/images/notes/image/universita/ex-notion/Livello di Rete/Untitled 10.png" alt="image/universita/ex-notion/Livello di Rete/Untitled 10">
<p>La figura mostra un esempio di instradamento su rete IP. Esistono tre router Ry, Rz e Rk rispettivamente amministratori delle reti (140.217.), (190.89.), e (130.136.). Il router Ry è connesso a Rz, e Rz è connesso a Rk. Tale informazione risulta dalle tabelle di instradamento di Ry, Rz, Rk. La rete del router Ry include due sottoreti (140.217.1.) e (140.217.2), amministrate dai rispettivi default router 140.217.1.254 e 140.217.2.254 . La rete del router Rk include tre sottoreti (130.136.1.), (130.136.2.) e (130.136.3.), amministrate dai rispettivi default router 130.136.1.254, 130.136.2.254 e 130.136.3.254 . Un pacchetto IP spedito dall’host 140.217.2.10 all’host 130.136.2.33 deve compiere il seguente tragitto: passa per il default router di sottorete 140.217.2.254 che, notando che il destinatario non appartiene alla sottorete, lo inoltra al default router del livello superiore di rete: 140.217.0.254. Il default router di rete controlla la propria tabella di forwarding e scopre che per raggiungere la destinazione il pacchetto deve essere inoltrato al router intermedio 190.89.0.254. Il router intermedio riceve il pacchetto, verifica la propria tabella di forwarding, scopre che il prossimo destinatario intermedio è il router 130.136.0.254, al quale inoltra il pacchetto. Il router 130.136.2.254 riceve il pacchetto e verifica che appartiene alla propria rete, inoltrando quindi il pacchetto internamente. Il router di sottorete 130.136.2.254 riceve il pacchetto e scopre che appartiene alla propria sottorete, inoltrando il pacchetto internamente. Finalmente, l’host 130.136.2.33 riceve il pacchetto a lui destinato. Si possono notare alcuni aspetti importanti: malgrado il numero elevato di host che potrebbero essere parte del sistema considerato, il processo di instradamento permane molto semplice, composto da piccole e semplici operazioni di base. Le tabelle di instradamento sono limitate agli elementi che agiscono allo stesso livello, e quindi l**’instradamento è gerarchico**.</p>
</li>
</ul>
<h3 id="routing-">Routing 🟨<a hidden class="anchor" aria-hidden="true" href="#routing-">#</a></h3>
<p>Si parlerà molto meglio del routing in <a href="/notes/data-plane/">Data Plane</a> e <a href="/notes/control-plane/">Control Plane</a></p>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Livello di Rete/Untitled 11.png" alt="image/universita/ex-notion/Livello di Rete/Untitled 11">
</li>
</ul>
<p>Il problema del routing può essere definito come il problema di mantenere l’aggiornamento delle tabelle di forwarding in tutti i router della rete.
Questo problema può essere a volte molto complesso, a causa di frequenti modifiche forzate dei cammini per i pacchetti in rete. Le cause di tali modifiche possono essere dovute a molti fattori, ad esempio: la mobilità degli host in reti senza fili, guasti di mezzi trasmissivi, interruzione delle linee, guasti di router, nuove politiche e accordi per lo scambio dei dati tra gestori di dorsali
e sistemi autonomi.</p>
<p>Un <strong>sistema autonomo</strong> (AS) è sinonimo di una grossa rete, o una collezione di reti, soggetta a una comune politica di amministrazione. Gli accordi commerciali tra gestori di AS possono modificare i cammini consentiti per lo scambio dei pacchetti di dati.
Per realizzare un parallelo intuitivo, gli AS si comportano come nazioni che permettano o meno il passaggio di pacchetti, analoghi a voli aerei, sul loro suolo nazionale.
Ogni volta che si verifica uno dei problemi citati, esistono router che hanno indicazioni errate nelle loro tabelle di forwarding. Tutto ciò può causare la perdita di pacchetti, oppure può determinare un disordine nell’arrivo di pacchetti che hanno seguito strade diverse. Ecco quindi una causa del servizio connectionless ottenuto dal livello rete basato solo sul protocollo IP. I router hanno bisogno di aggiornare al più presto le loro tabelle, per evitare malfunzionamenti del servizio.</p>
<p>In pratica fanno lo stesso modo per decidere dove mandare, cioè hanno lo stesso protocollo, ma dato che si trovano in parti diverse avranno poi tabelle di instradamento diverse.</p>
<p>la <strong>Core network</strong> è molto veloce nel trovare il percorso giusto (è molto più fisso, e sa più o meno dove mandare le cose).</p>
<p>I <strong>protocolli di routing</strong> hanno la funzione di richiedere e scambiare informazioni per trovare cammini alternativi (idealmente il cammino migliore tra le possibili alternative), tra mittenti e destinatari dei pacchetti, e consentire quindi l’aggiornamento delle tabelle di forwarding.
A puro titolo informativo, si citano alcune sigle di protocolli di routing adottati in Internet: Routing Information Protocol (RIP), Open Shortest Path First (OSPF), Border Gateway protocol (BGP).
Questi algoritmi sono tutti utilizzati in locale. La cosa brutta è che il cammino ottimo cambia nel tempo (anche nell’ordine dei secondi), quindi gli algoritmi si devono abituare dinamicamente a questi nuovi dati.</p>
<p><strong>Note sistemi distribuiti o centralizzati</strong></p>
<p>Il centralizzato è bello perché è chiaro a chi chiedere per andare poi a mandare il pacchetto dove si vuole, il problema è che se il nodo centrale fallisce, cade l&rsquo;intera rete.</p>
<p>Distribuito è bello perché risolve il problema del single point of failure però dall’altra parte ogni nodo non ha una visione globale quindi non può fare altro che andare a massimizzare localmente, che spesso non è la cosa migliore.</p>
<p><strong>Wikipedia sui sistemi autonomi</strong></p>
<p><a href="https://it.wikipedia.org/wiki/Sistema_autonomo">Link</a>, in pratica singola autorità amministrativa è la parola chiave.</p>
<h2 id="protocolli-basati-su-ip">Protocolli basati su IP<a hidden class="anchor" aria-hidden="true" href="#protocolli-basati-su-ip">#</a></h2>
<h3 id="protocollo-icmp-6-">Protocollo ICMP (6) 🟨+<a hidden class="anchor" aria-hidden="true" href="#protocollo-icmp-6-">#</a></h3>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Livello di Rete/Untitled 12.png" alt="image/universita/ex-notion/Livello di Rete/Untitled 12">
</li>
</ul>
<p>ICMP (<strong>Internet Control Message Protocol</strong>) è un protocollo standard definito per supportare i messaggi di controllo per la <strong>gestione della rete</strong> al livello 3. ICMP viene usato da semplici host, da router e persino da gateway (router speciali con ulteriori funzioni) per scambiare informazioni utili alla gestione del livello Rete. Le informazioni scambiate sono trasferite sotto forma di pacchetti IP. Utile per stabilire una <strong>sintomatologia</strong> dei problemi di reti.</p>
<p>Alcuni esempi di messaggi ICMP che possono essere scambiati indicano, ad esempio:</p>
<ol>
<li>situazioni di rete di destinazione irraggiungibile (possibile sintomo di problemi di routing, o di rottura di un router).
<ol>
<li>In questo caso può convenire andare a cercare il problema di rete, che può essere fisico, e fixarlo in questo modo</li>
</ol>
</li>
<li>rete di destinazione sconosciuta (possibile sintomo di indirizzo IP di rete male specificato)
<ol>
<li>In questo caso il router non sa a chi mandare, quindi alcuni fix sono 1. aggiornare tabelle di instradamento, o provare altre strade.</li>
<li>Ossia nessuno conosce l’indirizzo della rete locale</li>
</ol>
</li>
<li>host di destinazione non raggiungibile (possibile sintomo che l’host sia spento o il cavo di connessione sia male collegato).
Questo è un problema che non ci riguarda, quindi probabile che l’host si sia sconesso.
Per questo significa che <strong>la rete è conosciuta!</strong>, quindi problema di rete locale!.</li>
<li>host di destinazione sconosciuto (possibile sintomo di host number del’indirizzo IP male specificato, malgrado la rete indicata esista e sia raggiungibile).
problemi con indirizzo IP</li>
<li>protocollo richiesto non disponibile (sintomo di un tentativo di dialogo tra dispositivi male configurati, che non forniscono i servizi richiesti). (come se stessi provando ad accedere a un servizio in una porta sbagliata, o versione IP sbagliata o simili).</li>
<li>ricerca di cammino alternativo (può essere usato per risolvere i problemi di routing).</li>
</ol>
<p>Anche chi riceve il messaggio, può rispondere in modo preinpostato a quelle richieste. (e dato che è preimpostato non c&rsquo;è bisogno di avere un frame grosso!).</p>
<h3 id="applicazioni-su-icmp-2-">Applicazioni su ICMP (2) 🟩<a hidden class="anchor" aria-hidden="true" href="#applicazioni-su-icmp-2-">#</a></h3>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Livello di Rete/Untitled 13.png" alt="image/universita/ex-notion/Livello di Rete/Untitled 13">
</li>
</ul>
<p>Le applicazioni sono utilizzate solitamente per la verifica delle cause o del semplice sospetto di problemi di rete.
L’applicazione <strong>PING</strong> permette di testare la connessione tra due host: eseguendo il comando “ping &lt;indirizzo IP di host2” da un host1 qualsiasi (mittente) connesso in rete, l’applicazione invia una richiesta ICMP di eco, alla quale l’host2 indicato risponde con una risposta ICMP (eco della richiesta). Dopo l’invio della richiesta, host1 fa partire un timer. In caso di successo, viene
calcolato il tempo di andata e ritorno dei pacchetti (durata o Round Trip Time, RTT), mentre in caso di insuccesso viene indicato che il timer per la richiesta inviata è scaduto senza ottenere risposta (secondo esempio della prima figura).
Al termine dei tentativi, viene mostrato un elenco di statistiche sul numero di richieste andate a buon fine e i tempi medi stimati di andata e
ritorno dei pacchetti.</p>
<p>L’applicazione Traceroute (<strong>tracert</strong>) permette di verificare la lista di tutti i router attraversati da una richiesta ICMP inviata da host1 a host2. Il comando “tracert <indirizzo IP di host2>” eseguito da host1, causa l’invio di una sequenza di richieste ICMP verso host2, per le quali viene fissato il numero massimo di router da attraversare (numero di passaggi o tempo di vita, TTL), a valori crescenti da 1 in poi. Ogni router a distanza TTL risponde con un messaggio ICMP di errore (tempo di vita scaduto) attraverso il quale è possibile risalire al suo indirizzo IP (ognuno mostrato su righe successive).</p>
<h3 id="protocollo-arp-e-rarp-">Protocollo ARP e RARP 🟩<a hidden class="anchor" aria-hidden="true" href="#protocollo-arp-e-rarp-">#</a></h3>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Livello di Rete/Untitled 14.png" alt="image/universita/ex-notion/Livello di Rete/Untitled 14">
</li>
<li>
<p>Slide immagine</p>
  <img src="/images/notes/image/universita/ex-notion/Livello di Rete/Untitled 15.png" alt="image/universita/ex-notion/Livello di Rete/Untitled 15">
</li>
</ul>
<p>Il protocollo <strong>Address Resolution Protocol (ARP)</strong> aiuta a gestire l’associazione tra indirizzo IP di un dispositivo a livello rete e il suo indirizzo MAC a livello MAC/LLC .
Quando un router riceve un pacchetto a livello IP destinato alla sua sottorete (es. 130.136.2.33) esso verifica se a tale IP risulti o meno associato un indirizzo MAC.
In caso contrario, il router spedisce sui segmenti della rete locale un frame in <em>broadcast</em> (cioè ricevuto da tutti i dispositivi) contenente il codice di richiesta ARP, e l’indirizzo IP del destinatario del pacchetto. Tutti i riceventi vanno a confrontare, e se matcha risponde.</p>
<ul>
<li>
<p>Intuiviamente</p>
<p>Tale frame equivale quindi al rivolgere a tutti i dispositivi la domanda: “quale indirizzo MAC ha il dispositivo corrispondente al seguente indirizzo IP”? Il dispositivo in questione, se esiste, risponde con un frame indirizzato all’indirizzo MAC del router, contenente il codice di risposta ARP, e con allegato l’indirizzo MAC richiesto.
A questo punto il router può quindi preparare e spedire la busta di livello MAC/LLC, indirizzata al MAC del dispositivo destinatario del pacchetto IP, contenente il pacchetto IP incapsulato all’interno. Il destinatario riceve il frame e risponde con il frame di conferma per il sottolivello LLC.</p>
</li>
</ul>
<p>Quando è risposto possiamo andare a mappare l’IP con il MAC locale. Chi ha il MAC corrispondente può rispondere col proprio IP.</p>
<p>Esiste anche una versione analoga del protocollo ARP, detta <strong>Reverse-ARP</strong>, che risponde alla domanda: “quale indirizzo IP corrisponde al dispositivo con questo indirizzo MAC”?.
Può essere utile ad esempio se mi arriva un pacchetto a un IP nella mia sottorete, ma non so a quale host è destinato.</p>
<h3 id="protocolo-dhcp--">Protocolo DHCP 🟩-<a hidden class="anchor" aria-hidden="true" href="#protocolo-dhcp--">#</a></h3>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Livello di Rete/Untitled 16.png" alt="image/universita/ex-notion/Livello di Rete/Untitled 16">
</li>
<li>
<p>Slide di immagine</p>
  <img src="/images/notes/image/universita/ex-notion/Livello di Rete/Untitled 17.png" alt="image/universita/ex-notion/Livello di Rete/Untitled 17">
</li>
</ul>
<p>Questo protocollo è utilizzato per assegnare un IP in modo dinamico. <strong>porta 67</strong>, unico all&rsquo;interno della rete, chi non ha un servizio lì aperto droppa il messaggio.</p>
<p><strong>Introduzione: assegnazione IP</strong></p>
<p>I numeri di rete delle classi A, B e C, ovvero la parte sinistra degli indirizzi IP vengono assegnati da enti internazionali quali RIPE, ICANN, ARIN, APNIC a enti, aziende, consorzi e imprese che ne fanno richiesta motivata. Un problema molto più pratico riguarda il modo in cui un nuovo dispositivo che venga connesso a una rete esistente, veda associare al proprio indirizzo MAC un indirizzo IP della rete stessa. Il numero di rete o di sottorete viene automaticamente determinato dall’appartenenza alla rete, ovvero alla presenza al di sotto del dominio di gestione di un router.</p>
<p><strong>Soluzioni</strong>
La prima, ovvia alternativa (molto usata) è quella di avere un amministratore di rete che assegna manualmente uno dei numeri di host disponibili al nuovo indirizzo MAC. In questo modo l’associazione indirizzo MAC e indirizzo IP può essere mantenuta per un tempo indeterminato, e quindi si considera l’indirizzo IP come statico.</p>
<p>La seconda alternativa, molto usata in reti senza fili, in reti locali e nei collegamenti domestici a Internet Service Provider (ISP) via Modem o ADSL consiste nell’utilizzare un server per Dynamic Host Configuration Protocol (<strong>DHCP</strong>).
Il server DHCP è dotato di una lista di numeri di host liberi per la sottorete amministrata, che provvede ad associare su richiesta agli indirizzi MAC dei dispositivi che lo richiedono. Tale associazione dipende spesso dalla disponibilità degli indirizzi già assegnati in precedenza, quindi allo stesso indirizzo MAC possono essere associati di volta in volta indirizzi IP diversi, e si parla in questo caso di indirizzi IP dinamici. E’ possibile configurare attraverso DHCP anche altri parametri di rete, come la maschera di rete, il defaul router e il server DNS (che vedremo dopo).
Il servizio DHCP equivale spesso al concetto di rete “<strong>plug and play</strong>”, ovvero rete in cui basta connettere il dispositivo al medium e non c’è bisogno di nessuna configurazione manuale aggiuntiva. È questo è quasi un must per le reti wireless! Sarebbe improponibile che ci fosse un sistemista ad assegnare un indirizzo IP per ogni dispositivo che si connette!</p>
<p><strong>In breve:</strong></p>
<ol>
<li>Host che assegna IP a chi lo richiede</li>
<li>Gestione degli IP liberi e associazione ai MAC</li>
<li>Questa è chiaramente una forma di <strong>indirizzamento dinamico</strong> discusso in Univocità e statico/dinamico 🟩</li>
</ol>
<p>Ogni tot di tempo è fatto un <strong>ping</strong> se la macchina risponde è ancora lì, altrimenti libera l’IP.</p>
<p><strong>MAGGIORE DETTAGLIO 4passi</strong></p>
<ul>
<li>
<p>Slides</p>
  <img src="/images/notes/image/universita/ex-notion/Livello di Rete/Untitled 18.png" alt="image/universita/ex-notion/Livello di Rete/Untitled 18">
</li>
</ul>
<p>È importante avere 4 passi, perché l’HOST deve rispondere con la scelta del DHCP, nel caso in una sottorete ci siano molto DHCP.</p>
<p>ma <strong>Non esiste nessuna autenticazione</strong>, quindi è molto fragile ad attacchi (uno si potrebbe impersonare a DHCP senza problemi). I primi due passaggi sono facoltativi, ma lo rendono più solido contro possibilità di avere 2 DHCP server.</p>
<p>NOTA: comuqnue non è un protocollo per dare IP a dispositivi mobili che si spostino.</p>
<h3 id="ipv6-e-tunnelling-">IPv6 e tunnelling 🟩<a hidden class="anchor" aria-hidden="true" href="#ipv6-e-tunnelling-">#</a></h3>
<ul>
<li>
<p>Slide</p>
<p><a href="https://www.notion.so">https://www.notion.so</a></p>
</li>
<li>
<p>Immagine</p>
<p>Nella figura viene mostrato come sia possibile spedire pacchetti IPv6 tra due router IPv6 passando per cammini che includono router IPv4, attraverso il tunnelling IPv6 in IPv4. Il pacchetto IPv6 viene incapsulato dai ogni router IPv4 in pacchetti IPv4, in modo da poter essere instradato lungo la rete di router IPv4. Uscito dal tunnel IPv4 il pacchetto IPv6 prosegue il suo inoltro fino alla destinazione IPv6 finale.</p>
  <img src="/images/notes/image/universita/ex-notion/Livello di Rete/Untitled 19.png" alt="image/universita/ex-notion/Livello di Rete/Untitled 19">
</li>
</ul>
<p>Il motivo principale della necessità di IPv6 è la necessità di altri indirizzi IP.  IPv6 perché hanno tentato di fare un IPv5 in molti modi ma sono caduti in disuso.</p>
<p><strong>Non c&rsquo;è frammentazione</strong>, con IPv6, mentre IPv4 ha bisogno… questo toglie il lavoro del router, e quindi rende tutto più veloce.</p>
<p>Dal 1990 è stato avviato un progetto di definizione e sviluppo di una nuova versione del protocollo IPv4, denominato versione IPv6. In seguito all’esplosione del collegamento di calcolatori in rete, e quindi dell’utilizzo di indirizzi e reti IP, le proiezioni mostrano che al ritmo attuale gli indirizzi IPv4 saranno esauriti nel decennio 2008-2018.
Brevemente, le caratteristiche salienti di IPv6 vanno nella direzione di ovviare a questo problema, oltre a migliorare alcuni aspetti di IPv4.
La caratteristica fondamentale di IPv6 è la definizione di nuovi indirizzi IPv6 composti da 128 bit (16 byte), cioè ben quattro volte la dimensione degli indirizzi IPv4. Questo incredibile numero di indirizzi potrebbe consentire di avere circa 15000 indirizzi IPv6 per dispositivi diversi su ogni metro quadrato di superficie dell’intero pianeta, oceani inclusi.</p>
<p>Sono inoltre stati ridefiniti i campi che costituiscono la busta dei pacchetti di livello IPv4, aggiungendo ad esempio parametri per la gestione di flussi di pacchetti IP con diversi livelli di priorità. Purtroppo la definizione di IPv6 nella maggioranza dei casi non permette di continuare a usare i vecchi router IPv4, e quindi non è compatibile con l’attuale struttura di Internet.</p>
<p><strong>Tunnelling</strong></p>
<p>Il tunnelling è <strong>fondamentale per la compatibilità</strong> fra IPV4 e IPv6</p>
<p>La sperimentazione e lo sviluppo di IPv6 sta procedendo su reti IPv6 separate, che possono in certi casi integrarsi alle reti IPv4 usando la tecnica del <strong>tunnelling</strong> dei pacchetti IPv6 in IPv4. Quindi wrappo con un pacchetto IPv4 i router che capiscono solo IPv4.</p>
<p>Si chiama tunnelling perché il wrap ci assomiglia tanto!</p>
<h3 id="nat">NAT<a hidden class="anchor" aria-hidden="true" href="#nat">#</a></h3>
<h1 id="cose-vecchie">Cose vecchie<a hidden class="anchor" aria-hidden="true" href="#cose-vecchie">#</a></h1>
<h3 id="confronto-col-mac">Confronto col MAC<a hidden class="anchor" aria-hidden="true" href="#confronto-col-mac">#</a></h3>
<p>L&rsquo;indirizzo Internet Protocol è il protocollo internet a <em>livello 3</em> più utile per la comunicazione fra reti locali diverse. Una delle caratteristiche che la contraddistingue dal MAC è il fatto che sia <strong>gerarchico</strong>, ossia c&rsquo;è una sorta di indirizzo generale, indirizzo specifico e indirizzo della rete locale!. Oltre al fatto che è gerarchico <strong>non è univoco</strong>, perché può succedere molto spesso che viene riassegnato.</p>
<h3 id="caratteristiche-ip-3">Caratteristiche IP (3)<a hidden class="anchor" aria-hidden="true" href="#caratteristiche-ip-3">#</a></h3>
<ul>
<li><strong>Globale</strong> perché non esiste rete connessa ad Internet che non abbia indirizzo IP;</li>
<li><strong>Strutturato</strong> perché è diviso in due parti, una per l’indirizzo della rete locale e l’altro per l’indirizzo della scheda di rete interna alla rete locale;</li>
<li><strong>Gerarchico</strong> perché appunto le due parti di indirizzo sono in ordine gerarchico (rete locale &gt; scheda di rete).</li>
</ul>
<h3 id="indirizzamento-ip">Indirizzamento IP<a hidden class="anchor" aria-hidden="true" href="#indirizzamento-ip">#</a></h3>
<p>Se succede che due IP sono uguali, questo succede <strong>solamente a rete locale</strong> perché anche la prima parte dell’IP deve essere uguale, quindi se ne accorge il Router e risolve questo.</p>
<p><strong>Staticità e dinamicità</strong></p>
<p>Statico → IP associato a MAC</p>
<p>Dinamico → IP che cambia, quindi è più difficile</p>
<h3 id="classi-di-rete">Classi di rete<a hidden class="anchor" aria-hidden="true" href="#classi-di-rete">#</a></h3>
<p>Dividiamo l’IP in 3 classi principali <strong>A, B, C</strong> a seconda di quanti IP riescono a supportare</p>
<p><strong>Classe A</strong></p>
<p>Il bit più significativo è 0. Quindi la prima sezione va da 1 a 126, perché 0 è utilizzato per l’identificazione. Sono quelle più prezione perché possono avere più host (</p>
$2^{24}$
<p>  host).</p>
<p><strong>Classe B</strong></p>
<p>Hanno i primi due bit come valore 10. e vanno da 128 a 191,</p>
<p><strong>Classe C</strong></p>
<h2 id="router-1">Router<a hidden class="anchor" aria-hidden="true" href="#router-1">#</a></h2>
<p>I router ricevono pacchetti e guardano la parte di rete locale, se matcha è OK, viene inoltrato ad altri router della rete locale per smistare ulteriormente, altrimenti inoltra ad altri router in altre reti, attraverso i collegamenti chiamati <strong>dorsali</strong>.</p>
<h3 id="tabelle-e-protocollo-di-instradamento">Tabelle e protocollo di instradamento<a hidden class="anchor" aria-hidden="true" href="#tabelle-e-protocollo-di-instradamento">#</a></h3>
<p>Queste sono tabelle che hanno un utilizzo molto simile a quanto utilizzato per lo switch, che mappa una porta a un indirizzo MAC. In questo caso mappa la tolopogia di rete (che non so in che modo sia intesa questa mappa). Di solito il router è collegato a <strong>un solo altro router</strong> che viene chiamato <strong>default gateway</strong>.</p>
<p>Il protocollo, invece, si occupa di aggiornare questa tabella secondo le occorrenza (TODO, non so su quali regole).</p>
<h3 id="protocollo-di-routing">Protocollo di routing<a hidden class="anchor" aria-hidden="true" href="#protocollo-di-routing">#</a></h3>
<p>Questo protocollo che si occupa di trovare il percorso più breve, e di <strong>frammentare</strong> il messaggio originale in pacchetti più piccoli, ma senza fare controlli su un arrivo corretto di queste informazioni. Quind fa una scelta per capire che strada fare</p>
<h3 id="cidr-classless-inter-domain-routing">CIDR Classless Inter Domain Routing<a hidden class="anchor" aria-hidden="true" href="#cidr-classless-inter-domain-routing">#</a></h3>
<p>Si utilizza una scrittura molto compatta per</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/no-tags/">No-Tags</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Livello di Rete on x"
            href="https://x.com/intent/tweet/?text=Livello%20di%20Rete&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2flivello-di-rete%2f&amp;hashtags=no-tags">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Livello di Rete on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2flivello-di-rete%2f&amp;title=Livello%20di%20Rete&amp;summary=Livello%20di%20Rete&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2flivello-di-rete%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Livello di Rete on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2flivello-di-rete%2f&title=Livello%20di%20Rete">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Livello di Rete on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2flivello-di-rete%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Livello di Rete on whatsapp"
            href="https://api.whatsapp.com/send?text=Livello%20di%20Rete%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2flivello-di-rete%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Livello di Rete on telegram"
            href="https://telegram.me/share/url?text=Livello%20di%20Rete&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2flivello-di-rete%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Livello di Rete on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Livello%20di%20Rete&u=https%3a%2f%2fflecart.github.io%2fnotes%2flivello-di-rete%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
