<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Virtual Machines | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="‚òÅcloud-computing, sistemi-operativi">
<meta name="description" content="
The fundamental idea behind a virtual machine is to abstract the hardware
of a single computer (the CPU, memory, disk drives, network interface cards,
and so forth) into several different execution environments, thereby creating
the illusion that each separate environment is running on its own private
computer. (Silberschatz et al. 2018).

Virtualization allows a single computer to host multiple virtual machines, each potentially running a completely different operating system.
√à virtuale nel senso che la macchina virtuale ha la stessa percezione della realt√† di una macchina reale. Qualcosa che non √® la realt√† ma appare molto simile ad essa.">
<meta name="author" content="Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="https://flecart.github.io/notes/virtual-machines/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/virtual-machines/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>
<script type="text/javascript" async
src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>






      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-WW6NN2QGKF');
        }
      </script><meta property="og:url" content="https://flecart.github.io/notes/virtual-machines/">
  <meta property="og:site_name" content="X. Angelo Huang&#39;s Blog">
  <meta property="og:title" content="Virtual Machines">
  <meta property="og:description" content=" The fundamental idea behind a virtual machine is to abstract the hardware of a single computer (the CPU, memory, disk drives, network interface cards, and so forth) into several different execution environments, thereby creating the illusion that each separate environment is running on its own private computer. (Silberschatz et al. 2018).
Virtualization allows a single computer to host multiple virtual machines, each potentially running a completely different operating system.
√à virtuale nel senso che la macchina virtuale ha la stessa percezione della realt√† di una macchina reale. Qualcosa che non √® la realt√† ma appare molto simile ad essa.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="notes">
    <meta property="article:tag" content="‚òÅCloud-Computing">
    <meta property="article:tag" content="Sistemi-Operativi">
      <meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:title" content="Virtual Machines">
<meta name="twitter:description" content="
The fundamental idea behind a virtual machine is to abstract the hardware
of a single computer (the CPU, memory, disk drives, network interface cards,
and so forth) into several different execution environments, thereby creating
the illusion that each separate environment is running on its own private
computer. (Silberschatz et al. 2018).

Virtualization allows a single computer to host multiple virtual machines, each potentially running a completely different operating system.
√à virtuale nel senso che la macchina virtuale ha la stessa percezione della realt√† di una macchina reale. Qualcosa che non √® la realt√† ma appare molto simile ad essa.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Virtual Machines",
      "item": "https://flecart.github.io/notes/virtual-machines/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Virtual Machines",
  "name": "Virtual Machines",
  "description": " The fundamental idea behind a virtual machine is to abstract the hardware of a single computer (the CPU, memory, disk drives, network interface cards, and so forth) into several different execution environments, thereby creating the illusion that each separate environment is running on its own private computer. (Silberschatz et al. 2018).\nVirtualization allows a single computer to host multiple virtual machines, each potentially running a completely different operating system.\n√à virtuale nel senso che la macchina virtuale ha la stessa percezione della realt√† di una macchina reale. Qualcosa che non √® la realt√† ma appare molto simile ad essa.\n",
  "keywords": [
    "‚òÅcloud-computing", "sistemi-operativi"
  ],
  "articleBody": " The fundamental idea behind a virtual machine is to abstract the hardware of a single computer (the CPU, memory, disk drives, network interface cards, and so forth) into several different execution environments, thereby creating the illusion that each separate environment is running on its own private computer. (Silberschatz et al. 2018).\nVirtualization allows a single computer to host multiple virtual machines, each potentially running a completely different operating system.\n√à virtuale nel senso che la macchina virtuale ha la stessa percezione della realt√† di una macchina reale. Qualcosa che non √® la realt√† ma appare molto simile ad essa.\nStoricamente parlando le macchine virtuali erano un primo approccio al multitasking.\nL‚Äôidea principale √® creare un sistema che possa apparire al sistema operativo come hardware, in questo modo posso utilizzare un programma per emulare un altro sistema operativo. √à hypervisor, VMM (virtual machine monitor).\nOvviamente ho uno fortissimo svantaggio in velocit√†, perch√© la simulazione software √® molto meno efficiente della simulazione hardware. Un collegamento carino √® con (Hofstadter 2007), una macchina che sia abbastanza espressiva da poter emulare s√© stesso.\nAnalisi vantaggi svantaggi üü® Posso avere sistemi operativi differenti sulla stessa macchina o SO, quindi posso sperimentarli senza installarli veramente. Posso simulare architetture differenti, e quindi supporre di avere istruzioni differenti di architettura altra! SO monotask in sistemi multitask. Maggiore sicurezza a bug software, √® efficienza energetica. Svantaggi:\nfortemente inefficiente Peso in pi√π sia sulla memoria Context Switch molto frequenti che lo rendono pi√π lento I/O lento. Difficile condividere risorse fra una macchina virtuale o all‚Äôaltra. Desiderata per virtualizzazione Chiamiamo le propriet√† di partizionamento:\nCondividere le risorse della stessa macchina Isolare le macchine diverse, in modo che non possano influenzarsi a livello software, in modo da creare la giusta simulazione, esattamente come macchine fisiche reali, che non possono comunicare fra di loro. E la incapsulazione, con controllo completo di checkpointing, migrazione e replay. Nel caso di servizi cloud, avere queste desiderata rende possibile andare a copiare i dati in giro e riprendere l‚Äôesecuzione in un altro hardware, vedere Cloud Computing Services.\nDesiderata principale:\nEfficienza: la virtualizzazione non deve essere troppo lenta, altrimenti non ha senso. Compatibilit√†: deve essere compatibile con il software esistente (deve eseguire allo stesso modo in macchina virtualizzata o meno). Isolamento: le macchine virtuali devono essere isolate fra di loro. pr Virtualizzazione di Popek and Goldberg üü® Nel 1974 Popek e Goldberg hanno definito i requisiti per la virtualizzazione, che sono:\nDevono esistere una modalit√† kernel and user. Tutte le istruzioni sensibili devono essere istruzioni privilegiate. Le istruzioni sensibili sono quelle che cambiano lo stato a livello hardware (allocazioni, mappature) Le istruzioni privilegiate sono quelle che usano trap. Al tempo il processore Intel x86 non era virtualizzabile, perch√© certe istruzioni sensibili (sensitive) non aveva istruzioni privilegiate, e quindi non poteva essere virtualizzato. Per esempio il registro %cs conteneva il livello di privilegio, e non poteva essere virtualizzato (esempio se OS pusha quel registro sulla stack, si dovrebbe aspettare il massimo livello di privilegio), dato che il VMM non poteva catturare la trap ed emulare l‚Äôistruzione, non era possibile virtualizzare questa operazione. Per questo usiamo binary translation per questo, ma impatta leggermente la velocit√† di esecuzione.\nLivello processo o sistema üü© Le macchine virtuali di cui abbiamo parlato ora virtualizzano solamente l‚Äôhardware, cio√® fa finta di avere un sistema hardware.\nMentre altre macchine virtuali provano a virtualizzare a livello di ABI (application binary interface) (che √® livello di processo).\nMacchina virtuale a livello di processo (process VM): permette ad un programma di essere eseguito allo stesso modo su qualsiasi piattaforma. Un esempio di questo √® la macchina virtuale di Java. Viene eseguita come una normale applicazione all‚Äôinterno di un SO ospite e supporta un singolo processo. Il suo scopo √® fornire un ambiente indipendente dalla piattaforma hardware e dal SO ospite. Vengono virtualizzati sia l‚Äôhardware che il sistema operativo. Macchina virtuale a livello di sistema (system VM): permette l‚Äôesecuzione di un completo SO, anche con un ISA diverso da quello della macchina reale. Viene virtualizzato esclusivamente e completamente l‚Äôhardware. Differenza type 1 and 2 hypervisors type 1 hypervisor and a type 2 hypervisor is that a type 2 makes uses of a host operating system and its file system to create processes, store files, and so on. A type 1 hypervisor has no underlying support and must perform all these functions itself (it runs on the bare metal, come se fosse lui stesso un sistema operativo, √® infatti un sistema operativo che non fa altro che fare sistemi operativi!)\nEsistono anche type 0 hypervisors che sono direttamente supporto per macchine virtuali fatte a livello hardware. Esempi di questo sono IBM LPARs and Oracle LDOMs.\nVirtual Machine Monitor Questo √® quello che viene chiamato anche type 1 hypervisor. √à un sistema operativo che gestisce altri sistemi operativi che eseguono sopra di esso. Chi sta sopra pensa di possedere l‚Äôintero hardware, mentre in realt√† √® la VMM che prova a tradurre o mandare di sotto.\nVirtualizzatori In questa sezione introduciamo alcuni eventi di virtualizzatori.\nQemu üü© qemu √® un traduttore dinamico come se fosse un compilatore fra una architettura in una altra, fatta a runtime (quindi √® un interprete, tipo 10x pi√π lento rispetto esecuzione normale, ma un ordine di grandezza pi√π veloce rispetto altri emulatori).\nCon qemu posso anche dire al processo emulato di utilizzare il mio stesso kernel, nel caso che condivida l‚Äôarchitettura, questo rende la cosa molto pi√π veloce del normale! e.g. KVM (che √® il nome dell‚ÄôHypervisor per linux). Questo √® anche una tipologia di type-2-hypervisor perch√© attingo al kernel della macchina ospite per fare funzionare pi√π in fretta, e non faccio simulazione sistema totale.\nUtile o per runnare programmi per architettura differente (in questo senso program VM), oppure per emulare un sistema operativo dentro un sistema operativo.\nComando per caricare una macchina virtuale con qemu e utilizzare KVM senza vga, non starebbe sullo schermo senza quella flag. hda gli specifica il file con cui emulare il disco, k il layout del keyboard m √® la memoria ram monitor √® per poter mandare interrupt dal terminale in cui ho lanciato il mio comando di emulazione. Quando installa prima √® installato nella RAM disk, e poi viene utilizzato per l‚Äôinstallazione vera e propria.\nXEN üü© XEN √® hypervisor livello 1 (SO che permette di fare altri SO virtuali), e utilizzare paravirtualizzazione (si fanno trap and emulate principalmente) , e utilizza una gestione diversa dei drivers che possiede, ossia il Domain0 possiede tutti i drivers fisici (le interazioni con i device le manda alla macchina 0, perch√© per restare un sistema operativo semplice non riesce a gestire sistemi operativi).\nEsempio di maggiore efficienza\nPer il type 2 hypervisor il SO installato pensa veramente di stare in una macchina s√©, quindi fa cose per minimizzare i seek del disco ma in questo caso non deve fare veramente seek, quindi √® meno efficiente, facendo una assunzione errata.\nSi utilizzano paravirtualizzazione, ossia devices virtuali pi√π efficienti per questa cosa, ed effettivamente non assumo di stare utilizzando device fisici, ma sono a conoscenza di utilizzare device virtuali, e posso fare ottimizzazioni del caso (che non so quali siano forse per il disco non faccio cose strane per il seek ad esempio).\nIl problema √® che essendo a conoscenza, dovrei fare il mio SO in modo che sia compatibile con le hyper all offerte dall hypervisor\nImplementazione della Virtualizzazione Possiamo considerare tre metodi principali di virtualizzazione:\nSimulazione diretta üü© Simulazione via software sull‚Äôhost (molto molto lento, tipo 100x volte pi√π lento) Un esempio √® QEMU in full emulation. Esecuzione diretta üü®‚Äì Trap and emulate in cui il VMM intercetta il trap ed esegue l‚Äôistruzione equivalente Emulazione con supporto hardware come con le estensioni Intel VT-x e AMD-V. Questo √® il metodo pi√π utilizzato oggi giorno. Vedi sezione di istruzioni di virtualizzazione. Add Virtual Machine Control Structure (VMCS) che decide quali istruzioni fanno VMexit, e quando si pu√≤ cambiare queste informazioni con VMread or write e simili, consentendo all‚Äôhypervisor di controllare il comportamento della VM. Dynamic binary translation Necessario quando l‚Äôhardware non √® totalmente virtualizzabile, quindi introduce delle istruzioni di emulazione in pi√π. Paravirtualizzazione üü© In questo caso il SO virtuale √® a conoscenza che esiste un hypervisor quindi pu√≤ fare delle hypercall per eseguire delle istruzioni sensitive, e in generale √® un approccio pi√π veloce invece della virtualizzazione totale di cui abbiamo parlato prima. Per√≤ bisogna essere a conoscenza del hypervisor. Quindi andiamo a modificare parti del SO in modo da tenere in considerazione l‚Äôesistenza dell‚Äôhypervisor, rende pi√π veloce, per√≤ bisogna andare a modificare il SO stesso, per ogni SO. Un esempio √® XEN. Parametrizzazione SO üü© Questo non √® proprio un metodo di virtualizzazione di un Sistema Operativo, ma un modo per modificare leggermente alcuni sistemi operativi.\nEssendo libero linux, √® molto comodo poter cambiare alcuni parametri e poi ricompilare il kernel seguendo quei parametri. Tanto √® tutto open source, quindi si potrebbe fare. Questo permette al kernel di essere molto portabile.\nUna cosa molto importante da capire √® che il kernel √® una cosa diversa della distribuzione, il kernel √® il primo programma che viene caricato dal bootloader e carica il FS e tutto il resto (quindi le cose iniziali), il secondo sono tutte le utility per il kernel che lo rendono utilizzabile da un utente normale.\nComando runnato per la emulazione kernel/distribuzione\nSlide parametrizzazione ++ portabilit√† (che deve runnare per hardware differentI)\nIstruzioni di virtualizzazione üü• Abbiamo aggiunto delle istruzioni di emulazione come VMX ON, VMX OFF, VMLAUNCH, VMRETURN in cui il processore sa di stare emulando, e quindi √® pi√π veloce perch√© esegue l‚Äôistruzione in altro modo, forse con istruzione nativa. Pagina wiki fa pensare di essere in kernel mode, ma non √® in kernel mode, √® come se stesse in un livello di priviliegio intermedio.\nVMLAUNCH\nQueste sono quelle principali istruzioni che permettono la virtualizzazioen a livello software, il fatto che rende l‚Äôesecuzione molto pi√π veloce, quindi invece di simulare tutto sopra il sistema operativo attuale (e syscalls attuali) posso accedere ad istruzioni hardware molto pi√π veloci.\nMemoria Virtuale C‚Äô√® una MMU del sistema operativo che mappa alla VM fisica, che si deve basare all‚Äôindirizzo logico, che deve essere risolto dalla MMU reale fino ad avere un indirizzo fisico.\nDobbiamo virtualizzare l'accesso in memoria da quella parte, l'hypervisor deve tradurre la memoria \"fisica\" del guest con una memoria fisica reale, abbiamo uno schema del genere: Guest Virtual Address (GVA) ‚Üí Guest Physical Address (GPA) ‚Üí Host Physical Address (HPA) Shadow Page Tables üü• Permettono di evitare l'utilizzo di **Shadow page tables**, che sono il remapping della pagine virtuali con le pagine fisiche. Ci sono esattamente lo stesso numero di pagine nei sistemi operativi virtuali con il numero di pagine nel shadow page table. Questo √® una soluzione che si pu√≤ implementare anche *senza supporto hardware*. Svantaggi: Esiste molto overhead di memoria per quanto riguarda questa parte.\nExtended Page Tables üü• Abbiamo in pratica una sezione di traduzione in pi√π per mapparlo a EPT (Extended Page Tables), che mappa le pagine virtuali con le pagine fisiche, e quindi non c‚Äô√® overhead di memoria, e quindi √® molto pi√π efficiente in comparazione con le shadow page tables, per√≤ necessita di supporto hardware all‚Äôoperazione, questa √® la soluzione preferita in ambienti cloud.\nMulti-Level Translation Solitamente i sistemi x86-64 utilizzano un sistema di traduzione che √® multi-livello. Questa nota √® di particolare interesse perch√© se abbiamo un TLB miss in virtualizzazione, dobbiamo andare a recuperare le informazioni da EPT e prende molti molti accessi in pi√π. HugePages This is an idea that attempts to solve the problem in virtualization that we raised above. With bigger virtual pages it is more difficult to have a TLB miss (hugepage is 2MB, while gigantic pages are 1GB). The idea is that here big part of the memory is mapped to the physical address, which means we don‚Äôt have to translate it, having thus fewer walks when we have TLB miss.\nThe drawback with this solution is that Internal fragmentation (wasted memory) is much higher, and the system becomes slow for small dynamic allocations.\nVirtualizzazione di I/O Esistono moltissimi dispositivi I/O, che rendono la possibilit√† di virtualizzare un po‚Äô difficile. Scrivere drivers a livello I/O non √® poi tanto pratico.\nProblemi di virtualizzazione I/O Il dispositivo I/O virtuale deve essere in grado di: Virtual device interface\nTraps device commands Translates DMA operations Injects virtual interrupts Si ricorda in Devices OS che solitamente questi usano Direct Memory Access per scrivere per il sistema operativo, per√≤ questo spesso non √® possibile e bisogna fare qualche interrupt virtuale per risolvere questo problema. Possiamo\nPara virtualizzare l‚Äôinterfaccia del device Emulare il device I/O. Single Root I/O Virtualization SR-IOV enables hardware-assisted virtualization by partitioning a single PCIe device into multiple Virtual Functions (VFs), which can be assigned directly to virtual machines (VMs) or containers. This reduces overhead caused by traditional software-based I/O virtualization.\nKey Components of SR-IOV:\nPhysical Function (PF) The main PCIe function, fully featured, controlled by the host OS (hypervisor). Manages and configures the Virtual Functions. Virtual Functions (VFs) Lightweight PCIe functions with limited resources, assigned to VMs or containers. Each VM gets direct access to a VF, bypassing the hypervisor for performance gains. References [1] Hofstadter ‚ÄúI Am a Strange Loop‚Äù Basic Books 2007 [2] Silberschatz et al. ‚ÄúOperating System Concepts‚Äù Wiley 2018 ",
  "wordCount" : "2214",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/virtual-machines/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;¬ª&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Virtual Machines
    </h1>
    <div class="post-meta">11 min&nbsp;¬∑&nbsp;Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul><ul><ul>
                <li>
                    <a href="#analisi-vantaggi-svantaggi-" aria-label="Analisi vantaggi svantaggi üü®">Analisi vantaggi svantaggi üü®</a><ul>
                        
                <li>
                    <a href="#desiderata-per-virtualizzazione" aria-label="Desiderata per virtualizzazione">Desiderata per virtualizzazione</a></li>
                <li>
                    <a href="#virtualizzazione-di-popek-and-goldberg-" aria-label="Virtualizzazione di Popek and Goldberg üü®">Virtualizzazione di Popek and Goldberg üü®</a></li></ul>
                </li>
                <li>
                    <a href="#livello-processo-o-sistema-" aria-label="Livello processo o sistema üü©">Livello processo o sistema üü©</a><ul>
                        
                <li>
                    <a href="#differenza-type-1-and-2-hypervisors" aria-label="Differenza type 1 and 2 hypervisors">Differenza type 1 and 2 hypervisors</a></li>
                <li>
                    <a href="#virtual-machine-monitor" aria-label="Virtual Machine Monitor">Virtual Machine Monitor</a></li></ul>
                </li>
                <li>
                    <a href="#virtualizzatori" aria-label="Virtualizzatori">Virtualizzatori</a><ul>
                        
                <li>
                    <a href="#qemu-" aria-label="Qemu üü©">Qemu üü©</a></li>
                <li>
                    <a href="#xen-" aria-label="XEN üü©">XEN üü©</a></li></ul>
                </li>
                <li>
                    <a href="#implementazione-della-virtualizzazione" aria-label="Implementazione della Virtualizzazione">Implementazione della Virtualizzazione</a><ul>
                        
                <li>
                    <a href="#simulazione-diretta-" aria-label="Simulazione diretta üü©">Simulazione diretta üü©</a></li>
                <li>
                    <a href="#esecuzione-diretta---" aria-label="Esecuzione diretta üü®&ndash;">Esecuzione diretta üü®&ndash;</a></li>
                <li>
                    <a href="#paravirtualizzazione-" aria-label="Paravirtualizzazione üü©">Paravirtualizzazione üü©</a></li>
                <li>
                    <a href="#parametrizzazione-so-" aria-label="Parametrizzazione SO üü©">Parametrizzazione SO üü©</a></li>
                <li>
                    <a href="#istruzioni-di-virtualizzazione-" aria-label="Istruzioni di virtualizzazione üü•">Istruzioni di virtualizzazione üü•</a></li></ul>
                </li>
                <li>
                    <a href="#memoria-virtuale" aria-label="Memoria Virtuale">Memoria Virtuale</a><ul>
                        
                <li>
                    <a href="#shadow-page-tables-" aria-label="Shadow Page Tables üü•">Shadow Page Tables üü•</a></li>
                <li>
                    <a href="#extended-page-tables-" aria-label="Extended Page Tables üü•">Extended Page Tables üü•</a></li>
                <li>
                    <a href="#multi-level-translation" aria-label="Multi-Level Translation">Multi-Level Translation</a></li>
                <li>
                    <a href="#hugepages" aria-label="HugePages">HugePages</a></li></ul>
                </li>
                <li>
                    <a href="#virtualizzazione-di-io" aria-label="Virtualizzazione di I/O">Virtualizzazione di I/O</a><ul>
                        
                <li>
                    <a href="#problemi-di-virtualizzazione-io" aria-label="Problemi di virtualizzazione I/O">Problemi di virtualizzazione I/O</a></li>
                <li>
                    <a href="#single-root-io-virtualization" aria-label="Single Root I/O Virtualization">Single Root I/O Virtualization</a></li></ul>
                </li></ul>
                    </ul>
                    
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><blockquote>
<p>The fundamental idea behind a virtual machine is to abstract the hardware
of a single computer (the CPU, memory, disk drives, network interface cards,
and so forth) into several different execution environments, thereby creating
the illusion that each separate environment is running on its own private
computer. <a href="https://books.google.ch/books/about/Operating_System_Concepts.html?id=FHJlDwAAQBAJ&redir_esc=y">(Silberschatz et al. 2018)</a>.</p></blockquote>
<blockquote>
<p>Virtualization allows a single computer to host multiple virtual machines, each potentially running a completely different operating system.</p></blockquote>
<p>√à virtuale nel senso che la macchina virtuale ha la stessa percezione della realt√† di una macchina reale. Qualcosa che non √® la realt√† ma appare molto simile ad essa.</p>
<p>Storicamente parlando le macchine virtuali erano un primo approccio al multitasking.</p>
<p>L‚Äôidea principale √® creare un sistema che possa apparire al sistema operativo come hardware, in questo modo posso utilizzare un programma per emulare un altro sistema operativo. √à <strong>hypervisor, VMM (virtual machine monitor)</strong>.</p>
<p>Ovviamente ho uno fortissimo svantaggio in velocit√†, perch√© la simulazione software √® molto meno efficiente della simulazione hardware. Un collegamento carino √® con <a href="https://psycnet.apa.org/record/2007-01197-000">(Hofstadter 2007)</a>, una macchina che sia abbastanza espressiva da poter emulare s√© stesso.</p>
<h3 id="analisi-vantaggi-svantaggi-">Analisi vantaggi svantaggi üü®<a hidden class="anchor" aria-hidden="true" href="#analisi-vantaggi-svantaggi-">#</a></h3>
<img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 16.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 16">
<ul>
<li>Posso avere sistemi operativi differenti sulla stessa macchina o SO, quindi posso sperimentarli senza installarli veramente.</li>
<li>Posso simulare architetture differenti, e quindi supporre di avere istruzioni differenti di architettura altra!</li>
<li>SO monotask in sistemi multitask.</li>
<li>Maggiore sicurezza a bug software, √® efficienza energetica.</li>
</ul>
<p><strong>Svantaggi</strong>:</p>
<ol>
<li>fortemente inefficiente
<ol>
<li>Peso in pi√π sia sulla memoria</li>
<li>Context Switch molto frequenti che lo rendono pi√π lento</li>
<li>I/O lento.</li>
</ol>
</li>
<li>Difficile condividere risorse fra una macchina virtuale o all&rsquo;altra.</li>
</ol>
<h4 id="desiderata-per-virtualizzazione">Desiderata per virtualizzazione<a hidden class="anchor" aria-hidden="true" href="#desiderata-per-virtualizzazione">#</a></h4>
<p>Chiamiamo le propriet√† di <strong>partizionamento</strong>:</p>
<ul>
<li><strong>Condividere</strong> le risorse della stessa macchina</li>
<li><strong>Isolare</strong> le macchine diverse, in modo che non possano influenzarsi a livello software, in modo da creare la giusta simulazione, esattamente come macchine fisiche reali, che non possono comunicare fra di loro.</li>
</ul>
<p>E la <strong>incapsulazione</strong>, con controllo completo di checkpointing, migrazione e replay.
Nel caso di servizi cloud, avere queste desiderata rende possibile andare a copiare i dati in giro e riprendere l&rsquo;esecuzione in un altro hardware, vedere <a href="/notes/cloud-computing-services">Cloud Computing Services</a>.</p>
<p><strong>Desiderata principale</strong>:</p>
<ul>
<li><strong>Efficienza</strong>: la virtualizzazione non deve essere troppo lenta, altrimenti non ha senso.</li>
<li><strong>Compatibilit√†</strong>: deve essere compatibile con il software esistente (deve eseguire allo stesso modo in macchina virtualizzata o meno).</li>
<li><strong>Isolamento</strong>: le macchine virtuali devono essere isolate fra di loro.
pr</li>
</ul>
<h4 id="virtualizzazione-di-popek-and-goldberg-">Virtualizzazione di Popek and Goldberg üü®<a hidden class="anchor" aria-hidden="true" href="#virtualizzazione-di-popek-and-goldberg-">#</a></h4>
<p>Nel 1974 Popek e Goldberg hanno definito i requisiti per la virtualizzazione, che sono:</p>
<ul>
<li>Devono esistere una modalit√† kernel and user.</li>
<li>Tutte le istruzioni sensibili devono essere istruzioni <strong>privilegiate</strong>.
<ul>
<li>Le istruzioni sensibili sono quelle che cambiano lo stato a livello hardware (allocazioni, mappature)</li>
<li>Le istruzioni privilegiate sono quelle che usano trap.</li>
</ul>
</li>
</ul>
<p>Al tempo il processore Intel x86 non era virtualizzabile, perch√© certe istruzioni sensibili (sensitive) non aveva istruzioni privilegiate, e quindi non poteva essere virtualizzato.
Per esempio il registro %cs conteneva il livello di privilegio, e non poteva essere virtualizzato (esempio se OS pusha quel registro sulla stack, si dovrebbe aspettare il massimo livello di privilegio), dato che il VMM non poteva catturare la trap ed emulare l&rsquo;istruzione, non era possibile virtualizzare questa operazione.
Per questo usiamo binary translation per questo, ma impatta leggermente la velocit√† di esecuzione.</p>
<h3 id="livello-processo-o-sistema-">Livello processo o sistema üü©<a hidden class="anchor" aria-hidden="true" href="#livello-processo-o-sistema-">#</a></h3>
<p>Le macchine virtuali di cui abbiamo parlato ora virtualizzano solamente l‚Äôhardware, cio√® fa finta di avere un sistema hardware.</p>
<p>Mentre altre macchine virtuali provano a virtualizzare a livello di ABI (application binary interface) (che √® livello di processo).</p>
<ul>
<li>Macchina virtuale a livello di processo (<strong>process VM)</strong>: permette ad un programma di essere eseguito allo stesso modo su qualsiasi piattaforma. Un esempio di questo √® la macchina virtuale di Java.
Viene eseguita come una normale applicazione all&rsquo;interno di un SO ospite e supporta un singolo processo. Il suo scopo √® fornire un ambiente indipendente dalla piattaforma hardware e dal SO ospite. Vengono virtualizzati sia l‚Äôhardware che il sistema operativo.</li>
<li>Macchina virtuale a livello di sistema (<strong>system VM</strong>): permette l&rsquo;esecuzione di un completo SO, anche con un ISA diverso da quello della macchina reale. Viene virtualizzato esclusivamente e completamente <strong>l‚Äôhardware</strong>.</li>
</ul>
<h4 id="differenza-type-1-and-2-hypervisors">Differenza type 1 and 2 hypervisors<a hidden class="anchor" aria-hidden="true" href="#differenza-type-1-and-2-hypervisors">#</a></h4>
<p>type 1 hypervisor and a type 2 hypervisor is that a type 2 makes uses of a host operating system and its file system to create processes, store files, and so on. A type 1 hypervisor has no underlying support and must perform all these functions itself (it runs on the bare metal, come se fosse lui stesso un sistema operativo, √® infatti un sistema operativo che non fa altro che fare sistemi operativi!)</p>
<p>Esistono anche type 0 hypervisors che sono direttamente supporto per macchine virtuali fatte a livello hardware. Esempi di questo sono IBM LPARs and Oracle LDOMs.</p>
<h4 id="virtual-machine-monitor">Virtual Machine Monitor<a hidden class="anchor" aria-hidden="true" href="#virtual-machine-monitor">#</a></h4>
<p>Questo √® quello che viene chiamato anche type 1 hypervisor. √à un sistema operativo che gestisce altri sistemi operativi che eseguono sopra di esso. Chi sta sopra pensa di possedere l&rsquo;intero hardware, mentre in realt√† √® la VMM che prova a tradurre o mandare di sotto.</p>
<h3 id="virtualizzatori">Virtualizzatori<a hidden class="anchor" aria-hidden="true" href="#virtualizzatori">#</a></h3>
<p>In questa sezione introduciamo alcuni eventi di virtualizzatori.</p>
<h4 id="qemu-">Qemu üü©<a hidden class="anchor" aria-hidden="true" href="#qemu-">#</a></h4>
<p><strong>qemu</strong> √® un traduttore dinamico come se fosse un compilatore fra una architettura in una altra, fatta a runtime (quindi √® un interprete, tipo 10x pi√π lento rispetto esecuzione normale, ma un ordine di grandezza pi√π veloce rispetto altri emulatori).</p>
<p>Con qemu posso anche dire al processo emulato di utilizzare il mio stesso kernel, nel caso che condivida l&rsquo;architettura, questo rende la cosa molto pi√π veloce del normale! e.g. KVM (che √® il nome dell‚ÄôHypervisor per linux). Questo √® anche una tipologia di <strong>type-2-hypervisor</strong> perch√© attingo al kernel della macchina ospite per fare funzionare pi√π in fretta, e non faccio simulazione sistema totale.</p>
<p>Utile o per runnare programmi per architettura differente (in questo senso program VM), oppure per emulare un sistema operativo dentro un sistema operativo.</p>
<ul>
<li>
<p>Comando per caricare una macchina virtuale con qemu e utilizzare KVM
<img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 17.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 17"></p>
<p>senza vga, non starebbe sullo schermo senza quella flag.
hda gli specifica il file con cui emulare il disco, k il layout del keyboard
m √® la memoria ram
monitor √® per poter mandare interrupt dal terminale in cui ho lanciato il mio comando di emulazione.
Quando installa prima √® installato nella RAM disk, e poi viene utilizzato per l‚Äôinstallazione vera e propria.</p>
</li>
</ul>
<h4 id="xen-">XEN üü©<a hidden class="anchor" aria-hidden="true" href="#xen-">#</a></h4>
<p>XEN √® hypervisor livello 1 (SO che permette di fare altri SO virtuali), e utilizzare paravirtualizzazione (si fanno trap and emulate principalmente) , e utilizza una gestione diversa dei drivers che possiede, ossia il <strong>Domain0</strong> possiede tutti i drivers fisici (le interazioni con i device le manda alla macchina 0, perch√© per restare un sistema operativo semplice non riesce a gestire sistemi operativi).</p>
<p><strong>Esempio di maggiore efficienza</strong></p>
<p>Per il type 2 hypervisor il SO installato pensa veramente di stare in una macchina s√©, quindi fa cose per minimizzare i seek del disco ma in questo caso non deve fare veramente seek, quindi √® meno efficiente, facendo una assunzione errata.</p>
<p>Si utilizzano paravirtualizzazione, ossia devices virtuali pi√π efficienti per questa cosa, ed effettivamente non assumo di stare utilizzando device fisici, ma sono a conoscenza di utilizzare device virtuali, e posso fare ottimizzazioni del caso (che non so quali siano forse per il disco non faccio cose strane per il seek ad esempio).</p>
<p>Il problema √® che essendo a conoscenza, dovrei fare il mio SO in modo che sia compatibile con le hyper all offerte dall hypervisor</p>
<h3 id="implementazione-della-virtualizzazione">Implementazione della Virtualizzazione<a hidden class="anchor" aria-hidden="true" href="#implementazione-della-virtualizzazione">#</a></h3>
<p>Possiamo considerare tre metodi principali di virtualizzazione:</p>
<h4 id="simulazione-diretta-">Simulazione diretta üü©<a hidden class="anchor" aria-hidden="true" href="#simulazione-diretta-">#</a></h4>
<ul>
<li>Simulazione via software sull&rsquo;host (molto molto lento, tipo 100x volte pi√π lento)
<ul>
<li>Un esempio √® QEMU in full emulation.</li>
</ul>
</li>
</ul>
<h4 id="esecuzione-diretta---">Esecuzione diretta üü®&ndash;<a hidden class="anchor" aria-hidden="true" href="#esecuzione-diretta---">#</a></h4>
<ul>
<li>Trap and emulate in cui il VMM intercetta il trap ed esegue l&rsquo;istruzione equivalente</li>
<li>Emulazione con supporto hardware
<ul>
<li>come con le estensioni <strong>Intel VT-x</strong> e <strong>AMD-V</strong>.</li>
<li>Questo √® il metodo pi√π utilizzato oggi giorno.</li>
<li>Vedi sezione di istruzioni di virtualizzazione.</li>
<li>Add <strong>Virtual Machine Control Structure</strong> (VMCS) che decide quali istruzioni fanno VMexit, e quando si pu√≤ cambiare queste informazioni con VMread or write e simili, consentendo all‚Äôhypervisor di controllare il comportamento della VM.</li>
</ul>
</li>
<li>Dynamic binary translation
<ul>
<li>Necessario quando l&rsquo;hardware non √® totalmente virtualizzabile, quindi introduce delle istruzioni di emulazione in pi√π.</li>
</ul>
</li>
</ul>
<h4 id="paravirtualizzazione-">Paravirtualizzazione üü©<a hidden class="anchor" aria-hidden="true" href="#paravirtualizzazione-">#</a></h4>
<ul>
<li>In questo caso il SO virtuale √® a conoscenza che esiste un hypervisor quindi pu√≤ fare delle <strong>hypercall</strong> per eseguire delle istruzioni sensitive, e in generale √® un approccio pi√π veloce invece della virtualizzazione totale di cui abbiamo parlato prima. Per√≤ bisogna essere a conoscenza del hypervisor.</li>
<li>Quindi andiamo a modificare parti del SO in modo da tenere in considerazione l‚Äôesistenza dell‚Äôhypervisor, rende pi√π veloce, per√≤ bisogna andare a modificare il SO stesso, per ogni SO.</li>
<li>Un esempio √® XEN.</li>
</ul>
<h4 id="parametrizzazione-so-">Parametrizzazione SO üü©<a hidden class="anchor" aria-hidden="true" href="#parametrizzazione-so-">#</a></h4>
<p>Questo non √® proprio un metodo di virtualizzazione di un Sistema Operativo, ma un modo per modificare leggermente alcuni sistemi operativi.</p>
<p>Essendo libero linux, √® molto comodo poter cambiare alcuni parametri e poi <strong>ricompilare il kernel seguendo quei parametri</strong>. Tanto √® tutto open source, quindi si potrebbe fare. Questo permette al kernel di essere molto portabile.</p>
<p>Una cosa molto importante da capire √® che <strong>il kernel √® una cosa diversa della distribuzione</strong>, il kernel √® il primo programma che viene caricato dal bootloader e carica il FS e tutto il resto (quindi le cose iniziali), il secondo sono tutte le utility per il kernel che lo rendono utilizzabile da un utente normale.</p>
<ul>
<li>
<p>Comando runnato per la emulazione kernel/distribuzione</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 18.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 18">
</li>
<li>
<p>Slide parametrizzazione ++ portabilit√† (che deve runnare per hardware differentI)</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 19.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 19">
</li>
</ul>
<h4 id="istruzioni-di-virtualizzazione-">Istruzioni di virtualizzazione üü•<a hidden class="anchor" aria-hidden="true" href="#istruzioni-di-virtualizzazione-">#</a></h4>
<p>Abbiamo aggiunto delle istruzioni di emulazione come <code>VMX ON, VMX OFF, VMLAUNCH, VMRETURN</code>  in cui il processore sa di stare emulando, e quindi √® pi√π veloce perch√© esegue l&rsquo;istruzione in altro modo, forse con istruzione nativa. Pagina <a href="https://en.wikipedia.org/wiki/X86_virtualization">wiki</a>
fa pensare di essere in kernel mode, ma non √® in kernel mode, √® come se stesse in un livello di priviliegio intermedio.</p>
<p>VMLAUNCH</p>
<p>Queste sono quelle principali istruzioni che permettono la virtualizzazioen a livello software, il fatto che rende l&rsquo;esecuzione molto pi√π veloce, quindi invece di simulare tutto sopra il sistema operativo attuale (e syscalls attuali) posso accedere ad istruzioni hardware molto pi√π veloci.</p>
<h3 id="memoria-virtuale">Memoria Virtuale<a hidden class="anchor" aria-hidden="true" href="#memoria-virtuale">#</a></h3>
<p>C&rsquo;√® una MMU del sistema operativo che mappa alla VM fisica, che si deve basare all&rsquo;indirizzo logico, che deve essere risolto dalla MMU reale fino ad avere un indirizzo fisico.</p>
<img src="/images/notes/image/universita/ex-notion/Architettura software del OS/Untitled 20.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura software del OS/Untitled 20">
Dobbiamo virtualizzare l'accesso in memoria da quella parte, l'hypervisor deve tradurre la memoria "fisica" del guest con una memoria fisica reale, abbiamo uno schema del genere:
Guest Virtual Address (GVA) ‚Üí Guest Physical Address (GPA) ‚Üí Host Physical Address (HPA)
<h4 id="shadow-page-tables-">Shadow Page Tables üü•<a hidden class="anchor" aria-hidden="true" href="#shadow-page-tables-">#</a></h4>
<img src="/images/notes/Virtual Machines-20250503180708873.webp" width="481" class="center" alt="Virtual Machines-20250503180708873"/>
Permettono di evitare l'utilizzo di **Shadow page tables**, che sono il remapping della pagine virtuali con le pagine fisiche.
Ci sono esattamente lo stesso numero di pagine nei sistemi operativi virtuali con il numero di pagine nel shadow page table. Questo √® una soluzione che si pu√≤ implementare anche *senza supporto hardware*.
<p>Svantaggi:
Esiste molto <strong>overhead</strong> di memoria per quanto riguarda questa parte.</p>
<h4 id="extended-page-tables-">Extended Page Tables üü•<a hidden class="anchor" aria-hidden="true" href="#extended-page-tables-">#</a></h4>
<p>Abbiamo in pratica una sezione di traduzione in pi√π per mapparlo a EPT (Extended Page Tables), che mappa le pagine virtuali con le pagine fisiche, e quindi non c&rsquo;√® overhead di memoria, e quindi √® molto pi√π efficiente in comparazione con le shadow page tables, per√≤ necessita di supporto hardware all&rsquo;operazione, questa √® la soluzione preferita in ambienti cloud.</p>
<img src="/images/notes/Architettura software del OS-20250226132408095.webp" style="width: 100%" class="center" alt="Architettura software del OS-20250226132408095">
<h4 id="multi-level-translation">Multi-Level Translation<a hidden class="anchor" aria-hidden="true" href="#multi-level-translation">#</a></h4>
<p>Solitamente i sistemi x86-64 utilizzano un sistema di traduzione che √® multi-livello.
<img src="/images/notes/Virtual Machines-20250503182746118.webp" style="width: 100%" class="center" alt="Virtual Machines-20250503182746118"></p>
<p>Questa nota √® di particolare interesse perch√© se abbiamo un TLB miss in virtualizzazione, dobbiamo andare a recuperare le informazioni da EPT e prende molti molti accessi in pi√π.
<img src="/images/notes/Virtual Machines-20250503182925807.webp" style="width: 100%" class="center" alt="Virtual Machines-20250503182925807"></p>
<h4 id="hugepages">HugePages<a hidden class="anchor" aria-hidden="true" href="#hugepages">#</a></h4>
<p>This is an idea that attempts to solve the problem in virtualization that we raised above. With bigger virtual pages it is more difficult to have a TLB miss (hugepage is 2MB, while gigantic pages are 1GB).
The idea is that here big part of the memory is mapped to the physical address, which means we don&rsquo;t have to translate it, having thus fewer walks when we have TLB miss.</p>
<p>The drawback with this solution is that Internal fragmentation (wasted memory) is much higher, and the system becomes slow for small dynamic allocations.</p>
<h3 id="virtualizzazione-di-io">Virtualizzazione di I/O<a hidden class="anchor" aria-hidden="true" href="#virtualizzazione-di-io">#</a></h3>
<p>Esistono moltissimi dispositivi I/O, che rendono la possibilit√† di virtualizzare un po&rsquo; difficile. Scrivere drivers a livello I/O non √® poi tanto pratico.</p>
<h4 id="problemi-di-virtualizzazione-io">Problemi di virtualizzazione I/O<a hidden class="anchor" aria-hidden="true" href="#problemi-di-virtualizzazione-io">#</a></h4>
<p>Il dispositivo I/O virtuale deve essere in grado di:
Virtual device interface</p>
<ul>
<li>Traps device commands</li>
<li>Translates DMA operations</li>
<li>Injects virtual interrupts</li>
</ul>
<p>Si ricorda  in <a href="/notes/devices-os">Devices OS</a> che solitamente questi usano Direct Memory Access per scrivere per il sistema operativo, per√≤ questo spesso non √® possibile e bisogna fare qualche interrupt virtuale per risolvere questo problema.
Possiamo</p>
<ul>
<li>Para virtualizzare l&rsquo;interfaccia del device</li>
<li>Emulare il device I/O.</li>
</ul>
<h4 id="single-root-io-virtualization">Single Root I/O Virtualization<a hidden class="anchor" aria-hidden="true" href="#single-root-io-virtualization">#</a></h4>
<p>SR-IOV enables <strong>hardware-assisted virtualization</strong> by partitioning a single PCIe device into multiple <strong>Virtual Functions (VFs)</strong>, which can be assigned directly to virtual machines (VMs) or containers. This reduces overhead caused by traditional software-based I/O virtualization.</p>
<p><strong>Key Components of SR-IOV:</strong></p>
<ol>
<li><strong>Physical Function (PF)</strong>
<ul>
<li>The main PCIe function, fully featured, controlled by the host OS (hypervisor).</li>
<li>Manages and configures the Virtual Functions.</li>
</ul>
</li>
<li><strong>Virtual Functions (VFs)</strong>
<ul>
<li>Lightweight PCIe functions with limited resources, assigned to VMs or containers.</li>
<li>Each VM gets direct access to a VF, bypassing the hypervisor for performance gains.</li>
</ul>
</li>
</ol>
<img src="/images/notes/Virtual Machines-20250503183322645.webp" width="523" class="center" alt="Virtual Machines-20250503183322645"/>
<h1 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h1>
<p id=hofstadterAmStrangeLoop2007>[1] Hofstadter <a href="https://psycnet.apa.org/record/2007-01197-000">‚ÄúI Am a Strange Loop‚Äù</a> Basic Books 2007
 </p>
<p id=silberschatzOperatingSystemConcepts2018>[2] Silberschatz et al. <a href="https://books.google.ch/books/about/Operating_System_Concepts.html?id=FHJlDwAAQBAJ&redir_esc=y">‚ÄúOperating System Concepts‚Äù</a> Wiley 2018
 </p>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/cloud-computing/">‚òÅCloud-Computing</a></li>
      <li><a href="https://flecart.github.io/tags/sistemi-operativi/">Sistemi-Operativi</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Virtual Machines on x"
            href="https://x.com/intent/tweet/?text=Virtual%20Machines&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fvirtual-machines%2f&amp;hashtags=%e2%98%81cloud-computing%2csistemi-operativi">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Virtual Machines on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fvirtual-machines%2f&amp;title=Virtual%20Machines&amp;summary=Virtual%20Machines&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2fvirtual-machines%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Virtual Machines on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2fvirtual-machines%2f&title=Virtual%20Machines">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Virtual Machines on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2fvirtual-machines%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Virtual Machines on whatsapp"
            href="https://api.whatsapp.com/send?text=Virtual%20Machines%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2fvirtual-machines%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Virtual Machines on telegram"
            href="https://telegram.me/share/url?text=Virtual%20Machines&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fvirtual-machines%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Virtual Machines on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Virtual%20Machines&u=https%3a%2f%2fflecart.github.io%2fnotes%2fvirtual-machines%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span> ¬∑ 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
