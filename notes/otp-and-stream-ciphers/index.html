<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>OTP and Stream Ciphers | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="üõ°Ô∏ècybersecurity">
<meta name="description" content="XOR operation √à una operazione binaria abbastanza semplice per√≤ ci sar√† importante per andare ad analizzare dei cifrari di un certo genere. Come il ONE TIME PAD che faremo fra poco in OTP and Stream Ciphers.
Teorema cifratura con XOR Prendiamo $X$ una variabile aleatoria in $\left{ 0,1 \right}^{n}$ uniforme, sia $Y$ una variabile aleatoria su uno stesso dominio come vogliamo. Tali per cui $X, Y$ siano indipendenti Allora avremo che $C = X \oplus Y$ √® una variabile aleatoria uniforme.">
<meta name="author" content="Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="flecart.github.io/notes/otp-and-stream-ciphers/">
<link crossorigin="anonymous" href="flecart.github.io/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="flecart.github.io/notes/otp-and-stream-ciphers/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>


<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-WW6NN2QGKF', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="OTP and Stream Ciphers" />
<meta property="og:description" content="XOR operation √à una operazione binaria abbastanza semplice per√≤ ci sar√† importante per andare ad analizzare dei cifrari di un certo genere. Come il ONE TIME PAD che faremo fra poco in OTP and Stream Ciphers.
Teorema cifratura con XOR Prendiamo $X$ una variabile aleatoria in $\left{ 0,1 \right}^{n}$ uniforme, sia $Y$ una variabile aleatoria su uno stesso dominio come vogliamo. Tali per cui $X, Y$ siano indipendenti Allora avremo che $C = X \oplus Y$ √® una variabile aleatoria uniforme." />
<meta property="og:type" content="article" />
<meta property="og:url" content="flecart.github.io/notes/otp-and-stream-ciphers/" />
<meta property="og:image" content="flecart.github.io/images/papermod-cover.png" />
<meta property="article:section" content="notes" />



<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="flecart.github.io/images/papermod-cover.png" />
<meta name="twitter:title" content="OTP and Stream Ciphers"/>
<meta name="twitter:description" content="XOR operation √à una operazione binaria abbastanza semplice per√≤ ci sar√† importante per andare ad analizzare dei cifrari di un certo genere. Come il ONE TIME PAD che faremo fra poco in OTP and Stream Ciphers.
Teorema cifratura con XOR Prendiamo $X$ una variabile aleatoria in $\left{ 0,1 \right}^{n}$ uniforme, sia $Y$ una variabile aleatoria su uno stesso dominio come vogliamo. Tali per cui $X, Y$ siano indipendenti Allora avremo che $C = X \oplus Y$ √® una variabile aleatoria uniforme."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "OTP and Stream Ciphers",
      "item": "flecart.github.io/notes/otp-and-stream-ciphers/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "OTP and Stream Ciphers",
  "name": "OTP and Stream Ciphers",
  "description": "XOR operation √à una operazione binaria abbastanza semplice per√≤ ci sar√† importante per andare ad analizzare dei cifrari di un certo genere. Come il ONE TIME PAD che faremo fra poco in OTP and Stream Ciphers.\nTeorema cifratura con XOR Prendiamo $X$ una variabile aleatoria in $\\left{ 0,1 \\right}^{n}$ uniforme, sia $Y$ una variabile aleatoria su uno stesso dominio come vogliamo. Tali per cui $X, Y$ siano indipendenti Allora avremo che $C = X \\oplus Y$ √® una variabile aleatoria uniforme.",
  "keywords": [
    "üõ°Ô∏ècybersecurity"
  ],
  "articleBody": "XOR operation √à una operazione binaria abbastanza semplice per√≤ ci sar√† importante per andare ad analizzare dei cifrari di un certo genere. Come il ONE TIME PAD che faremo fra poco in OTP and Stream Ciphers.\nTeorema cifratura con XOR Prendiamo $X$ una variabile aleatoria in $\\left{ 0,1 \\right}^{n}$ uniforme, sia $Y$ una variabile aleatoria su uno stesso dominio come vogliamo. Tali per cui $X, Y$ siano indipendenti Allora avremo che $C = X \\oplus Y$ √® una variabile aleatoria uniforme.\nQuesto √® necessario per la sicurezza di OTP. Dimostrazione: Supponiamo $n=1$ poi credo si possa estendere a $n$ pi√π grande senza troppi problemi: $$ \\mathbb{P}(C=0) = \\mathbb{P}((X,Y) = (0,0)) + \\mathbb{P}((X, Y) =(1,1)) = \\frac{p_{0}}{2} + \\frac{p_{1}}{2} = \\frac{1}{2} $$ Quindi $\\mathbb{P}(C=1) = \\frac{1}{2}$ e si continua provando ad aggiungere parti.\nOne Time Pad Cipher Inventato da Vernam 1917. e 1926 sempre lui, infatti questo √® il cipher che √® nella teoria veramente unbreakable! Lo ha chiamato BSS = Binary Symmetric source, vedi: https://cs.ioc.ee/yik/schools/win2006/massey/slides1.pdf\nDescrizione del cipher üü© Prendiamo $K, M, C \\in \\left{ 1, 0 \\right}^{n}$ Allora $$ E(k, m) = k \\oplus m $$ e decrittazione diventa $$ D(k, C) = k \\oplus C $$\nLa cosa importante √® che $k$ √® usato solo una volta, altrimenti ho problemi di sicurezza molto importanti (vedi many-time-pad). Una altra cosa importante √® che $k$ sia uniforme, che poi usando il teorema di XOR di sopra, possiamo avere massima sicurezza (entropia massima)\nNecessit√† del mezzo comunicativo üü®++ Ci sono anche restrizioni sulla generazione e sulla conoscenza della chiave dai due parties che cercano di comunicare! Dimostrazione segretezza perfetta üü© Si basa sulla definizione in Classical Cyphers#Security of the Key.\nVogliamo dimostrare $\\mathbb{P}(E(k, m_{0}) = c) = \\mathbb{P}(E(k, m_{1}) = c)$ .\nAllora nel nostro caso abbiamo: $$ \\forall m,c: \\mathbb{P}(E(k, m) = c)] = \\frac{#\\text{Chiavi tali per cui } E(k,m) = c}{\\lvert K \\rvert } $$ Va vale il fatto che $\\forall m, c$ $#\\left{ k \\in K: E(k, m) = c \\right} = 1$ Quindi abbiamo la segretezza. (√® 1 perch√© con OTP √® unica la chiave che viene utilizzata per ottenere quello).\nSvantaggi OTP üü© La difficolt√† di utilizzo di OTP, nonostante le forti garanzie teoriche √® dalla lunghezza della chiave. Vedi Classical Cyphers#Security of the Key per maggiori dettagli.\nLa chiave deve avere stessa lunghezza del messaggio (overhead, difficolt√† per mandare messaggi lunghi) Distruzione della chiave dopo l‚Äôutilizzo (che si fa solo una volta!) La comunicazione della chiave. Per questo motivo non si utilizza per applicazioni commerciali.\nAttacks on OTP Many time pad attack üü®+ Se ho $c_{1} = m_{1} \\oplus PRNG(k)$ e $c_{2} = m_{2} \\oplus PRNG(k)$ Io so che solitamente da $m_{1} \\oplus m_{2}$ riusciamo a ricavare $m_{1}$ e $m_{2}$ per ridondanze del linguaggio TODO: approfondire. Quindi avendo i due ciphertext posso avere il valore sopra, perch√© $$ c_{1} \\oplus c_{2} = k \\oplus m_{1} \\oplus k \\oplus m_{2} = m_{1} \\oplus m_{2} $$\nQuesto √® stato usato nel verona project (‚Äò41 - ‚Äò80)\nAmerican National Security Agency decrypted Soviet messages that were transmitted in the 1940s. That was possible because the Soviets reused the keys in the one-time pad scheme.\nNo integrit√† üü© Un attaccante pu√≤ cambiare a suo piacimento il valore del plaintext iniziale, questo √® soprattutto utile se sa bene cosa cambiare, altrimenti un umano probabilmente pu√≤ capire che il messaggio √® senza senso, ma nella teoria √® giusto, il ricevente non pu√≤ capire se il messaggio √® stato modificato, o originariamente √® stato mandato cos√¨:\nSe attaccante modifica $c$ creando $c^{*} = c \\oplus p$ il ricevente avr√† $m \\oplus p$ quindi √® modificato, e non sa che √® stato cambiato.\nNOTA particolare Questo attacco √® particolarmente pericolo quanso\nSi sa la posizione del testo da cambiare Si sa il contenuto del testo cifrato in quella posizione. Se si hanno queste informazioni posso metterci un valore a piacere in quella zona. Questa cosa dovresti riuscire a capire perch√© sia cos√¨. Ad alto livello ti dico: fai xor con quella parte di testo, cos√¨ hai 0 in plaintext, poi rifai xor col tuo messaggio per metterci quello che ti pare. Real-world attacks L‚Äôunico takeaway √® non usare chiavi ripetute, che vedi sopra.\nWindows NT PPT (non fare) Perch√© veniva ripetuta la chiave sia client che server\nWEP (non fare) IV veniva ripetuta ongi 16M frames, che era presente Le chiavi generate per i vari frame sono molto correlate, perch√© cambia solo IV in sequente (dice la prof. che inviava anche in chiaro). Non so esattamente i dettagli ma non dovrebbe essere importante. Stream Ciphers Now we talk about stream ciphers, next about block ciphers, after that asymmetric cipher.., con questra struttura\nIntroduction Motivation and basic stuff üü© LSM was first kind of crypto for cellphones, and it was a stream cipher (fast, at least 12 y ago confronted with the other ciphers that existed).\nEncrypting individual bits! when block ciphers encrypt blocks of it. This leads to simple encryption and decryption operations. (this is a big addendum! most of embeeded devices use this because its easy and fast!) The hardware is nice for these cyphers. Standard template of encrypt decrypt (non fare) And we can note it‚Äôs an shift cipher (affine cipher) discussed in the Classical Cyphers.\nA note is that the decryption uses the Plus! This is because we are in modulus 2, and a sum is actually a xor operation. (see the logic table of it).\nProof of why the two operations are the same\nSempre dalla tavola logica si pu√≤ vedere che uno 0 pu√≤ essere criptato 50% a 0 e 50% a1, quindi √® resistente ad attacchi di analisi delle frequenze (ma questo solo se ho un generatore randomico buono !).\nRandom generators As the security of the scream cipher is dependent on the keys, we need to have a way to generate random keys.\nCategories of random number generators (3) (non fare) Cercare su Randomness per descrizione sul tema.\nTrue Random Number Generators tipically from random physical processes ma non riesco a farlo moltro in fretta\nLancio di dati Rumore Movimento del mouse. Random keyboard types. (e distanza tempo fra di essi). Pseudo-random Number Generators (vorremmo qualcosa di random, ma che possa produrre la stessa sequenza deterministic\nMost of these are not criptografically secure! (are usually predictable, so useless for cryptography). But they satisfy important statistical properties necessary for randomness (and tests) Forma classica di computazione\nCryptographically Secure PRNGs (same as PRNGs, but with unpredictability).\nDefinition of unpredictability\nCio√® non riesco a predire in che modo la sequenza pu√≤ continuare in tempo polinomiale, data una sequenza di bits di output. Definizione PRNG Per la Jocelyne √® una funzione $\\left{ 0, 1 \\right}^{s} \\to \\left{ 0, 1 \\right}^{n}$ in cui $s \\ll n$ in teoria gli algoritmi possono generare cose infinite, ma per quanto ci interessa, vogliamo restringerci solamente a un numero finito di bit in output (che √® cosa nella pratica abbiamo) Una cosa √® che l‚Äôalgoritmo che li genera √® deterministico, compattabile diciamo con Kolmogorov complexity, ma con buoni security guarantees e anche statistiche, vedi Randomness.\nOPT tramite PRNG üü© Possiamo usare #One Time Pad Cipher usando i PRNG! Cos√¨ risolviamo il problema di comunicazione di cose troppo grosse.\nAnalisi sicurezza stream cipher con PRNG Solamente che abbiamo la nota teorica in Classical Cyphers#Security of the Key che non possiamo avere sicurezza se la chiave reale √® minore rispetto a quella reale.\nStiamo spostando la sicurezza dell‚ÄôOTP sul seed che genera.\nExamples of PRNGs Questi sono stati analizzati tempo fa da Knuth nell‚Äôart of computer programming.\nLinear Congruential Generator üü© abbiamo una sequenza $r_{0} = seed$ e $r_{i+1} = a \\cdot r_{i} + b \\mod p$ Sembra che questa cosa molto semplice abbiamo propriet√† statistiche Randomness molto carine, ma molto facile da scoprire.\nglibc random (non impo) $r_{i} = (r_{i - 3} + r_{i - 31}) \\mod 2^{32}$ in cui gli index sono dei singoli bit credo Poi viene ritornato $r_{i} /2$ per qualche motivo\nNota: questo non √® sicuro per√≤ come generatore!\nSecurity necessities for PRNGs Non predictability (!) Possiamo definire che un PRNG √® predictable se esiste $i \\in N$ tale per cui avendo la sequenza $x_{0}, x_{1}, \\dots, x_{i}$ esista un algoritmo computabile secondo La macchina di Turing e che sia anche efficiente tale per cui possa calcolare $x_{i+1}, \\dots$. con una probabilit√† alta. Se vale questo, e possono trovare l‚Äôalgoritmo che computa questo algoritmo, avrei tutto poi per decifrare, anche se non conosco la chiave iniziale.\nLa prof la definisce cos√¨: $\\exists A, \\exists i : 1 \\leq i \\leq n - 1$ tale per cui $$ \\mathbb{P}{k \\leftarrow K} \\left[ A(G(k)|x{1},x_{2}, \\dots, x_{i}) = G(k)|x_{i+1}\\right] \\geq \\frac{1}{2} + \\varepsilon $$ con $\\varepsilon = \\frac{1}{2^{30}}$. Quindi se riesce a farlo in modo migliore del random gi√† diciamo che √® predictable.\nUna domanda interessante √® perch√© lo si definisce in modo probabilistico.\nStatistical Tests e Advantage Qui viene definito solo come un algoritmo che outputta 0 o 1 dopo che gli diamo la stringa iniziale in input. Note migliori dovrebbero essere in Randomness. Con questo test e la possibilit√† di definire una sequenza truly random $r$ possiamo definire il concetto di advantage che in breve √® quanto bene riusciamo a distinguere la PRNG dal random vero. A me sembra abbastanza inutile questa definizione. Per√≤ pu√≤ essere utile per definire che il PRNG non √® abbastanza simile al random. L‚Äôalgoritmo $A$ √® spesso chiamato oracolo.\nSecurity with advantage Secondo la prof. questa ‚Äúadvantage‚Äù √® una misura di quanto il sistema √® rompibile. Se √® simile a 1 sono abbastanza sicuro, altrimenti √® 0.\nA PRNG $G : K \\to \\left{ 0, 1 \\right}^{n}$ √® sicuro se per ogni test possibile (e questo √® gi√† molto irrealistico) √® vero che $$ Adv_{PRNG}[A, G] \\leq \\varepsilon $$ dove $\\varepsilon$ √® molto molto piccolo, negligible si potrebbe dire. Sembra che questo problema si riduca a $P \\not= NP$ per qualche motivo strano. Queste sono definizioni con oracolo perch√© assumiamo di avere un $r$ che √® truly random.\nLa cosa interessante con questa definizione √® che se √® sicura, allora non √® predicibile, e questa conclusione intuitivamente non √® molto difficile. yao ¬¥82 sembra dimostrare che c‚Äô√® proprio una equivalenza, se non √® predictable, allora √® sicuro sotto questa definizione.\nQuesta definizione comunque secondo (Stinson 2005) chapt 6.9 √® molto difficile da raggiungere, perch√© troppo facile da rompere, perch√© tratta di leaks di informazione, ma solitamente di molto poco conto.\nSemantic security (!) Why is semantic security important? see here. It relates to the notion ‚Äúno information about hte plaintext from the ciphertext‚Äù.\nDefinizione semantic security Da https://en.wikipedia.org/wiki/Semantic_security\na¬†semantically secure¬†cryptosystem¬†is one where only negligible information about the¬†plaintext¬†can be feasibly extracted from the¬†ciphertext.\nDa un punto di vista teorico, questo √® un rilassamento della nozione di Classical Cyphers#Security of the Key, in cui si richiede che siano uguali, in questo setting richiediamo che siano solo vicine le due probabilit√†. Solo che sembra che sia inutile la nozione per s√© quindi introduciamo l‚Äôesperimento.\nNelle slides si fa un gioco di questo genere:\nChallenger e adversary L‚Äôavversario invia due messaggi in chiaro, Challenger invia i messaggi cifrati L‚Äôobiettivo dell‚Äôavversario √® identificare quale cyphertext coincide a quale messaggio, se si pu√≤ fare, non √® sicuro secondo la definizione di semantic security di sopra, anche se non so nella pratica quanto sia vero. Questo √® vero quando #Security with advantage √® negligible, quindi non si pu√≤ fare. Per il prof. √® leggermente diverso rispetto a questo:\nProbabilit√† di associare il ciphertext al corrispettivo plaintext.\nQuesto si pu√≤ riassumere in questo: Ossia non √® in grado di distinguere la funzione fatta con chiave da una funzione a caso nell‚Äôinsieme delle funzioni.\nSemantic security for many-time key Abbiamo ora che la chiave √® usata pi√π di una volta, quindi abbiamo molte coppie, magari anche qualche plaintext. Infatti pu√≤ scegliere quale plaintext avere a suo piacimento, si chiama chosen plaintext.\nOssia pu√≤ scegliere quanti messaggi vuole per un certo esperimento\nNonce based-security L‚Äôidea √® la stessa di cui abbiamo parlato in Sicurezza delle reti per un protocollo di autenticazione. Un esempio carino di questo √® in Block Ciphers#Cipher Block Chaining (CBC) per cercare di randomizzare l‚ÄôIV.\nRandomized encryption Sono delle funzioni che ritornano cyphertext in modo probabilistico (non sempre la stessa)\nPractical stream ciphers In questo caso andiamo ad utilizzare un PRNGs, non pi√π truly random, per le ragioni di efficienza di comunicazione‚Ä¶\nla chiave sono i valori delle cose affini nel LCG.. (forse anche il seed? boh)\nRC4 cipher Non so bene come √® stato creato questo algoritmo, probabilmente provato cose a caso??? Questo √® stato inventato da Ron Rivest, lo stesso che ha inventato l‚Äôalgoritmo di RSA del 1987.\nInizializzazione Usiamo il seed $s$ per inizializzare una permutazione dei primi 256 numeri\nS[i] \u003c- arange(0, 257) s = len S j \u003c- 0 for i \u003c- 0 to 255 do: k \u003c- S[i mod s] j \u003c- (j + S[i] + k) mod 256 swap(s[i], s[j]) Con questo algoritmo in pseudocodice\nGenerazione (non fatta) #### Attacchi üü® Non segue la definizione di [Classical Cyphers#Security of the Key](//notes/classical-cyphers#security-of-the-key), c'√® del bias in quanto generato che si pu√≤ sfruttare in modo abbastanza semplice, per esempio si pu√≤ attaccare WEP che usava questo algoritmo in questo modo. ### Content Scrambling System (non fatto) eStream Cypher Si ha solitamente un nonce in questo caso, lo stesso che abbiamo usato in Sicurezza delle reti. Quindi un valore randomico utilizzato una singola volta\nSalsa 20 √à un algoritmo moderno di stream cipher, solitamente implementato in hardware per velocit√†. Prende una chiave 256 bit e un nonce di 64. Utilizza questo per fare un mix di 20 rounds e poi produrre ili bit stream utilizzato per encodare il plaintext iniziale. Questo √® ancora sicuro, attacchi esistenti non riescono a romperlo totalmente pagina wiki Veloce che fa Mezzo giga al secondo di cifrazione.\nLinear Feedback Shift Registers This is a way to create a stream of bits to xor with the message. This stream is generated with a key. One of the advantages is that it‚Äôs low power in hardware.\nShift registers You have to remember flip flops by Circuiti Sequenziali in architecture.\nCoso per storare un singolo bit sincronizzato dal clock del computer. La cosa interessante quando si collegano input e output fra flipflops diversi, √® che ad ogni ciclo di clock, si ha una specie di onda che shifta tutti i bit! Quando l‚Äôoutput √® rixorato in certi modi e rimesso all‚Äôinizio, ecco che riusciamo ad avere il feedback lineare!\nEsempio di mini Linear feedback Shift register\nEsempio di LFSR generalizzato\nMatematical Description Con p, per dire se √® 0 o 1 (o aperto o chiuso). E poi in pratica √® l‚Äôoperazione di +, o xor.\nWe want to have a LSFR which has a very long period\nPossiamo anche descrivere un LSFR con dei polinomi. In particolare √® importante sapere\nil numero dei registri Le porte che sono aperte e quelle che sono chiuse. Quindi si pu√≤ rappresentare come $$ P(x) = x^{m} + p_{m - 1}x^{m - 1} + \\dots + p_{1}x + p_{0} $$ Per√≤ non so ancora perch√© questa rappresentazione del LSFR √® utile, boh, lasciamo star.\nTheorem on the period of LSFR L‚Äôidea della dimostrazione √® tipo che gli stati interni della LSFR √® al massimo $2^m - 1$, quindi al massimo il periodo √® quello. (non posso avere 0 perch√© senn√≤ avrei periodo di 1, che non serve a niente).\nMa non tutti hanno periodo massimo! Forse centrano qualcosa i polinomi ciclotomici, per√≤ sta fuori dalla mia capacit√† matematica lol.\nEsempi di LSFR massimi e non\nKnown Plaintext Attacks Il nemico conosce\nTutto il ciphertext il grado dell‚ÄôLSFR (se non lo sa fa bruteforce, e quindi √® come se lo sapesse) Conosce i primi 2m bits del plaintext, quindi sa i primi 2m bits generati. Dal plaintext conosciuto, vorremme ricavare tutti i bits successivi di questo stream cipher. (basta ricavare i valori dei p, ora vediamo un metodo per ricavarli).\nDato che possiede 2m bits conosciuti e conosce m, deve risolvere un sistema di m incognite e m equazioni, e questo si fa, quindi cos√¨ riesce a ricavare LSFR da queste!\nReferences [1] Stinson ‚ÄúCryptography: Theory and Practice, Third Edition‚Äù CRC Press 2005\n",
  "wordCount" : "2715",
  "inLanguage": "en",
  "image": "flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "flecart.github.io/notes/otp-and-stream-ciphers/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="flecart.github.io/flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="flecart.github.io/">Home</a>&nbsp;¬ª&nbsp;<a href="flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      OTP and Stream Ciphers
    </h1>
    <div class="post-meta">13 min&nbsp;¬∑&nbsp;Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul><ul><ul>
                <li>
                    <a href="#xor-operation" aria-label="XOR operation">XOR operation</a><ul>
                        
                <li>
                    <a href="#teorema-cifratura-con-xor" aria-label="Teorema cifratura con XOR">Teorema cifratura con XOR</a></li></ul>
                </li></ul>
                    
                <li>
                    <a href="#one-time-pad-cipher" aria-label="One Time Pad Cipher">One Time Pad Cipher</a><ul>
                        <ul>
                        
                <li>
                    <a href="#descrizione-del-cipher-" aria-label="Descrizione del cipher üü©">Descrizione del cipher üü©</a></li>
                <li>
                    <a href="#necessit%c3%a0-del-mezzo-comunicativo-" aria-label="Necessit√† del mezzo comunicativo üü®&#43;&#43;">Necessit√† del mezzo comunicativo üü®++</a></li>
                <li>
                    <a href="#dimostrazione-segretezza-perfetta-" aria-label="Dimostrazione segretezza perfetta üü©">Dimostrazione segretezza perfetta üü©</a></li>
                <li>
                    <a href="#svantaggi-otp-" aria-label="Svantaggi OTP üü©">Svantaggi OTP üü©</a></li></ul>
                    
                <li>
                    <a href="#attacks-on-otp" aria-label="Attacks on OTP">Attacks on OTP</a><ul>
                        
                <li>
                    <a href="#many-time-pad-attack-" aria-label="Many time pad attack üü®&#43;">Many time pad attack üü®+</a></li>
                <li>
                    <a href="#no-integrit%c3%a0-" aria-label="No integrit√† üü©">No integrit√† üü©</a></li></ul>
                </li>
                <li>
                    <a href="#real-world-attacks" aria-label="Real-world attacks">Real-world attacks</a><ul>
                        
                <li>
                    <a href="#windows-nt-ppt-non-fare" aria-label="Windows NT PPT (non fare)">Windows NT PPT (non fare)</a></li>
                <li>
                    <a href="#wep-non-fare" aria-label="WEP (non fare)">WEP (non fare)</a></li></ul>
                </li></ul>
                </li></ul>
                    
                <li>
                    <a href="#stream-ciphers" aria-label="Stream Ciphers">Stream Ciphers</a><ul>
                        
                <li>
                    <a href="#introduction" aria-label="Introduction">Introduction</a><ul>
                        
                <li>
                    <a href="#motivation-and-basic-stuff-" aria-label="Motivation and basic stuff üü©">Motivation and basic stuff üü©</a></li>
                <li>
                    <a href="#standard-template-of-encrypt-decrypt-non-fare" aria-label="Standard template of encrypt decrypt (non fare)">Standard template of encrypt decrypt (non fare)</a></li></ul>
                </li>
                <li>
                    <a href="#random-generators" aria-label="Random generators">Random generators</a><ul>
                        
                <li>
                    <a href="#categories-of-random-number-generators-3-non-fare" aria-label="Categories of random number generators (3) (non fare)">Categories of random number generators (3) (non fare)</a></li>
                <li>
                    <a href="#definizione-prng" aria-label="Definizione PRNG">Definizione PRNG</a><ul>
                        
                <li>
                    <a href="#opt-tramite-prng-" aria-label="OPT tramite PRNG üü©">OPT tramite PRNG üü©</a></li>
                <li>
                    <a href="#analisi-sicurezza-stream-cipher-con-prng" aria-label="Analisi sicurezza stream cipher con PRNG">Analisi sicurezza stream cipher con PRNG</a></li></ul>
                </li>
                <li>
                    <a href="#examples-of-prngs" aria-label="Examples of PRNGs">Examples of PRNGs</a><ul>
                        
                <li>
                    <a href="#linear-congruential-generator-" aria-label="Linear Congruential Generator üü©">Linear Congruential Generator üü©</a></li>
                <li>
                    <a href="#glibc-random-non-impo" aria-label="glibc random (non impo)">glibc random (non impo)</a></li></ul>
                </li>
                <li>
                    <a href="#security-necessities-for-prngs" aria-label="Security necessities for PRNGs">Security necessities for PRNGs</a><ul>
                        
                <li>
                    <a href="#non-predictability-" aria-label="Non predictability (!)">Non predictability (!)</a></li>
                <li>
                    <a href="#statistical-tests-e-advantage" aria-label="Statistical Tests e Advantage">Statistical Tests e Advantage</a></li>
                <li>
                    <a href="#security-with-advantage" aria-label="Security with advantage">Security with advantage</a></li></ul>
                </li>
                <li>
                    <a href="#semantic-security-" aria-label="Semantic security (!)">Semantic security (!)</a><ul>
                        
                <li>
                    <a href="#definizione-semantic-security" aria-label="Definizione semantic security">Definizione semantic security</a></li>
                <li>
                    <a href="#semantic-security-for-many-time-key" aria-label="Semantic security for many-time key">Semantic security for many-time key</a></li>
                <li>
                    <a href="#nonce-based-security" aria-label="Nonce based-security">Nonce based-security</a></li>
                <li>
                    <a href="#randomized-encryption" aria-label="Randomized encryption">Randomized encryption</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#practical-stream-ciphers" aria-label="Practical stream ciphers">Practical stream ciphers</a><ul>
                        
                <li>
                    <a href="#rc4-cipher" aria-label="RC4 cipher">RC4 cipher</a><ul>
                        
                <li>
                    <a href="#inizializzazione" aria-label="Inizializzazione">Inizializzazione</a></li>
                <li>
                    <a href="#generazione-non-fatta" aria-label="Generazione (non fatta)">Generazione (non fatta)</a></li></ul>
                </li>
                <li>
                    <a href="#estream-cypher" aria-label="eStream Cypher">eStream Cypher</a><ul>
                        
                <li>
                    <a href="#salsa-20" aria-label="Salsa 20">Salsa 20</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#linear-feedback-shift-registers" aria-label="Linear Feedback Shift Registers">Linear Feedback Shift Registers</a><ul>
                        
                <li>
                    <a href="#shift-registers" aria-label="Shift registers">Shift registers</a></li>
                <li>
                    <a href="#matematical-description" aria-label="Matematical Description">Matematical Description</a></li>
                <li>
                    <a href="#theorem-on-the-period-of-lsfr" aria-label="Theorem on the period of LSFR">Theorem on the period of LSFR</a></li>
                <li>
                    <a href="#known-plaintext-attacks" aria-label="Known Plaintext Attacks">Known Plaintext Attacks</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="xor-operation">XOR operation<a hidden class="anchor" aria-hidden="true" href="#xor-operation">#</a></h3>
<p>√à una operazione binaria abbastanza semplice  per√≤ ci sar√† importante per andare ad analizzare dei cifrari di un certo genere. Come il ONE TIME PAD che faremo fra poco in <a href="//notes/otp-and-stream-ciphers.">OTP and Stream Ciphers.</a></p>
<h4 id="teorema-cifratura-con-xor">Teorema cifratura con XOR<a hidden class="anchor" aria-hidden="true" href="#teorema-cifratura-con-xor">#</a></h4>
<p>Prendiamo $X$ una variabile aleatoria in $\left{ 0,1 \right}^{n}$ <strong>uniforme</strong>, sia $Y$ una variabile aleatoria su uno stesso dominio come vogliamo. Tali per cui $X, Y$ siano indipendenti
Allora avremo che $C = X \oplus Y$ √® una variabile aleatoria <strong>uniforme</strong>.</p>
<p>Questo √® necessario per la sicurezza di OTP.
<strong>Dimostrazione</strong>:
Supponiamo $n=1$ poi credo si possa estendere a $n$ pi√π grande senza troppi problemi:
$$
\mathbb{P}(C=0) = \mathbb{P}((X,Y) = (0,0)) + \mathbb{P}((X, Y) =(1,1))
= \frac{p_{0}}{2} + \frac{p_{1}}{2} = \frac{1}{2}
$$
Quindi $\mathbb{P}(C=1) = \frac{1}{2}$ e si continua provando ad aggiungere parti.</p>
<h2 id="one-time-pad-cipher">One Time Pad Cipher<a hidden class="anchor" aria-hidden="true" href="#one-time-pad-cipher">#</a></h2>
<p>Inventato da Vernam 1917. e 1926 sempre lui, infatti questo √® il cipher che √® nella teoria veramente unbreakable! Lo ha chiamato BSS = Binary Symmetric source, vedi: <a href="https://cs.ioc.ee/yik/schools/win2006/massey/slides1.pdf">https://cs.ioc.ee/yik/schools/win2006/massey/slides1.pdf</a></p>
<h4 id="descrizione-del-cipher-">Descrizione del cipher üü©<a hidden class="anchor" aria-hidden="true" href="#descrizione-del-cipher-">#</a></h4>
<p>Prendiamo $K, M, C \in \left{ 1, 0 \right}^{n}$
Allora
$$
E(k, m) = k \oplus  m
$$
e decrittazione diventa
$$
D(k, C) = k \oplus C
$$</p>
<p>La cosa importante √® che $k$ √® usato solo una volta, altrimenti ho problemi di sicurezza molto importanti (vedi many-time-pad).
Una altra cosa importante √® che $k$ sia uniforme, che poi usando il teorema di XOR di sopra, possiamo avere massima sicurezza (entropia massima)</p>
<h4 id="necessit√†-del-mezzo-comunicativo-">Necessit√† del mezzo comunicativo üü®++<a hidden class="anchor" aria-hidden="true" href="#necessit√†-del-mezzo-comunicativo-">#</a></h4>
<p>Ci sono anche restrizioni sulla <strong>generazione</strong> e sulla <strong>conoscenza</strong> della chiave dai due parties che cercano di comunicare!
<img src="/images/notes/image/universita/ex-notion/Stream Ciphers/Untitled 6.png" alt="image/universita/ex-notion/Stream Ciphers/Untitled 6"></p>
<h4 id="dimostrazione-segretezza-perfetta-">Dimostrazione segretezza perfetta üü©<a hidden class="anchor" aria-hidden="true" href="#dimostrazione-segretezza-perfetta-">#</a></h4>
<p>Si basa sulla definizione in <a href="//notes/classical-cyphers#security-of-the-key">Classical Cyphers#Security of the Key</a>.</p>
<p>Vogliamo dimostrare $\mathbb{P}(E(k, m_{0}) = c) = \mathbb{P}(E(k, m_{1}) = c)$ .</p>
<p>Allora nel nostro caso abbiamo:
$$
\forall m,c: \mathbb{P}(E(k, m) = c)] = \frac{#\text{Chiavi tali per cui } E(k,m) = c}{\lvert K \rvert }
$$
Va vale il fatto che $\forall m, c$   $#\left{ k \in K: E(k, m) = c \right} = 1$
Quindi abbiamo la segretezza. (√® 1 perch√© con OTP √® unica la chiave che viene utilizzata per ottenere quello).</p>
<h4 id="svantaggi-otp-">Svantaggi OTP üü©<a hidden class="anchor" aria-hidden="true" href="#svantaggi-otp-">#</a></h4>
<p>La difficolt√† di utilizzo di OTP, nonostante le forti garanzie teoriche √® dalla lunghezza della chiave.
Vedi <a href="//notes/classical-cyphers#security-of-the-key">Classical Cyphers#Security of the Key</a> per maggiori dettagli.</p>
<ol>
<li>La chiave deve avere <strong>stessa</strong> lunghezza del messaggio (overhead, difficolt√† per mandare messaggi lunghi)</li>
<li>Distruzione della chiave dopo l‚Äôutilizzo (che si fa solo una volta!)</li>
<li>La comunicazione della chiave.</li>
</ol>
<p>Per questo motivo non si utilizza per applicazioni commerciali.</p>
<h3 id="attacks-on-otp">Attacks on OTP<a hidden class="anchor" aria-hidden="true" href="#attacks-on-otp">#</a></h3>
<h4 id="many-time-pad-attack-">Many time pad attack üü®+<a hidden class="anchor" aria-hidden="true" href="#many-time-pad-attack-">#</a></h4>
<p>Se ho $c_{1} = m_{1} \oplus PRNG(k)$ e $c_{2} = m_{2} \oplus PRNG(k)$
Io so che solitamente da $m_{1} \oplus m_{2}$ riusciamo a ricavare $m_{1}$ e $m_{2}$ per ridondanze del linguaggio TODO: approfondire.
Quindi avendo i due ciphertext posso avere il valore sopra, perch√©
$$
c_{1} \oplus  c_{2} = k \oplus m_{1} \oplus  k \oplus  m_{2} = m_{1} \oplus  m_{2}
$$</p>
<p>Questo √® stato usato nel <strong>verona project</strong> (&lsquo;41 - &lsquo;80)</p>
<blockquote>
<p>American National Security Agency decrypted Soviet messages that were transmitted in the 1940s. That was possible because the Soviets reused the keys in the one-time pad scheme.</p>
</blockquote>
<h4 id="no-integrit√†-">No integrit√† üü©<a hidden class="anchor" aria-hidden="true" href="#no-integrit√†-">#</a></h4>
<p>Un attaccante pu√≤ cambiare a suo piacimento il valore del <em>plaintext iniziale</em>, questo √® soprattutto utile se sa bene cosa cambiare, altrimenti un umano probabilmente pu√≤ capire che il messaggio √® senza senso, ma nella teoria √® giusto, il ricevente non pu√≤ capire se il messaggio √® stato modificato, o originariamente √® stato mandato cos√¨:</p>
<p>Se attaccante modifica $c$ creando $c^{*} = c \oplus p$ il ricevente avr√† $m \oplus p$ quindi √® modificato, e non sa che √® stato cambiato.</p>
<p><strong>NOTA particolare</strong>
Questo attacco √® particolarmente pericolo quanso</p>
<ol>
<li>Si sa la posizione del testo da cambiare</li>
<li>Si sa il contenuto del testo cifrato in quella posizione.
Se si hanno queste informazioni posso metterci un valore a piacere in quella zona. Questa cosa dovresti riuscire a capire perch√© sia cos√¨.
Ad alto livello ti dico: fai xor con quella parte di testo, cos√¨ hai 0 in plaintext, poi rifai xor col tuo messaggio per metterci quello che ti pare.</li>
</ol>
<h3 id="real-world-attacks">Real-world attacks<a hidden class="anchor" aria-hidden="true" href="#real-world-attacks">#</a></h3>
<p>L&rsquo;unico takeaway √® non usare chiavi ripetute, che vedi sopra.</p>
<h4 id="windows-nt-ppt-non-fare">Windows NT PPT (non fare)<a hidden class="anchor" aria-hidden="true" href="#windows-nt-ppt-non-fare">#</a></h4>
<p>Perch√© veniva ripetuta la chiave sia client che server</p>
<h4 id="wep-non-fare">WEP (non fare)<a hidden class="anchor" aria-hidden="true" href="#wep-non-fare">#</a></h4>
<ol>
<li>IV veniva ripetuta ongi 16M frames, che era presente</li>
<li>Le chiavi generate per i vari frame sono molto correlate, perch√© cambia solo IV in sequente (dice la prof. che inviava anche in chiaro). Non so esattamente i dettagli ma non dovrebbe essere importante.</li>
</ol>
<h1 id="stream-ciphers">Stream Ciphers<a hidden class="anchor" aria-hidden="true" href="#stream-ciphers">#</a></h1>
<p>Now we talk about stream ciphers, next about block ciphers, after that asymmetric cipher..,  con questra struttura</p>
<img src="/images/notes/image/universita/ex-notion/Stream Ciphers/Untitled.png" alt="image/universita/ex-notion/Stream Ciphers/Untitled">
<h2 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h2>
<h3 id="motivation-and-basic-stuff-">Motivation and basic stuff üü©<a hidden class="anchor" aria-hidden="true" href="#motivation-and-basic-stuff-">#</a></h3>
<p>LSM was first kind of crypto for cellphones, and it was a stream cipher (fast, at least 12 y ago confronted with the other ciphers that existed).</p>
<ol>
<li>Encrypting <strong>individual bits!</strong> when block ciphers encrypt blocks of it.</li>
<li>This leads to simple encryption and decryption operations. (this is a big addendum! most of embeeded devices use this because its easy  and fast!) The hardware is nice for these cyphers.</li>
</ol>
<h3 id="standard-template-of-encrypt-decrypt-non-fare">Standard template of encrypt decrypt (non fare)<a hidden class="anchor" aria-hidden="true" href="#standard-template-of-encrypt-decrypt-non-fare">#</a></h3>
<img src="/images/notes/image/universita/ex-notion/Stream Ciphers/Untitled 1.png" alt="image/universita/ex-notion/Stream Ciphers/Untitled 1">
<p>And we can note it‚Äôs an shift cipher (affine cipher) discussed in the <a href="//notes/classical-cyphers">Classical Cyphers</a>.</p>
<p>A note is that the decryption uses the Plus! This is because we are in modulus 2, and a sum is actually a <strong>xor operation</strong>. (see the logic table of it).</p>
<ul>
<li>
<p>Proof of why the two operations are the same</p>
  <img src="/images/notes/image/universita/ex-notion/Stream Ciphers/Untitled 2.png" alt="image/universita/ex-notion/Stream Ciphers/Untitled 2">
</li>
</ul>
<p>Sempre dalla tavola logica si pu√≤ vedere che uno 0 pu√≤ essere criptato 50% a 0 e 50% a1, quindi √® resistente ad attacchi di analisi delle frequenze (ma questo solo se ho un generatore randomico buono !).</p>
<h2 id="random-generators">Random generators<a hidden class="anchor" aria-hidden="true" href="#random-generators">#</a></h2>
<p>As the security of the scream cipher is dependent on the keys, we need to have a way to generate random keys.</p>
<h3 id="categories-of-random-number-generators-3-non-fare">Categories of random number generators (3) (non fare)<a hidden class="anchor" aria-hidden="true" href="#categories-of-random-number-generators-3-non-fare">#</a></h3>
<p>Cercare su <a href="//notes/randomness">Randomness</a> per descrizione sul tema.</p>
<ol>
<li>
<p>True Random Number Generators  <strong>tipically from random physical processes</strong> ma non riesco a farlo moltro in fretta</p>
<ol>
<li>Lancio di dati</li>
<li>Rumore</li>
<li>Movimento del mouse.</li>
<li>Random keyboard types. (e distanza tempo fra di essi).</li>
</ol>
</li>
<li>
<p>Pseudo-random Number Generators (vorremmo qualcosa di random, ma che possa produrre la stessa sequenza <strong>deterministic</strong></p>
<ol>
<li>Most of these are not criptografically secure! (are usually predictable, so useless for cryptography).</li>
<li>But they satisfy important statistical properties necessary for randomness (and tests)</li>
</ol>
<ul>
<li>
<p>Forma classica di computazione</p>
  <img src="/images/notes/image/universita/ex-notion/Stream Ciphers/Untitled 3.png" alt="image/universita/ex-notion/Stream Ciphers/Untitled 3">
</li>
</ul>
</li>
<li>
<p>Cryptographically Secure PRNGs (same as PRNGs, but with <strong>unpredictability</strong>).</p>
<ul>
<li>
<p>Definition of unpredictability</p>
  <img src="/images/notes/image/universita/ex-notion/Stream Ciphers/Untitled 4.png" alt="image/universita/ex-notion/Stream Ciphers/Untitled 4">
</li>
</ul>
<ol>
<li>Cio√® non riesco a predire in che modo la sequenza pu√≤ continuare in tempo polinomiale, data una sequenza di bits di output.</li>
</ol>
</li>
</ol>
<h3 id="definizione-prng">Definizione PRNG<a hidden class="anchor" aria-hidden="true" href="#definizione-prng">#</a></h3>
<p>Per la Jocelyne √® una funzione $\left{ 0, 1 \right}^{s} \to \left{ 0, 1 \right}^{n}$ in cui $s \ll n$ in teoria gli algoritmi possono generare cose infinite, ma per quanto ci interessa, vogliamo restringerci solamente a un numero finito di bit in output (che √® cosa nella pratica abbiamo)
Una cosa √® che l&rsquo;algoritmo che li genera √® <strong>deterministico</strong>, compattabile diciamo con <a href="//notes/kolmogorov-complexity">Kolmogorov complexity</a>, ma con buoni security guarantees e anche statistiche, vedi <a href="//notes/randomness">Randomness</a>.</p>
<h4 id="opt-tramite-prng-">OPT tramite PRNG üü©<a hidden class="anchor" aria-hidden="true" href="#opt-tramite-prng-">#</a></h4>
<img src="/images/notes/OTP and Stream Ciphers-20240222112904461.webp" alt="OTP and Stream Ciphers-20240222112904461">
<p>Possiamo usare <a href="flecart.github.io/notes/otp-and-stream-ciphers/#one-time-pad-cipher">#One Time Pad Cipher</a> usando i PRNG! Cos√¨ risolviamo il problema di comunicazione di cose troppo grosse.</p>
<h4 id="analisi-sicurezza-stream-cipher-con-prng">Analisi sicurezza stream cipher con PRNG<a hidden class="anchor" aria-hidden="true" href="#analisi-sicurezza-stream-cipher-con-prng">#</a></h4>
<p>Solamente che abbiamo la nota teorica in <a href="//notes/classical-cyphers#security-of-the-key">Classical Cyphers#Security of the Key</a> che non possiamo avere sicurezza se la chiave reale √® minore rispetto a quella reale.</p>
<p>Stiamo spostando la sicurezza dell&rsquo;OTP sul seed che genera.</p>
<h3 id="examples-of-prngs">Examples of PRNGs<a hidden class="anchor" aria-hidden="true" href="#examples-of-prngs">#</a></h3>
<p>Questi sono stati analizzati tempo fa da Knuth nell&rsquo;art of computer programming.</p>
<h4 id="linear-congruential-generator-">Linear Congruential Generator üü©<a hidden class="anchor" aria-hidden="true" href="#linear-congruential-generator-">#</a></h4>
<p>abbiamo una sequenza $r_{0} = seed$ e $r_{i+1} = a \cdot r_{i} + b \mod p$
Sembra che questa cosa molto semplice abbiamo propriet√† statistiche <a href="//notes/randomness">Randomness</a> molto carine, ma molto facile da scoprire.</p>
<h4 id="glibc-random-non-impo">glibc random (non impo)<a hidden class="anchor" aria-hidden="true" href="#glibc-random-non-impo">#</a></h4>
<p>$r_{i} = (r_{i - 3} + r_{i - 31}) \mod 2^{32}$ in cui gli index sono dei singoli bit credo
Poi viene ritornato $r_{i} /2$ per qualche motivo</p>
<p>Nota: questo non √® sicuro per√≤ come generatore!</p>
<h3 id="security-necessities-for-prngs">Security necessities for PRNGs<a hidden class="anchor" aria-hidden="true" href="#security-necessities-for-prngs">#</a></h3>
<h4 id="non-predictability-">Non predictability (!)<a hidden class="anchor" aria-hidden="true" href="#non-predictability-">#</a></h4>
<p>Possiamo definire che un PRNG √® <strong>predictable</strong> se esiste $i \in N$ tale per cui avendo la sequenza $x_{0}, x_{1}, \dots, x_{i}$ esista un algoritmo computabile secondo <a href="//notes/la-macchina-di-turing">La macchina di Turing</a> e che sia anche efficiente tale per cui possa calcolare $x_{i+1}, \dots$. con una probabilit√† alta.
Se vale questo, e possono trovare l&rsquo;algoritmo che computa questo algoritmo, avrei tutto poi per decifrare, anche se non conosco la chiave iniziale.</p>
<p>La prof la definisce cos√¨:
$\exists A, \exists i : 1 \leq i \leq n - 1$ tale per cui
$$
\mathbb{P}<em>{k \leftarrow K} \left[ A(G(k)|x</em>{1},x_{2}, \dots, x_{i}) = G(k)|x_{i+1}\right]  \geq \frac{1}{2} + \varepsilon
$$
con $\varepsilon = \frac{1}{2^{30}}$. Quindi se riesce a farlo in modo migliore del random gi√† diciamo che √® predictable.</p>
<p>Una domanda interessante √® perch√© lo si definisce in modo probabilistico.</p>
<h4 id="statistical-tests-e-advantage">Statistical Tests e Advantage<a hidden class="anchor" aria-hidden="true" href="#statistical-tests-e-advantage">#</a></h4>
<p>Qui viene definito solo come un algoritmo che outputta 0 o 1 dopo che gli diamo la stringa iniziale in input. Note migliori dovrebbero essere in <a href="//notes/randomness">Randomness</a>.
Con questo test e la possibilit√† di definire una sequenza <em>truly random</em> $r$ possiamo definire il concetto di <strong>advantage</strong> che in breve √® quanto bene riusciamo a distinguere la PRNG dal random vero.
<img src="/images/notes/OTP and Stream Ciphers-20240229100443638.webp" alt="OTP and Stream Ciphers-20240229100443638"></p>
<p>A me sembra abbastanza inutile questa definizione.
Per√≤ pu√≤ essere utile per definire che il PRNG non √® abbastanza simile al random.
L&rsquo;algoritmo $A$ √® spesso chiamato <strong>oracolo</strong>.</p>
<h4 id="security-with-advantage">Security with advantage<a hidden class="anchor" aria-hidden="true" href="#security-with-advantage">#</a></h4>
<p>Secondo la prof. questa &ldquo;advantage&rdquo; √® una misura di quanto il sistema √® rompibile. Se √® simile a 1 sono abbastanza sicuro, altrimenti √® 0.</p>
<p>A PRNG $G : K \to \left{ 0, 1 \right}^{n}$ √® sicuro se per ogni test possibile (e questo √® gi√† molto irrealistico) √® vero che
$$
Adv_{PRNG}[A, G] \leq \varepsilon
$$
dove $\varepsilon$ √® molto molto piccolo, <em>negligible si potrebbe dire</em>. Sembra che questo problema si riduca a $P \not= NP$ per qualche motivo strano. Queste sono definizioni con <strong>oracolo</strong> perch√© assumiamo di avere un $r$ che √® <em>truly random</em>.</p>
<p>La cosa interessante con questa definizione √® che se √® sicura, allora non √® predicibile, e questa conclusione intuitivamente non √® molto difficile. yao ¬¥82 sembra dimostrare che c&rsquo;√® proprio una equivalenza, se non √® predictable, allora √® sicuro sotto questa definizione.</p>
<p>Questa definizione comunque secondo <a href="https://books.google.it/books/about/Cryptography.html?id=FAPLBQAAQBAJ">(Stinson 2005)</a> chapt 6.9 √® molto difficile da raggiungere, perch√© troppo facile da rompere, perch√© tratta di leaks di informazione, ma solitamente di molto poco conto.</p>
<h3 id="semantic-security-">Semantic security (!)<a hidden class="anchor" aria-hidden="true" href="#semantic-security-">#</a></h3>
<p>Why is semantic security important? <a href="https://chat.openai.com/share/3de4a58b-707c-465b-8874-1090c23be472">see here</a>.
It relates to the notion &ldquo;no information about hte plaintext from the ciphertext&rdquo;.</p>
<h4 id="definizione-semantic-security">Definizione semantic security<a hidden class="anchor" aria-hidden="true" href="#definizione-semantic-security">#</a></h4>
<p>Da <a href="https://en.wikipedia.org/wiki/Semantic_security">https://en.wikipedia.org/wiki/Semantic_security</a></p>
<blockquote>
<p>a¬†<strong>semantically secure</strong>¬†<a href="https://en.wikipedia.org/wiki/Cryptosystem">cryptosystem</a>¬†is one where only negligible information about the¬†<a href="https://en.wikipedia.org/wiki/Plaintext">plaintext</a>¬†can be feasibly extracted from the¬†<a href="https://en.wikipedia.org/wiki/Ciphertext">ciphertext</a>.</p>
</blockquote>
<p>Da un punto di vista teorico, questo √® un rilassamento della nozione di <a href="//notes/classical-cyphers#security-of-the-key">Classical Cyphers#Security of the Key</a>, in cui si richiede che siano uguali, in questo setting richiediamo che siano solo vicine le due probabilit√†. Solo che sembra che sia inutile la nozione per s√© quindi introduciamo l&rsquo;esperimento.</p>
<p>Nelle slides si fa un gioco di questo genere:</p>
<ol>
<li>Challenger e adversary</li>
<li>L&rsquo;avversario invia due messaggi in chiaro,</li>
<li>Challenger invia i messaggi cifrati
L&rsquo;obiettivo dell&rsquo;avversario √® identificare quale cyphertext coincide a quale messaggio, se si pu√≤ fare, non √® sicuro secondo la definizione di semantic security di sopra, anche se non so nella pratica quanto sia vero.
Questo √® vero quando <a href="flecart.github.io/notes/otp-and-stream-ciphers/#security-with-advantage">#Security with advantage</a> √® <em>negligible</em>, quindi non si pu√≤ fare.</li>
</ol>
<p>Per il prof. √® leggermente diverso rispetto a questo:</p>
<blockquote>
<p>Probabilit√† di associare il ciphertext al corrispettivo plaintext.</p>
</blockquote>
<p>Questo si pu√≤ riassumere in questo:
<img src="/images/notes/OTP and Stream Ciphers-20240307112804651.webp" alt="OTP and Stream Ciphers-20240307112804651"></p>
<p>Ossia <strong>non √® in grado di distinguere</strong> la funzione fatta con chiave da una funzione a caso nell&rsquo;insieme delle funzioni.</p>
<h4 id="semantic-security-for-many-time-key">Semantic security for many-time key<a hidden class="anchor" aria-hidden="true" href="#semantic-security-for-many-time-key">#</a></h4>
<p>Abbiamo ora che la chiave √® usata pi√π di una volta, quindi abbiamo molte coppie, magari anche qualche <strong>plaintext</strong>. Infatti pu√≤ <strong>scegliere quale plaintext avere</strong> a suo piacimento, si chiama <strong>chosen plaintext</strong>.</p>
<p>Ossia pu√≤ scegliere quanti messaggi vuole per un certo esperimento</p>
<img src="/images/notes/OTP and Stream Ciphers-20240307114233707.webp" alt="OTP and Stream Ciphers-20240307114233707">
<h4 id="nonce-based-security">Nonce based-security<a hidden class="anchor" aria-hidden="true" href="#nonce-based-security">#</a></h4>
<p>L&rsquo;idea √® la stessa di cui abbiamo parlato in <a href="//notes/sicurezza-delle-reti">Sicurezza delle reti</a> per un protocollo di autenticazione.
Un esempio carino di questo √® in <a href="//notes/block-ciphers#cipher-block-chaining-(cbc)">Block Ciphers#Cipher Block Chaining (CBC)</a> per cercare di randomizzare l&rsquo;IV.</p>
<h4 id="randomized-encryption">Randomized encryption<a hidden class="anchor" aria-hidden="true" href="#randomized-encryption">#</a></h4>
<p>Sono delle funzioni che ritornano cyphertext in modo probabilistico (non sempre la stessa)</p>
<h2 id="practical-stream-ciphers">Practical stream ciphers<a hidden class="anchor" aria-hidden="true" href="#practical-stream-ciphers">#</a></h2>
<p>In questo caso andiamo ad utilizzare un PRNGs, non pi√π truly random, per le ragioni di efficienza di comunicazione‚Ä¶</p>
<img src="/images/notes/image/universita/ex-notion/Stream Ciphers/Untitled 7.png" alt="image/universita/ex-notion/Stream Ciphers/Untitled 7">
<p>la chiave sono i valori delle cose affini nel LCG.. (forse anche il seed? boh)</p>
<h3 id="rc4-cipher">RC4 cipher<a hidden class="anchor" aria-hidden="true" href="#rc4-cipher">#</a></h3>
<p>Non so bene come √® stato creato questo algoritmo, probabilmente provato cose a caso???
Questo √® stato inventato da Ron Rivest, lo stesso che ha inventato l&rsquo;algoritmo di RSA del 1987.</p>
<h4 id="inizializzazione">Inizializzazione<a hidden class="anchor" aria-hidden="true" href="#inizializzazione">#</a></h4>
<p>Usiamo il seed $s$ per inizializzare una permutazione dei primi 256 numeri</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">S[i] &lt;- arange(0, 257)
</span></span><span class="line"><span class="cl">s = len S
</span></span><span class="line"><span class="cl">j &lt;- 0
</span></span><span class="line"><span class="cl">for i &lt;- 0 to 255 do:
</span></span><span class="line"><span class="cl">	k &lt;- S[i mod s]
</span></span><span class="line"><span class="cl">	j &lt;- (j + S[i] + k) mod 256
</span></span><span class="line"><span class="cl">	swap(s[i], s[j])
</span></span></code></pre></div><p>Con questo algoritmo in pseudocodice</p>
<h4 id="generazione-non-fatta">Generazione (non fatta)<a hidden class="anchor" aria-hidden="true" href="#generazione-non-fatta">#</a></h4>
<img src="/images/notes/OTP and Stream Ciphers-20240222115340902.webp" alt="OTP and Stream Ciphers-20240222115340902">
#### Attacchi üü®
Non segue la definizione di [Classical Cyphers#Security of the Key](//notes/classical-cyphers#security-of-the-key), c'√® del bias in quanto generato che si pu√≤ sfruttare in modo abbastanza semplice, per esempio si pu√≤ attaccare WEP che usava questo algoritmo in questo modo.
### Content Scrambling System (non fatto)
<h3 id="estream-cypher">eStream Cypher<a hidden class="anchor" aria-hidden="true" href="#estream-cypher">#</a></h3>
<p>Si ha solitamente un <strong>nonce</strong> in questo caso, lo stesso che abbiamo usato in <a href="//notes/sicurezza-delle-reti">Sicurezza delle reti</a>. Quindi un valore randomico utilizzato una singola volta</p>
<h4 id="salsa-20">Salsa 20<a hidden class="anchor" aria-hidden="true" href="#salsa-20">#</a></h4>
<p>√à un algoritmo moderno di stream cipher, solitamente implementato in hardware per velocit√†.
Prende una chiave 256 bit e un nonce di 64.
Utilizza questo per fare un  mix di 20 rounds e poi produrre ili bit stream utilizzato per encodare il plaintext iniziale.
Questo √® ancora sicuro, attacchi esistenti non riescono a romperlo totalmente <a href="https://en.wikipedia.org/wiki/Salsa20#Cryptanalysis_of_Salsa20">pagina wiki</a>
Veloce che fa
Mezzo giga al secondo di cifrazione.</p>
<h2 id="linear-feedback-shift-registers">Linear Feedback Shift Registers<a hidden class="anchor" aria-hidden="true" href="#linear-feedback-shift-registers">#</a></h2>
<p>This is a way to create a stream of bits to xor with the message. This stream is generated with a key.
One of the advantages is that it‚Äôs low power in hardware.</p>
<h3 id="shift-registers">Shift registers<a hidden class="anchor" aria-hidden="true" href="#shift-registers">#</a></h3>
<p>You have to remember flip flops by <a href="//notes/circuiti-sequenziali">Circuiti Sequenziali</a> in architecture.</p>
<ol>
<li>Coso per storare un <strong>singolo bit</strong> sincronizzato dal clock del computer.</li>
</ol>
<p>La cosa interessante quando si collegano input e output fra flipflops diversi, √® che ad ogni ciclo di clock, si ha una specie di onda che shifta tutti i bit!
Quando l‚Äôoutput √® rixorato in certi modi e rimesso all‚Äôinizio, ecco che riusciamo ad avere il feedback lineare!</p>
<ul>
<li>
<p>Esempio di mini Linear feedback Shift register</p>
  <img src="/images/notes/image/universita/ex-notion/Stream Ciphers/Untitled 8.png" alt="image/universita/ex-notion/Stream Ciphers/Untitled 8">
</li>
<li>
<p>Esempio di LFSR generalizzato</p>
  <img src="/images/notes/image/universita/ex-notion/Stream Ciphers/Untitled 9.png" alt="image/universita/ex-notion/Stream Ciphers/Untitled 9">
</li>
</ul>
<h3 id="matematical-description">Matematical Description<a hidden class="anchor" aria-hidden="true" href="#matematical-description">#</a></h3>
<p>Con p, per dire se √® 0 o 1 (o aperto o chiuso). E poi in pratica √® l‚Äôoperazione di +, o xor.</p>
<img src="/images/notes/image/universita/ex-notion/Stream Ciphers/Untitled 10.png" alt="image/universita/ex-notion/Stream Ciphers/Untitled 10">
<p>We want to have a LSFR which has a very <strong>long period</strong></p>
<p>Possiamo anche descrivere un LSFR con dei polinomi. In particolare √® importante sapere</p>
<ol>
<li>il numero dei registri</li>
<li>Le porte che sono aperte e quelle che sono chiuse.</li>
</ol>
<p>Quindi si pu√≤ rappresentare come
$$
P(x) = x^{m} + p_{m - 1}x^{m - 1} + \dots + p_{1}x + p_{0}
$$
<img src="/images/notes/image/universita/ex-notion/Stream Ciphers/Untitled 11.png" alt="image/universita/ex-notion/Stream Ciphers/Untitled 11"></p>
<p>Per√≤ non so ancora perch√© questa rappresentazione del LSFR √® utile, boh, lasciamo star.</p>
<h3 id="theorem-on-the-period-of-lsfr">Theorem on the period of LSFR<a hidden class="anchor" aria-hidden="true" href="#theorem-on-the-period-of-lsfr">#</a></h3>
<img src="/images/notes/image/universita/ex-notion/Stream Ciphers/Untitled 12.png" alt="image/universita/ex-notion/Stream Ciphers/Untitled 12">
<p>L‚Äôidea della dimostrazione √® tipo che gli stati interni della LSFR √® al massimo $2^m - 1$, quindi al massimo il periodo √® quello. (non posso avere 0 perch√© senn√≤ avrei periodo di 1, che non serve a niente).</p>
<p>Ma non tutti hanno periodo massimo! Forse centrano qualcosa i polinomi ciclotomici, per√≤ sta fuori dalla mia capacit√† matematica lol.</p>
<ul>
<li>
<p>Esempi di LSFR massimi e non</p>
  <img src="/images/notes/image/universita/ex-notion/Stream Ciphers/Untitled 13.png" alt="image/universita/ex-notion/Stream Ciphers/Untitled 13">
</li>
</ul>
<h3 id="known-plaintext-attacks">Known Plaintext Attacks<a hidden class="anchor" aria-hidden="true" href="#known-plaintext-attacks">#</a></h3>
<p>Il nemico conosce</p>
<ul>
<li>Tutto il ciphertext</li>
<li>il grado dell‚ÄôLSFR (se non lo sa fa bruteforce, e quindi √® come se lo sapesse)</li>
<li>Conosce i primi 2m bits del plaintext, quindi sa i primi 2m bits generati.</li>
</ul>
<p>Dal plaintext conosciuto, vorremme ricavare tutti i bits successivi di questo stream cipher. (basta ricavare i valori dei p, ora vediamo un metodo per ricavarli).</p>
<p>Dato che possiede 2m bits conosciuti e conosce m, deve risolvere un sistema di m incognite e m equazioni, e questo si fa, quindi cos√¨ riesce a <strong>ricavare LSFR</strong> da queste!</p>
<h1 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h1>
<p>[1] Stinson <a href="https://books.google.it/books/about/Cryptography.html?id=FAPLBQAAQBAJ">‚ÄúCryptography: Theory and Practice, Third Edition‚Äù</a> CRC Press 2005</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="flecart.github.io/tags/%EF%B8%8Fcybersecurity/">üõ°Ô∏èCybersecurity</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share OTP and Stream Ciphers on x"
            href="https://x.com/intent/tweet/?text=OTP%20and%20Stream%20Ciphers&amp;url=flecart.github.io%2fnotes%2fotp-and-stream-ciphers%2f&amp;hashtags=%f0%9f%9b%a1%ef%b8%8fcybersecurity">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share OTP and Stream Ciphers on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=flecart.github.io%2fnotes%2fotp-and-stream-ciphers%2f&amp;title=OTP%20and%20Stream%20Ciphers&amp;summary=OTP%20and%20Stream%20Ciphers&amp;source=flecart.github.io%2fnotes%2fotp-and-stream-ciphers%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share OTP and Stream Ciphers on reddit"
            href="https://reddit.com/submit?url=flecart.github.io%2fnotes%2fotp-and-stream-ciphers%2f&title=OTP%20and%20Stream%20Ciphers">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share OTP and Stream Ciphers on facebook"
            href="https://facebook.com/sharer/sharer.php?u=flecart.github.io%2fnotes%2fotp-and-stream-ciphers%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share OTP and Stream Ciphers on whatsapp"
            href="https://api.whatsapp.com/send?text=OTP%20and%20Stream%20Ciphers%20-%20flecart.github.io%2fnotes%2fotp-and-stream-ciphers%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share OTP and Stream Ciphers on telegram"
            href="https://telegram.me/share/url?text=OTP%20and%20Stream%20Ciphers&amp;url=flecart.github.io%2fnotes%2fotp-and-stream-ciphers%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share OTP and Stream Ciphers on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=OTP%20and%20Stream%20Ciphers&u=flecart.github.io%2fnotes%2fotp-and-stream-ciphers%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
