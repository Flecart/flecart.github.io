<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Reti di flusso | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="üìàoptimization">
<meta name="description" content="Questi problemi sono una sottoclasse della programmazione lineare con variabili reali. (Alcuni riescono a riconoscere se un problema √® in questa forma, e lo risolvono in modo istantaneo se questo succede).
Un problema dei router √® un classico problema di flusso, che si risolvono con questi algoritmi polinomiali
Note introduttive
Rete, terminologia
In questo caso andiamo ad indicare con rete un grafo con $G = (N, A)$ con $N$ nodi e $A$ archi, che solitamente sono diretti con pesi associati.
Possiamo interpretare gli archi come canali in cui fluiranno un qualcosa (ad esempio acqua in un tubo). Questi possono essere discreti o continui (mi sembra di ricordare che il discreto stranamente √® pi√π facile del continuo, non  so se vale anche in questo caso).
Abbiamo poi i nodi che sono punti di ingresso e uscita della nostra rete.">
<meta name="author" content="
By Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="https://flecart.github.io/notes/reti-di-flusso/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f790d9af969c56c079c1ce2d5972a04486bf3d6144295d5fba319830e1e55a7a.css" integrity="sha256-95DZr5acVsB5wc4tWXKgRIa/PWFEKV1fujGYMOHlWno=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/reti-di-flusso/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>
<script type="text/javascript" async
src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>






      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-WW6NN2QGKF');
        }
      </script><meta property="og:url" content="https://flecart.github.io/notes/reti-di-flusso/">
  <meta property="og:site_name" content="X. Angelo Huang&#39;s Blog">
  <meta property="og:title" content="Reti di flusso">
  <meta property="og:description" content="Questi problemi sono una sottoclasse della programmazione lineare con variabili reali. (Alcuni riescono a riconoscere se un problema √® in questa forma, e lo risolvono in modo istantaneo se questo succede).
Un problema dei router √® un classico problema di flusso, che si risolvono con questi algoritmi polinomiali
Note introduttive Rete, terminologia In questo caso andiamo ad indicare con rete un grafo con $G = (N, A)$ con $N$ nodi e $A$ archi, che solitamente sono diretti con pesi associati. Possiamo interpretare gli archi come canali in cui fluiranno un qualcosa (ad esempio acqua in un tubo). Questi possono essere discreti o continui (mi sembra di ricordare che il discreto stranamente √® pi√π facile del continuo, non so se vale anche in questo caso). Abbiamo poi i nodi che sono punti di ingresso e uscita della nostra rete.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="notes">
    <meta property="article:tag" content="üìàOptimization">
      <meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:title" content="Reti di flusso">
<meta name="twitter:description" content="Questi problemi sono una sottoclasse della programmazione lineare con variabili reali. (Alcuni riescono a riconoscere se un problema √® in questa forma, e lo risolvono in modo istantaneo se questo succede).
Un problema dei router √® un classico problema di flusso, che si risolvono con questi algoritmi polinomiali
Note introduttive
Rete, terminologia
In questo caso andiamo ad indicare con rete un grafo con $G = (N, A)$ con $N$ nodi e $A$ archi, che solitamente sono diretti con pesi associati.
Possiamo interpretare gli archi come canali in cui fluiranno un qualcosa (ad esempio acqua in un tubo). Questi possono essere discreti o continui (mi sembra di ricordare che il discreto stranamente √® pi√π facile del continuo, non  so se vale anche in questo caso).
Abbiamo poi i nodi che sono punti di ingresso e uscita della nostra rete.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Reti di flusso",
      "item": "https://flecart.github.io/notes/reti-di-flusso/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Reti di flusso",
  "name": "Reti di flusso",
  "description": "Questi problemi sono una sottoclasse della programmazione lineare con variabili reali. (Alcuni riescono a riconoscere se un problema √® in questa forma, e lo risolvono in modo istantaneo se questo succede).\nUn problema dei router √® un classico problema di flusso, che si risolvono con questi algoritmi polinomiali\nNote introduttive Rete, terminologia In questo caso andiamo ad indicare con rete un grafo con $G = (N, A)$ con $N$ nodi e $A$ archi, che solitamente sono diretti con pesi associati. Possiamo interpretare gli archi come canali in cui fluiranno un qualcosa (ad esempio acqua in un tubo). Questi possono essere discreti o continui (mi sembra di ricordare che il discreto stranamente √® pi√π facile del continuo, non so se vale anche in questo caso). Abbiamo poi i nodi che sono punti di ingresso e uscita della nostra rete.\n",
  "keywords": [
    "üìàoptimization"
  ],
  "articleBody": "Questi problemi sono una sottoclasse della programmazione lineare con variabili reali. (Alcuni riescono a riconoscere se un problema √® in questa forma, e lo risolvono in modo istantaneo se questo succede).\nUn problema dei router √® un classico problema di flusso, che si risolvono con questi algoritmi polinomiali\nNote introduttive Rete, terminologia In questo caso andiamo ad indicare con rete un grafo con $G = (N, A)$ con $N$ nodi e $A$ archi, che solitamente sono diretti con pesi associati. Possiamo interpretare gli archi come canali in cui fluiranno un qualcosa (ad esempio acqua in un tubo). Questi possono essere discreti o continui (mi sembra di ricordare che il discreto stranamente √® pi√π facile del continuo, non so se vale anche in questo caso). Abbiamo poi i nodi che sono punti di ingresso e uscita della nostra rete.\nAbbiamo studiato questo nel corso di algoritmi, nella lezione sui Grafi.\nSbilanciamento Sbilanciamento, mi da informazione riguardo se il nodo vuole ricevere o dare fuori, quindi il fatto che sia negativo positivo pu√≤ essere buona roba.\nNodi di input output e trasferimento Importante sapere cosa sono nodo di input, output e trasferimento e quando un nodo si pu√≤ chiare in questo modo.\nCapacit√† inferiore e superiore Oltre a ci√≤ possiamo definire capacit√† inferiore e superiore degli archi, e definire un concetto di ammissibilit√† di un trasferimento di un arco quando la quantit√† che ci passa rispetta queste condizioni.\nVincoli di un problema di flusso (3) Domanda e offerta globale Conservazione del flusso sol nodo locale Ammissibilit√† del flusso Slide\nIl perch√© si utilizzano grafi √® perch√© sono espressivi per questo genere di problemi, ossia sono molto utili per modellizzare questo. E hanno una complessit√† gestibile perch√© sono stati molto studiati ed esistono algoritmi efficienti per questa(credo)\nNormalizzazione della capacit√† inferiore (3) Si tratta in questa parte di trasformare il problema in un altro problema con le capacit√† inferiori nulle, basta considerare questa cosa nel calcolo della funzione obiettivo e rimodulare i valori degli archi (per capacit√† superiore).\nLe 3 cose per normalizzare\nTogliere l a capacit√† superiore Aggiungere l a b (cos√¨ flusso si conserva Considerare il costo di questo flusso Cio√® semplifico mettendo quanto deve passare per la capacit√† inferiore come flusso proveniente dall‚Äôesterno!\nSlide\nModelizzazione del flusso di costo minimo (!!!) (3) Come si pu√≤ notare la condizione √® molto facile da scrivere.\nMinimizzare il costo $cx$, con x il vettore dei flussi, c il vettore dei costi Condizione di massimo flusso $\\forall i, 0\\leq x_i \\leq u_i$, con u il vettore dei massimi E tutte le condizioni di bilanciamento $Ex = b$ con E la matrice (probabilmente sparsa) che mi calcola l‚Äôincidenza (0, 1, -1 per dire esiste, entrata o uscita), che devono essere uguali a b. Condizione dei pozzi\nSpesso √® molto buono idealizzare con un solo pozzo di entrata e un solo pozzo di uscita. Al fine di avere questo risultato si creano due pozzi aggiuntivi , uno che prende tutte le entrate e una che prende tutte le uscite\nSlide costruzione dei pozzi e sorgenti\n**Condizione limiti di nodo\nPer modellizzare cose come i router, che sono s√¨ dei nodi, ma hanno dei limiti per trasmettere e ricevere creiamo un nodo fittizio che sia in grado di rappresentare questo genere di occazioni\nslide\nProblema del flusso massimo Caratteristiche flusso max (3) Slide definizione del problema\nDa notare che questo problema pu√≤ essere visto come caso particolare di MCF in cui\nCosti sono nulli Sbilanciamenti sono nulli Presenza di arco fittizio con capacit√† infinita da target a source Tagli Definizione Slide\nIn pratica √® una partizione dei nodi di una rete.\nUn s-t taglio√® un taglio in cui s e t stanno in partizioni differenti (dato che sono due le partizioni direi che stanno nelle due partizioni corrispondenti).\nAndiamo ora a caratterizzare gli archi.\nA+ attraversa da s a t\nA- attraversa da t a s.\nEsempio di Taglio\nI rossi sono A+, i verdi sono A-\nEsempio del prof pi√π contorto\nPropriet√† !! (2) Enunciato:\n$$ \\forall (s-t)\\text{-taglio} \\, (N_{s}, N_{t}) \\text{ e ogni flusso ammissibile } x \\text{ con valore } v: $$$$ \\begin{cases} v = \\sum_{(i, j) \\in A^{+}(N_{s}, N_{t})} x_{ij} - \\sum_{(i, j) \\in A^{-} (N_{s}, N_{t})} x_{ij} \\\\ v \\leq \\sum_{(i, j) \\in A^{+}(N_{s}, N_{t})} u_{ij} \\end{cases} $$Ossia il flusso √® uguale a ci√≤ che attraversa il taglio, e tutto questo √® sempre minore alla capacit√† del taglio!\nDimostrazione\nPer 1 in pratica prende la differenza iniziale e riscrive i nodi di trasferimento (quindi input - output = 0) in altro modo per averlo nella forma che ci piace). Gli archi interni si cancellano fra di loro, gli archi esterni in Nt non vengono proprio contati, quindi possiamo andare a considerare solamente gli archi della frontiera quindi andiamo a finire in questo modo.\nDimo Slides\nFlusso e capacit√† del taglio Le propriet√† dei tagli spiegati in precedenza sono dei punti fondamentali per l‚Äôanalisi di questo problema di flusso!.\nIl valore di un flusso ammissibile √® sempre minore o uguale della capacit√† di qualunque taglio.\nAndremo a cercare un caso in cui il flusso = capacit√†. In quanto trovato questo taglio, questo √® un flusso massimo! Per il lemma precedente non pu√≤ crescere ancora.\nFord Fulkerson Andremo in questa parte ad introdurre alcuni concetti molto utili che ci porteranno alla definizione dell‚Äôalgoritmo di Ford Fulkelson.\nGrafi residui Utile per dirmi se possono ancora migliorare o meno in un arco.\nQuindi ci d√† un concetto di flusso rimanente per un arco (termine mio questo) utilizzato per decidere se possiamo utilizzarlo o meno per migliorare qualcosa.\nSlide\nCammini aumentanti Chiachiamo in questo modo i cammini nel grafo dei residui. Lo chiamiamo in questo modo perch√© ci permette di avere pi√π flusso da s a t. In particolare lo utilizzo in questo modo\nSe √® un arco discorde diminuisco il valore del flusso. Se √® un arco concorde aumento il flusso. Il valore di aumento o diminuzione √® il minimo del residuo fra tutti gli archi, questa cosa la chiamiamo capacit√† del cammino aumentante.\nL‚Äôalgoritmo L‚Äôalgoritmo si traduce nel\nSetta flusso iniziale a 0 Prendi un cammino aumentante a caso, se esiste aggiungi al flusso il valore di cui √® aumentato, altrimenti ritorna il flusso. Continua finch√© non esci. Slide\nCorrettezza Per dimostrare la correttezza √® spesso molto bello trovare l‚Äôinvariante, in questo caso √® il seguente lemma\nSe x √® un flusso ammissibile, allora √® ammissibile anche il flusso modificato con una iterazione dell‚Äôalgoritmo. Se ho il flusso massimo, allora non posso trovare cammini aumentanti o flussi altri.\nSlide lemmi su flusso massimo e ammissibilit√†, con cammini aumentanti\nLemma fondamentale per correttezza, esistenza di taglio v\nNOTA: raggiungibili con un cammino aumentante!\nIntera dimostrazione insieme\nComplessit√† Possiamo dire che ha fine solo se ha capacit√† intere, altrimenti potrebbe essere che non termini mai. Il prof dice che questo algo d√† troppa libert√† per cui la complessit√† non √® sotto controllo.\nTeorema e dimostrazione complessit√† casi interi\nMa questa √® una complessit√† pseudo-polinomiale nel senso che √® polinomiale solo se non si utilizza la compressione logaritmica nella rappresentazione degli interi (quindi polinomiale nel tempo, ma non nella rappresentazione in memoria).\nMa comunque il termine U ci √® abbastanza brutto.\nMax Flow Min Cut (!) Se riusciamo a dimostrare che il massimo flusso √® ‚â• di un taglio allora mettendo insieme al lemma sul upper bound del massimo flusso ho finito.\nUtilizziamo il risultato nella dimostrazione di FF, assumendo che abbiamo un flusso massimo, quindi non ci sono cammini aumentanti, allora abbiamo un taglio di capacit√† v, per cui ho finito.\nEnunciato e dimo\nEdmonds Karp Introduzione Questo algoritmo non √® altro che una implementazione di Ford_fulkerson. Quindi sappiamo gi√† che sia corretta. Utilizza una bfs per trovare il cammino aumentante migliore.\nUtilizzando la bfs, quindi scegliemo sempre il percorso pi√π corto questa √® una delle propriet√† di maggior rilievo per EK.\nLemma distanze di EK (non chiede dim) Questo √® un lemma che caratterizza fortemente EK, perch√© √® una conseguenza della sua ricerca in BFS che trova gli archi critici pi√π corti prima di quelli pi√π lunghi.\n√à anche fondamentale per fare il calcolo della complessit√† dell‚Äôalgoritmo!\nEnunciato\nDimostrazione (non fatta in classe) preso dal cormen\nComplessit√† (!!) Il lemma di sopra ci permette di togliere il termine sulla capacit√† degli archi. Il motivo √® che per il lemma precedente ogni arco pu√≤ essere considerato al pi√π |N| volte, con N il numero dei nodi. Quindi Applico BFS, per ogni arco, al pi√π N volte, costo $O(NM^2)$\nHint dimostrazione\nAndiamo a considerare gli archi che vengono saturati durante il percorso di un cammino aumentante (questo esiste sempre perch√© il cammino aumentante √® costruito sul minimo del percorso.\nVogliamo dire che ogni arco pu√≤ essere al massimo considerato critico N volte, per cui al massimo ho NA.\nDopo aver fatto questa osservazione, bisogna andare a fare un ragionamento sulla distanza, che continua a crescere per ogni iterazione, e lo pu√≤ fare per al massimo il numero di nodi, prima di diventare staccato.\nDimostrazione\nGoldberg-Tarjan Slide algoritmo\n!\n",
  "wordCount" : "1510",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/reti-di-flusso/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;¬ª&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Reti di flusso
    </h1>
    <div class="post-meta">Reading Time: 8 minutes&nbsp;¬∑&nbsp;
By Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#note-introduttive" aria-label="Note introduttive">Note introduttive</a><ul>
                        
                <li>
                    <a href="#rete-terminologia" aria-label="Rete, terminologia">Rete, terminologia</a><ul>
                        
                <li>
                    <a href="#sbilanciamento" aria-label="Sbilanciamento">Sbilanciamento</a></li>
                <li>
                    <a href="#nodi-di-input-output-e-trasferimento" aria-label="Nodi di input output e trasferimento">Nodi di input output e trasferimento</a></li>
                <li>
                    <a href="#capacit%c3%a0-inferiore-e-superiore" aria-label="Capacit√† inferiore e superiore">Capacit√† inferiore e superiore</a></li></ul>
                </li>
                <li>
                    <a href="#vincoli-di-un-problema-di-flusso-3" aria-label="Vincoli di un problema di flusso (3)">Vincoli di un problema di flusso (3)</a></li>
                <li>
                    <a href="#normalizzazione-della-capacit%c3%a0-inferiore-3" aria-label="Normalizzazione della capacit√† inferiore (3)">Normalizzazione della capacit√† inferiore (3)</a></li>
                <li>
                    <a href="#modelizzazione-del-flusso-di-costo-minimo--3" aria-label="Modelizzazione del flusso di costo minimo (!!!) (3)">Modelizzazione del flusso di costo minimo (!!!) (3)</a></li></ul>
                </li>
                <li>
                    <a href="#problema-del-flusso-massimo" aria-label="Problema del flusso massimo">Problema del flusso massimo</a><ul>
                        
                <li>
                    <a href="#caratteristiche-flusso-max-3" aria-label="Caratteristiche flusso max (3)">Caratteristiche flusso max (3)</a></li></ul>
                </li>
                <li>
                    <a href="#tagli" aria-label="Tagli">Tagli</a><ul>
                        
                <li>
                    <a href="#definizione" aria-label="Definizione">Definizione</a></li>
                <li>
                    <a href="#propriet%c3%a0--2" aria-label="Propriet√† !! (2)">Propriet√† !! (2)</a></li>
                <li>
                    <a href="#flusso-e-capacit%c3%a0-del-taglio" aria-label="Flusso e capacit√† del taglio">Flusso e capacit√† del taglio</a></li></ul>
                </li>
                <li>
                    <a href="#ford-fulkerson" aria-label="Ford Fulkerson">Ford Fulkerson</a><ul>
                        
                <li>
                    <a href="#grafi-residui" aria-label="Grafi residui">Grafi residui</a></li>
                <li>
                    <a href="#cammini-aumentanti" aria-label="Cammini aumentanti">Cammini aumentanti</a></li>
                <li>
                    <a href="#lalgoritmo" aria-label="L‚Äôalgoritmo">L‚Äôalgoritmo</a></li>
                <li>
                    <a href="#correttezza" aria-label="Correttezza">Correttezza</a></li>
                <li>
                    <a href="#complessit%c3%a0" aria-label="Complessit√†">Complessit√†</a></li>
                <li>
                    <a href="#max-flow-min-cut-" aria-label="Max Flow Min Cut (!)">Max Flow Min Cut (!)</a></li></ul>
                </li>
                <li>
                    <a href="#edmonds-karp" aria-label="Edmonds Karp">Edmonds Karp</a><ul>
                        
                <li>
                    <a href="#introduzione" aria-label="Introduzione">Introduzione</a></li>
                <li>
                    <a href="#lemma-distanze-di-ek-non-chiede-dim" aria-label="Lemma distanze di EK (non chiede dim)">Lemma distanze di EK (non chiede dim)</a></li>
                <li>
                    <a href="#complessit%c3%a0-" aria-label="Complessit√† (!!)">Complessit√† (!!)</a></li></ul>
                </li>
                <li>
                    <a href="#goldberg-tarjan" aria-label="Goldberg-Tarjan">Goldberg-Tarjan</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Questi problemi sono una <strong>sottoclasse della programmazione lineare</strong> con variabili reali. (Alcuni riescono a riconoscere se un problema √® in questa forma, e lo risolvono in modo istantaneo se questo succede).</p>
<p>Un problema dei router √® un classico problema di flusso, che si risolvono con questi algoritmi polinomiali</p>
<h2 id="note-introduttive">Note introduttive<a hidden class="anchor" aria-hidden="true" href="#note-introduttive">#</a></h2>
<h3 id="rete-terminologia">Rete, terminologia<a hidden class="anchor" aria-hidden="true" href="#rete-terminologia">#</a></h3>
<p>In questo caso andiamo ad indicare con rete un grafo con $G = (N, A)$ con $N$ nodi e $A$ archi, che solitamente sono diretti con pesi associati.
Possiamo interpretare gli archi come <strong>canali</strong> in cui fluiranno un qualcosa (ad esempio acqua in un tubo). Questi possono essere discreti o continui (mi sembra di ricordare che il discreto stranamente √® pi√π facile del continuo, non  so se vale anche in questo caso).
Abbiamo poi i <em>nodi</em> che sono <strong>punti di ingresso e uscita</strong> della nostra rete.</p>
<p>Abbiamo studiato questo nel corso di algoritmi, nella lezione sui <a href="/notes/grafi">Grafi</a>.</p>
<h4 id="sbilanciamento">Sbilanciamento<a hidden class="anchor" aria-hidden="true" href="#sbilanciamento">#</a></h4>
<p><strong>Sbilanciamento</strong>, mi da informazione riguardo se il nodo vuole ricevere o dare fuori, quindi il fatto che sia negativo   positivo pu√≤ essere buona roba.</p>
<img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 1.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 1">
<h4 id="nodi-di-input-output-e-trasferimento">Nodi di input output e trasferimento<a hidden class="anchor" aria-hidden="true" href="#nodi-di-input-output-e-trasferimento">#</a></h4>
<p>Importante sapere cosa sono <strong>nodo di input, output e trasferimento</strong> e quando un nodo si pu√≤ chiare in questo modo.</p>
<h4 id="capacit√†-inferiore-e-superiore">Capacit√† inferiore e superiore<a hidden class="anchor" aria-hidden="true" href="#capacit√†-inferiore-e-superiore">#</a></h4>
<p>Oltre a ci√≤ possiamo definire <strong>capacit√† inferiore e superiore</strong> degli archi, e definire un concetto di <strong>ammissibilit√†</strong> di un trasferimento di un arco quando la quantit√† che ci passa rispetta queste condizioni.</p>
<h3 id="vincoli-di-un-problema-di-flusso-3">Vincoli di un problema di flusso (3)<a hidden class="anchor" aria-hidden="true" href="#vincoli-di-un-problema-di-flusso-3">#</a></h3>
<ol>
<li><strong>Domanda e offerta globale</strong></li>
<li><strong>Conservazione del flusso</strong> sol nodo locale</li>
<li><strong>Ammissibilit√† del flusso</strong></li>
</ol>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 2.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 2">
</li>
</ul>
<p>Il perch√© si utilizzano grafi √® perch√© sono <strong>espressivi</strong> per questo genere di problemi, ossia sono molto utili per modellizzare questo. E hanno una complessit√† gestibile perch√© sono stati molto studiati ed <strong>esistono algoritmi efficienti per questa</strong>(credo)</p>
<h3 id="normalizzazione-della-capacit√†-inferiore-3">Normalizzazione della capacit√† inferiore (3)<a hidden class="anchor" aria-hidden="true" href="#normalizzazione-della-capacit√†-inferiore-3">#</a></h3>
<p>Si tratta in questa parte di trasformare il problema in un altro problema con le capacit√† inferiori nulle, basta considerare questa cosa nel calcolo della funzione obiettivo e rimodulare i valori degli archi (per capacit√† superiore).</p>
<p>Le 3 cose per normalizzare</p>
<ol>
<li>Togliere l a capacit√† superiore</li>
<li>Aggiungere l a b (cos√¨ flusso si conserva</li>
<li>Considerare il costo di questo flusso</li>
</ol>
<p>Cio√® semplifico mettendo quanto deve passare per la capacit√† inferiore come flusso proveniente dall&rsquo;esterno!</p>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 3.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 3">
</li>
</ul>
<h3 id="modelizzazione-del-flusso-di-costo-minimo--3">Modelizzazione del flusso di costo minimo (!!!) (3)<a hidden class="anchor" aria-hidden="true" href="#modelizzazione-del-flusso-di-costo-minimo--3">#</a></h3>
<img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 4.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 4">
<p>Come si pu√≤ notare la condizione √® molto facile da scrivere.</p>
<ol>
<li>Minimizzare il costo $cx$, con x il vettore dei flussi, c il vettore dei costi</li>
<li>Condizione di massimo flusso $\forall i, 0\leq x_i \leq u_i$, con u il vettore dei massimi</li>
<li>E tutte le condizioni di bilanciamento $Ex = b$ con E la matrice (probabilmente sparsa) che mi calcola l‚Äôincidenza (0, 1, -1 per dire esiste, entrata o uscita), che devono essere uguali a b.</li>
</ol>
<p><strong>Condizione dei pozzi</strong></p>
<p>Spesso √® molto buono idealizzare con un solo pozzo di entrata e un solo pozzo di uscita. Al fine di avere questo risultato si creano due pozzi aggiuntivi , uno che prende tutte le entrate e una che prende tutte le uscite</p>
<ul>
<li>
<p>Slide costruzione dei pozzi e sorgenti</p>
  <img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 5.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 5">
</li>
</ul>
<p>**Condizione limiti di nodo</p>
<p>Per modellizzare cose come i router, che sono s√¨ dei nodi, ma hanno dei limiti per trasmettere e ricevere creiamo un nodo fittizio che sia in grado di rappresentare questo genere di occazioni</p>
<ul>
<li>
<p>slide</p>
  <img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 6.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 6">
</li>
</ul>
<h2 id="problema-del-flusso-massimo">Problema del flusso massimo<a hidden class="anchor" aria-hidden="true" href="#problema-del-flusso-massimo">#</a></h2>
<h3 id="caratteristiche-flusso-max-3">Caratteristiche flusso max (3)<a hidden class="anchor" aria-hidden="true" href="#caratteristiche-flusso-max-3">#</a></h3>
<ul>
<li>
<p>Slide definizione del problema</p>
  <img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 7.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 7">
  <img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 8.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 8">
  <img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 9.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 9">
</li>
</ul>
<p>Da notare che questo problema pu√≤ essere visto come <strong>caso particolare di MCF</strong> in cui</p>
<ol>
<li>Costi sono nulli</li>
<li>Sbilanciamenti sono nulli</li>
<li>Presenza di arco fittizio con capacit√† infinita da target a source</li>
</ol>
<h2 id="tagli">Tagli<a hidden class="anchor" aria-hidden="true" href="#tagli">#</a></h2>
<h3 id="definizione">Definizione<a hidden class="anchor" aria-hidden="true" href="#definizione">#</a></h3>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 10.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 10">
</li>
</ul>
<p>In pratica √® una <strong>partizione</strong> dei nodi di una rete.</p>
<p>Un <strong>s-t taglio</strong>√® un taglio in cui s e t stanno in partizioni differenti (dato che sono due le partizioni direi che stanno nelle due partizioni corrispondenti).</p>
<p>Andiamo ora a <strong>caratterizzare gli archi</strong>.</p>
<p><strong>A+</strong> attraversa da s a t</p>
<p><strong>A-</strong> attraversa da t a s.</p>
<ul>
<li>
<p>Esempio di Taglio</p>
  <img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 11.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 11">
<p>I rossi sono A+, i verdi sono A-</p>
</li>
<li>
<p>Esempio del prof pi√π contorto</p>
  <img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 12.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 12">
</li>
</ul>
<h3 id="propriet√†--2">Propriet√† !! (2)<a hidden class="anchor" aria-hidden="true" href="#propriet√†--2">#</a></h3>
<p>Enunciato:</p>
$$
\forall (s-t)\text{-taglio} \, (N_{s}, N_{t}) \text{ e ogni flusso ammissibile } x \text{ con valore } v:
$$$$
\begin{cases}
v = \sum_{(i, j) \in A^{+}(N_{s}, N_{t})} x_{ij} - \sum_{(i, j) \in A^{-} (N_{s}, N_{t})} x_{ij} \\
v \leq \sum_{(i, j) \in A^{+}(N_{s}, N_{t})} u_{ij}
\end{cases}
$$<p>Ossia il <strong>flusso √® uguale a ci√≤ che attraversa il taglio</strong>, e tutto questo √® sempre minore alla capacit√† del taglio!</p>
<ul>
<li>
<p>Dimostrazione</p>
<p>Per 1 in pratica prende la differenza iniziale e riscrive i nodi di trasferimento (quindi input - output = 0) in altro modo per averlo nella forma che ci piace).
Gli archi interni si cancellano fra di loro, gli archi esterni in Nt non vengono proprio contati, quindi possiamo andare a considerare solamente gli archi della frontiera quindi andiamo a finire in questo modo.</p>
  <img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 14.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 14">
</li>
<li>
<p>Dimo Slides</p>
  <img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 15.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 15">
</li>
</ul>
<h3 id="flusso-e-capacit√†-del-taglio">Flusso e capacit√† del taglio<a hidden class="anchor" aria-hidden="true" href="#flusso-e-capacit√†-del-taglio">#</a></h3>
<p>Le propriet√† dei tagli spiegati in precedenza sono dei punti fondamentali per l‚Äôanalisi di questo problema di flusso!.</p>
<blockquote>
<p><strong>Il valore di un flusso ammissibile √® sempre minore o uguale della capacit√† di qualunque taglio</strong>.</p></blockquote>
<p>Andremo a cercare un caso in cui <strong>il flusso = capacit√†</strong>. In quanto trovato questo taglio, questo √® un flusso massimo! Per il lemma precedente non pu√≤ crescere ancora.</p>
<h2 id="ford-fulkerson">Ford Fulkerson<a hidden class="anchor" aria-hidden="true" href="#ford-fulkerson">#</a></h2>
<p>Andremo in questa parte ad introdurre alcuni concetti molto utili che ci porteranno alla definizione dell‚Äôalgoritmo di Ford Fulkelson.</p>
<h3 id="grafi-residui">Grafi residui<a hidden class="anchor" aria-hidden="true" href="#grafi-residui">#</a></h3>
<p>Utile per dirmi se possono ancora migliorare o meno in un arco.</p>
<p>Quindi ci d√† un concetto di <strong>flusso rimanente</strong> per un arco (termine mio questo) utilizzato per decidere se possiamo utilizzarlo o meno per migliorare qualcosa.</p>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 16.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 16">
</li>
</ul>
<h3 id="cammini-aumentanti">Cammini aumentanti<a hidden class="anchor" aria-hidden="true" href="#cammini-aumentanti">#</a></h3>
<p>Chiachiamo in questo modo i cammini nel grafo dei residui. Lo chiamiamo in questo modo perch√© ci permette di avere pi√π flusso da s a t. In particolare lo utilizzo in questo modo</p>
<ol>
<li>Se √® un arco discorde diminuisco il valore del flusso.</li>
<li>Se √® un arco concorde aumento il flusso.</li>
</ol>
<p>Il valore di aumento o diminuzione √® il minimo del residuo fra tutti gli archi, questa cosa la chiamiamo <strong>capacit√†</strong> del cammino aumentante.</p>
<img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 17.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 17">
<h3 id="lalgoritmo">L‚Äôalgoritmo<a hidden class="anchor" aria-hidden="true" href="#lalgoritmo">#</a></h3>
<p>L‚Äôalgoritmo si traduce nel</p>
<ol>
<li>Setta flusso iniziale a 0</li>
<li>Prendi un cammino aumentante a caso, se esiste aggiungi al flusso il valore di cui √® aumentato, altrimenti ritorna il flusso.</li>
<li>Continua finch√© non esci.</li>
</ol>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 18.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 18">
</li>
</ul>
<h3 id="correttezza">Correttezza<a hidden class="anchor" aria-hidden="true" href="#correttezza">#</a></h3>
<p>Per dimostrare la correttezza √® spesso molto bello trovare l‚Äôinvariante, in questo caso √® il seguente lemma</p>
<blockquote>
<p>Se x √® un flusso ammissibile, allora √® ammissibile anche il flusso modificato con una iterazione dell‚Äôalgoritmo.
Se ho il flusso massimo, allora non posso trovare cammini aumentanti o flussi altri.</p></blockquote>
<ul>
<li>
<p>Slide lemmi su flusso massimo e ammissibilit√†, con cammini aumentanti</p>
  <img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 19.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 19">
</li>
<li>
<p>Lemma fondamentale per correttezza, esistenza di taglio v</p>
<p>NOTA: raggiungibili con un <strong>cammino aumentante!</strong></p>
  <img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 20.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 20">
</li>
<li>
<p>Intera dimostrazione insieme</p>
  <img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 21.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 21">
</li>
</ul>
<h3 id="complessit√†">Complessit√†<a hidden class="anchor" aria-hidden="true" href="#complessit√†">#</a></h3>
<p>Possiamo dire che ha fine solo se ha <strong>capacit√† intere</strong>, altrimenti potrebbe essere che non termini mai. Il prof dice che questo algo d√† troppa libert√† per cui la complessit√† non √® sotto controllo.</p>
<ul>
<li>
<p>Teorema e dimostrazione complessit√† casi interi</p>
  <img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 22.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 22">
</li>
</ul>
<p>Ma questa √® una complessit√† <strong>pseudo-polinomiale</strong> nel senso che √® polinomiale solo se non si utilizza la compressione logaritmica nella rappresentazione degli interi (quindi polinomiale nel tempo, ma non nella rappresentazione in memoria).</p>
<p>Ma comunque il termine U ci √® abbastanza brutto.</p>
<h3 id="max-flow-min-cut-">Max Flow Min Cut (!)<a hidden class="anchor" aria-hidden="true" href="#max-flow-min-cut-">#</a></h3>
<p>Se riusciamo a dimostrare che il massimo flusso √® ‚â• di un taglio allora mettendo insieme al lemma sul upper bound del massimo flusso ho finito.</p>
<p>Utilizziamo il risultato nella dimostrazione di FF, assumendo che abbiamo un flusso massimo, quindi non ci sono cammini aumentanti, allora abbiamo un taglio di capacit√† v, per cui ho finito.</p>
<ul>
<li>
<p>Enunciato e dimo</p>
  <img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 23.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 23">
</li>
</ul>
<h2 id="edmonds-karp">Edmonds Karp<a hidden class="anchor" aria-hidden="true" href="#edmonds-karp">#</a></h2>
<h3 id="introduzione">Introduzione<a hidden class="anchor" aria-hidden="true" href="#introduzione">#</a></h3>
<p>Questo algoritmo non √® altro che una implementazione di Ford_fulkerson. Quindi <strong>sappiamo gi√† che sia corretta</strong>. Utilizza una bfs per trovare il cammino aumentante migliore.</p>
<p>Utilizzando la bfs, quindi scegliemo sempre il percorso pi√π corto questa √® una delle propriet√† di maggior rilievo per EK.</p>
<h3 id="lemma-distanze-di-ek-non-chiede-dim">Lemma distanze di EK (non chiede dim)<a hidden class="anchor" aria-hidden="true" href="#lemma-distanze-di-ek-non-chiede-dim">#</a></h3>
<p>Questo √® un lemma che caratterizza fortemente EK, perch√© √® una conseguenza della sua ricerca in BFS che trova gli archi critici pi√π corti prima di quelli pi√π lunghi.</p>
<p>√à anche fondamentale per fare il calcolo della complessit√† dell&rsquo;algoritmo!</p>
<ul>
<li>
<p>Enunciato</p>
  <img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 24.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 24">
</li>
<li>
<p>Dimostrazione (non fatta in classe) preso dal cormen</p>
  <img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 25.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 25">
  <img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 26.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 26">
</li>
</ul>
<h3 id="complessit√†-">Complessit√† (!!)<a hidden class="anchor" aria-hidden="true" href="#complessit√†-">#</a></h3>
<p>Il lemma di sopra ci permette di togliere il termine sulla capacit√† degli archi.
<img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 27.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 27"></p>
<p>Il motivo √® che per il lemma precedente ogni arco pu√≤ essere considerato al pi√π |N| volte, con N il numero dei nodi. Quindi Applico BFS, per ogni arco, al pi√π N volte, costo $O(NM^2)$</p>
<ul>
<li>
<p>Hint dimostrazione</p>
<p>Andiamo a considerare gli archi che vengono saturati durante il percorso di un cammino aumentante (questo esiste sempre perch√© il cammino aumentante √® costruito sul minimo del percorso.</p>
<p>Vogliamo dire che ogni arco pu√≤ essere al massimo considerato critico N volte, per cui al massimo ho NA.</p>
<p>Dopo aver fatto questa osservazione, bisogna andare a fare un ragionamento sulla distanza, che continua a crescere per ogni iterazione, e lo pu√≤ fare per al massimo il numero di nodi, prima di diventare staccato.</p>
</li>
<li>
<p>Dimostrazione</p>
  <img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 28.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 28">
  <img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 29.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 29">
</li>
</ul>
<h2 id="goldberg-tarjan">Goldberg-Tarjan<a hidden class="anchor" aria-hidden="true" href="#goldberg-tarjan">#</a></h2>
<ul>
<li>
<p>Slide algoritmo</p>
<p>!<img src="/images/notes/image/universita/ex-notion/Reti di flusso/Untitled 30.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Reti di flusso/Untitled 30"></p>
</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/optimization/">üìàOptimization</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Reti di flusso on x"
            href="https://x.com/intent/tweet/?text=Reti%20di%20flusso&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2freti-di-flusso%2f&amp;hashtags=%f0%9f%93%88optimization">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Reti di flusso on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2freti-di-flusso%2f&amp;title=Reti%20di%20flusso&amp;summary=Reti%20di%20flusso&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2freti-di-flusso%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Reti di flusso on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2freti-di-flusso%2f&title=Reti%20di%20flusso">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Reti di flusso on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2freti-di-flusso%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Reti di flusso on whatsapp"
            href="https://api.whatsapp.com/send?text=Reti%20di%20flusso%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2freti-di-flusso%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Reti di flusso on telegram"
            href="https://telegram.me/share/url?text=Reti%20di%20flusso&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2freti-di-flusso%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Reti di flusso on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Reti%20di%20flusso&u=https%3a%2f%2fflecart.github.io%2fnotes%2freti-di-flusso%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span> ¬∑ 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
