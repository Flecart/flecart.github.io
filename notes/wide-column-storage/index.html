<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Wide Column Storage | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="ðŸ““big-data">
<meta name="description" content="Introduction to Wide Column Storages One of the bottlenecks of traditional relational databases is the speed of the Joints, which could be done in $\mathcal{O}(n)$ using a merge join, assuming some indexes are present which make the keys already sorted. The other solution, of just using Distributed file systems, is also not optimal: they have usually a high latency, with high throughput, that is not optimal with the series of small files that it is optimized for.">
<meta name="author" content="Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="https://flecart.github.io/notes/wide-column-storage/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/wide-column-storage/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>




<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>
<script type="text/javascript" async
src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>





<script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-WW6NN2QGKF', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Wide Column Storage" />
<meta property="og:description" content="Introduction to Wide Column Storages One of the bottlenecks of traditional relational databases is the speed of the Joints, which could be done in $\mathcal{O}(n)$ using a merge join, assuming some indexes are present which make the keys already sorted. The other solution, of just using Distributed file systems, is also not optimal: they have usually a high latency, with high throughput, that is not optimal with the series of small files that it is optimized for." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://flecart.github.io/notes/wide-column-storage/" />
<meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png" />
<meta property="article:section" content="notes" />



<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png" />
<meta name="twitter:title" content="Wide Column Storage"/>
<meta name="twitter:description" content="Introduction to Wide Column Storages One of the bottlenecks of traditional relational databases is the speed of the Joints, which could be done in $\mathcal{O}(n)$ using a merge join, assuming some indexes are present which make the keys already sorted. The other solution, of just using Distributed file systems, is also not optimal: they have usually a high latency, with high throughput, that is not optimal with the series of small files that it is optimized for."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Wide Column Storage",
      "item": "https://flecart.github.io/notes/wide-column-storage/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Wide Column Storage",
  "name": "Wide Column Storage",
  "description": "Introduction to Wide Column Storages One of the bottlenecks of traditional relational databases is the speed of the Joints, which could be done in $\\mathcal{O}(n)$ using a merge join, assuming some indexes are present which make the keys already sorted. The other solution, of just using Distributed file systems, is also not optimal: they have usually a high latency, with high throughput, that is not optimal with the series of small files that it is optimized for.",
  "keywords": [
    "ðŸ““big-data"
  ],
  "articleBody": "Introduction to Wide Column Storages One of the bottlenecks of traditional relational databases is the speed of the Joints, which could be done in $\\mathcal{O}(n)$ using a merge join, assuming some indexes are present which make the keys already sorted. The other solution, of just using Distributed file systems, is also not optimal: they have usually a high latency, with high throughput, that is not optimal with the series of small files that it is optimized for. While Object Storages, do not have APIs that could be helpful -\u003e richer logical model.\nWide Column Storage solve this problem by keeping the entire table already joined -\u003e highly structured data, and providing similar querying abilities compared to relational tables. This brings to highly sparse relational tables.\nThe Usage Wide column stores were invented to provide more control over performance and in particular, in order to achieve high-throughput and low latency for objects ranging from a few bytes to about 10 MB, which are too big and numerous to be efficiently stored as so-called clobs (character large objects) or blobs (binary large objects) in a relational database system, but also too small and numerous to be efficiently accessed in a distributed file system. ~From Chapter 6 of Big Data book\nThe idea here is sharding, trying to spread RDBMS into multiple machines, so that one machine has some tables, others other, one example is the famous cassandra that Discord used to scale their system.\nDesign principles ðŸŸ¨â€“ Two main principles guide the design of wide column stores:\nWide sparse, joint, data tables, because the joins are the expensive operations Batch processing: Store together what is accessed together. These are the current problems, with wide column stores we should solve all of these problems. This project has originated at Google with Big Table (similarly to Big Query). HBase is an opensource equivalent of the Google projects.\nWith traditional relational database management systems, the joins are the expensive part of the operations. Wide Column Stores solve this problem by storing large sparse tables, as in the image: Basic Characteristics We summarize here some of the defining characteristics for Wide Column Storages:\nSupport up to 10MB for files Sparse data model No Schema enforcement (difference compared to RBDMS) No SQL, but something lower level similar to key-value stores. HBase Logical Model Row Ids and Keys ðŸŸ© Row ids are just sequences of bits, but unlike RDBMS they are sortable, and is compound of different things, like row, column or version.\nSpecifically a key is composed of\nColumn Family Row Id Column qualifier (name) Version (timestamp associated to a value). Column Families ðŸŸ© An intution over this new concept is the following: these could be the actual tables that would get stored if the table was normalized. These must be known in advance; it is possible to add a new family but it is an expensive operation. One can also add columns on the fly in the tables, but not column families.\nAlso columns have names (array of bytes, that are repeated a lot in the physical model, so they should be quite short!), not specific types as with RDBMS, those are called column qualifiers. We will see later in the physical level that both families and qualifiers are repeated in every key-value pair, which pushes towards a shorter names.\nOperations ðŸŸ© They have classical GET, POST, PUT, DELETE operations. The difference with RDBMS is that they also support range queries on the ID or timestamp for the versions, called scans, differently from object stores or key value stores.\nLocks Row updates are atomic, no matter how many row columns constitute the row-level transaction. This keeps the locking model simple.\nFrom the Hadoop guide here.\nPhysical Architecture Image From the textbook. Regions and Stores ðŸŸ© A region is just a continuous section of the rows. We define the stores which are intersections between a region and a column family. All the cells of a store are stored together. A single region is usually assigned to a RegionServer (see next section). When a region becomes too large, a RegionServer splits this region into two, and then could be rebalanced by the HMaster. The responsibility does not imply storage! This is a very important thing because the actual data is in HDFS. The responsibility is not replicated, because HDFS automatically replicates the underlying data.\nOn a probability point of view, all the files are going to come back to the RegionServer because RegionServers are usually going to delete and recreate files, and HDFS by default stores the first copy on the same machine it is creating it from. The nice thing is that if the hblock is in the same machine, the process can circumvent HDFS and directly read that HDFS block. This was possible because HDFS and Wide column storage has been developed by the same team. So they have nice compatibilities.\nNetwork architecture ðŸŸ© The network topology is the same as the one we have for Distributed file systems. We have a main node and some slave nodes. In this context they are called HMaster and RegionServers. We also have standby master nodes in this case.\nThe HMaster has a metatable of all the responsibilities of every RegionServer, heartbeat and reports system also here to keep track of this in a old version, before there were also race conditions, see Programmi Concorrenti. Now in order too keep the presence of everybody is something called a zoo-keeper.\nCreating tables, deleting them, creating column families, all the Data Definition operations go through the HMaster. HMasterâ€™s job is to load balance the RegionServerâ€™s load in terms of quantity of data. If regions grow too big, then it can split or reorganize the regions across the servers.\nHFiles and KeyValues ðŸŸ¨ Stores are Memorized as HFiles, organized in HBlocks of fixed size of 64Kb (+ last key key value, so it could be a little larger), usually the key-values are read in the blocks. These blocks are then compacted together (see #Log Structured Trees) until it reaches a maximum size for a region, which is typically 10GB. When the limit is reached, the region is usually divided into two.\nThese files are just list of the cells, stored by coordinate (keys, often in CamelCase) and values (also different versions are stored along side each other)\nA KeyValue in a HFiles is made of 4 parts:\nKey-length Value-length Key Value This is a prefix code, see Algorithmic Probability for something more about prefix codes.\nThe HFile also contains the boundary index of all the blocks that it has. So that it is easy to check for membership inside the blocks\nStructure of Key and Values ðŸŸ¥++ One also has an index, idea similar from b-trees, so the lookup inside a HDFS block is easy.\nThis image from the book cleanly summarizes the structure of the Key: The red part of the key is of variable length. Grey boxes are of fixed length, also column family. The qualifier is variable, but you can recover that by knowing the length of the whole key.\nIn memory key-value store ðŸŸ©- We store the key values in order in memory using some sort of tree. The upside is that we donâ€™t need to cancel and recreate the block in HDFS, because that only allows appending, the written data is not modifiable. When the RAM store is full, then we flush the memory down to an HFile. When we flush we have a linear merge and we store the new file in this way.\nWe have three cases when the flush happens:\nWrite-ahead log is full Memstore size if sull Max memstore for a single store Write-Ahead log ðŸŸ© This is a log to keep the changes done in the RAM, so that we donâ€™t lose things after a crash. Appending is ok in HDFS, so itâ€™s quite compatible with the underlying system. -\u003e Every write is first written in this log file before being put in the RAM. This is similar to the EditLog in HDFS.\nLog Structured Trees These structures attempt to optimize for throughput, the B-Trees are optimized for latency. As every id is sorted by key, itâ€™s easy to merge the HFiles together, we just need to use the Merge function, the same for MergeSort algorithm.\nCompaction ðŸŸ© This is a process that merges many HFiles together when you have too many HFiles because of the flushes. The compaction process is still a linear process because the key values stores are linear. Merging two HFiles usually is makes the system faster for reads because we donâ€™t need to search anymore for all all the mini files that the system creates after the memstore is full. By default HFiles have a maximum size of 10GB (this is the max size after compactions I suppose). If it gets bigger, then the region might be splitted.\nThis is usually triggered when:\nThe number of files is above a certain threshold. Or it might follow a 2048 game rule by merging HFiles with the same size (this is what the Professor has explained). Optimization of HBase Lookup tables ðŸŸ¨â€“ In order to know which RegionServer a client should communicate with to receive KeyValues corresponding to a specific region, there is a main, big lookup table that lists all regions of all tables together with the coor dinates of the RegionServer in charge of this region as well as additional metadata.\nSo, just lookup tables that are known by everybody, and this should make communication a little bit faster.\nCache Usages We should not use cache when we have random access or when we are doing batch processing, because the data the batches are processing are usually separate and independent with each other. You should refer to Memoria and Memoria virtuale to know how usually is cache made.\nKey Ranges Efficiently tells for sure that a Key range is not contained in a file.\nSo they are just some small optimizations, which at the end make HBase quite fast.\nBloom Filters ðŸŸ© It is basically a black box that can tell with absolute certainty that a certain key does not belong to an HFile, while it only predicts with good probability (albeit not certain) that it does belong to it.\nSo that we can skip over files so that we can fasten the lookup time. Without bloom filters we would look for a specific key value in every single HFile, which could be quite slow.\nData locality and Short Circuiting ðŸŸ© We have specified in some paragraphs before that when HBase writes a HFile to a node, the first replica of the file is written on the same node. This allows for short circuiting which allows to directly read from the disk without asking the NameNode for the classical HDFS system.\n",
  "wordCount" : "1804",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/wide-column-storage/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;Â»&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Wide Column Storage
    </h1>
    <div class="post-meta">9 min&nbsp;Â·&nbsp;Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul><ul>
                <li>
                    <a href="#introduction-to-wide-column-storages" aria-label="Introduction to Wide Column Storages">Introduction to Wide Column Storages</a><ul>
                        
                <li>
                    <a href="#the-usage" aria-label="The Usage">The Usage</a></li>
                <li>
                    <a href="#design-principles---" aria-label="Design principles ðŸŸ¨&ndash;">Design principles ðŸŸ¨&ndash;</a></li>
                <li>
                    <a href="#basic-characteristics" aria-label="Basic Characteristics">Basic Characteristics</a></li></ul>
                </li></ul>
                    
                <li>
                    <a href="#hbase" aria-label="HBase">HBase</a><ul>
                        
                <li>
                    <a href="#logical-model" aria-label="Logical Model">Logical Model</a><ul>
                        
                <li>
                    <a href="#row-ids-and-keys-" aria-label="Row Ids and Keys ðŸŸ©">Row Ids and Keys ðŸŸ©</a></li>
                <li>
                    <a href="#column-families-" aria-label="Column Families ðŸŸ©">Column Families ðŸŸ©</a></li>
                <li>
                    <a href="#operations-" aria-label="Operations ðŸŸ©">Operations ðŸŸ©</a></li>
                <li>
                    <a href="#locks" aria-label="Locks">Locks</a></li></ul>
                </li>
                <li>
                    <a href="#physical-architecture" aria-label="Physical Architecture">Physical Architecture</a><ul>
                        
                <li>
                    <a href="#regions-and-stores-" aria-label="Regions and Stores ðŸŸ©">Regions and Stores ðŸŸ©</a></li>
                <li>
                    <a href="#network-architecture-" aria-label="Network architecture ðŸŸ©">Network architecture ðŸŸ©</a></li>
                <li>
                    <a href="#hfiles-and-keyvalues-" aria-label="HFiles and KeyValues ðŸŸ¨">HFiles and KeyValues ðŸŸ¨</a></li>
                <li>
                    <a href="#structure-of-key-and-values-" aria-label="Structure of Key and Values ðŸŸ¥&#43;&#43;">Structure of Key and Values ðŸŸ¥++</a></li>
                <li>
                    <a href="#in-memory-key-value-store--" aria-label="In memory key-value store ðŸŸ©-">In memory key-value store ðŸŸ©-</a></li>
                <li>
                    <a href="#write-ahead-log-" aria-label="Write-Ahead log ðŸŸ©">Write-Ahead log ðŸŸ©</a></li></ul>
                </li>
                <li>
                    <a href="#log-structured-trees" aria-label="Log Structured Trees">Log Structured Trees</a><ul>
                        
                <li>
                    <a href="#compaction-" aria-label="Compaction ðŸŸ©">Compaction ðŸŸ©</a></li></ul>
                </li>
                <li>
                    <a href="#optimization-of-hbase" aria-label="Optimization of HBase">Optimization of HBase</a><ul>
                        
                <li>
                    <a href="#lookup-tables---" aria-label="Lookup tables ðŸŸ¨&ndash;">Lookup tables ðŸŸ¨&ndash;</a></li>
                <li>
                    <a href="#cache-usages" aria-label="Cache Usages">Cache Usages</a></li>
                <li>
                    <a href="#key-ranges" aria-label="Key Ranges">Key Ranges</a></li>
                <li>
                    <a href="#bloom-filters-" aria-label="Bloom Filters ðŸŸ©">Bloom Filters ðŸŸ©</a></li>
                <li>
                    <a href="#data-locality-and-short-circuiting-" aria-label="Data locality and Short Circuiting ðŸŸ©">Data locality and Short Circuiting ðŸŸ©</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="introduction-to-wide-column-storages">Introduction to Wide Column Storages<a hidden class="anchor" aria-hidden="true" href="#introduction-to-wide-column-storages">#</a></h3>
<p>One of the bottlenecks of traditional relational databases is the speed of the Joints, which could be done in $\mathcal{O}(n)$ using a merge join, assuming some indexes are present which make the keys already sorted.
The other solution, of just using <a href="/notes/distributed-file-systems/">Distributed file systems</a>, is also not optimal: they have usually a high latency, with high throughput, that is not optimal with the series of small files that it is optimized for.
While Object Storages, do not have APIs that could be helpful -&gt; <strong>richer logical model</strong>.</p>
<p>Wide Column Storage solve this problem by keeping the entire table already joined -&gt; <strong>highly structured data</strong>, and providing similar querying abilities compared to relational tables. This brings to highly sparse relational tables.</p>
<h4 id="the-usage">The Usage<a hidden class="anchor" aria-hidden="true" href="#the-usage">#</a></h4>
<blockquote>
<p>Wide column stores were invented to provide more control over performance and in particular, in order to achieve high-throughput and low latency for objects ranging from a few bytes to about <strong>10 MB</strong>, which are too big and numerous to be efficiently stored as so-called clobs (character large objects) or blobs (binary large objects) in a relational database system, but also too small and numerous to be efficiently accessed in a distributed file system. ~<em>From Chapter 6 of <a href="https://ghislainfourny.github.io/big-data-textbook/">Big Data book</a></em></p>
</blockquote>
<p>The idea here is <strong>sharding</strong>, trying to spread RDBMS into multiple machines, so that one machine has some tables, others other, one example is the famous <a href="https://cassandra.apache.org/_/index.html">cassandra</a> that Discord used to scale their system.</p>
<h4 id="design-principles---">Design principles ðŸŸ¨&ndash;<a hidden class="anchor" aria-hidden="true" href="#design-principles---">#</a></h4>
<p>Two main principles guide the design of wide column stores:</p>
<ul>
<li>Wide sparse, joint, data tables, because the joins are the expensive operations</li>
<li><strong>Batch processing</strong>: Store together what is accessed together.</li>
</ul>
<p>These are the current problems, with wide column stores we should solve all of these problems.
<img src="/images/notes/Wide Column Storage-20241015094859900.webp" width="612" alt="Wide Column Storage-20241015094859900"></p>
<p>This project has originated at Google with Big Table (similarly to Big Query). HBase is an opensource equivalent of the Google projects.</p>
<p>With traditional relational database management systems, the joins are the expensive part of the operations.
Wide Column Stores solve this problem by storing large <strong>sparse</strong> tables, as in the image:
<img src="/images/notes/Wide Column Storage-20241015180733794.webp" width="585" alt="Wide Column Storage-20241015180733794"></p>
<h4 id="basic-characteristics">Basic Characteristics<a hidden class="anchor" aria-hidden="true" href="#basic-characteristics">#</a></h4>
<p>We summarize here some of the defining characteristics for Wide Column Storages:</p>
<ul>
<li>Support up to 10MB for files</li>
<li>Sparse data model</li>
<li>No Schema enforcement (difference compared to RBDMS)</li>
<li>No SQL, but something lower level similar to key-value stores.</li>
</ul>
<h2 id="hbase">HBase<a hidden class="anchor" aria-hidden="true" href="#hbase">#</a></h2>
<h3 id="logical-model">Logical Model<a hidden class="anchor" aria-hidden="true" href="#logical-model">#</a></h3>
<h4 id="row-ids-and-keys-">Row Ids and Keys ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#row-ids-and-keys-">#</a></h4>
<p>Row ids are just sequences of bits, but unlike RDBMS they are <strong>sortable</strong>, and is compound of different things, like row, column or version.</p>
<p>Specifically a <strong>key</strong> is composed of</p>
<ul>
<li>Column Family</li>
<li>Row Id</li>
<li>Column qualifier (name)</li>
<li>Version (timestamp associated to a value).</li>
</ul>
<h4 id="column-families-">Column Families ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#column-families-">#</a></h4>
<p>An intution over this new concept is the following: these could be the actual tables that would get stored if the table was normalized.
These <strong>must be known in advance</strong>; it is possible to add a new family but it is an expensive operation.
One can also add columns on the fly in the tables, but not column families.</p>
<p>Also columns have <strong>names</strong> (array of bytes, that are repeated a lot in the physical model, so they should be quite short!), not specific types as with RDBMS, those are called <strong>column qualifiers</strong>.
We will see later in the physical level that both families and qualifiers are repeated in every key-value pair, which pushes towards a shorter names.</p>
<h4 id="operations-">Operations ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#operations-">#</a></h4>
<p>They have classical GET, POST, PUT, DELETE operations. The difference with RDBMS is that they also support range queries on the ID or timestamp for the versions, called <strong>scans</strong>, differently from object stores or key value stores.</p>
<h4 id="locks">Locks<a hidden class="anchor" aria-hidden="true" href="#locks">#</a></h4>
<blockquote>
<p>Row updates are atomic, no matter how many row columns constitute the row-level transaction. This keeps the locking model simple.</p>
</blockquote>
<p>From the Hadoop guide <a href="https://piazza-resources.s3.amazonaws.com/ist3pwd6k8p5t/iu5gqbsh8re6mj/OReilly.Hadoop.The.Definitive.Guide.4th.Edition.2015.pdf">here</a>.</p>
<h3 id="physical-architecture">Physical Architecture<a hidden class="anchor" aria-hidden="true" href="#physical-architecture">#</a></h3>
<img src="/images/notes/Wide Column Storage-20250120124713189.webp" alt="Wide Column Storage-20250120124713189">
Image From the textbook.
<h4 id="regions-and-stores-">Regions and Stores ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#regions-and-stores-">#</a></h4>
<p>A region is just a <em>continuous section</em> of the rows.
We define the <strong>stores</strong> which are intersections between a region and a column family. All the cells of a store are <em>stored together</em>.
A single region is usually assigned to a RegionServer (see next section).
When a region becomes too large, a RegionServer splits this region into two, and then could be rebalanced by the HMaster.
The responsibility does not imply storage! This is a very important thing because the actual data is in HDFS.
The responsibility is not replicated, because HDFS automatically replicates the underlying data.</p>
<p>On a probability point of view, all the files are going to come back to the RegionServer because RegionServers are usually going to delete and recreate files, and HDFS by default stores the first copy on the same machine it is creating it from.
The nice thing is that if the hblock is in the same machine, the process can circumvent HDFS and directly read that HDFS block. This was possible because HDFS and Wide column storage has been developed by the same team. So they have nice compatibilities.</p>
<h4 id="network-architecture-">Network architecture ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#network-architecture-">#</a></h4>
<p>The network topology is the same as the one we have for <a href="/notes/distributed-file-systems/">Distributed file systems</a>. We have a main node and some slave nodes. In this context they are called <strong>HMaster</strong> and <strong>RegionServers</strong>. We also have standby master nodes in this case.</p>
<p>The HMaster has a metatable of all the responsibilities of every RegionServer, heartbeat and reports system also here to keep track of this in a old version, before there were also race conditions, see <a href="/notes/programmi-concorrenti/">Programmi Concorrenti</a>.
Now in order too keep the presence of everybody is something called a <strong>zoo-keeper</strong>.</p>
<p>Creating tables, deleting them, creating column families, all the Data Definition operations go through the HMaster.
HMaster&rsquo;s job is to load balance the RegionServer&rsquo;s load in terms of quantity of data. If regions grow too big, then it can split or reorganize the regions across the servers.</p>
<h4 id="hfiles-and-keyvalues-">HFiles and KeyValues ðŸŸ¨<a hidden class="anchor" aria-hidden="true" href="#hfiles-and-keyvalues-">#</a></h4>
<p>Stores are Memorized as <strong>HFiles</strong>, organized in HBlocks of <strong>fixed</strong> size of 64Kb (+ last key key value, so it could be a little larger), usually the key-values are read in the blocks.
These blocks are then compacted together (see <a href="/notes/wide-column-storage/#log-structured-trees">#Log Structured Trees</a>) until it reaches a maximum size for a region, which is typically 10GB. When the limit is reached, the region is usually divided into two.</p>
<p>These files are just list of the cells, stored by coordinate (keys, often in CamelCase) and values (also different versions are stored along side each other)</p>
<p>A KeyValue in a HFiles is made of 4 parts:</p>
<ul>
<li>Key-length</li>
<li>Value-length</li>
<li>Key</li>
<li>Value</li>
</ul>
<p>This is a prefix code, see <a href="/notes/algorithmic-probability/">Algorithmic Probability</a> for something more about prefix codes.</p>
<p>The HFile also contains the boundary index of all the blocks that it has. So that it is easy to check for membership inside the blocks</p>
<h4 id="structure-of-key-and-values-">Structure of Key and Values ðŸŸ¥++<a hidden class="anchor" aria-hidden="true" href="#structure-of-key-and-values-">#</a></h4>
<p>One also has an index, idea similar from <a href="/notes/index-b-trees-and-hashes/">b-trees</a>, so the lookup inside a HDFS block is easy.</p>
<p>This image from the book cleanly summarizes the structure of the Key:
<img src="/images/notes/Wide Column Storage-20241015190027475.webp" alt="Wide Column Storage-20241015190027475"></p>
<p>The red part of the key is of <strong>variable length</strong>. Grey boxes are of fixed length, also column family. The qualifier is variable, but you can recover that by knowing the length of the whole key.</p>
<h4 id="in-memory-key-value-store--">In memory key-value store ðŸŸ©-<a hidden class="anchor" aria-hidden="true" href="#in-memory-key-value-store--">#</a></h4>
<p>We store the key values in order in memory using some sort of tree. The upside is that we don&rsquo;t need to cancel and recreate the block in HDFS, because that only allows appending, the written data is not modifiable.
When the RAM store is full, then we flush the memory down to an HFile.
When we flush we have a linear merge and we store the new file in this way.</p>
<p>We have three cases when the flush happens:</p>
<ul>
<li>Write-ahead log is full</li>
<li>Memstore size if sull</li>
<li>Max memstore for a single store</li>
</ul>
<h4 id="write-ahead-log-">Write-Ahead log ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#write-ahead-log-">#</a></h4>
<p>This is a log to keep the changes done in the RAM, so that we don&rsquo;t lose things after a crash. Appending is ok in HDFS, so it&rsquo;s quite compatible with the underlying system.
-&gt; Every write is first written in this log file before being put in the RAM.
This is similar to the EditLog in HDFS.</p>
<h3 id="log-structured-trees">Log Structured Trees<a hidden class="anchor" aria-hidden="true" href="#log-structured-trees">#</a></h3>
<p>These structures attempt to optimize for throughput, the B-Trees are optimized for latency.
As every id is sorted by key, it&rsquo;s easy to merge the HFiles together, we just need to use the Merge function, the same for <a href="https://en.wikipedia.org/wiki/Merge_sort">MergeSort</a> algorithm.</p>
<h4 id="compaction-">Compaction ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#compaction-">#</a></h4>
<p>This is a process that merges many HFiles together when you have too many HFiles because of the flushes.
The compaction process is still a linear process because the key values stores are linear.
Merging two HFiles usually is makes the system faster for reads because we don&rsquo;t need to search anymore for all all the mini files that the system creates after the memstore is full.
By default HFiles have a maximum size of 10GB (this is the max size after compactions I suppose).
If it gets bigger, then the region might be splitted.</p>
<p>This is usually triggered when:</p>
<ol>
<li>The number of files is above a certain threshold.</li>
<li>Or it might follow a 2048 game rule by merging HFiles with the same size (this is what the Professor has explained).</li>
</ol>
<h3 id="optimization-of-hbase">Optimization of HBase<a hidden class="anchor" aria-hidden="true" href="#optimization-of-hbase">#</a></h3>
<h4 id="lookup-tables---">Lookup tables ðŸŸ¨&ndash;<a hidden class="anchor" aria-hidden="true" href="#lookup-tables---">#</a></h4>
<blockquote>
<p>In order to know which RegionServer a client should communicate with to receive KeyValues corresponding to a specific region, there is a main, big lookup table that lists all regions of all tables together with the coor dinates of the RegionServer in charge of this region as well as additional metadata.</p>
</blockquote>
<p>So, just lookup tables that are <strong>known</strong> by everybody, and this should make communication a little bit faster.</p>
<h4 id="cache-usages">Cache Usages<a hidden class="anchor" aria-hidden="true" href="#cache-usages">#</a></h4>
<p>We should not use cache when we have random access or when we are doing batch processing, because the data the batches are processing are usually separate and independent with each other.
You should refer to <a href="/notes/memoria/">Memoria</a> and <a href="/notes/memoria-virtuale/">Memoria virtuale</a> to know how usually is cache made.</p>
<h4 id="key-ranges">Key Ranges<a hidden class="anchor" aria-hidden="true" href="#key-ranges">#</a></h4>
<blockquote>
<p>Efficiently tells  <strong>for sure</strong>  that a Key range is not contained in a file.</p>
</blockquote>
<p>So they are just some small optimizations, which at the end make HBase quite fast.</p>
<h4 id="bloom-filters-">Bloom Filters ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#bloom-filters-">#</a></h4>
<blockquote>
<p>It is basically a black box that can tell with absolute certainty that a certain key does not belong to an HFile, while it only predicts with good probability (albeit not certain) that it does belong to it.</p>
</blockquote>
<p>So that we can <strong>skip</strong> over files so that we can fasten the lookup time. Without bloom filters we would look for a specific key value in every single HFile, which could be quite slow.</p>
<h4 id="data-locality-and-short-circuiting-">Data locality and Short Circuiting ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#data-locality-and-short-circuiting-">#</a></h4>
<p>We have specified in some paragraphs before that when HBase writes a HFile to a node, the first replica of the file is written on the same node.
This allows for <strong>short circuiting</strong> which allows to directly read from the disk without asking the NameNode for the classical <a href="/notes/distributed-file-systems/#hadoop">HDFS</a> system.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/big-data/">ðŸ““Big-Data</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Wide Column Storage on x"
            href="https://x.com/intent/tweet/?text=Wide%20Column%20Storage&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fwide-column-storage%2f&amp;hashtags=%f0%9f%93%93big-data">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Wide Column Storage on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fwide-column-storage%2f&amp;title=Wide%20Column%20Storage&amp;summary=Wide%20Column%20Storage&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2fwide-column-storage%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Wide Column Storage on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2fwide-column-storage%2f&title=Wide%20Column%20Storage">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Wide Column Storage on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2fwide-column-storage%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Wide Column Storage on whatsapp"
            href="https://api.whatsapp.com/send?text=Wide%20Column%20Storage%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2fwide-column-storage%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Wide Column Storage on telegram"
            href="https://telegram.me/share/url?text=Wide%20Column%20Storage&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fwide-column-storage%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Wide Column Storage on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Wide%20Column%20Storage&u=https%3a%2f%2fflecart.github.io%2fnotes%2fwide-column-storage%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2025 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
