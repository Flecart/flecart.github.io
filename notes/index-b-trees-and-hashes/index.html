<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Index, B-trees and hashes | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="üìôbasi-di-dati">
<meta name="description" content="Indexes
Trattiamo qui di alcuni metodi che sono utilizzati per costruire indici
Introduction to indexes
Gli indici sono una struttura di dati aggiuntiva che ci permette di ricercare pi√π in fretta alcuni valori per le queries. In questa sezione proviamo ad approfondire in che modo possono essere costruite e gestite.
Search keys
Sono in breve la cosa che vogliamo andare a cercare. Solitamente sono nella forma
&lt;key, label&gt;, che ci permette di trovare in fretta il label, che si potrebbe intendere come il valore che noi stiamo provando a cercare.">
<meta name="author" content="Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="https://flecart.github.io/notes/index-b-trees-and-hashes/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/index-b-trees-and-hashes/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>
<script type="text/javascript" async
src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>






      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-WW6NN2QGKF');
        }
      </script><meta property="og:url" content="https://flecart.github.io/notes/index-b-trees-and-hashes/">
  <meta property="og:site_name" content="X. Angelo Huang&#39;s Blog">
  <meta property="og:title" content="Index, B-trees and hashes">
  <meta property="og:description" content="Indexes Trattiamo qui di alcuni metodi che sono utilizzati per costruire indici
Introduction to indexes Gli indici sono una struttura di dati aggiuntiva che ci permette di ricercare pi√π in fretta alcuni valori per le queries. In questa sezione proviamo ad approfondire in che modo possono essere costruite e gestite.
Search keys Sono in breve la cosa che vogliamo andare a cercare. Solitamente sono nella forma &lt;key, label&gt;, che ci permette di trovare in fretta il label, che si potrebbe intendere come il valore che noi stiamo provando a cercare.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="notes">
    <meta property="article:tag" content="üìôBasi-Di-Dati">
      <meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:title" content="Index, B-trees and hashes">
<meta name="twitter:description" content="Indexes
Trattiamo qui di alcuni metodi che sono utilizzati per costruire indici
Introduction to indexes
Gli indici sono una struttura di dati aggiuntiva che ci permette di ricercare pi√π in fretta alcuni valori per le queries. In questa sezione proviamo ad approfondire in che modo possono essere costruite e gestite.
Search keys
Sono in breve la cosa che vogliamo andare a cercare. Solitamente sono nella forma
&lt;key, label&gt;, che ci permette di trovare in fretta il label, che si potrebbe intendere come il valore che noi stiamo provando a cercare.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Index, B-trees and hashes",
      "item": "https://flecart.github.io/notes/index-b-trees-and-hashes/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Index, B-trees and hashes",
  "name": "Index, B-trees and hashes",
  "description": "Indexes Trattiamo qui di alcuni metodi che sono utilizzati per costruire indici\nIntroduction to indexes Gli indici sono una struttura di dati aggiuntiva che ci permette di ricercare pi√π in fretta alcuni valori per le queries. In questa sezione proviamo ad approfondire in che modo possono essere costruite e gestite.\nSearch keys Sono in breve la cosa che vogliamo andare a cercare. Solitamente sono nella forma \u0026lt;key, label\u0026gt;, che ci permette di trovare in fretta il label, che si potrebbe intendere come il valore che noi stiamo provando a cercare.\n",
  "keywords": [
    "üìôbasi-di-dati"
  ],
  "articleBody": "Indexes Trattiamo qui di alcuni metodi che sono utilizzati per costruire indici\nIntroduction to indexes Gli indici sono una struttura di dati aggiuntiva che ci permette di ricercare pi√π in fretta alcuni valori per le queries. In questa sezione proviamo ad approfondire in che modo possono essere costruite e gestite.\nSearch keys Sono in breve la cosa che vogliamo andare a cercare. Solitamente sono nella forma , che ci permette di trovare in fretta il label, che si potrebbe intendere come il valore che noi stiamo provando a cercare.\nLabels and record identifiers (3) Primary vs secondary indexes √à primary se gli attributi che vengono guardati contengono la chiave primaria della relazione Altrimenti √® secondary Dense vs sparse indexes Dense se per ogni chiave del file esiste una chiave di ricerca. Altrimenti √® sparsa. Chiaramente per index sparsi abbiamo bisogno di meno spazio per storarli in memoria!\nClustered vs unclustered indexes Clustered se viene utilizzato l‚Äôordine dei labels (eh, non ho capito questo criterio credo.)\nChiaramente se √® unclustered non abbiamo pi√π i vantaggi della cache, e quindi √® pi√π lento accedere!\nSequential Index example In pratica dividiamo il file in molti pezzi contigui, e proviamo ad indexarli in modo contiguo, come in figura: Questo metodo √® denso e clustered per fare indexing, mentre per il fatto che sia primario o meno dipende!?\nB-trees La differenza fra B-trees e B+-trees √® che il primo pu√≤ tenere valori anche nei nodi intermedi, mentre il secondo tiene valori solamente nelle foglie.\nAbbiamo circa 40ms per l‚Äôaccesso al blocco, solitamente di tipo 4k bytes. La osservazione principale √® che gli algoritmi non lavorano pi√π in RAM, che √® facile accedere subito (nanosecondi ad accedere), quindi √® pi√π facile fare algoritmi che tengano in conto questa cosa.. La base di dati ha bisogno di indici, perch√© in questo modo utilizzo permette il miglior accesso\nun index √® interamente di grandezza del blocco. Dipendente da chiavi valori. Un indice un singolo blocco diciamo (quindi abbiamo centinaia di archi) (il costo √® $\\log_{n}(N)$) con $n$ il branching factor. Con pochi livelli, posso accedere a molte cose! (quindi faccio pochi seek per raggiungere i valori). B-trees Nodi interi e nodi foglia Abbiamo che √® un albero con pi√π rami, solitamente largo per non necessitare di pi√π letture per andare a leggere (ricorda che ram √® circa un milione di volte pi√π veloce!). Praticamente\nInsertion and deletion Quando ho trovato il nodo in cui inserire, e trovando che il nodo √® pieno, dovrei provare a spezzare, e creare un nuovo nodo genitore e c‚Äô√® lo stesso il processo ricorsivo anche sul genitore, se non c‚Äô√® spazio continuo a dividere (anche la radice si pu√≤ splittare). Vedi slide 30 Lab06 Per la deletion la slide √® 39.\nC‚Äô√® un fattore di riempimento che si dovrebbe andare a considerare, per capire se posso fondere pi√π nodi assieme, in modo che non debbano prendere troppo spazio.\nCome in immagine:\nL‚Äôalgoritmo √® molto chiaro se visto con le immagini e gli steps, poi in questa occasione non ci interessa analizzarlo.\nNotare: questa √® una implementazione un po‚Äô meno efficiente perch√© i valori effettivi possono essere presenti solamente sulle foglie, sarebbe pi√π efficiente se si vede che in un nodo intermedio il valore esiste allora esister√† anche sulle foglie per cui si pu√≤ gi√† restituire il risultato. Questo applicativo ha una versione pi√π efficiente: https://www.cs.usfca.edu/~galles/visualization/BTree.html.\nHashes Gli hash sono utili per la ricerca di chiavi uguali tipo per indici oppure per database piccoli (credo) che non hanno bisogno di b-trees.\nStatic Hash Per questa tipologia di hash allochiamo uno spazio fisso non estensibile. Data una certa chiave di ricerca, andiamo a prendere il bucket con quel valore. Se √® gi√† pieno si possono usare linked list o alberi per memorizzare il valore.\nAnche in questo caso, come per i B-trees, si invita a guardare le slides, oppure disegnare per una comprensione migliore dell‚Äôargomento.\nExtensive hash Elementi di rilievo:\nOgni singolo blocco ha un contatore che indica il numero di bits utilizzati per indexarlo. Abbiamo un blocco intermedio di puntatori che vanno sui singolo blocchi di dati, contiene anche un dato che indica numero di bits per indexare il singolo bucket. L‚Äôalgoritmo di insertion √® un po‚Äô pi√π complicato, e differenzia caso in cui il numero di bit per indexare il blocco sia uguale o minore rispetto a quello per i bucket. Anche in questo caso dovresti descrivere l‚Äôesecuzione dell‚Äôalgoritmo con immagini, aiuta molto.\nL‚Äôunica cosa negativa √® il fatto di crescere in modo esponenziale per lo spazio nelle directories in casi proprio avversariali (o comunque molto difficili con una distribuzione normale diciamo).\nLinear Hash In questo caso cresce un blocco alla volta, finch√© un certo threshold di record/numbero di buckets viene soddisfatto si resta, altrimenti prova a crescere. Anche in questo caso come static hash, usiamo gli overflow blocks.\nInverted indexes introduzione sul funzionamento Per gestire cose come testo a volte pu√≤ risultare utile fare questo genere di index per trovarlo. In pratica, supponiamo di avere n indici, allora possiamo fare una tabella nella forma\nParola -\u003e Doc(posizione) In pratica, se ho un match per ogni singola parola con il documento e la posizione all‚Äôinterno del documento che la parola ha, in questo modo posso fare ricerca veloce nelle posizioni in cui la parola compare.\nQuando cerco una stringa esatta posso prendere l‚Äôintersezione fra i documenti in cui compaiono e restituire solamente quelle\nLinguistic preprocessing Sono metodi per diminuire la variet√† delle parole in modo che io abbia bisogno di meno spazio poi per memorizzare l‚Äôinverted index. Posso fare cose come\nStemming: in cui rimuovo lo stemdella parole, quindi suffissi o prefissi ricorrenti Normalization: ad esempio metto tutto minuscolo. Rimozione stop worlds: perch√© sono inutili ch√© non danno molte informazioni\n",
  "wordCount" : "958",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/index-b-trees-and-hashes/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;¬ª&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Index, B-trees and hashes
    </h1>
    <div class="post-meta">5 min&nbsp;¬∑&nbsp;Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#indexes" aria-label="Indexes">Indexes</a><ul>
                        
                <li>
                    <a href="#introduction-to-indexes" aria-label="Introduction to indexes">Introduction to indexes</a><ul>
                        
                <li>
                    <a href="#search-keys" aria-label="Search keys">Search keys</a></li>
                <li>
                    <a href="#labels-and-record-identifiers-3" aria-label="Labels and record identifiers (3)">Labels and record identifiers (3)</a></li></ul>
                </li>
                <li>
                    <a href="#primary-vs-secondary-indexes" aria-label="Primary vs secondary indexes">Primary vs secondary indexes</a><ul>
                        
                <li>
                    <a href="#dense-vs-sparse-indexes" aria-label="Dense vs sparse indexes">Dense vs sparse indexes</a></li>
                <li>
                    <a href="#clustered-vs-unclustered-indexes" aria-label="Clustered vs unclustered indexes">Clustered vs unclustered indexes</a></li>
                <li>
                    <a href="#sequential-index-example" aria-label="Sequential Index example">Sequential Index example</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#b-trees" aria-label="B-trees">B-trees</a><ul>
                        
                <li>
                    <a href="#b-trees-1" aria-label="B-trees">B-trees</a><ul>
                        
                <li>
                    <a href="#nodi-interi-e-nodi-foglia" aria-label="Nodi interi e nodi foglia">Nodi interi e nodi foglia</a></li>
                <li>
                    <a href="#insertion-and-deletion" aria-label="Insertion and deletion">Insertion and deletion</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#hashes" aria-label="Hashes">Hashes</a><ul>
                        
                <li>
                    <a href="#static-hash" aria-label="Static Hash">Static Hash</a></li>
                <li>
                    <a href="#extensive-hash" aria-label="Extensive hash">Extensive hash</a></li>
                <li>
                    <a href="#linear-hash" aria-label="Linear Hash">Linear Hash</a></li></ul>
                </li>
                <li>
                    <a href="#inverted-indexes" aria-label="Inverted indexes">Inverted indexes</a><ul>
                        <ul>
                        
                <li>
                    <a href="#introduzione-sul-funzionamento" aria-label="introduzione sul funzionamento">introduzione sul funzionamento</a></li>
                <li>
                    <a href="#linguistic-preprocessing" aria-label="Linguistic preprocessing">Linguistic preprocessing</a>
                </li>
            </ul>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="indexes">Indexes<a hidden class="anchor" aria-hidden="true" href="#indexes">#</a></h2>
<p>Trattiamo qui di alcuni metodi che sono utilizzati per costruire indici</p>
<h3 id="introduction-to-indexes">Introduction to indexes<a hidden class="anchor" aria-hidden="true" href="#introduction-to-indexes">#</a></h3>
<p>Gli indici sono una struttura di dati aggiuntiva che ci permette di ricercare pi√π in fretta alcuni valori per le queries. In questa sezione proviamo ad approfondire in che modo possono essere costruite e gestite.</p>
<h4 id="search-keys">Search keys<a hidden class="anchor" aria-hidden="true" href="#search-keys">#</a></h4>
<p>Sono in breve la cosa che vogliamo andare a cercare. Solitamente sono nella forma
<strong>&lt;key, label&gt;</strong>, che ci permette di trovare in fretta il label, che si potrebbe intendere come il valore che noi stiamo provando a cercare.</p>
<h4 id="labels-and-record-identifiers-3">Labels and record identifiers (3)<a hidden class="anchor" aria-hidden="true" href="#labels-and-record-identifiers-3">#</a></h4>
<img src="/images/notes/Index and hashes-1703772711043.jpeg" style="width: 100%" class="center" alt="Index and hashes-1703772711043">
<h3 id="primary-vs-secondary-indexes">Primary vs secondary indexes<a hidden class="anchor" aria-hidden="true" href="#primary-vs-secondary-indexes">#</a></h3>
<img src="/images/notes/The Database Management System-1701437037269.jpeg" style="width: 100%" class="center" alt="The Database Management System-1701437037269">
√à primary se gli attributi che vengono guardati contengono la chiave primaria della relazione
Altrimenti √® secondary
<h4 id="dense-vs-sparse-indexes">Dense vs sparse indexes<a hidden class="anchor" aria-hidden="true" href="#dense-vs-sparse-indexes">#</a></h4>
<p>Dense se per ogni chiave del file esiste una chiave di ricerca. Altrimenti √® sparsa.
Chiaramente per index sparsi abbiamo bisogno di <strong>meno spazio per storarli in memoria!</strong></p>
<h4 id="clustered-vs-unclustered-indexes">Clustered vs unclustered indexes<a hidden class="anchor" aria-hidden="true" href="#clustered-vs-unclustered-indexes">#</a></h4>
<p>Clustered se viene utilizzato l&rsquo;ordine dei labels (eh, non ho capito questo criterio credo.)</p>
<p>Chiaramente se √® <em>unclustered</em> non abbiamo pi√π i vantaggi della cache, e quindi √® <strong>pi√π lento accedere!</strong></p>
<h4 id="sequential-index-example">Sequential Index example<a hidden class="anchor" aria-hidden="true" href="#sequential-index-example">#</a></h4>
<p>In pratica dividiamo il file in molti pezzi contigui, e proviamo ad indexarli in modo contiguo, come in figura:<img src="/images/notes/Index and hashes-1703772953076.jpeg" style="width: 100%" class="center" alt="Index and hashes-1703772953076">
Questo metodo √® denso e clustered per fare indexing, mentre per il fatto che sia primario o meno dipende!?</p>
<h2 id="b-trees">B-trees<a hidden class="anchor" aria-hidden="true" href="#b-trees">#</a></h2>
<p>La differenza fra B-trees e B+-trees √® che il primo pu√≤ tenere valori anche nei nodi intermedi, mentre il secondo tiene valori solamente nelle foglie.</p>
<p>Abbiamo circa 40ms per l&rsquo;accesso al blocco, solitamente di tipo 4k bytes. La osservazione principale √® che gli algoritmi non lavorano pi√π in RAM, che √® facile accedere subito (nanosecondi ad accedere), quindi √® pi√π facile fare algoritmi che tengano in conto questa cosa..
La base di dati ha bisogno di indici, perch√© in questo modo utilizzo permette il miglior accesso</p>
<ol>
<li>un index √® interamente di grandezza del blocco. Dipendente da chiavi valori. Un indice un singolo blocco diciamo (quindi abbiamo centinaia di archi) (il costo √® $\log_{n}(N)$) con $n$ il branching factor.</li>
<li>Con pochi livelli, posso accedere a molte cose! (quindi faccio pochi seek per raggiungere i valori).</li>
</ol>
<h3 id="b-trees-1">B-trees<a hidden class="anchor" aria-hidden="true" href="#b-trees-1">#</a></h3>
<h4 id="nodi-interi-e-nodi-foglia">Nodi interi e nodi foglia<a hidden class="anchor" aria-hidden="true" href="#nodi-interi-e-nodi-foglia">#</a></h4>
<p>Abbiamo che √® un albero con pi√π rami, solitamente largo per non necessitare di pi√π letture per andare a leggere (ricorda che ram √® circa un milione di volte pi√π veloce!).
Praticamente</p>
<h4 id="insertion-and-deletion">Insertion and deletion<a hidden class="anchor" aria-hidden="true" href="#insertion-and-deletion">#</a></h4>
<p>Quando ho trovato il nodo in cui inserire, e trovando che il nodo √® pieno, dovrei provare a spezzare, e creare un nuovo nodo genitore e c&rsquo;√® lo stesso il processo ricorsivo anche sul genitore, se non c&rsquo;√® spazio continuo a dividere (anche la radice si pu√≤ splittare).
Vedi slide 30 Lab06
Per la deletion la slide √® 39.</p>
<p>C&rsquo;√® un <strong>fattore di riempimento</strong> che si dovrebbe andare a considerare, per capire se posso fondere pi√π nodi assieme, in modo che non debbano prendere troppo spazio.</p>
<p>Come in immagine:</p>
<img src="/images/notes/The Database Management System-1701437198073.jpeg" style="width: 100%" class="center" alt="The Database Management System-1701437198073">
<p>L&rsquo;algoritmo √® molto chiaro se visto con le immagini e gli steps, poi in questa occasione non ci interessa analizzarlo.</p>
<p>Notare: questa √® una implementazione un po&rsquo; meno efficiente perch√© i valori effettivi possono essere presenti solamente sulle foglie, sarebbe pi√π efficiente se si vede che in un nodo intermedio il valore esiste allora esister√† anche sulle foglie per cui si pu√≤ gi√† restituire il risultato.
Questo applicativo ha una versione pi√π efficiente: <a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html."><a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a>.</a></p>
<h2 id="hashes">Hashes<a hidden class="anchor" aria-hidden="true" href="#hashes">#</a></h2>
<p>Gli hash sono utili per la <strong>ricerca di chiavi uguali</strong> tipo per indici oppure per database piccoli (credo) che non hanno bisogno di b-trees.</p>
<h3 id="static-hash">Static Hash<a hidden class="anchor" aria-hidden="true" href="#static-hash">#</a></h3>
<p>Per questa tipologia di hash <strong>allochiamo uno spazio fisso</strong> non estensibile.
Data una certa chiave di ricerca, andiamo a prendere il <em>bucket</em> con quel valore.
Se √® gi√† pieno si possono usare linked list o alberi per memorizzare il valore.</p>
<p>Anche in questo caso, come per i B-trees, si invita a guardare le slides, oppure disegnare per una comprensione migliore dell&rsquo;argomento.</p>
<h3 id="extensive-hash">Extensive hash<a hidden class="anchor" aria-hidden="true" href="#extensive-hash">#</a></h3>
<p>Elementi di rilievo:</p>
<ol>
<li>Ogni singolo blocco ha un contatore che indica il numero di bits utilizzati per indexarlo.</li>
<li>Abbiamo un <strong>blocco intermedio</strong> di puntatori che vanno sui singolo blocchi di dati, contiene anche un dato che indica numero di bits per indexare il singolo bucket.</li>
</ol>
<p>L&rsquo;algoritmo di insertion √® un po&rsquo; pi√π complicato, e differenzia caso in cui il numero di bit per indexare il blocco sia uguale o minore rispetto a quello per i bucket.
Anche in questo caso dovresti descrivere l&rsquo;esecuzione dell&rsquo;algoritmo con immagini, aiuta molto.</p>
<p>L&rsquo;unica cosa negativa √® il fatto di crescere in modo esponenziale per lo spazio nelle directories in casi proprio avversariali (o comunque molto difficili con una distribuzione normale diciamo).</p>
<h3 id="linear-hash">Linear Hash<a hidden class="anchor" aria-hidden="true" href="#linear-hash">#</a></h3>
<p>In questo caso cresce un blocco alla volta, finch√© un certo threshold di record/numbero di buckets viene soddisfatto si resta, altrimenti prova a crescere.
Anche in questo caso come static hash, usiamo gli <strong>overflow blocks</strong>.</p>
<h2 id="inverted-indexes">Inverted indexes<a hidden class="anchor" aria-hidden="true" href="#inverted-indexes">#</a></h2>
<h4 id="introduzione-sul-funzionamento">introduzione sul funzionamento<a hidden class="anchor" aria-hidden="true" href="#introduzione-sul-funzionamento">#</a></h4>
<p>Per gestire cose come testo a volte pu√≤ risultare utile fare questo genere di index per trovarlo.
In pratica, supponiamo di avere n indici, allora possiamo fare una tabella nella forma</p>
<p>Parola -&gt; Doc(posizione)
In pratica, se ho un match per ogni singola parola con il documento e la posizione all&rsquo;interno del documento che la parola ha, in questo modo posso fare ricerca veloce nelle posizioni in cui la parola compare.</p>
<p>Quando cerco una stringa esatta posso prendere <em>l&rsquo;intersezione</em> fra i documenti in cui compaiono e restituire solamente quelle</p>
<h4 id="linguistic-preprocessing">Linguistic preprocessing<a hidden class="anchor" aria-hidden="true" href="#linguistic-preprocessing">#</a></h4>
<p>Sono metodi per <strong>diminuire la variet√† delle parole</strong> in modo che io abbia bisogno di meno spazio poi per memorizzare l&rsquo;inverted index.
Posso fare cose come</p>
<p><strong>Stemming</strong>: in cui rimuovo lo <em>stem</em>della parole, quindi suffissi o prefissi ricorrenti
<strong>Normalization</strong>: ad esempio metto tutto minuscolo.
<strong>Rimozione stop worlds</strong>: perch√© sono inutili ch√© non danno molte informazioni</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/basi-di-dati/">üìôBasi-Di-Dati</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Index, B-trees and hashes on x"
            href="https://x.com/intent/tweet/?text=Index%2c%20B-trees%20and%20hashes&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2findex-b-trees-and-hashes%2f&amp;hashtags=%f0%9f%93%99basi-di-dati">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Index, B-trees and hashes on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2findex-b-trees-and-hashes%2f&amp;title=Index%2c%20B-trees%20and%20hashes&amp;summary=Index%2c%20B-trees%20and%20hashes&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2findex-b-trees-and-hashes%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Index, B-trees and hashes on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2findex-b-trees-and-hashes%2f&title=Index%2c%20B-trees%20and%20hashes">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Index, B-trees and hashes on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2findex-b-trees-and-hashes%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Index, B-trees and hashes on whatsapp"
            href="https://api.whatsapp.com/send?text=Index%2c%20B-trees%20and%20hashes%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2findex-b-trees-and-hashes%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Index, B-trees and hashes on telegram"
            href="https://telegram.me/share/url?text=Index%2c%20B-trees%20and%20hashes&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2findex-b-trees-and-hashes%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Index, B-trees and hashes on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Index%2c%20B-trees%20and%20hashes&u=https%3a%2f%2fflecart.github.io%2fnotes%2findex-b-trees-and-hashes%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span> ¬∑ 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
