<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Programmazione lineare | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="no-tags">
<meta name="description" content="Vogliamo cercare di restare nel nostro spazio delle soluzioni ammissibili, senza dover stare ad esplorare tutto, vogliamo andare a concentrarci su una parte specifica di essa. Vogliamo utilizzare una struttura fondamentale per i problemi di programmazione lineare, che √® quello con cui vogliamo andare a fare. Il fatto √® che spostandoci leggermente da un punto tra le soluzioni, possiamo gestire in modo molto semplice il modo con cui si sposta la retta dei valori.">
<meta name="author" content="Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="https://flecart.github.io/notes/programmazione-lineare/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/programmazione-lineare/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>




<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>
<script type="text/javascript" async
src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>





<script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-WW6NN2QGKF', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Programmazione lineare" />
<meta property="og:description" content="Vogliamo cercare di restare nel nostro spazio delle soluzioni ammissibili, senza dover stare ad esplorare tutto, vogliamo andare a concentrarci su una parte specifica di essa. Vogliamo utilizzare una struttura fondamentale per i problemi di programmazione lineare, che √® quello con cui vogliamo andare a fare. Il fatto √® che spostandoci leggermente da un punto tra le soluzioni, possiamo gestire in modo molto semplice il modo con cui si sposta la retta dei valori." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://flecart.github.io/notes/programmazione-lineare/" />
<meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png" />
<meta property="article:section" content="notes" />



<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png" />
<meta name="twitter:title" content="Programmazione lineare"/>
<meta name="twitter:description" content="Vogliamo cercare di restare nel nostro spazio delle soluzioni ammissibili, senza dover stare ad esplorare tutto, vogliamo andare a concentrarci su una parte specifica di essa. Vogliamo utilizzare una struttura fondamentale per i problemi di programmazione lineare, che √® quello con cui vogliamo andare a fare. Il fatto √® che spostandoci leggermente da un punto tra le soluzioni, possiamo gestire in modo molto semplice il modo con cui si sposta la retta dei valori."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Programmazione lineare",
      "item": "https://flecart.github.io/notes/programmazione-lineare/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Programmazione lineare",
  "name": "Programmazione lineare",
  "description": "Vogliamo cercare di restare nel nostro spazio delle soluzioni ammissibili, senza dover stare ad esplorare tutto, vogliamo andare a concentrarci su una parte specifica di essa. Vogliamo utilizzare una struttura fondamentale per i problemi di programmazione lineare, che √® quello con cui vogliamo andare a fare. Il fatto √® che spostandoci leggermente da un punto tra le soluzioni, possiamo gestire in modo molto semplice il modo con cui si sposta la retta dei valori.",
  "keywords": [
    "no-tags"
  ],
  "articleBody": "Vogliamo cercare di restare nel nostro spazio delle soluzioni ammissibili, senza dover stare ad esplorare tutto, vogliamo andare a concentrarci su una parte specifica di essa. Vogliamo utilizzare una struttura fondamentale per i problemi di programmazione lineare, che √® quello con cui vogliamo andare a fare. Il fatto √® che spostandoci leggermente da un punto tra le soluzioni, possiamo gestire in modo molto semplice il modo con cui si sposta la retta dei valori.\nQuesto √® possiamo ridurci a considerare i vertici del poliedro che si costruisce, quindi andiamo in questa prima parte a definire alcune nozioni matematiche utili a mettere in gioco questa intuizione\nNozioni preliminari Vocabolario di base Iperpiano L‚Äôinsieme delle soluzioni di equazioni in\n$$ \\left\\{ x \\in \\mathbb{R}^{n} \\mid a^{T}x = b, a \\neq 0 \\right\\} $$ E si pu√≤ dimostrare che questo √® un insieme affine, quindi √® una linea. Questi piani sono anche convessi perch√© prendiamo tutti i punti ü§†.\nSemispazio $$ \\left\\{ x \\in \\mathbb{R}^{n} \\mid a^{T}x \\geq b, a \\neq 0 \\right\\} $$ Lo spazio √® diviso fra zone in cui √® maggiore e altre in cui √® minore. Questi non sono affini ma sono solo convessi (perch√© limitati in certe zone)\nPalla euclidea $$ B(x_{c}, r) = \\left\\{ x \\mid \\lvert x - x_{c} \\rvert _{2} \\leq r \\right\\} = \\left\\{ x _{c} + ru \\mid \\lvert u \\rvert _{2} \\leq 1 \\right\\} $$ Dove $r$ √® chiamato raggio.\nEllissoide √à un insieme formato in questo modo $$ \\left\\{ x \\mid (x - x_{c})^{T} P^{-1} (x - x_{c}) \\leq 1 \\right\\} $$ Quindi √® una forma quadratica quelle saltate in algebra. Nella pratica √® una palla, un po‚Äô allungata in certe direzioni descritte da $P$, che √® una matrice simmetrica definita positiva. ossia nell‚Äôinsieme $S_{++}$ Si scrive anche a volte come $$ \\left\\{ x_{c} + Au \\mid \\lvert u \\rvert _{2} \\leq 1 \\right\\} $$ Poliedro √à una intersezione di un numero finito di $m$ semispazi come definiti di sopra inoltre non vogliamo che da nessuna parte si estenda all‚Äôinfinito, quindi vogliamo che valga $$ \\left\\{ x \\mid Ax \\leq b \\right\\} $$ Per qualche valore di $A$ e $b$.\nUn poliedro √® una qualunque intersezione di semispazi (anche vuota, ma non √® molto interessante un poliedro vuoto), ed √® un insieme sempre convesso perch√© l‚Äôintersezione di cose convesse √® ancora convesso.\nL‚Äôamico del poliedro che deve essere per forza finito √® il politopo. (che √® la versione non bounded, ma alcuni autori utilizzano una definizione opposta, ma comunque non √® molto importante).)\nFacce üü® Formalmente:\nPreso un poliedro, andiamo a definire una sua faccia, un insieme di punti che soddisfano queste caratteristiche:\nGiace direttamente su una o pi√π condizioni Giace dentro il poliedro (quindi ogni punto della faccia √® un punto del poliedro anche!) Che matematicamente si possono andare a caratterizzare in questo modo: sia $I$ l‚Äôinsieme degli indici delle condizioni della matrice del poliedro che andiamo a prendere, e $\\bar{I}$ il suo complementare, allora\n$$ P_I = \\{x: A_Ix=b_I \\wedge A_{\\bar{I}}x \\leq b_{\\bar{I}} \\} $$ Intuitivamente L‚Äôintuizione per questa parte √® prendere un sottoinsieme che ci piace riguardante la nostra matrice, quella cosa corrisponder√† a una faccia del nostro poliedro.\nnozioni sulla dimensione della matrice finale √® molto buona, ci pu√≤ dare un concetto di dimensione della faccia che andiamo a prendere. Per fare un esempio, se riusciamo ad avere una faccia di dimensione n, √® un singolo punto, quindi √® un vertice!\nin generale, come dicono le dispense vale la relazione sul fatto che\nE` possibile verificare che una faccia determinata da una matrice AI di rango k ha dimensione n ‚àí k o inferiore, pagina 8 dispense 3.\nSpigoli e vertici e soluzioni base üü© Una sottomatrice di dimensione n, √® un vertice!.\nUna sottomatrice di dimensione n - 1 √® uno spigolo!.\nQuesto sar√† il nostro spazio di ricerca quelli sui vertifici!\nSoluzione di base\nParlano dei vertici e lo fanno attraverso il concetto di invertibilit√†. Una soluzione di base non √® detto che faccia parte del poliedro che stiamo andando a considerare! Vogliamo andare a considerare delle basi ammissibili ossia che sono anche all‚Äôinterno del poliedro (un esempio ez. √® il vertice).\nMatrice di base, ammissibilit√† o non della base.\nVincoli attivi üü®+ I vincoli attivi sono vincoli del nostro problema che vengono soddisfatte come uguaglianze. Questa √® una cosa di interesse, per ragioni che mi sono ancora oscure.\nDi importanza per√≤ √® la notazione $$ I(x) = \\{ i | A_ix = b_i\\} $$ Questa notazione pi√π o meno ci dice quante righe della matrice sto andando poi a contare\nCose convesse Trattate un po‚Äô meglio in Analisi di Convessit√†.\nInviluppi convessi üü© Queste cose ci sono molto utili, vanno simili al concetto di Base e dimensione, cercare di riassumere un insieme di punti illimitato con alcuni punti cardine limitati. In questo caso considero l‚Äôinsieme , $X = \\{x_1, ..., x_n\\}$\n$$ conv(X) = \\{ \\sum _{i = 0} \\lambda_ix_i | \\sum_{i = 0} \\lambda_i = 1 \\land \\lambda_i \\geq 0\\} $$ Questo insieme ci √® sufficiente per avere un politopo, per il caso infinito dovremmo andare sui coni.\nPer ora basta avere un intuizione per questo. Riusciamo a costruire in questo modo tutti i spigoli che uniscono i nostri punti di vertice, e partendo da questi possiamo andare a costruire l‚Äôintero politopo, ma la dimostrazione formale non la andiamo a dare.\nConi convessi See Analisi di Convessit√†#Convex Cone. Il concetto di cono convesso ci aiuta a costruire il caso infinito, considerando alcune operazioni di prolungamento e somma\n$x,y \\in C, \\lambda, \\beta \\in \\mathbb{R} \\implies \\lambda x + \\beta y \\in C$\nPossiamo provare a generalizzare questo concetto utilizzando la somma fra tutti i possibili\n$V = \\{ v_1, ... v_n\\}$\n$$ cono(V) = \\{ \\sum _{i = 1} \\lambda_i v_i | \\lambda_i \\in \\mathbb{R} ^+\\} $$ Teorema di Motzkin o di decomposizione (!) üü®+ Slide\nQuesto √® un teorema molto importante perch√© teorema caratterizzante dei poliedri!\nIntuizione\nPi√π o meno questo teorema ci dice che tutti i poliedri possono essere ridotti a un insieme di punti di partenza, che quasi vanno a formare una base (nel caso del politopo sono solamente questi punti di base, il cono che andiamo a considerare √® vuoto!) e poi poter estenderli in una direzione utilizzando il cono!\nDifferenza dimensione motzkin e vincoli\nL‚Äôutilizzo pi√π importante di questo teorema √® che possiamo caratterizzare i poliedri in modo molto pi√π semplice, differentemente a quanto fatto con i vincoli lineari, perch√© quelli hanno un‚Äôesplosione esponenziale per quanto riguarda il numero di vertici. (nota importnate √® che i vertici non si calcolano in modo molto veloce fra i vertici e i vincoli lineari!).\nVertici ‚Üí exp\nVincoli ‚Üí lin.\nQuesta differenza di crescita non ci piace proprio! Non ci piace andare a cercare il numero di vertici se questi vertici crescono in modo esponenziale!\nTh esistenza dell‚Äôottimo finito (!!) üü®++ Enunciato\nDimostrazione\nQuesto teorema lega in modo molto forte la parte di cono convesso con la soluzione del nostro problema lineare!\nossia possiamo avere soluzione solo se il cono non si espande verso l‚Äôinfinito positivo, se succede, la soluzione ottimale √® infinito, altrimenti possiamo andare a scartare il contributo negativo del cono, e tenerci solamente il contributo dato dalla inviluppo convesso.\nTeoria della dualit√† √à una branca dell‚Äôalgebra lineare che ci permette di semplificare tutti i concetti.\nIntro dualit√†üü© Slide\nSi fa una sorta di trasposta alla matrice di A.\ny √® pari al numero di righe di A\nLa trasformazione al duale √® molto facile, ed √® abbastanza intuitiva una volta che capiamo che vogliamo andare a fare l‚Äôupper bound.\nDualit√† asimmetrica üü•+ Teorema debole di dualit√† üü© Slide\nQui c‚Äô√® una cosa simile a quanto fatto in MCMF, il cui massimo di x √® boundato dal minimo del suo duale, in Tarjan e MCMF.\nCorollari di dualit√† (2) üü© Slide\nil fatto che ci sia un bound a x, implica che se x √® illimitato, non posso avere il bound! Abbiamo una condizione di ottimalit√† delle soluzioni trovate! Def Direzioni ammissibili Vogliamo trovare un modo per muoverci e trovare ancora una direzione ottimale!\nDef:\nun vettore $\\varepsilon \\in \\R ^n$ √® una direzione ammissibile se esiste $\\bar{\\lambda} \u003e 0$ tale che $x(\\lambda) = x + \\lambda \\varepsilon$, per ogni $\\lambda \\in 0...\\bar{\\lambda}$\nIntuizione\nOssia se possiamo spostarci di almeno un p√≤ verso la direzione che vogliamo!\nDef direzione di crescita Possiamo considerare una direzione di crescita\n$**\\lambda \\iff cx(\\lambda) = c \\bar{x} + \\lambda c\\varepsilon \u003e c \\bar{x} \\iff c\\varepsilon \u003e 0**$\nLa cosa interessante √® che una direzione di crescita cresce indipendentemente dal punto, questo √® una propriet√† molto forte della programmazione lineare!\nQuesti due concetti sono molto utili perch√© una volta che abbiamo una direzione ammissibile e di crescita allora si pu√≤ verificare che si pu√≤ migliorare ancora la soluzione di x.\nSuff e nec per direzione ammissibile Slide\nL‚Äôidea principale per questa dimostrazione √® sui vincoli attivi, differenziare se una riga √® un vincolo attivo o meno. Se lo √® allora voglio che sia minore, altrimeni basta scegliere un intorno sufficientemente piccolo perch√© il vincolo √® stretto.\nDa notare che se non √® un vincolo attivo allora ho una disuguaglianza stretta allora posso andare ad utilizzare cose di analisi\nOttimalit√† del punto Dato un punto $x$ ammissibile, questo punto √® ottimo sse non ci sono direzioni di crescita ammisibile\nIntuizione sulla dimo\n‚Üí se √® gi√† ottimo allora se esistessa una direzione di crescita, si potrebbe far crescere ancora il nostro punto di ottimo, violando l‚Äôipotesi di ottimalit√†\n‚ÜêSe non ho direzioni di crescita, supponendo per assurdo che non sia ottimo abbiamo allora possiamo trovare una direzione di crescita ammissibile, creando un assurdo, questa direzione la andiamo a trovare prendendo un punto ottimo e creando il vettore da questo punto a quello nostro iniziale.\nDimostrazione dispense\n!\n",
  "wordCount" : "1649",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/programmazione-lineare/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;¬ª&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Programmazione lineare
    </h1>
    <div class="post-meta">8 min&nbsp;¬∑&nbsp;Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#nozioni-preliminari" aria-label="Nozioni preliminari">Nozioni preliminari</a><ul>
                        
                <li>
                    <a href="#vocabolario-di-base" aria-label="Vocabolario di base">Vocabolario di base</a><ul>
                        
                <li>
                    <a href="#iperpiano" aria-label="Iperpiano">Iperpiano</a></li>
                <li>
                    <a href="#semispazio" aria-label="Semispazio">Semispazio</a></li>
                <li>
                    <a href="#palla-euclidea" aria-label="Palla euclidea">Palla euclidea</a></li>
                <li>
                    <a href="#ellissoide" aria-label="Ellissoide">Ellissoide</a></li>
                <li>
                    <a href="#poliedro" aria-label="Poliedro">Poliedro</a></li></ul>
                </li>
                <li>
                    <a href="#facce-" aria-label="Facce üü®">Facce üü®</a></li>
                <li>
                    <a href="#spigoli-e-vertici-e-soluzioni-base-" aria-label="Spigoli e vertici e soluzioni base üü©">Spigoli e vertici e soluzioni base üü©</a></li>
                <li>
                    <a href="#vincoli-attivi-" aria-label="Vincoli attivi üü®&#43;">Vincoli attivi üü®+</a></li></ul>
                </li>
                <li>
                    <a href="#cose-convesse" aria-label="Cose convesse">Cose convesse</a><ul>
                        
                <li>
                    <a href="#inviluppi-convessi-" aria-label="Inviluppi convessi üü©">Inviluppi convessi üü©</a></li>
                <li>
                    <a href="#coni-convessi" aria-label="Coni convessi">Coni convessi</a></li>
                <li>
                    <a href="#teorema-di-motzkin-o-di-decomposizione--" aria-label="Teorema di Motzkin o di decomposizione (!) üü®&#43;">Teorema di Motzkin o di decomposizione (!) üü®+</a></li>
                <li>
                    <a href="#th-esistenza-dellottimo-finito--" aria-label="Th esistenza dell‚Äôottimo finito (!!) üü®&#43;&#43;">Th esistenza dell‚Äôottimo finito (!!) üü®++</a></li></ul>
                </li>
                <li>
                    <a href="#teoria-della-dualit%c3%a0" aria-label="Teoria della dualit√†">Teoria della dualit√†</a><ul>
                        
                <li>
                    <a href="#intro-dualit%c3%a0" aria-label="Intro dualit√†üü©">Intro dualit√†üü©</a></li>
                <li>
                    <a href="#dualit%c3%a0-asimmetrica-" aria-label="Dualit√† asimmetrica üü•&#43;">Dualit√† asimmetrica üü•+</a></li>
                <li>
                    <a href="#teorema-debole-di-dualit%c3%a0-" aria-label="Teorema debole di dualit√† üü©">Teorema debole di dualit√† üü©</a></li>
                <li>
                    <a href="#corollari-di-dualit%c3%a0-2-" aria-label="Corollari di dualit√† (2) üü©">Corollari di dualit√† (2) üü©</a></li>
                <li>
                    <a href="#def-direzioni-ammissibili" aria-label="Def Direzioni ammissibili">Def Direzioni ammissibili</a></li>
                <li>
                    <a href="#def-direzione-di-crescita" aria-label="Def direzione di crescita">Def direzione di crescita</a></li>
                <li>
                    <a href="#suff-e-nec-per-direzione-ammissibile" aria-label="Suff e nec per direzione ammissibile">Suff e nec per direzione ammissibile</a></li>
                <li>
                    <a href="#ottimalit%c3%a0-del-punto" aria-label="Ottimalit√† del punto">Ottimalit√† del punto</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Vogliamo cercare di restare nel nostro spazio delle soluzioni ammissibili, senza dover stare ad esplorare tutto, vogliamo andare a concentrarci su una parte specifica di essa. Vogliamo utilizzare una struttura fondamentale per i problemi di programmazione lineare, che √® quello con cui vogliamo andare a fare. Il fatto √® che spostandoci leggermente da un punto tra le soluzioni, possiamo gestire in modo molto semplice il modo con cui si sposta la retta dei valori.</p>
<p>Questo √® <strong>possiamo ridurci a considerare i vertici</strong> del poliedro che si costruisce, quindi andiamo in questa prima parte a definire alcune nozioni matematiche utili a mettere in gioco questa intuizione</p>
<h2 id="nozioni-preliminari">Nozioni preliminari<a hidden class="anchor" aria-hidden="true" href="#nozioni-preliminari">#</a></h2>
<h3 id="vocabolario-di-base">Vocabolario di base<a hidden class="anchor" aria-hidden="true" href="#vocabolario-di-base">#</a></h3>
<h4 id="iperpiano">Iperpiano<a hidden class="anchor" aria-hidden="true" href="#iperpiano">#</a></h4>
<p>L&rsquo;insieme delle soluzioni di equazioni in</p>
$$
\left\{ x \in \mathbb{R}^{n} \mid a^{T}x = b, a \neq 0 \right\} 
$$
<p>
E si pu√≤ dimostrare che questo √® un insieme affine, quindi √® una linea. Questi piani sono anche convessi perch√© prendiamo tutti i punti ü§†.</p>
<h4 id="semispazio">Semispazio<a hidden class="anchor" aria-hidden="true" href="#semispazio">#</a></h4>
$$
\left\{ x \in \mathbb{R}^{n} \mid a^{T}x \geq b, a \neq 0 \right\} 
$$
<p>Lo spazio √® diviso fra zone in cui √® maggiore e altre in cui √® minore.
Questi <strong>non sono affini</strong> ma sono solo convessi (perch√© limitati in certe zone)</p>
<h4 id="palla-euclidea">Palla euclidea<a hidden class="anchor" aria-hidden="true" href="#palla-euclidea">#</a></h4>
$$
B(x_{c}, r) = \left\{ x \mid \lvert x - x_{c} \rvert _{2} \leq r \right\}  = \left\{ x _{c} + ru \mid \lvert u \rvert _{2} \leq 1 \right\} 
$$
<p>
Dove $r$ √® chiamato raggio.</p>
<h4 id="ellissoide">Ellissoide<a hidden class="anchor" aria-hidden="true" href="#ellissoide">#</a></h4>
<p>√à un insieme formato in questo modo
</p>
$$
\left\{ x \mid (x - x_{c})^{T} P^{-1} (x - x_{c}) \leq 1 \right\} 
$$
<p>
Quindi √® una <strong>forma quadratica</strong> quelle saltate in algebra.
Nella pratica √® una palla, un po&rsquo; allungata in certe direzioni descritte da $P$, che √® una matrice <strong>simmetrica definita positiva</strong>. ossia nell&rsquo;insieme $S_{++}$
Si scrive anche a volte come
</p>
$$
\left\{ x_{c} + Au \mid \lvert u \rvert _{2} \leq 1 \right\} 
$$
<h4 id="poliedro">Poliedro<a hidden class="anchor" aria-hidden="true" href="#poliedro">#</a></h4>
<p>√à una intersezione di un numero finito di $m$ semispazi come definiti di sopra inoltre non vogliamo che da nessuna parte si estenda all&rsquo;infinito, quindi vogliamo che valga
</p>
$$
\left\{ x \mid Ax \leq b \right\}
$$
<p>
Per qualche valore di $A$ e $b$.</p>
<img src="/images/notes/Programmazione lineare-20240327205441381.webp" alt="Programmazione lineare-20240327205441381">
<p>Un <strong>poliedro</strong> √® una qualunque intersezione di semispazi (anche vuota, ma non √® molto interessante un poliedro vuoto), ed √® un insieme sempre convesso perch√© l‚Äôintersezione di cose convesse √® ancora convesso.</p>
<p>L‚Äôamico del poliedro che deve essere per forza finito √® il <strong>politopo.</strong> (che √® la versione non bounded, ma alcuni autori utilizzano una definizione opposta, ma comunque non √® molto importante).)</p>
<h3 id="facce-">Facce üü®<a hidden class="anchor" aria-hidden="true" href="#facce-">#</a></h3>
<img src="/images/notes/image/universita/ex-notion/Programmazione lineare/Untitled 1.png" alt="image/universita/ex-notion/Programmazione lineare/Untitled 1">
<p><strong>Formalmente:</strong></p>
<p>Preso un poliedro, andiamo a definire una sua faccia, un insieme di punti che soddisfano queste caratteristiche:</p>
<ol>
<li>Giace direttamente su una o pi√π condizioni</li>
<li>Giace dentro il poliedro (quindi ogni punto della faccia √® un punto del poliedro anche!)</li>
</ol>
<p>Che matematicamente si possono andare a caratterizzare in questo modo: sia $I$ l‚Äôinsieme degli indici delle condizioni della matrice del poliedro che andiamo a prendere, e $\bar{I}$  il suo complementare, allora</p>
$$
P_I = \{x: A_Ix=b_I \wedge A_{\bar{I}}x \leq b_{\bar{I}} \}
$$
<p><strong>Intuitivamente</strong>
L&rsquo;intuizione per questa parte √® prendere un sottoinsieme che ci piace riguardante la nostra matrice, quella cosa corrisponder√† a una faccia del nostro poliedro.</p>
<p>nozioni sulla <strong>dimensione della matrice finale</strong> √® molto buona, ci pu√≤ dare un concetto di dimensione della faccia che andiamo a prendere. Per fare un esempio, se riusciamo ad avere una faccia di dimensione n, √® un singolo punto, quindi √® un vertice!</p>
<p>in generale, come dicono le dispense vale la relazione sul fatto che</p>
<blockquote>
<p>E` possibile verificare che una faccia determinata da una
matrice AI di rango k ha dimensione n ‚àí k o inferiore, pagina 8 dispense 3.</p>
</blockquote>
<h3 id="spigoli-e-vertici-e-soluzioni-base-">Spigoli e vertici e soluzioni base üü©<a hidden class="anchor" aria-hidden="true" href="#spigoli-e-vertici-e-soluzioni-base-">#</a></h3>
<p>Una sottomatrice di dimensione n, √® un vertice!.</p>
<p>Una sottomatrice di dimensione n - 1 √® uno spigolo!.</p>
<p>Questo sar√† il nostro <strong>spazio di ricerca</strong> quelli sui vertifici!</p>
<p><strong>Soluzione di base</strong></p>
<p>Parlano dei vertici e lo fanno attraverso il concetto di invertibilit√†. Una soluzione di base non √® detto che faccia parte del poliedro che stiamo andando a considerare! Vogliamo andare a considerare delle <strong>basi ammissibili</strong> ossia che sono anche all&rsquo;interno del poliedro (un esempio ez. √® il vertice).</p>
<p><strong>Matrice di base, ammissibilit√† o non della base.</strong></p>
<h3 id="vincoli-attivi-">Vincoli attivi üü®+<a hidden class="anchor" aria-hidden="true" href="#vincoli-attivi-">#</a></h3>
<p>I vincoli attivi sono vincoli del nostro problema che vengono soddisfatte come uguaglianze. Questa √® una cosa di interesse, per ragioni che mi sono ancora oscure.</p>
<pre><code>&lt;img src=&quot;/images/notes/image/universita/ex-notion/Programmazione lineare/Untitled 2.png&quot; alt=&quot;image/universita/ex-notion/Programmazione lineare/Untitled 2&quot;&gt;
</code></pre>
<p>Di importanza per√≤ √® la notazione
</p>
$$
I(x) = \{ i |  A_ix = b_i\}
$$
<p>Questa notazione pi√π o meno ci dice quante righe della matrice sto andando poi a contare</p>
<h2 id="cose-convesse">Cose convesse<a hidden class="anchor" aria-hidden="true" href="#cose-convesse">#</a></h2>
<p>Trattate un po&rsquo; meglio in <a href="/notes/analisi-di-convessit%C3%A0/">Analisi di Convessit√†</a>.</p>
<h3 id="inviluppi-convessi-">Inviluppi convessi üü©<a hidden class="anchor" aria-hidden="true" href="#inviluppi-convessi-">#</a></h3>
<p>Queste cose ci sono molto utili, vanno simili al concetto di <a href="/notes/base-e-dimensione/">Base e dimensione</a>, cercare di riassumere un insieme di punti illimitato con alcuni punti cardine limitati. In questo caso considero l&rsquo;insieme , $X = \{x_1, ..., x_n\}$</p>
$$
conv(X) = \{ \sum _{i = 0} \lambda_ix_i | \sum_{i = 0} \lambda_i = 1 \land \lambda_i \geq 0\}
$$
<p>Questo insieme ci √® sufficiente per avere un <strong>politopo</strong>, per il caso infinito dovremmo andare sui coni.</p>
<p>Per ora basta avere un intuizione per questo. Riusciamo a costruire in questo modo tutti i spigoli che uniscono i nostri punti di vertice, e partendo da questi possiamo andare a costruire l‚Äôintero politopo, ma la dimostrazione formale non la andiamo a dare.</p>
<h3 id="coni-convessi">Coni convessi<a hidden class="anchor" aria-hidden="true" href="#coni-convessi">#</a></h3>
<p>See <a href="/notes/analisi-di-convessit%C3%A0/#convex-cone">Analisi di Convessit√†#Convex Cone</a>.
<img src="/images/notes/image/universita/ex-notion/Programmazione lineare/Untitled 3.png" alt="image/universita/ex-notion/Programmazione lineare/Untitled 3"></p>
<p>Il concetto di cono convesso ci aiuta a costruire il caso infinito, considerando alcune operazioni di prolungamento e somma</p>
<p>$x,y \in C, \lambda, \beta \in \mathbb{R} \implies \lambda x + \beta y \in C$</p>
<p>Possiamo provare a generalizzare questo concetto utilizzando la somma fra tutti i possibili</p>
<p>$V = \{ v_1, ... v_n\}$</p>
$$
cono(V) = \{ \sum _{i = 1} \lambda_i v_i | \lambda_i \in \mathbb{R} ^+\}
$$
<h3 id="teorema-di-motzkin-o-di-decomposizione--">Teorema di Motzkin o di decomposizione (!) üü®+<a hidden class="anchor" aria-hidden="true" href="#teorema-di-motzkin-o-di-decomposizione--">#</a></h3>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Programmazione lineare/Untitled 4.png" alt="image/universita/ex-notion/Programmazione lineare/Untitled 4">
</li>
</ul>
<p>Questo √® un teorema molto importante perch√© <strong>teorema caratterizzante dei poliedri</strong>!</p>
<p><strong>Intuizione</strong></p>
<p>Pi√π o meno questo teorema ci dice che tutti i poliedri possono essere ridotti a un insieme di punti di partenza, che quasi vanno a formare una base (nel caso del politopo sono solamente questi punti di base, il cono che andiamo a considerare √® vuoto!) e poi poter estenderli in una direzione utilizzando il cono!</p>
<p><strong>Differenza dimensione motzkin e vincoli</strong></p>
<p>L‚Äôutilizzo pi√π importante di questo teorema √® che possiamo caratterizzare i poliedri in modo molto pi√π semplice, differentemente a quanto fatto con i vincoli lineari, perch√© quelli hanno un‚Äôesplosione esponenziale per quanto riguarda il numero di vertici. (nota importnate √® che i vertici non si calcolano in modo molto veloce fra i vertici e i vincoli lineari!).</p>
<p><strong>Vertici ‚Üí exp</strong></p>
<p><strong>Vincoli ‚Üí lin</strong>.</p>
<p>Questa differenza di crescita non ci piace proprio! Non ci piace andare a cercare il numero di vertici se questi vertici crescono in modo esponenziale!</p>
<h3 id="th-esistenza-dellottimo-finito--">Th esistenza dell‚Äôottimo finito (!!) üü®++<a hidden class="anchor" aria-hidden="true" href="#th-esistenza-dellottimo-finito--">#</a></h3>
<ul>
<li>
<p>Enunciato</p>
  <img src="/images/notes/image/universita/ex-notion/Programmazione lineare/Untitled 5.png" alt="image/universita/ex-notion/Programmazione lineare/Untitled 5">
</li>
<li>
<p>Dimostrazione</p>
  <img src="/images/notes/image/universita/ex-notion/Programmazione lineare/Untitled 6.png" alt="image/universita/ex-notion/Programmazione lineare/Untitled 6">
  <img src="/images/notes/image/universita/ex-notion/Programmazione lineare/Untitled 7.png" alt="image/universita/ex-notion/Programmazione lineare/Untitled 7">
</li>
</ul>
<p>Questo teorema lega in modo molto forte la parte di <strong>cono convesso</strong> con la soluzione del nostro problema lineare!</p>
<p>ossia possiamo avere soluzione solo se il cono non si espande verso l&rsquo;infinito positivo, se succede, la soluzione ottimale √® infinito, altrimenti possiamo andare a scartare il contributo negativo del cono, e tenerci solamente il contributo dato dalla inviluppo convesso.</p>
<h2 id="teoria-della-dualit√†">Teoria della dualit√†<a hidden class="anchor" aria-hidden="true" href="#teoria-della-dualit√†">#</a></h2>
<p>√à una branca dell&rsquo;algebra lineare che ci permette di semplificare tutti i concetti.</p>
<h3 id="intro-dualit√†">Intro dualit√†üü©<a hidden class="anchor" aria-hidden="true" href="#intro-dualit√†">#</a></h3>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Programmazione lineare/Untitled 8.png" alt="image/universita/ex-notion/Programmazione lineare/Untitled 8">
</li>
<li>
<p>Si fa una sorta di trasposta alla matrice di A.</p>
</li>
<li>
<p>y √® pari al numero di righe di A</p>
</li>
</ul>
<p>La trasformazione al duale √® molto facile, ed √® abbastanza intuitiva una volta che capiamo che vogliamo andare a fare l‚Äôupper bound.</p>
<h3 id="dualit√†-asimmetrica-">Dualit√† asimmetrica üü•+<a hidden class="anchor" aria-hidden="true" href="#dualit√†-asimmetrica-">#</a></h3>
<h3 id="teorema-debole-di-dualit√†-">Teorema debole di dualit√† üü©<a hidden class="anchor" aria-hidden="true" href="#teorema-debole-di-dualit√†-">#</a></h3>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Programmazione lineare/Untitled 9.png" alt="image/universita/ex-notion/Programmazione lineare/Untitled 9">
</li>
</ul>
<p>Qui c&rsquo;√® una cosa simile a quanto fatto in MCMF, il cui massimo di x √® boundato dal minimo del suo duale, in <a href="/notes/tarjan-e-mcmf/">Tarjan e MCMF</a>.</p>
<h3 id="corollari-di-dualit√†-2-">Corollari di dualit√† (2) üü©<a hidden class="anchor" aria-hidden="true" href="#corollari-di-dualit√†-2-">#</a></h3>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Programmazione lineare/Untitled 10.png" alt="image/universita/ex-notion/Programmazione lineare/Untitled 10">
</li>
</ul>
<ol>
<li>il fatto che ci sia un bound a x, implica che se x √® illimitato, non posso avere il bound!</li>
<li>Abbiamo una condizione di ottimalit√† delle soluzioni trovate!</li>
</ol>
<h3 id="def-direzioni-ammissibili">Def Direzioni ammissibili<a hidden class="anchor" aria-hidden="true" href="#def-direzioni-ammissibili">#</a></h3>
<p>Vogliamo trovare un modo per muoverci e trovare ancora una direzione ottimale!</p>
<p><strong>Def:</strong></p>
<p>un vettore $\varepsilon \in \R ^n$ √® una <strong>direzione ammissibile</strong> se esiste  $\bar{\lambda}  > 0$ tale che  $x(\lambda) = x +  \lambda \varepsilon$, per ogni $\lambda \in 0...\bar{\lambda}$</p>
<p><strong>Intuizione</strong></p>
<p>Ossia se possiamo spostarci di almeno un p√≤ verso la direzione che vogliamo!</p>
<h3 id="def-direzione-di-crescita">Def direzione di crescita<a hidden class="anchor" aria-hidden="true" href="#def-direzione-di-crescita">#</a></h3>
<p>Possiamo considerare una <strong>direzione di crescita</strong></p>
<p>$**\lambda  \iff cx(\lambda)  = c \bar{x} + \lambda c\varepsilon > c \bar{x} \iff c\varepsilon > 0**$</p>
<p>La cosa interessante √® che una direzione di crescita cresce <strong>indipendentemente dal punto</strong>, questo √® una propriet√† molto forte della programmazione lineare!</p>
<p>Questi due concetti sono molto utili perch√© una volta che abbiamo una <strong>direzione ammissibile e di crescita</strong> allora si pu√≤ verificare che si pu√≤ migliorare ancora la soluzione di x.</p>
<h3 id="suff-e-nec-per-direzione-ammissibile">Suff e nec per direzione ammissibile<a hidden class="anchor" aria-hidden="true" href="#suff-e-nec-per-direzione-ammissibile">#</a></h3>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Programmazione lineare/Untitled 11.png" alt="image/universita/ex-notion/Programmazione lineare/Untitled 11">
</li>
</ul>
<p>L&rsquo;idea principale per questa dimostrazione √® sui vincoli attivi, differenziare se una riga √® un vincolo attivo o meno. Se lo √® allora voglio che sia minore, altrimeni basta scegliere un intorno sufficientemente piccolo perch√© il vincolo √® stretto.</p>
<p>Da notare che se non √® un vincolo attivo allora ho una disuguaglianza stretta allora posso andare ad utilizzare cose di analisi</p>
<h3 id="ottimalit√†-del-punto">Ottimalit√† del punto<a hidden class="anchor" aria-hidden="true" href="#ottimalit√†-del-punto">#</a></h3>
<blockquote>
<p>Dato un punto $x$ ammissibile, questo punto √® ottimo sse non ci sono direzioni di crescita ammisibile</p>
</blockquote>
<p><strong>Intuizione sulla dimo</strong></p>
<p>‚Üí se √® gi√† ottimo allora se esistessa una direzione di crescita, si potrebbe far crescere ancora il nostro punto di ottimo, violando l‚Äôipotesi di ottimalit√†</p>
<p>‚ÜêSe non ho direzioni di crescita, supponendo per assurdo che non sia ottimo abbiamo allora possiamo trovare una direzione di crescita ammissibile, creando un assurdo, questa direzione la andiamo a trovare prendendo un punto ottimo e creando il vettore da questo punto a quello nostro iniziale.</p>
<ul>
<li>
<p>Dimostrazione dispense</p>
<p>!<img src="/images/notes/image/universita/ex-notion/Programmazione lineare/Untitled 12.png" alt="image/universita/ex-notion/Programmazione lineare/Untitled 12"></p>
</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/no-tags/">No-Tags</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Programmazione lineare on x"
            href="https://x.com/intent/tweet/?text=Programmazione%20lineare&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fprogrammazione-lineare%2f&amp;hashtags=no-tags">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Programmazione lineare on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fprogrammazione-lineare%2f&amp;title=Programmazione%20lineare&amp;summary=Programmazione%20lineare&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2fprogrammazione-lineare%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Programmazione lineare on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2fprogrammazione-lineare%2f&title=Programmazione%20lineare">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Programmazione lineare on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2fprogrammazione-lineare%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Programmazione lineare on whatsapp"
            href="https://api.whatsapp.com/send?text=Programmazione%20lineare%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2fprogrammazione-lineare%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Programmazione lineare on telegram"
            href="https://telegram.me/share/url?text=Programmazione%20lineare&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fprogrammazione-lineare%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Programmazione lineare on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Programmazione%20lineare&u=https%3a%2f%2fflecart.github.io%2fnotes%2fprogrammazione-lineare%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
