<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Top-down Parser | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="no-tags">
<meta name="description" content="Ripasso Prox: 60 Ripasso: May 23, 2023 Ultima modifica: June 11, 2023 3:00 PM Primo Abbozzo: November 11, 2022 3:47 PM Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ— Studi Personali: No
Elementi di ripasso Domande
Top-down Parser Top-down Algoritmo di parsing ðŸŸ© Slide
Questo si potrebbe considerare come algoritmo classico di parsing con non determinismo. (vado avanti, ed esploro tutto, senza look ahead).
Esempio di esecuzione
Commenti efficienza di sopra ðŸŸ© Ãˆ molto inefficiente, in particolare si potrebbe trovare una compessitÃ  esponenziale del tipo">
<meta name="author" content="Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="https://flecart.github.io/notes/top-down-parser/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/top-down-parser/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>




<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>
<script type="text/javascript" async
src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>





<script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-WW6NN2QGKF', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Top-down Parser" />
<meta property="og:description" content="Ripasso Prox: 60 Ripasso: May 23, 2023 Ultima modifica: June 11, 2023 3:00 PM Primo Abbozzo: November 11, 2022 3:47 PM Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ— Studi Personali: No
Elementi di ripasso Domande
Top-down Parser Top-down Algoritmo di parsing ðŸŸ© Slide
Questo si potrebbe considerare come algoritmo classico di parsing con non determinismo. (vado avanti, ed esploro tutto, senza look ahead).
Esempio di esecuzione
Commenti efficienza di sopra ðŸŸ© Ãˆ molto inefficiente, in particolare si potrebbe trovare una compessitÃ  esponenziale del tipo" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://flecart.github.io/notes/top-down-parser/" />
<meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png" />
<meta property="article:section" content="notes" />



<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png" />
<meta name="twitter:title" content="Top-down Parser"/>
<meta name="twitter:description" content="Ripasso Prox: 60 Ripasso: May 23, 2023 Ultima modifica: June 11, 2023 3:00 PM Primo Abbozzo: November 11, 2022 3:47 PM Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ— Studi Personali: No
Elementi di ripasso Domande
Top-down Parser Top-down Algoritmo di parsing ðŸŸ© Slide
Questo si potrebbe considerare come algoritmo classico di parsing con non determinismo. (vado avanti, ed esploro tutto, senza look ahead).
Esempio di esecuzione
Commenti efficienza di sopra ðŸŸ© Ãˆ molto inefficiente, in particolare si potrebbe trovare una compessitÃ  esponenziale del tipo"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Top-down Parser",
      "item": "https://flecart.github.io/notes/top-down-parser/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Top-down Parser",
  "name": "Top-down Parser",
  "description": "Ripasso Prox: 60 Ripasso: May 23, 2023 Ultima modifica: June 11, 2023 3:00 PM Primo Abbozzo: November 11, 2022 3:47 PM Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ— Studi Personali: No\nElementi di ripasso Domande\nTop-down Parser Top-down Algoritmo di parsing ðŸŸ© Slide\nQuesto si potrebbe considerare come algoritmo classico di parsing con non determinismo. (vado avanti, ed esploro tutto, senza look ahead).\nEsempio di esecuzione\nCommenti efficienza di sopra ðŸŸ© Ãˆ molto inefficiente, in particolare si potrebbe trovare una compessitÃ  esponenziale del tipo",
  "keywords": [
    "no-tags"
  ],
  "articleBody": "Ripasso Prox: 60 Ripasso: May 23, 2023 Ultima modifica: June 11, 2023 3:00 PM Primo Abbozzo: November 11, 2022 3:47 PM Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ— Studi Personali: No\nElementi di ripasso Domande\nTop-down Parser Top-down Algoritmo di parsing ðŸŸ© Slide\nQuesto si potrebbe considerare come algoritmo classico di parsing con non determinismo. (vado avanti, ed esploro tutto, senza look ahead).\nEsempio di esecuzione\nCommenti efficienza di sopra ðŸŸ© Ãˆ molto inefficiente, in particolare si potrebbe trovare una compessitÃ  esponenziale del tipo\n$O(b^{|w|})$ , con b il massimo numero di produzioni. (la produzione maggiore la espando sempre!)\nSlide\nSi puÃ² rendere molto piÃ¹ efficiente con un valore di lookahead.\nFirst e Follow Utilizzeremo il simbolo $ per segnalare la fine di una stringa, cosÃ¬ puÃ² godere della prefix property, che Ã¨ una cosa fondamentale per le DPDA, vedi Linguaggi Deterministici e DPDA.\nFirst intro ðŸŸ© Slide\nIn pratica Ã¨ un insieme che contiene i primi caratteri possibili per tutti! (ad ochio attento si puÃ² notare quanto sia importante per il lookahead, andiamo in pratica a considerare le produzioni che abbiano il simbolo di lookahead).\nEsempio di uso e in-uso di first\nCalcolo del first ðŸŸ© Interessante in questa parte lâ€™utilizzo dellâ€™insieme dei simboli annullabili che abbiamo descritto in Semplificazione grammatiche., sembra sia legata molto al first\nSlide\nLâ€™intuizione di maggior rilievo per questo algoritmo Ã¨ che in quel modo si sta facendo un or , unione fra tutti i simboli che sono annullabili.\nQuesto algoritmo si puÃ² estendere in modo quasi banale ai non terminali che non sono annullabili (perchÃ© basta prendere il primo carattere\nSlide che descrive per simboli non annullabili\nEsempi del calcolo del first\nFollow intro ðŸŸ©â€” Slide\nQuindi un terminale appartiene a follow terminale se puÃ² comparire dopo\nUna cosa particolare di questa definizione Ã¨ il terminale $.\nA volte ci puÃ² interessare sapere cosa viene dopo un non terminale annullabile cosÃ¬ possiamo decidere di annullarlo e tenere il prossimo.\nMini esempio\nCalcolo del follow ðŸŸ© Slide algo\nDa notare che per calcolare questa funzione abbiamo bisogno del first!\nEsempio 1\nEsempio 2\nGrammatiche LL(1) Tabella di parsing intro LL(1) ðŸŸ© Definizione\nHo una tabella che mappa (NT, T) â†’ produzione.\nIn pratica una tabella di parsing ci dÃ  una idea del modo in cui comportarci per ogni singolo input e ogni terminale, Ã¨ quindi fondamentale per capire in che modo espandersiâ€¦\nOssia se ho un NT sulla stack e vedo con lookahead 1 un terminale, allora provo a capire con quale produzione posso espandere.\nAlgoritmo per riempimento tabella ðŸŸ© Algoritmo calcolo della tabella\nSe il first di qualcosa che voglio mettere Ã¨ noto, allora Ã¨ easyâ€¦\nAltrimenti la metto per lâ€™intera riga.\nTh sui LL(1) (chiede molto) ðŸŸ© Definizione di grammatica LL(1)\nEnunciato e dimo\nLa dimostrazione di questo Ã¨ molti dalla costruzione della tabella di parsing. (in particolare lâ€™unici modi che ci importano per dimostrare se un linguaggio Ã¨ LL(1) Ã¨ questo oppure la costruzione della tabella d parsing).\nEsempio grammatica in forma sopra\nEsempio 2\nParser LL(1) ! ðŸŸ© Slide Algo pseudocodice\nLâ€™idea Ã¨ principalmente di utilizzare la tabella di parsing per capire quale produzione utilizzare quando ho un non terminale!\nQuanto ho terminali li poppo dalla pila (se non posso poppare ritorno errore) Quando ho non-terminali vado a guardare nella tabella, se non ho niente fallisco Alla fine se ho svuotato la pila e letto tutto sono molto felice. Esempio di parsing 1\nEsempio 2\nesempio 3\nTh. ling regolare â†’ generabile da LL(1) ðŸŸ¨- Dalla lezione 14 (credo)\nCon i teoremi espressi in Grammatiche Regolari, posso trasformare lâ€™espressione regolare in DFA e poi il dfa minimo in grammatica regolare da questo posso creare la grammatica LL1, vogliamo ora dire che possiamo sempre farlo (nel toggle câ€™Ã¨ il piccolo algoritmino utilizzato per creare la grammatica).\nDimo\nMini lemma:\nOgni grammatica regolare con solo produzioni $V \\implies aW$ e produzioni epsilon Ã¨ una grammatica LL(1)\nIl motivo Ã¨ che i first di ogni produzione di un non terminale sono diversi fra di loro, perchÃ© sono tutti parte dellâ€™alfabeto e sono unici. E i follow sono sempre stringa terminale, quindi per il teorema di caratterizzazione dei linguaggi LL(1), questo Ã¨ un linguaggio LL(k).\nSi puÃ² verificare che questo Ã¨ il tipo di grammatica che si estrae da un automa minimo, quindi il teorema Ã¨ soddisfatto.\nGrammatiche LL(k) Generalizzazione first follow e tabella ðŸŸ©- Slide\nIntuizione\nOra il first ha la concezione dei **primi k **, lettere che possono essere anche minori di k, nel caso in cui io abbia giÃ  una stringa terminale. Ma non posso avere minore di K se non Ã¨ terminale!!!!\nAllo stesso modo follow k sono i primi k caratteri che possono seguire il nostro non terminale.\nLa tabella Ã¨ generata esattamente nello stesso modo**,* solo che bisogna fare un pÃ² di attenzione alle colonne, che ora possono essere di dimensione molto maggiore rispetto alla dimensione dellâ€™alfabeto (potenze di esse, almeno potenzialmente, poi nella pratica io mi metto a storare quello che mi serve.\nEsempio di utilizzo di first e follow generali\nTeoremi (4) su LL(k) ðŸŸ¨ Slide\nQuesti teoremi ci danno una forte relazione fra\ngrammatica ambigua â†’ non Ã¨ LL(k) con questa anche la sua contronominale ricorsiva sinistra â†’ non LL(k) essere LL(k) â†’ essere un linguaggio libero deterministico â†’ Non ambigua esiste L deterministico tale che non ci sia G di class LL(k) (quindi i linguaggi LL(k) non bastano per avere tutti i linguaggi deterministici! Gerarchia classi di linguaggi LL(k) ðŸŸ© Slide\nQuello che si puÃ² osservare Ã¨ che ogni classe di linguaggio con k maggiore include quella con k minore. Il motivo intuitivo che non Ã¨ presente nella slide Ã¨ tipo: se posso riconoscerlo guardando una lettera piÃ¹ avanti, lo posso ancora fare guardandone 2 o piÃ¹â€¦\nSi puÃ² notare che non tutti i linguaggi liberi deterministici sono riconosciuti da linguaggi LL(k), si puÃ² osservare lâ€™esempio di sotto.\nLibero det not implies LL(k) ðŸŸ¨+ esempio Incompletezza dei linguagg LL(1)\nIn questo caso Ã¨ solamente enunciato che non si puÃ² modellare la grammatica cosÃ¬ trovata per renderla di classe LL(k).\nPerÃ² intuitivamente si puÃ² capire che avrei bisogni di un k infinito per poter scegliere fra le due produzioni, riesco sempre a trovare un k che non funzioniâ€¦\nEsercizio a caso\n",
  "wordCount" : "1041",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/top-down-parser/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;Â»&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Top-down Parser
    </h1>
    <div class="post-meta">5 min&nbsp;Â·&nbsp;Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#elementi-di-ripasso" aria-label="Elementi di ripasso">Elementi di ripasso</a></li>
                <li>
                    <a href="#top-down-parser" aria-label="Top-down Parser">Top-down Parser</a><ul>
                        
                <li>
                    <a href="#top-down" aria-label="Top-down">Top-down</a><ul>
                        
                <li>
                    <a href="#algoritmo-di-parsing-" aria-label="Algoritmo di parsing ðŸŸ©">Algoritmo di parsing ðŸŸ©</a></li>
                <li>
                    <a href="#commenti-efficienza-di-sopra-" aria-label="Commenti efficienza di sopra ðŸŸ©">Commenti efficienza di sopra ðŸŸ©</a></li></ul>
                </li>
                <li>
                    <a href="#first-e-follow" aria-label="First e Follow">First e Follow</a><ul>
                        
                <li>
                    <a href="#first-intro-" aria-label="First intro ðŸŸ©">First intro ðŸŸ©</a></li>
                <li>
                    <a href="#calcolo-del-first-" aria-label="Calcolo del first ðŸŸ©">Calcolo del first ðŸŸ©</a></li>
                <li>
                    <a href="#follow-intro-" aria-label="Follow intro ðŸŸ©â€”">Follow intro ðŸŸ©â€”</a></li>
                <li>
                    <a href="#calcolo-del-follow--" aria-label="Calcolo del follow  ðŸŸ©">Calcolo del follow  ðŸŸ©</a></li></ul>
                </li>
                <li>
                    <a href="#grammatiche-ll1" aria-label="Grammatiche LL(1)">Grammatiche LL(1)</a><ul>
                        
                <li>
                    <a href="#tabella-di-parsing-intro-ll1-" aria-label="Tabella di parsing intro LL(1) ðŸŸ©">Tabella di parsing intro LL(1) ðŸŸ©</a></li>
                <li>
                    <a href="#algoritmo-per-riempimento-tabella-" aria-label="Algoritmo per riempimento tabella ðŸŸ©">Algoritmo per riempimento tabella ðŸŸ©</a></li>
                <li>
                    <a href="#th-sui-ll1-chiede-molto-" aria-label="Th sui LL(1) (chiede molto) ðŸŸ©">Th sui LL(1) (chiede molto) ðŸŸ©</a></li>
                <li>
                    <a href="#parser-ll1--" aria-label="Parser LL(1) ! ðŸŸ©">Parser LL(1) ! ðŸŸ©</a></li>
                <li>
                    <a href="#th-ling-regolare--generabile-da-ll1---" aria-label="Th. ling regolare â†’ generabile da LL(1)  ðŸŸ¨-">Th. ling regolare â†’ generabile da LL(1)  ðŸŸ¨-</a></li></ul>
                </li>
                <li>
                    <a href="#grammatiche-llk" aria-label="Grammatiche LL(k)">Grammatiche LL(k)</a><ul>
                        
                <li>
                    <a href="#generalizzazione-first-follow-e-tabella--" aria-label="Generalizzazione first follow e tabella ðŸŸ©-">Generalizzazione first follow e tabella ðŸŸ©-</a></li>
                <li>
                    <a href="#teoremi-4-su-llk-" aria-label="Teoremi (4) su LL(k) ðŸŸ¨">Teoremi (4) su LL(k) ðŸŸ¨</a></li>
                <li>
                    <a href="#gerarchia-classi-di-linguaggi-llk-" aria-label="Gerarchia classi di linguaggi LL(k) ðŸŸ©">Gerarchia classi di linguaggi LL(k) ðŸŸ©</a></li>
                <li>
                    <a href="#libero-det-not-implies-llk-" aria-label="Libero det not implies LL(k) ðŸŸ¨&#43;">Libero det not implies LL(k) ðŸŸ¨+</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Ripasso Prox: 60
Ripasso: May 23, 2023
Ultima modifica: June 11, 2023 3:00 PM
Primo Abbozzo: November 11, 2022 3:47 PM
Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ—
Studi Personali: No</p>
<h1 id="elementi-di-ripasso">Elementi di ripasso<a hidden class="anchor" aria-hidden="true" href="#elementi-di-ripasso">#</a></h1>
<ul>
<li>
<p>Domande</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled.png" alt="image/universita/ex-notion/Top-down Parser/Untitled">
</li>
</ul>
<h1 id="top-down-parser">Top-down Parser<a hidden class="anchor" aria-hidden="true" href="#top-down-parser">#</a></h1>
<h2 id="top-down">Top-down<a hidden class="anchor" aria-hidden="true" href="#top-down">#</a></h2>
<h3 id="algoritmo-di-parsing-">Algoritmo di parsing ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#algoritmo-di-parsing-">#</a></h3>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 1.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 1">
</li>
</ul>
<p>Questo si potrebbe considerare come algoritmo classico di parsing con non determinismo. (vado avanti, ed esploro tutto, senza look ahead).</p>
<ul>
<li>
<p>Esempio di esecuzione</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 2.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 2">
</li>
</ul>
<h3 id="commenti-efficienza-di-sopra-">Commenti efficienza di sopra ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#commenti-efficienza-di-sopra-">#</a></h3>
<p>Ãˆ molto inefficiente, in particolare si potrebbe trovare una compessitÃ  esponenziale del tipo</p>
$O(b^{|w|})$
<p>, con b il massimo numero di produzioni. (la produzione maggiore la espando sempre!)</p>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 3.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 3">
</li>
</ul>
<p>Si puÃ² rendere molto piÃ¹ efficiente con un valore di lookahead.</p>
<h2 id="first-e-follow">First e Follow<a hidden class="anchor" aria-hidden="true" href="#first-e-follow">#</a></h2>
<p>Utilizzeremo il simbolo <strong>$</strong> per segnalare la fine di una stringa, cosÃ¬ puÃ² godere della prefix property, che Ã¨ una cosa fondamentale per le DPDA, vedi <a href="/notes/linguaggi-deterministici-e-dpda/">Linguaggi Deterministici e DPDA</a>.</p>
<h3 id="first-intro-">First intro ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#first-intro-">#</a></h3>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 4.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 4">
</li>
</ul>
<p>In pratica Ã¨ un insieme che contiene i primi caratteri possibili per tutti! (ad ochio attento si puÃ² notare quanto sia importante per il lookahead, andiamo in pratica a considerare le produzioni che abbiano il simbolo di lookahead).</p>
<ul>
<li>
<p>Esempio di uso e in-uso di first</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 5.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 5">
</li>
</ul>
<h3 id="calcolo-del-first-">Calcolo del first ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#calcolo-del-first-">#</a></h3>
<p>Interessante in questa parte lâ€™utilizzo dellâ€™insieme dei simboli annullabili che abbiamo descritto in <a href="/notes/semplificazione-grammatiche/">Semplificazione grammatiche</a>., sembra sia legata molto al first</p>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 6.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 6">
</li>
</ul>
<p>Lâ€™intuizione di maggior rilievo per questo algoritmo Ã¨ che in quel modo si sta facendo un <strong>or</strong> , unione fra tutti i simboli che sono annullabili.</p>
<p>Questo algoritmo si puÃ² estendere in modo quasi banale ai non terminali che non sono annullabili (perchÃ© basta prendere il primo carattere</p>
<ul>
<li>
<p>Slide che descrive per simboli non annullabili</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 7.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 7">
</li>
<li>
<p>Esempi del calcolo del first</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 8.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 8">
</li>
</ul>
<h3 id="follow-intro-">Follow intro ðŸŸ©â€”<a hidden class="anchor" aria-hidden="true" href="#follow-intro-">#</a></h3>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 9.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 9">
</li>
</ul>
<p>Quindi un terminale appartiene a follow terminale se puÃ² comparire dopo</p>
<p>Una cosa particolare di questa definizione Ã¨ il terminale $.</p>
<p>A volte ci puÃ² interessare sapere cosa viene dopo un non terminale <strong>annullabile</strong> cosÃ¬ possiamo decidere di annullarlo e tenere il prossimo.</p>
<ul>
<li>
<p>Mini esempio</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 10.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 10">
</li>
</ul>
<h3 id="calcolo-del-follow--">Calcolo del follow  ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#calcolo-del-follow--">#</a></h3>
<ul>
<li>
<p>Slide algo</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 11.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 11">
</li>
</ul>
<p>Da notare che per calcolare questa funzione abbiamo bisogno del first!</p>
<ul>
<li>
<p>Esempio 1</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 12.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 12">
</li>
<li>
<p>Esempio 2</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 13.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 13">
</li>
</ul>
<h2 id="grammatiche-ll1">Grammatiche LL(1)<a hidden class="anchor" aria-hidden="true" href="#grammatiche-ll1">#</a></h2>
<h3 id="tabella-di-parsing-intro-ll1-">Tabella di parsing intro LL(1) ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#tabella-di-parsing-intro-ll1-">#</a></h3>
<ul>
<li>
<p>Definizione</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 14.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 14">
</li>
</ul>
<p>Ho una tabella che mappa (NT, T) â†’ produzione.</p>
<p>In pratica una tabella di parsing ci dÃ  una idea del modo in cui comportarci per ogni singolo input e ogni terminale, Ã¨ quindi fondamentale per capire in che modo espandersiâ€¦</p>
<p>Ossia se ho un NT sulla stack e vedo con lookahead 1 un terminale, allora provo a capire con quale produzione posso espandere.</p>
<h3 id="algoritmo-per-riempimento-tabella-"><strong>Algoritmo per riempimento tabella</strong> ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#algoritmo-per-riempimento-tabella-">#</a></h3>
<ul>
<li>
<p>Algoritmo calcolo della tabella</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 15.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 15">
</li>
</ul>
<p>Se il first di qualcosa che voglio mettere Ã¨ noto, allora Ã¨ easyâ€¦</p>
<p>Altrimenti la metto per lâ€™intera riga.</p>
<h3 id="th-sui-ll1-chiede-molto-">Th sui LL(1) (chiede molto) ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#th-sui-ll1-chiede-molto-">#</a></h3>
<ul>
<li>
<p>Definizione di grammatica LL(1)</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 16.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 16">
</li>
<li>
<p>Enunciato e dimo</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 17.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 17">
</li>
</ul>
<p>La dimostrazione di questo Ã¨ molti dalla costruzione della tabella di parsing. (in particolare l&rsquo;unici modi che ci importano per dimostrare se un linguaggio Ã¨ LL(1) Ã¨ questo oppure la costruzione della tabella d parsing).</p>
<ul>
<li>
<p>Esempio grammatica in forma sopra</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 18.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 18">
</li>
<li>
<p>Esempio 2</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 19.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 19">
</li>
</ul>
<h3 id="parser-ll1--">Parser LL(1) ! ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#parser-ll1--">#</a></h3>
<ul>
<li>
<p>Slide Algo pseudocodice</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 20.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 20">
</li>
</ul>
<p>Lâ€™idea Ã¨ principalmente di utilizzare la tabella di parsing per capire quale produzione utilizzare quando ho un non terminale!</p>
<ol>
<li>Quanto ho terminali li poppo dalla pila (se non posso poppare ritorno errore)</li>
<li>Quando ho non-terminali vado a guardare nella tabella, se non ho niente fallisco</li>
<li>Alla fine se ho svuotato la pila e letto tutto sono molto felice.</li>
</ol>
<ul>
<li>
<p>Esempio di parsing 1</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 21.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 21">
</li>
<li>
<p>Esempio 2</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 22.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 22">
</li>
<li>
<p>esempio 3</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 23.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 23">
</li>
</ul>
<h3 id="th-ling-regolare--generabile-da-ll1---">Th. ling regolare â†’ generabile da LL(1)  ðŸŸ¨-<a hidden class="anchor" aria-hidden="true" href="#th-ling-regolare--generabile-da-ll1---">#</a></h3>
<img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 24.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 24">
<p>Dalla lezione 14 (credo)</p>
<p>Con i teoremi espressi in <a href="/notes/grammatiche-regolari/">Grammatiche Regolari</a>, posso trasformare lâ€™espressione regolare in DFA e poi il dfa minimo in <strong>grammatica regolare</strong> da questo posso creare la grammatica LL1, vogliamo ora dire che possiamo sempre farlo (nel toggle câ€™Ã¨ il piccolo algoritmino utilizzato per creare la grammatica).</p>
<ul>
<li>
<p>Dimo</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 25.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 25">
</li>
</ul>
<p><strong>Mini lemma:</strong></p>
<blockquote>
<p>Ogni grammatica regolare con solo produzioni </p>
$V \implies aW$
<p>  e produzioni epsilon Ã¨ una grammatica LL(1)</p>
</blockquote>
<p>Il motivo Ã¨ che i first di ogni produzione di un non terminale sono diversi fra di loro, perchÃ© sono tutti parte dellâ€™alfabeto e sono unici. E i follow sono sempre stringa terminale, quindi per il teorema di caratterizzazione dei linguaggi LL(1), questo Ã¨ un linguaggio LL(k).</p>
<p>Si puÃ² verificare che questo Ã¨ il tipo di grammatica che si estrae da un automa minimo, quindi il teorema Ã¨ soddisfatto.</p>
<h2 id="grammatiche-llk">Grammatiche LL(k)<a hidden class="anchor" aria-hidden="true" href="#grammatiche-llk">#</a></h2>
<h3 id="generalizzazione-first-follow-e-tabella--">Generalizzazione first follow e tabella ðŸŸ©-<a hidden class="anchor" aria-hidden="true" href="#generalizzazione-first-follow-e-tabella--">#</a></h3>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 26.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 26">
</li>
</ul>
<p><strong>Intuizione</strong></p>
<p>Ora il first ha la concezione dei **primi k **, lettere che possono essere anche minori di k, nel caso in cui io abbia giÃ  una stringa terminale. Ma non posso avere minore di K se non Ã¨ terminale!!!!</p>
<p>Allo stesso modo follow k sono i primi k caratteri che possono seguire il nostro non terminale.</p>
<p>La tabella Ã¨ generata esattamente nello stesso modo**,* solo che bisogna fare un pÃ² di attenzione alle colonne, che ora possono essere di dimensione molto maggiore rispetto alla dimensione dellâ€™alfabeto (potenze di esse, almeno potenzialmente, poi nella pratica io mi metto a storare quello che mi serve.</p>
<ul>
<li>
<p>Esempio di utilizzo di first e follow generali</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 27.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 27">
</li>
</ul>
<h3 id="teoremi-4-su-llk-">Teoremi (4) su LL(k) ðŸŸ¨<a hidden class="anchor" aria-hidden="true" href="#teoremi-4-su-llk-">#</a></h3>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 28.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 28">
</li>
</ul>
<p>Questi teoremi ci danno una forte relazione fra</p>
<ol>
<li>grammatica ambigua â†’ non Ã¨ LL(k)  con questa anche la sua contronominale</li>
<li>ricorsiva sinistra â†’ non LL(k)</li>
<li>essere LL(k) â†’ essere un linguaggio libero deterministico â†’ Non ambigua</li>
<li>esiste L deterministico tale che non ci sia G di class LL(k) (quindi i linguaggi LL(k) non bastano per avere tutti i linguaggi deterministici!</li>
</ol>
<h3 id="gerarchia-classi-di-linguaggi-llk-">Gerarchia classi di linguaggi LL(k) ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#gerarchia-classi-di-linguaggi-llk-">#</a></h3>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 29.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 29">
</li>
</ul>
<p>Quello che si puÃ² osservare Ã¨ che ogni classe di linguaggio con k maggiore include quella con k minore. Il motivo intuitivo che non Ã¨ presente nella slide Ã¨ tipo: se posso riconoscerlo guardando una lettera piÃ¹ avanti, lo posso ancora fare guardandone 2 o piÃ¹â€¦</p>
<p>Si puÃ² notare che non tutti i linguaggi liberi deterministici sono riconosciuti da linguaggi LL(k), si puÃ² osservare l&rsquo;esempio di sotto.</p>
<h3 id="libero-det-not-implies-llk-">Libero det not implies LL(k) ðŸŸ¨+<a hidden class="anchor" aria-hidden="true" href="#libero-det-not-implies-llk-">#</a></h3>
<ul>
<li>
<p>esempio Incompletezza dei linguagg LL(1)</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 30.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 30">
</li>
</ul>
<p>In questo caso Ã¨ solamente enunciato che non si puÃ² modellare la grammatica cosÃ¬ trovata per renderla di classe LL(k).</p>
<p>PerÃ² intuitivamente si puÃ² capire che avrei bisogni di un k infinito per poter scegliere fra le due produzioni, riesco sempre a trovare un k che non funzioniâ€¦</p>
<ul>
<li>
<p>Esercizio a caso</p>
  <img src="/images/notes/image/universita/ex-notion/Top-down Parser/Untitled 31.png" alt="image/universita/ex-notion/Top-down Parser/Untitled 31"></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/no-tags/">No-Tags</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Top-down Parser on x"
            href="https://x.com/intent/tweet/?text=Top-down%20Parser&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2ftop-down-parser%2f&amp;hashtags=no-tags">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Top-down Parser on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2ftop-down-parser%2f&amp;title=Top-down%20Parser&amp;summary=Top-down%20Parser&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2ftop-down-parser%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Top-down Parser on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2ftop-down-parser%2f&title=Top-down%20Parser">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Top-down Parser on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2ftop-down-parser%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Top-down Parser on whatsapp"
            href="https://api.whatsapp.com/send?text=Top-down%20Parser%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2ftop-down-parser%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Top-down Parser on telegram"
            href="https://telegram.me/share/url?text=Top-down%20Parser&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2ftop-down-parser%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Top-down Parser on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Top-down%20Parser&u=https%3a%2f%2fflecart.github.io%2fnotes%2ftop-down-parser%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
