<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Architettura e livelli 1, 2 | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="🕸computer-networks">
<meta name="description" content="Perché a stack
Capire l’architettura significa capire la struttura (l’organizzazione) del nostro app e comprenderne i motivi (i sottoproblemi risolti) che ogni livello prova a risolvere
La soluzione che è stata individuata, e ha rappresentato uno dei principali cardini del successo delle reti e della nascita di Internet, è data dalla separazione delle classi di protocolli in livelli. La struttura dei livelli dei protocolli di rete prende il nome di architettura dei protocolli di rete.
Il concetto di architettura dei protocolli, suddivisa in livelli, è semplice ed è basato su alcune condizioni.">
<meta name="author" content="
By Xuanqiang Angelo Huang">
<link rel="canonical" href="https://flecart.github.io/notes/architettura-e-livelli-1-2/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f790d9af969c56c079c1ce2d5972a04486bf3d6144295d5fba319830e1e55a7a.css" integrity="sha256-95DZr5acVsB5wc4tWXKgRIa/PWFEKV1fujGYMOHlWno=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/architettura-e-livelli-1-2/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>
<script type="text/javascript" async
src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>






      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-WW6NN2QGKF');
        }
      </script><meta property="og:url" content="https://flecart.github.io/notes/architettura-e-livelli-1-2/">
  <meta property="og:site_name" content="X. Angelo Huang&#39;s Blog">
  <meta property="og:title" content="Architettura e livelli 1, 2">
  <meta property="og:description" content="Perché a stack Capire l’architettura significa capire la struttura (l’organizzazione) del nostro app e comprenderne i motivi (i sottoproblemi risolti) che ogni livello prova a risolvere
La soluzione che è stata individuata, e ha rappresentato uno dei principali cardini del successo delle reti e della nascita di Internet, è data dalla separazione delle classi di protocolli in livelli. La struttura dei livelli dei protocolli di rete prende il nome di architettura dei protocolli di rete. Il concetto di architettura dei protocolli, suddivisa in livelli, è semplice ed è basato su alcune condizioni.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="notes">
    <meta property="article:published_time" content="2024-08-28T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-08-28T00:00:00+00:00">
    <meta property="article:tag" content="🕸Computer-Networks">
      <meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:title" content="Architettura e livelli 1, 2">
<meta name="twitter:description" content="Perché a stack
Capire l’architettura significa capire la struttura (l’organizzazione) del nostro app e comprenderne i motivi (i sottoproblemi risolti) che ogni livello prova a risolvere
La soluzione che è stata individuata, e ha rappresentato uno dei principali cardini del successo delle reti e della nascita di Internet, è data dalla separazione delle classi di protocolli in livelli. La struttura dei livelli dei protocolli di rete prende il nome di architettura dei protocolli di rete.
Il concetto di architettura dei protocolli, suddivisa in livelli, è semplice ed è basato su alcune condizioni.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Architettura e livelli 1, 2",
      "item": "https://flecart.github.io/notes/architettura-e-livelli-1-2/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Architettura e livelli 1, 2",
  "name": "Architettura e livelli 1, 2",
  "description": "Perché a stack Capire l’architettura significa capire la struttura (l’organizzazione) del nostro app e comprenderne i motivi (i sottoproblemi risolti) che ogni livello prova a risolvere\nLa soluzione che è stata individuata, e ha rappresentato uno dei principali cardini del successo delle reti e della nascita di Internet, è data dalla separazione delle classi di protocolli in livelli. La struttura dei livelli dei protocolli di rete prende il nome di architettura dei protocolli di rete. Il concetto di architettura dei protocolli, suddivisa in livelli, è semplice ed è basato su alcune condizioni.\n",
  "keywords": [
    "🕸computer-networks"
  ],
  "articleBody": "Perché a stack Capire l’architettura significa capire la struttura (l’organizzazione) del nostro app e comprenderne i motivi (i sottoproblemi risolti) che ogni livello prova a risolvere\nLa soluzione che è stata individuata, e ha rappresentato uno dei principali cardini del successo delle reti e della nascita di Internet, è data dalla separazione delle classi di protocolli in livelli. La struttura dei livelli dei protocolli di rete prende il nome di architettura dei protocolli di rete. Il concetto di architettura dei protocolli, suddivisa in livelli, è semplice ed è basato su alcune condizioni.\nOgni livello\nSvolge determinate funzioni di gestione dei processi di comunicazione, attraverso uno o più protocolli alternativi. Fornisce un livello di astrazione più elevato della rete di comunicazione sottostante, sfruttando i servizi implementati dai livelli sottostanti. Ha relazioni dirette solo con i livelli immediatamente superiore e inferiore, attraverso richieste e servizi concordati, detti interfaccia del livello In altre parole, i livelli superiori non devono preoccuparsi di risolvere problemi che saranno gestiti e risolti dai livelli inferiori.\nLa cosa migliore per questa struttura è che se ho bisogni differenti posso individuare il livello che mi interessa e re-mplementare solo quanto ho bisogno, senza dover cambiare l’intera stack.\nEsempio architettura a livelli (fatta dal prof in persona e rubata da altri profzz, lel)\nSi ha un esempio di trasmissione e ricezione delle informazioni tramite questa metafora.\nOgni livello risolvere un problema preciso nella fase di trasmissione dell’informazione…\nLa cosa interessante è che dal livello di dichiarazione (o app) non si vede tutto il sotto, è come se magicamente fosse tradotto e presentato nella lingua corretta! Risolve un grande problema di complessità.\nVantaggi\nRiutilizzabilità di molti layers, basta cambiare cose di un singolo layer se ho bisogno di fare cose mie. Gli strati paritari si parlano astraendo tutto quanto avviene di sotto. Si potrebbe andare a parlare di encapsulation and data hiding cioè tutti i dati di un singolo livello sono isolati a quello e i dati sono solamenti di questo livello. Esposte sono solamente le relazioni, come si parla sopra. (facilita anche il debuggin per singolo LIVELLO)\nArchitettura standard (OSI) !!! Lo Standard ISO/OSI RM (International Organization for Standardization (ISO)/Open System Interconnection Reference Model) definisce un insieme di livelli completo e rigoroso per l’architettura dei protocolli di rete, prevedendo un livello per la gestione di ogni problema di comunicazione in rete.\nCiò che si va a standarizzare è l’interfaccia dei vari livelli. (API)*. Mentre l’implementazione di queste funzioni è lasciato a piacere, basta che soddisfi quello che deve fare. (Questo è ciò che permette la flessibilità di questra struttura). L’architettura dei protocolli di rete definita da ISO/OSI RM prevede sette livelli dei protocolli, numerati da 7 a 1 dall’alto al basso.\nil livello fisico si occupa di definire le tecniche di codifica dei dati, la trasmissione e la ricezione dei dati sul mezzo fisico di trasmissione (→ Fisica here). livello LLC/MAC si occupa di garantire l’affidabilità del mezzo di trasmissione e la gestione dell’accesso al mezzo trasmissivo ad accesso multiplo (evitando le collisioni). A questo livello il pacchetto si chiama FRAME. MAC (Media Access Control) è sotto. Inserisce gli indirizzi di destinatario e mittente (MAC) (spesso questi indirizzi sono solamente locali, per sapere a chi dare come step intermedio), forniti dal costruttore Decisione di quando trasmette (ad esempio può chiedere al livello fisico se il canale è libero o meno, e gestisce questa cosa col suo protocollo, quindi dilazionare il tempo di trasmissione) LLC (Logical link control) è sopra Verifica che non ci siano stati errori di trasmissione delle informazioni ricevute. Dire di inviare l’acknowledgement, se è il momento giusto. Gestire pacchetti duplicati. Il livello rete si occupa di frammentare i dati in pacchetti, scrivere gli indirizzi dei destinatari finali e instradare i pacchetti verso i destinatari intermedi del cammino. In questa sezione andiamo oltre alla rete locale, è qui che nasce internet vero! Il router è un elemento principale di questo. Frammentazione dei pacchetti Indirizzamento IP che servono a dare un identificativo alla scheda di rete in ambito locale per capire in quale direzione trasferire. Il livello trasporto si occupa di garantire i servizi di trasmissione dei pacchetti (orientati alla connessione e non) e del controllo della congestione della rete. Un esempio di protocollo a questo livello è il TCP(Trasmission Control Protocol). Che fa i controlli sull’acknowledgement e simili Potrebbe essere ch ealcuni router siano congestionati, quindi che droppino alcuni pacchetti Non è una soluzione dire agli altri router di inviare in modo più lento. (Dovrebbe essere il mittente che dovrebbe rallentare nell’invio di pacchetti, in modo che non si congestionano nessun nodo). Il livello sessione mantiene e gestisce lo stato attuale del collegamento tra due applicazioni remote. (quindi poter riprendere da un certo stato quando per un certo momento ti sconnetti). Di solito questo è gestito dall’applicazione, e non viene implementato. Il livello presentazione risolve eventuali eterogeneità del formato dei dati tra i nodi della rete. Perché i formati sono già leggibili, senza dover interpretare i bit per capire cosa rappresentano. Il livello applicazione fornisce alle applicazioni in esecuzione sul calcolatore i servizi e le primitive di trasmissione e ricezione dei dati. primitive che servono al processo di esecuzione per funzionare. es. funzione per mandare i dati e simli. Qui le funzioni possono essere moooltee Architettura dei protocolli di internet In questa sezione si tratta di come effettivamente quanto dell’architettura OSI è implementata\nL’architettura dei protocolli di Internet, nel senso più comunemente adottato, prevede di fatto l’implementazione di solo cinque livelli dei sette livelli dello Standard ISO/OSI RM. Rimangono spesso esclusi i livelli 5 (sessione) e 6 (presentazione), gli altri livelli sono uguali. Il motivo per cui succede è che principalmente questi livelli sono implementati a livello applicazione.\nUn aspetto che si pone in evidenza, è il concetto di incapsulamento dei dati tra i livelli implementati. In fase di trasmissione, ogni livello riceve dati dall’alto (dati spediti dall’applicazione) e li inserisce in “buste virtuali” (incapsulamento) ponendo in testa e in coda alcuni dati aggiuntivi, necessari per fornire al livello della controparte ricevente le informazioni utili all’implementazione del protocollo dello stesso livello. In fase di ricezione, ogni livello X riceve dal livello più basso i dati imbustati dallo stesso livello X sul trasmettitore, quindi verifica i dati della busta, agisce in conseguenza alle specifiche fornite nei dati della busta, e passa solo il contenuto della busta ai livelli superiori (decapsulamento). Il livello trasporto spezza i dati dell’applicazione in frammenti e li imbusta, aggiungendo informazioni utili all’ordinamento e al riassemblaggio dei dati ricevuti, oltre che al controllo della congestione della rete.\nIl livello rete frammenta ulteriormente i dati in pacchetti (se sono troppo lunghi), scrive l’indirizzo del destinatario sulla busta, e decide il cammino sul quale inviare il pacchetto a seconda dell’indirizzo di rete del destinatario.\nIl livello MAC/LLC esegue la consegna finale dei dati a dispositivi di una rete locale.\nLivelli ISO/OSI Livello fisico\nSono a livelli fisico perché devono avere lo stesso mezzo fisico (eg ethernet solo ethernet!, wifi solo wifi!)\nSegmento di rete Segmento di rete\nun mezzo di trasmissione condiviso con canale ad accesso multiplo, in cui tutte le schede collegate al segmento ricevono quanto trasmesso\nGli indirizzi MAC sono consapevoli dell’esistenza di questo mezzo di broadcast, con prima il destinatario, così lo legge subito.\nCollegarli tutti in un canale broadcast non è che sia molto buono\nRischio di collisioni molto alto Perdita di intensità dei segnali elettrici Principalmente spreco di tempo ed energie. Quindi abbiamo bisogno di modi per creare segmenti per risolvere questi problemi., che facciano cose intelligenti.\nIl segmento di rete è importante! Mini rete locale, è anche il modo in cui mando il pacchetto al router con source e destination.\nComposizione di segmenti di rete (4) Appunti prof di dispositivi per livello 1 e 2\nA questo punto esistono i presupposti per introdurre alcuni dispositivi che possono essere usati per comporre ed estendere una rete locale di calcolatori, unendo segmenti di rete altrimenti separati. Il primo dispositivo è il ripetitore (repeater). Siccome i segnali emessi su qualsiasi mezzo fisico si degradano al crescere della distanza percorsa, esiste un limite massimo per la lunghezza di un segmento di rete. Ad esempio, un segmento Ethernet, può variare dai 100 ai 200 metri. Un repeater è un dispositivo che agendo solo a livello fisico, amplifica e rigenera il segnale ricevuto verso un prolungamento del segmento di rete. Mediante un repeater è possibile collegare due segmenti di rete aventi la stessa tecnologia a livello MAC, ed estendere la lunghezza dei segmenti di rete locale. Un Hub (che significa perno di una ruota a raggi) è un altro dispositivo che agisce solo a livello fisico. Esso realizza il punto centrale di connessione, detto concentratore, dei segmenti di una rete locale con topologia a stella. In pratica si tratta di un ripetitore (repeater) con tante connessioni entranti e uscenti. Un Bridge (ponte) è invece un dispositivo che agisce anche da traduttore a livello due (MAC/LLC). Un bridge permette di connettere segmenti di una stessa rete locale ma con tecnologie e MAC diversi tra loro (ad esempio un segmento Ethernet con uno Token Ring). I bridge fanno quindi da traduttori dei frame nei formati richiesti dal livello MAC di ogni segmento connesso al bridge, e provvedono alla trasmissione su segmenti diversi adottando il protocollo MAC opportuno. I Bridge sono dotati della capacità di filtrare e instradare opportunamente i frame di dati sul segmento opportuno, osservando sui frame le informazioni di indirizzo MAC del dispositivo destinatario. Uno Switch (commutatore) è un dispositivo di livello due (MAC/LLC) analogo al bridge. Al contrario del bridge, esso permette di connettere un numero maggiore di segmenti diversi (fino a 10 o 12).\nRepeater\nRipetitori. I segnali trasmessi sul mezzo fisico degradano con la distanza, nella fattispecie l’ethernet degrada dopo circa 200 metri, quindi ogni 200 (o, meglio, 100) metri si aggiunge un ripetitore. Il ripetitore amplifica e rigenera il segnale ricevuto. Il repeater collega due segmenti di rete che hanno la stessa tecnologia MAC; non legge i dati, vede semplicemente che sta arrivando un segnale e lo amplifica e passa oltre. Con l’allungarsi delle distanze chiaramente le trasmissioni impiegano un po’ di tempo in più per viaggiare da mittente e destinatario, quindi nel caso di reti LAN più grandi diventa necessario allungare i tempi di timeout.\nHub\nÈ un repeater multiporta. È il nodo centrale di una rete a stella. Quando riceve un segnale da una porta lo copia e lo manda a tutti gli altri elementi della rete. È usato pochissimo in quanto costa poco meno dello switch, che però offre più funzionalità e porte.\nBridge\nhub ripete tutto quanto ha avuto a tutti quanti sono collegati, ma ha il problema grosso delle collisioni\nSwitch\nConnette tecnologie omogenee.\nriesce a filtrare e inviare i frame al segmento giusto. Quindi si comporta come un hub quando non sa dove andare, ma riesce ad ascoltare gli segmenti e vedere se è libero, se è libero manda, e se torna l’ACK allora aggiorna la propria tabella dei segmenti che mappa il MAC con il segmento corretto.\nAppunti di bianchi\nLavora a livello 2. A differenza del bridge permette di connettere molti più segmenti (oggi gli switch hanno anche 96 porte). Interconnette tecnologie omogenee, non diverse, e filtra i pacchetti da inoltrare a seconda della loro destinazione. Manda i dati in broadcast solo se non sa dov’è il destinatario. - Buffered switch: ha un buffer di memoria che ha la funzione di memorizzare tutti i frame che arrivano. Questo siccome la trasmissione deve essere smistata e non è automatica, ma segue le regole del protocollo MAC, può essere necessario che una trasmissione debba attendere il completamento di un’altra precedente.\nBridge\nFunziona come uno switch (quindi lavora a livello 2) ma connette tecnologie a livello locale con MAC protocol diversi (ad es. Ethernet e Wifi). Se riceve trasmissioni da un protocollo (ad es. Ethernet) e deve mandarle ad un altro protocollo (ad es. Wifi) prende il pacchetto, lo smembra e lo ricostruisce in un frame compatibile con l’altro protocollo (i dati cambiano la “busta gialla”).\nNote sui primi 2 livelli Livello fisico È il livello della scheda di rete, dei mezzi di trasmissione fisici, codifica e decodifica dei segnali in analogici e digitali.\nImportante in questa parte è il concetto di velocità del mezzo trasmissivo e velocità di trasmissione.\nLa velocità di trasmissione dipenda dalla durata del vagone, o della rappresentazione dei dati nel mezzo trasmissivo.\nAppunti prof Livello fisico I valori possibili per i dati digitali (bit) del calcolatore sono solo due: i valori 0 e 1. Tali valori devono essere trasmessi o ricevuti sui mezzi di trasmissione delle reti, sotto forma di variazioni di segnali analogici (elettrici, ottici o radio), uno di seguito all’altro. Per questo scopo, i dati digitali devono essere opportunamente codificati o decodificati, in sequenza, da parte della scheda di rete. L’attività di codifica, effettuata in fase di trasmissione, equivale a tradurre i valori dei bit in segnali analogici. L’attività di decodifica, effettuata in fase di ricezione, equivale a tradurre i segnali analogici ricevuti nei valori dei bit. Le tecniche di codifica digitali permettono di ridurre, ma non di escludere completamente, la possibilità di errori di trasmissione sulla rete. Una nota importante riguarda l’ambiguità di fondo sul concetto di velocità della trasmissione dei segnali in rete. Dal punto di vista fisico, tutti i segnali analogici, elettrici, ottici o radio, si propagano praticamente alla stessa velocità, cioè alla velocità della luce, pari a circa 300.000 Km/sec. Non ha quindi senso parlare di bit, oppure di segnali, più veloci di altri. Tuttavia, nell’esempio in figura, un canale A di comunicazione sul quale siano codificati dieci bit al secondo ha una densità di trasmissione dei bit (detta anche capacità del canale) pari alla metà della capacità ottenuta da un canale B, sul quale possano essere codificati venti bit al secondo. I canali a capacità più elevata, ovvero in grado di trasmettere più bit al secondo, devono tali prestazioni al fatto di usare meno tempo per codificare, ovvero rappresentare il valore del bit sul mezzo trasmissivo, rispetto a canali più “lenti”. Le migliori tecnologie di rete sono quelle che permettono di codificare i bit nel minor tempo possibile, ottenendo quindi alte capacità dei canali (ad esempio, miliardi di bit trasmessi al secondo). Livello di collegamento MAC\nCanale Mac di broadcast\nStruttura e utilizzo dell’indirizzo MAC\nPolicies generali per l’arbitraggio del canale per risolvere le collisioni.\nAppunti prof Livello Mac\nAnalizziamo ora l’esempio più semplice per la definizione di una rete di calcolatori a commutazione di pacchetto: un segmento di rete locale. Un segmento di rete locale è definito come un mezzo di trasmissione condiviso sul quale sia definito un canale ad accesso multiplo.\nOgni calcolatore si assume dotato della scheda di rete opportuna per il mezzo trasmissivo e i protocolli di codifica utilizzati al livello uno (fisico). Ogni scheda di rete è dotata di un identificativo (indirizzo) di livello MAC unico al mondo (assegnato dal costruttore). Ogni trasmissione di un pacchetto di dati (detto frame a questo livello) sul canale ad accesso multiplo è ricevuta da tutti i calcolatori la cui scheda di rete sia connessa al canale stesso. Immaginiamo che il dispositivo con indirizzo MAC1 voglia spedire un frame di dati al dispositivo con indirizzo MAC5, e allo stesso tempo il dispositivo di indirizzo MAC4 voglia spedire un frame di dati al dispositivo di indirizzo MAC2.\nNel contesto del canale condiviso, la conoscenza degli indirizzi MAC dei dispositivi mittente e destinatario basta ad effettuare la trasmissione, sul canale comune. Semplificando molto il problema, per ragioni di presentazione, è sufficiente aggiungere le informazioni sull’indirizzo MAC del destinatario e del mittente sulla busta di ogni frame, prima di trasmetterlo.\nOgni frame trasmesso sul canale da parte di ogni dispositivo risulta quindi rilevato da tutti gli altri dispositivi, ma viene ricevuto (cioè copiato e passato ai livelli superiori) solo se l’indirizzo MAC del destinatario specificato nel frame coincide con l’indirizzo MAC del dispositivo ricevente. Il compito principale dei protocolli di livello 2 (MAC/LLC), oltre all’indirizzamento dei frame trasmessi sul canale condiviso del segmento di rete locale, è dato dall’arbitraggio degli accessi al canale. Ossia\nDeterminare i nodi che possono trasmettre Quando possono trasmettere L’ordine di trasmissione per evitare collisioni LLC\nControllare se i dati sono corretti, o ricevuti doppi (se doppio o errato faccio finta di non averlo ricevuto). Mandare acknowledgment (che non succede col broadcast). Appunti prof affidabilità di questo livello (ACKs) Scopo dei protocolli del livello 2 (MAC/LLC) è nascondere ai livelli superiori i dettagli del mezzo fisico, e mostrare il canale condiviso sul segmento di rete locale come se si trattasse di un canale affidabile, senza alcun errore di trasmissione. A tal fine il frame di dati viene delimitato mediante particolari etichette di bit, poste all’inizio e alla fine del frame, e viene arricchito con altri campi di dati utili al protocollo. La trasmissione di un frame procede per tentativi, fino alla ricezione di una conferma (un frame di conferma) da parte del destinatario. Quello qui illustrato è solo un meccanismo semplice per realizzare trasmissione affidabile, tra quelli possibili. La figura mostra la sequenza temporale di eventi gestiti dal livello 2 (MAC/LLC) per la trasmissione affidabile di un frame di dati tra due dispositivi sulla stessa rete locale. Il frame di dati viene spedito dal dispositivo con indirizzo MAC1 al dispositivo con indirizzo MAC2 sul mezzo trasmissivo. Il mittente fa partire un timer dopo la trasmissione. Il ricevente MAC2 si accorge che il frame è destinato a lui, ma rileva errori sui bit ricevuti, per cui non fa nulla (non passa il frame ai livelli superiori) e non invia la conferma a MAC1. Allo scadere del timer, MAC1 verifica che non ha ricevuto conferma, per cui ripete da capo la trasmissione, e fa ripartire il timer. Questa volta MAC2 riceve correttamente il frame e spedisce a MAC1 un frame di conferma. MAC1 riceve il frame di conferma e solo ora considera terminata con successo la trasmissione del frame. Ai livelli dei protocolli superiori al livello due tutto ciò viene nascosto, e appare solamente la trasmissione corretta del frame sul segmento di rete. Collaborazione livelli per affidabilità (!!) Acknowledgement livello 4\nNon è sufficiente verificare che funzioni a livello 2, bisogna anche avere un ACK a livello 4 che sia end-to-end, così so sicuro che tutto il processo passo passo a livello MAC funziona, ossia sono riuscito effettivamente a raggiungere il destinatario.\nQuindi serve questo ack a livelli diversi e tempi diversi (uno fa end-to-end ack, l’altro fa ack ogni step). Ma l’ACK a livello 4 è necessario, perché il mittende deve sapere se sia ricevuto, mentre il livello 2 non sarebbe strettamente necessario, ma è molto probabile che vada male qualcosa a livello intermedio, e questo ACK riesce a risolvere problemi a questo livello ritrasmettendo.\nLivello 2 Evitare che un fallimento di singolo frame fallisca l’intera trasmissione a livello più alto (e quindi riuscire a recuperare molto più in fretta se viene perso a questo livello). Livello 4 Informare il mittente che l’informazione è stato ricevuto correttamente (quindi end-to-end). Caso di segmento faulty !\nNel caso in cui il livello MAC non riesce proprio a ricevere l’ACK, questo lo comunica al livello di Rete che ha una immagine della sua topologia di rete, e prova a creare un nuovo percorso per arrivare a destinazione. Si vede qua come avere più strare possibili per arrivare alla destinazione sia necessario.\nAlcune tecnologie di rete Ethernet Il più famoso è il protocollo Ethernet che da il nome a una vasta serie di schede di rete che implementano la sua definizione, per l’utilizzo in reti locali basate su mezzo fisico cablato. L’idea di base di Ethernet, per ridurre le collisioni dei segnali, è di adottare il principio dell’ascolto del canale, prima di ogni trasmissione (se vede che è occupato, viene rigenerato un tempo di attesa casuale). Se nessuno sta già trasmettendo, allora la trasmissione può essere iniziata senza collisione con le trasmissioni in atto. Siccome può accadere che due schede di rete possano iniziare allo stesso istante le rispettive trasmissioni, occorre trovare una soluzione all’insorgere di possibili collisioni. La scheda di rete trasmittente è in grado di rilevare le collisioni in atto durante la trasmissione, e in tal caso interrompe immediatamente il tentativo di trasmissione. Il tentativo verrà tentato da capo, dopo un attesa di tempo casuale, variabile da scheda a scheda.\nWifi Una tecnica simile a Ethernet viene adottata nelle reti senza fili (wireless), ad esempio in reti Wi-Fi conformi allo Standard IEEE 802.11. Il problema principale in reti senza fili è dato dall’impossibilità pratica di realizzare la rilevazione di collisioni in atto durante la fase di trasmissione. La tecnica si basa sulla prevenzione delle collisioni, dilazionando nel tempo i tentativi di accesso.\nToken Ring Il protocollo Token Ring è un protocollo MAC concepito per reti locali con topologia ad anello. L’accesso è regolato per mezzo di un frame speciale, detto Token, che viene passato (trasmesso), come se fosse un “testimone”, ciclicamente tra tutti i dispositivi in rete. Solo chi detiene il token ha diritto di trasmettere sul canale, evitando il rischio di collisione, dopodiché deve trasmettere il token alla stazione successiva nell’anello.\nLa cosa bella di questo è che la trasmissione è necessariamente senza collisioni dato che parla solo uno alla volta, questo è una cosa molto bella.\nUn altra cosa è acknowledgement implicito perché se il messaggio ritorna al mittente uguale, allora è OK. Potrei anche costruire comunicazioni a pochi bit, veloci (simili a voice over IP).\nSvantaggio\nNon ho modo di recuperare se\nPerdo il token (questo è una cosa molto grave!). Un host va giù, e viene rotto il link. (unique point of failure!) Note generali\nQueste reti si identificano tutte come best effort perché possono sempre non funzionare, causa collisioni o interferenze di rete\nEsempio di rete locale Appunti prof di boh La figura mostra un esempio di rete locale composta da diversi segmenti: un segmento con topologia ad anello e protocollo MAC di tipo token ring colorato in rosso e da vari segmenti ethernet, con topologia a stella e a bus, colorati in blu. A sinistra, un calcolatore dotato di dispositivo di rete token ring con indirizzo MAC A è connesso a un anello di rete token ring insieme ad altri 3 calcolatori e insieme a un bridge (oppure uno switch) identificato dal colore giallo (per indicare che agisce a livello MAC/LLC) e dalla lettera B sullo schermo. Il bridge B agisce da collegamento e traduttore dei frame tra il segmento token ring (rosso) ed il successivo segmento ethernet (blu). Il bridge B ha quindi due connettori di rete: uno token ring e uno ethernet. Il segmento ethernet del bridge B è connesso a un Hub (H) dal quale partono sei segmenti ethernet, di tipo punto a punto, verso altrettanti calcolatori. Uno di questi calcolatori, identificato dalla lettera R è un repeater, che propaga e amplifica i segnali verso un successivo segmento ethernet con topologia a bus, sul quale esistono quattro calcolatori. Al termine del bus esiste un nuovo repeater R, che propaga e amplifica i segnali verso un ultimo segmento ethernet con topologia a bus, al quale è collegato un calcolatore dotato di scheda ethernet con indirizzo MAC B. Al di sopra dei dispositivi citati viene rappresentato il cammino logico di un frame trasmesso dal calcolatore con MAC A al calcolatore con MAC B, passando per i segmenti, i connettori di rete, e i livelli dei protocolli opportuni. In particolare, il bridge B è l’unico elemento nel quale il frame trasmesso sul segmento token ring sale fino al livello 2, per essere tradotto e ritrasmesso sul segmento uscente adottando il nuovo protocollo MAC ethernet. Nei rimanenti dispositivi hub e repeater, i frame sono semplicemente ricevuti e ri-trasmessi sui segmenti uscenti. Se il bridge avesse dovuto connettere più di due segmenti diversi, allora si sarebbe utilizzato uno switch, che svolge l’attività del bridge gestendo più interfacce di rete e protocolli. Dovrebbe essere chiaro a questo punto come sia possibile connettere diversi segmenti di rete locale, e gestire la trasmissione di frame di dati tra due dispositivi qualsiasi di una rete locale, semplicemente identificando i dispositivi attraverso il loro indirizzo MAC. ",
  "wordCount" : "4059",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "2024-08-28T00:00:00Z",
  "dateModified": "2024-08-28T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang Angelo Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/architettura-e-livelli-1-2/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Architettura e livelli 1, 2
    </h1>
    <div class="post-meta"><span title='2024-08-28 00:00:00 +0000 UTC'>August 28, 2024</span>&nbsp;·&nbsp;Reading Time: 20 minutes&nbsp;·&nbsp;
By Xuanqiang Angelo Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul><ul>
                <li>
                    <a href="#perch%c3%a9-a-stack" aria-label="Perché a stack">Perché a stack</a></li>
                <li>
                    <a href="#architettura-standard-osi-" aria-label="Architettura standard (OSI) !!!">Architettura standard (OSI) !!!</a></li>
                <li>
                    <a href="#architettura-dei-protocolli-di-internet" aria-label="Architettura dei protocolli di internet">Architettura dei protocolli di internet</a></li></ul>
                    
                <li>
                    <a href="#livelli-isoosi" aria-label="Livelli ISO/OSI">Livelli ISO/OSI</a><ul>
                        
                <li>
                    <a href="#segmento-di-rete" aria-label="Segmento di rete">Segmento di rete</a></li>
                <li>
                    <a href="#composizione-di-segmenti-di-rete-4" aria-label="Composizione di segmenti di rete (4)">Composizione di segmenti di rete (4)</a></li></ul>
                </li>
                <li>
                    <a href="#note-sui-primi-2-livelli" aria-label="Note sui primi 2 livelli">Note sui primi 2 livelli</a><ul>
                        
                <li>
                    <a href="#livello-fisico" aria-label="Livello fisico">Livello fisico</a></li>
                <li>
                    <a href="#livello-di-collegamento" aria-label="Livello di collegamento">Livello di collegamento</a></li>
                <li>
                    <a href="#collaborazione-livelli-per-affidabilit%c3%a0-" aria-label="Collaborazione livelli per affidabilità (!!)">Collaborazione livelli per affidabilità (!!)</a></li>
                <li>
                    <a href="#alcune-tecnologie-di-rete" aria-label="Alcune tecnologie di rete">Alcune tecnologie di rete</a><ul>
                        
                <li>
                    <a href="#ethernet" aria-label="Ethernet">Ethernet</a></li>
                <li>
                    <a href="#wifi" aria-label="Wifi">Wifi</a></li>
                <li>
                    <a href="#token-ring" aria-label="Token Ring">Token Ring</a></li></ul>
                </li>
                <li>
                    <a href="#esempio-di-rete-locale" aria-label="Esempio di rete locale">Esempio di rete locale</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="perché-a-stack">Perché a stack<a hidden class="anchor" aria-hidden="true" href="#perché-a-stack">#</a></h3>
<p>Capire l’architettura significa capire la struttura (l’organizzazione) del nostro app e comprenderne i motivi (i sottoproblemi risolti) che ogni livello prova a risolvere</p>
<p>La soluzione che è stata individuata, e ha rappresentato uno dei principali cardini del successo delle reti e della nascita di Internet, è data dalla separazione delle classi di protocolli in livelli. La struttura dei livelli dei protocolli di rete prende il nome di architettura dei protocolli di rete.
Il concetto di architettura dei protocolli, suddivisa in livelli, è semplice ed è basato su alcune condizioni.</p>
<p>Ogni livello</p>
<ul>
<li>Svolge determinate funzioni di gestione dei processi di comunicazione, attraverso uno o più protocolli alternativi.</li>
<li>Fornisce un livello di astrazione più elevato della rete di comunicazione sottostante, sfruttando i servizi implementati dai livelli sottostanti.</li>
<li>Ha relazioni dirette solo con i livelli immediatamente superiore e inferiore, attraverso richieste e servizi concordati, detti interfaccia del livello</li>
</ul>
<p>In altre parole, i livelli superiori non devono preoccuparsi di risolvere problemi che saranno gestiti e risolti dai livelli inferiori.</p>
<p>La cosa migliore per questa struttura è che se ho bisogni differenti posso individuare il livello che mi interessa e <strong>re-mplementare solo quanto ho bisogno</strong>, senza dover cambiare l&rsquo;intera stack.</p>
<ul>
<li>
<p>Esempio architettura a livelli (fatta dal prof in persona e rubata da altri profzz, lel)</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura e livelli 1, 2/Untitled.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura e livelli 1, 2/Untitled">
<p>Si ha un esempio di trasmissione e ricezione delle informazioni tramite questa metafora.</p>
<p>Ogni livello risolvere un problema preciso nella fase di trasmissione dell’informazione…</p>
<p>La cosa interessante è che dal livello di dichiarazione (o app) non si vede tutto il sotto, è come se magicamente fosse tradotto e presentato nella lingua corretta! Risolve un grande problema di complessità.</p>
</li>
</ul>
<p><strong>Vantaggi</strong></p>
<ol>
<li>Riutilizzabilità di molti layers, basta cambiare cose di un singolo layer se ho bisogno di fare cose mie.</li>
<li>Gli strati paritari si parlano astraendo tutto quanto avviene di sotto.</li>
</ol>
<p>Si potrebbe andare a parlare di <strong>encapsulation and data hiding</strong> cioè tutti i dati di un singolo livello sono isolati a quello e i dati sono solamenti di questo livello. Esposte sono solamente le relazioni, come si parla sopra. (facilita anche il debuggin per singolo LIVELLO)</p>
<h3 id="architettura-standard-osi-">Architettura standard (OSI) !!!<a hidden class="anchor" aria-hidden="true" href="#architettura-standard-osi-">#</a></h3>
<pre><code>&lt;img src=&quot;/images/notes/image/universita/ex-notion/Architettura e livelli 1, 2/Untitled 1.png&quot; style=&quot;width: 100%&quot; class=&quot;center&quot; alt=&quot;image/universita/ex-notion/Architettura e livelli 1, 2/Untitled 1&quot;&gt;
</code></pre>
<p>Lo Standard <strong>ISO/OSI RM</strong> (International Organization for Standardization (ISO)/Open System Interconnection Reference Model) definisce un insieme di livelli completo e rigoroso per l’architettura dei protocolli di rete, prevedendo un livello per la gestione di ogni problema di comunicazione in rete.</p>
<p>Ciò che si va a standarizzare è <em><em>l&rsquo;interfaccia dei vari livelli</em>. (API)</em>*. Mentre l&rsquo;implementazione di queste funzioni è lasciato a piacere, basta che soddisfi quello che deve fare. (Questo è ciò che permette la <em>flessibilità</em> di questra struttura).
L’architettura dei protocolli di rete definita da ISO/OSI RM prevede sette livelli dei protocolli, numerati da 7 a 1 dall’alto al basso.</p>
<ol>
<li><strong>il livello fisico</strong> si occupa di definire le tecniche di codifica dei dati, la trasmissione e la ricezione dei dati sul mezzo fisico di trasmissione (→ <em>Fisica here</em>).</li>
<li><strong>livello LLC/MAC</strong> si occupa di garantire l’affidabilità del mezzo di trasmissione e la gestione dell’accesso al mezzo trasmissivo ad accesso multiplo (evitando le collisioni).
A questo livello il pacchetto si chiama <em>FRAME.</em>
<ol>
<li><em>MAC</em> (Media Access Control) è sotto.
<ol>
<li>Inserisce gli indirizzi di destinatario e mittente (MAC) (spesso questi indirizzi sono solamente locali, per sapere a chi dare come step intermedio), forniti dal costruttore</li>
<li>Decisione di quando trasmette (ad esempio può chiedere al livello fisico se il canale è libero o meno, e gestisce questa cosa col suo protocollo, quindi dilazionare il tempo di trasmissione)</li>
</ol>
</li>
<li><em>LLC</em> (Logical link control) è sopra
<ol>
<li>Verifica che non ci siano stati errori di trasmissione delle informazioni ricevute.</li>
<li>Dire di inviare l’acknowledgement, se è il momento giusto.</li>
<li>Gestire pacchetti duplicati.</li>
</ol>
</li>
</ol>
</li>
<li><strong>Il livello rete</strong> si occupa di frammentare i dati in pacchetti, scrivere gli indirizzi dei destinatari finali e instradare i pacchetti verso i destinatari intermedi del cammino.
In questa sezione andiamo oltre alla rete locale, è qui che nasce internet vero!
Il <a href="/notes/control-plane">router</a> è un elemento principale di questo.
<ol>
<li>Frammentazione dei pacchetti</li>
<li>Indirizzamento <em>IP</em> che servono a dare un identificativo alla scheda di rete in ambito locale per capire in quale direzione trasferire.</li>
</ol>
</li>
<li><strong>Il livello trasporto</strong> si occupa di garantire i servizi di trasmissione dei pacchetti (orientati alla connessione e non) e del controllo della congestione della rete.
Un esempio di protocollo a questo livello è il <em>TCP(Trasmission Control Protocol</em>). Che fa i controlli sull’acknowledgement e simili
<ol>
<li>Potrebbe essere ch ealcuni router siano congestionati, quindi che droppino alcuni pacchetti</li>
<li>Non è una soluzione dire agli altri router di inviare in modo più lento. (Dovrebbe essere il mittente che dovrebbe rallentare nell&rsquo;invio di pacchetti, in modo che non si congestionano nessun nodo).</li>
</ol>
</li>
<li><strong>Il livello sessione</strong> mantiene e gestisce lo stato attuale del collegamento tra due applicazioni remote. (quindi poter riprendere da un certo stato quando per un certo momento ti sconnetti).
Di solito questo è gestito dall’applicazione, e non viene implementato.</li>
<li><strong>Il livello presentazione</strong> risolve eventuali eterogeneità del formato dei dati tra i nodi della rete.
Perché i formati sono già leggibili, senza dover interpretare i bit per capire cosa rappresentano.</li>
<li><strong>Il livello applicazione</strong> fornisce alle applicazioni in esecuzione sul calcolatore i servizi e le primitive di trasmissione e ricezione dei dati. <em>primitive</em> che servono al processo di esecuzione per funzionare. es. funzione per mandare i dati e simli. Qui le funzioni possono essere moooltee</li>
</ol>
<h3 id="architettura-dei-protocolli-di-internet">Architettura dei protocolli di internet<a hidden class="anchor" aria-hidden="true" href="#architettura-dei-protocolli-di-internet">#</a></h3>
<p>In questa sezione si tratta di come effettivamente quanto dell&rsquo;architettura OSI è implementata</p>
<pre><code>&lt;img src=&quot;/images/notes/image/universita/ex-notion/Architettura e livelli 1, 2/Untitled 2.png&quot; style=&quot;width: 100%&quot; class=&quot;center&quot; alt=&quot;image/universita/ex-notion/Architettura e livelli 1, 2/Untitled 2&quot;&gt;
</code></pre>
<p>L’architettura dei protocolli di Internet, nel senso più comunemente adottato, prevede di fatto l’implementazione di solo cinque livelli dei sette livelli dello Standard ISO/OSI RM. Rimangono spesso esclusi i livelli 5 (sessione) e 6 (presentazione), gli altri livelli sono uguali. Il motivo per cui succede è che principalmente questi livelli sono implementati a livello applicazione.</p>
<p>Un aspetto che si pone in evidenza, è il concetto di <strong>incapsulamento dei dati</strong> tra i livelli implementati. In fase di trasmissione, ogni livello riceve dati dall’alto (dati spediti dall’applicazione) e li inserisce in “buste virtuali” (<strong>incapsulamento</strong>) ponendo in testa e in coda alcuni dati aggiuntivi, necessari per fornire al livello della controparte ricevente le informazioni utili all’implementazione del protocollo dello stesso livello. In fase di ricezione, ogni livello X riceve dal livello più basso i dati imbustati dallo stesso livello X sul trasmettitore, quindi verifica i dati della busta, agisce in conseguenza alle specifiche fornite nei dati della busta, e passa solo il contenuto della busta ai livelli superiori (<strong>decapsulamento</strong>).
Il livello trasporto spezza i dati dell’applicazione in frammenti e li imbusta, aggiungendo informazioni utili all’ordinamento e al riassemblaggio dei dati ricevuti, oltre che al controllo della congestione della rete.</p>
<p>Il livello rete frammenta ulteriormente i dati in pacchetti (se sono troppo lunghi), scrive l’indirizzo del destinatario sulla busta, e decide il cammino sul quale inviare il pacchetto a seconda dell’indirizzo di rete del destinatario.</p>
<p>Il livello MAC/LLC esegue la consegna finale dei dati a dispositivi di una rete locale.</p>
<h2 id="livelli-isoosi">Livelli ISO/OSI<a hidden class="anchor" aria-hidden="true" href="#livelli-isoosi">#</a></h2>
<p><strong>Livello fisico</strong></p>
<p>Sono a livelli fisico perché devono avere lo stesso mezzo fisico (eg ethernet solo ethernet!, wifi solo wifi!)</p>
<h3 id="segmento-di-rete">Segmento di rete<a hidden class="anchor" aria-hidden="true" href="#segmento-di-rete">#</a></h3>
<ul>
<li>
<p>Segmento di rete</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura e livelli 1, 2/Untitled 3.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura e livelli 1, 2/Untitled 3">
</li>
</ul>
<blockquote>
<p>un mezzo di trasmissione <em>condiviso</em> con canale ad accesso multiplo, in cui <strong>tutte</strong> le schede collegate al segmento ricevono quanto trasmesso</p></blockquote>
<p>Gli indirizzi MAC sono consapevoli dell&rsquo;esistenza di questo mezzo di broadcast, con prima il destinatario, così lo legge subito.</p>
<p>Collegarli tutti in un canale broadcast non è che sia molto buono</p>
<ol>
<li>Rischio di collisioni molto alto</li>
<li>Perdita di intensità dei segnali elettrici</li>
<li>Principalmente spreco di tempo ed energie.</li>
</ol>
<p>Quindi abbiamo bisogno di modi per creare segmenti per risolvere questi problemi., che facciano cose intelligenti.</p>
<p>Il segmento di rete è importante! Mini rete locale, è anche il modo in cui mando il pacchetto al router con source e destination.</p>
<h3 id="composizione-di-segmenti-di-rete-4">Composizione di segmenti di rete (4)<a hidden class="anchor" aria-hidden="true" href="#composizione-di-segmenti-di-rete-4">#</a></h3>
<ul>
<li>
<p>Appunti prof  di dispositivi per livello 1 e 2</p>
<p>A questo punto esistono i presupposti per introdurre alcuni dispositivi che possono essere usati per comporre ed estendere una rete locale di calcolatori, unendo segmenti di rete altrimenti separati.
Il primo dispositivo è il ripetitore (<strong>repeater</strong>). Siccome i segnali emessi su qualsiasi mezzo fisico si degradano al crescere della distanza percorsa, esiste un limite massimo per la lunghezza di un segmento di rete. Ad esempio, un segmento Ethernet, può variare dai 100 ai 200 metri. Un repeater è un dispositivo che agendo solo a livello fisico, amplifica e rigenera il segnale ricevuto
verso un prolungamento del segmento di rete. Mediante un repeater è possibile collegare due segmenti di rete aventi la stessa tecnologia a livello MAC, ed estendere la lunghezza dei segmenti di rete locale.
Un <strong>Hub</strong> (che significa perno di una ruota a raggi) è un altro dispositivo che agisce solo a livello fisico. Esso realizza il punto centrale di connessione, detto concentratore, dei segmenti di una rete locale con topologia a stella. In pratica si tratta di un ripetitore (repeater) con tante connessioni entranti e uscenti.
Un <strong>Bridge</strong> (ponte) è invece un dispositivo che agisce anche da traduttore a livello due (MAC/LLC). Un bridge permette di connettere segmenti di una stessa rete locale ma con tecnologie e MAC diversi tra loro (ad esempio un segmento Ethernet con uno Token Ring). I bridge fanno quindi da traduttori dei frame nei formati richiesti dal livello MAC di ogni segmento connesso al bridge, e provvedono alla trasmissione su segmenti diversi adottando il protocollo MAC opportuno.
I Bridge sono dotati della capacità di filtrare e instradare opportunamente i frame di dati sul segmento opportuno, osservando sui frame le informazioni di indirizzo MAC del dispositivo destinatario.
Uno <strong>Switch</strong> (commutatore) è un dispositivo di livello due (MAC/LLC) analogo al bridge. Al contrario del bridge, esso permette di connettere un numero maggiore di segmenti diversi (fino a 10 o 12).</p>
</li>
</ul>
<p><strong>Repeater</strong></p>
<p>Ripetitori. I segnali trasmessi sul mezzo fisico degradano con la distanza, nella fattispecie l’ethernet degrada dopo circa 200 metri, quindi ogni 200 (o, meglio, 100) metri si aggiunge un ripetitore. Il ripetitore <strong>amplifica</strong> e <strong>rigenera</strong> il segnale ricevuto. Il repeater collega due segmenti di rete che hanno la <em>stessa</em> tecnologia MAC; non legge i dati, vede semplicemente che sta arrivando un segnale e lo amplifica e passa oltre. Con l’allungarsi delle distanze chiaramente le trasmissioni impiegano un po’ di tempo in più per viaggiare da mittente e destinatario, quindi nel caso di reti LAN più grandi diventa necessario allungare i tempi di timeout.</p>
<p><strong>Hub</strong></p>
<p>È un repeater multiporta. È il nodo centrale di una rete a stella. Quando riceve un segnale da una porta lo copia e lo manda a tutti gli altri elementi della rete. È usato pochissimo in quanto costa poco meno dello switch, che però offre più funzionalità e porte.</p>
<p><strong>Bridge</strong></p>
<p><em>hub</em> ripete tutto quanto ha avuto a tutti quanti sono collegati, ma ha il problema grosso delle collisioni</p>
<p><strong>Switch</strong></p>
<p>Connette tecnologie omogenee.</p>
<p>riesce a filtrare e inviare i frame al segmento giusto. Quindi si comporta come un hub quando non sa dove andare, ma riesce ad <strong>ascoltare</strong> gli segmenti e vedere se è libero, se è libero manda, e se torna l’ACK allora aggiorna la propria <strong>tabella dei segmenti</strong> che mappa il MAC con il segmento corretto.</p>
<ul>
<li>
<p>Appunti di bianchi</p>
<p>Lavora a livello 2. A differenza del bridge permette di connettere molti più
segmenti (oggi gli switch hanno anche 96 porte). Interconnette tecnologie
omogenee, non diverse, e filtra i pacchetti da inoltrare a seconda della
loro destinazione. Manda i dati in broadcast solo se non sa dov’è il destinatario. - Buffered switch: ha un buffer di memoria che ha la funzione
di memorizzare tutti i frame che arrivano. Questo siccome la trasmissione
deve essere smistata e non è automatica, ma segue le regole del protocollo MAC, può essere necessario che una trasmissione debba attendere il
completamento di un’altra precedente.</p>
</li>
</ul>
<p><strong>Bridge</strong></p>
<p>Funziona come uno switch (quindi lavora a livello 2) ma connette tecnologie a livello locale con MAC protocol <strong>diversi</strong> (ad es. Ethernet e Wifi). Se riceve trasmissioni da un protocollo (ad es. Ethernet) e deve mandarle ad un altro protocollo (ad es. Wifi) prende il pacchetto, lo smembra e lo ricostruisce in un frame compatibile con l’altro protocollo (i dati cambiano la “busta gialla”).</p>
<h2 id="note-sui-primi-2-livelli">Note sui primi 2 livelli<a hidden class="anchor" aria-hidden="true" href="#note-sui-primi-2-livelli">#</a></h2>
<h3 id="livello-fisico">Livello fisico<a hidden class="anchor" aria-hidden="true" href="#livello-fisico">#</a></h3>
<img src="/images/notes/image/universita/ex-notion/Architettura e livelli 1, 2/Untitled 4.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura e livelli 1, 2/Untitled 4">
<p>È il livello della scheda di rete, dei mezzi di trasmissione fisici, codifica e decodifica dei segnali in analogici e digitali.</p>
<p>Importante in questa parte è il concetto di <strong>velocità del mezzo trasmissivo e velocità di trasmissione</strong>.</p>
<p>La velocità di trasmissione dipenda dalla durata del vagone, o della rappresentazione dei dati nel mezzo trasmissivo.</p>
<ul>
<li>Appunti prof Livello fisico
I valori possibili per i dati digitali (bit) del calcolatore sono solo due: i valori 0 e 1.
Tali valori devono essere trasmessi o ricevuti sui mezzi di trasmissione delle reti, sotto forma di variazioni di segnali analogici (elettrici, ottici o radio), uno di seguito all’altro.
Per questo scopo, i dati digitali devono essere opportunamente codificati o decodificati, in sequenza, da parte della scheda di rete.
L’attività di codifica, effettuata in fase di trasmissione, equivale a tradurre i valori dei bit in segnali analogici. L’attività di decodifica, effettuata in fase di ricezione, equivale a tradurre i segnali analogici ricevuti nei valori dei bit.
Le tecniche di codifica digitali permettono di ridurre, ma non di escludere completamente, la possibilità di errori di trasmissione sulla rete.
Una nota importante riguarda l’ambiguità di fondo sul concetto di velocità della trasmissione dei segnali in rete. Dal punto di vista fisico, tutti i segnali analogici, elettrici, ottici o radio, si propagano praticamente alla stessa velocità, cioè alla velocità della luce, pari a circa 300.000 Km/sec. Non ha quindi senso parlare di bit, oppure di segnali, più veloci di altri. Tuttavia, nell’esempio in figura, un canale A di comunicazione sul quale siano codificati dieci bit al secondo ha una <strong>densità di trasmissione</strong> dei bit (detta anche capacità del canale) pari alla metà della capacità ottenuta da un canale B, sul quale possano essere codificati venti bit al secondo. I canali a capacità più elevata, ovvero in grado di trasmettere più bit al secondo, devono tali prestazioni al fatto di usare meno tempo per codificare, ovvero rappresentare il valore del bit sul mezzo trasmissivo, rispetto
a canali più “lenti”.
Le migliori tecnologie di rete sono quelle che permettono di codificare i bit nel minor tempo possibile, ottenendo quindi alte capacità dei canali (ad esempio, miliardi di bit trasmessi al secondo).</li>
</ul>
<h3 id="livello-di-collegamento">Livello di collegamento<a hidden class="anchor" aria-hidden="true" href="#livello-di-collegamento">#</a></h3>
<p><strong>MAC</strong></p>
<ul>
<li>
<p>Canale Mac di broadcast</p>
</li>
<li>
<p>Struttura e utilizzo dell&rsquo;indirizzo MAC</p>
</li>
<li>
<p>Policies generali per l’arbitraggio del canale per risolvere le collisioni.</p>
</li>
<li>
<p>Appunti prof Livello Mac</p>
<p>Analizziamo ora l’esempio più semplice per la definizione di una rete di calcolatori a commutazione di pacchetto: un <strong>segmento di rete locale</strong>. Un segmento di rete locale è definito come un mezzo di trasmissione condiviso sul quale sia definito un canale ad accesso multiplo.</p>
<p>Ogni calcolatore si assume dotato della scheda di rete opportuna per il mezzo trasmissivo e i protocolli di codifica utilizzati al livello uno (fisico). Ogni scheda di rete è dotata di un identificativo (indirizzo) di livello MAC unico al mondo (assegnato dal costruttore). Ogni trasmissione di un pacchetto di dati (detto frame a questo livello) sul canale ad accesso multiplo è ricevuta da tutti i calcolatori la cui scheda di rete sia connessa al canale stesso.
Immaginiamo che il dispositivo con indirizzo MAC1 voglia spedire un frame di dati al dispositivo con indirizzo MAC5, e allo stesso tempo il dispositivo di indirizzo MAC4 voglia spedire un frame di dati al dispositivo di indirizzo MAC2.</p>
<p>Nel contesto del canale condiviso, la conoscenza degli indirizzi MAC dei dispositivi mittente e destinatario basta ad effettuare la trasmissione, sul canale comune. Semplificando molto il problema, per ragioni di presentazione, è sufficiente aggiungere le informazioni sull’indirizzo MAC del destinatario e del mittente sulla busta di ogni frame, prima di trasmetterlo.</p>
<p>Ogni frame trasmesso sul canale da parte di ogni dispositivo risulta quindi rilevato da tutti gli altri dispositivi, ma viene ricevuto (cioè copiato e passato ai livelli superiori) solo se l’indirizzo MAC del destinatario specificato nel frame coincide con l’indirizzo MAC del dispositivo ricevente.
Il compito principale dei protocolli di livello 2 (MAC/LLC), oltre all’indirizzamento dei frame trasmessi sul canale condiviso del segmento di rete locale, è dato dall’arbitraggio degli accessi al canale. Ossia</p>
<ol>
<li>Determinare i nodi che possono trasmettre</li>
<li>Quando possono trasmettere</li>
<li>L’ordine di trasmissione per evitare collisioni</li>
</ol>
</li>
</ul>
<p><strong>LLC</strong></p>
<img src="/images/notes/image/universita/ex-notion/Architettura e livelli 1, 2/Untitled 5.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura e livelli 1, 2/Untitled 5">
<ul>
<li>Controllare se i dati sono corretti, o ricevuti doppi (se doppio o errato faccio finta di non averlo ricevuto).</li>
<li>Mandare acknowledgment (che non succede col broadcast).</li>
<li>Appunti prof  affidabilità di questo livello (ACKs)
Scopo dei protocolli del livello 2 (MAC/LLC) è <em>nascondere</em> ai livelli superiori i dettagli del mezzo fisico, e mostrare il canale condiviso sul segmento di rete locale come se si trattasse di un canale affidabile, <strong>senza alcun errore di trasmissione</strong>. A tal fine il frame di dati viene delimitato mediante particolari etichette di bit, poste all’inizio e alla fine del frame, e viene arricchito con altri campi di dati utili al protocollo.
La trasmissione di un frame procede per tentativi, fino alla <strong>ricezione di una conferma</strong> (un frame di conferma) da parte del destinatario. Quello qui illustrato è solo un meccanismo semplice per realizzare trasmissione affidabile, tra quelli possibili.
La figura mostra la sequenza temporale di eventi gestiti dal livello 2 (MAC/LLC) per la trasmissione affidabile di un frame di dati tra due dispositivi sulla stessa rete locale. Il frame di dati viene spedito dal dispositivo con indirizzo MAC1 al dispositivo con indirizzo MAC2 sul mezzo trasmissivo. Il mittente fa partire un timer dopo la trasmissione. Il ricevente MAC2 si accorge che il frame è destinato a lui, ma rileva errori sui bit ricevuti, per cui non fa nulla (non passa il frame ai livelli superiori) e non invia la conferma a MAC1. Allo scadere del timer, MAC1 verifica che non ha ricevuto conferma, per cui ripete da capo la trasmissione, e fa ripartire il timer. Questa volta MAC2 riceve correttamente il frame e spedisce a MAC1 un frame di conferma. MAC1 riceve il frame di conferma e solo ora considera terminata con successo la trasmissione del frame.
Ai livelli dei protocolli superiori al livello due tutto ciò viene nascosto, e appare solamente la trasmissione corretta del frame sul segmento di rete.</li>
</ul>
<h3 id="collaborazione-livelli-per-affidabilità-">Collaborazione livelli per affidabilità (!!)<a hidden class="anchor" aria-hidden="true" href="#collaborazione-livelli-per-affidabilità-">#</a></h3>
<ul>
<li>
<p>Acknowledgement livello 4</p>
  <img src="/images/notes/image/universita/ex-notion/Architettura e livelli 1, 2/Untitled 6.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Architettura e livelli 1, 2/Untitled 6">
</li>
</ul>
<p>Non è sufficiente verificare che funzioni a livello 2, bisogna anche avere un ACK a livello 4 che sia end-to-end, così so sicuro che tutto il processo passo passo a livello MAC funziona, ossia sono riuscito effettivamente a raggiungere il destinatario.</p>
<p>Quindi serve questo ack a livelli diversi e tempi diversi (uno fa end-to-end ack, l’altro fa ack ogni step). Ma l’ACK a livello 4 è necessario, perché il mittende deve sapere se sia ricevuto, mentre il livello 2 non sarebbe strettamente necessario, ma è molto probabile che vada male qualcosa a livello intermedio, e questo ACK riesce a risolvere problemi a questo livello ritrasmettendo.</p>
<ul>
<li>Livello 2 Evitare che un fallimento di singolo frame fallisca l’intera trasmissione a livello più alto (e quindi riuscire a recuperare molto più in fretta se viene perso a questo livello).</li>
<li>Livello 4 Informare il mittente che l’informazione è stato ricevuto correttamente (quindi end-to-end).</li>
</ul>
<p><strong>Caso di segmento faulty !</strong></p>
<p>Nel caso in cui il livello MAC non riesce proprio a ricevere l’ACK, questo lo comunica al livello di Rete che ha una immagine della sua topologia di rete, e prova a creare un nuovo percorso per arrivare a destinazione. Si vede qua come avere più strare possibili per arrivare alla destinazione sia necessario.</p>
<h3 id="alcune-tecnologie-di-rete">Alcune tecnologie di rete<a hidden class="anchor" aria-hidden="true" href="#alcune-tecnologie-di-rete">#</a></h3>
<h4 id="ethernet">Ethernet<a hidden class="anchor" aria-hidden="true" href="#ethernet">#</a></h4>
<p>Il più famoso è il protocollo <strong>Ethernet</strong> che da il nome a una vasta serie di schede di rete che implementano la sua definizione, per l’utilizzo in reti locali basate su mezzo fisico cablato.
L’idea di base di Ethernet, per ridurre le collisioni dei segnali, è di adottare il <strong>principio dell’ascolto</strong> del canale, prima di ogni trasmissione (se vede che è occupato, viene rigenerato un tempo di attesa casuale). Se nessuno sta già trasmettendo, allora la trasmissione può essere iniziata senza collisione con le trasmissioni in atto. Siccome può accadere che due schede di rete possano iniziare allo stesso istante le rispettive trasmissioni, occorre trovare una soluzione all’insorgere di possibili collisioni. La scheda di rete trasmittente è in grado di rilevare le collisioni in atto <em>durante</em> la trasmissione, e in tal caso interrompe immediatamente il tentativo di trasmissione.
Il tentativo verrà tentato da capo, dopo un attesa di tempo casuale, variabile da scheda a scheda.</p>
<h4 id="wifi">Wifi<a hidden class="anchor" aria-hidden="true" href="#wifi">#</a></h4>
<p>Una tecnica simile a Ethernet viene adottata nelle reti senza fili (wireless), ad esempio in reti <strong>Wi-Fi conformi allo Standard IEEE 802.11</strong>. Il problema principale in reti senza fili è dato dall’impossibilità pratica di realizzare la rilevazione di collisioni in atto durante la fase di trasmissione. La tecnica si basa sulla prevenzione delle collisioni, dilazionando nel tempo i tentativi di accesso.</p>
<h4 id="token-ring">Token Ring<a hidden class="anchor" aria-hidden="true" href="#token-ring">#</a></h4>
<p>Il protocollo <strong>Token Ring</strong> è un protocollo MAC concepito per reti locali con <em>topologia ad anello</em>.
L’accesso è regolato per mezzo di un frame speciale, detto Token, che viene passato (trasmesso), come se fosse un “<em>testimone</em>”, ciclicamente tra tutti i dispositivi in rete. Solo chi detiene il token ha diritto di trasmettere sul canale, evitando il rischio di collisione, dopodiché deve trasmettere il token alla stazione successiva nell’anello.</p>
<p>La cosa bella di questo è che la trasmissione è necessariamente senza collisioni dato che parla solo uno alla volta, questo è una cosa molto bella.</p>
<p>Un altra cosa è acknowledgement implicito perché se il messaggio ritorna al mittente uguale, allora è OK. Potrei anche costruire comunicazioni a pochi bit, veloci (simili a voice over IP).</p>
<p><strong>Svantaggio</strong></p>
<p>Non ho modo di recuperare se</p>
<ol>
<li>Perdo il token (questo è una cosa molto grave!).</li>
<li>Un host va giù, e viene rotto il link. (unique point of failure!)</li>
</ol>
<p><strong>Note generali</strong></p>
<p>Queste reti si identificano tutte come best effort perché possono sempre non funzionare, causa collisioni o interferenze di rete</p>
<h3 id="esempio-di-rete-locale">Esempio di rete locale<a hidden class="anchor" aria-hidden="true" href="#esempio-di-rete-locale">#</a></h3>
<ul>
<li>Appunti prof di boh
La figura mostra un esempio di rete locale composta da diversi segmenti: un segmento con topologia ad anello e protocollo MAC di tipo token ring colorato in rosso e da vari segmenti ethernet, con topologia a stella e a bus, colorati in blu. A sinistra, un calcolatore dotato di dispositivo di rete token ring con indirizzo MAC A è connesso a un anello di rete token ring insieme ad altri 3 calcolatori e insieme a un bridge (oppure uno switch) identificato dal colore giallo (per indicare che agisce a livello MAC/LLC) e dalla lettera B sullo schermo. Il bridge B agisce da collegamento e traduttore dei frame tra il segmento token ring (rosso) ed il successivo segmento ethernet (blu). Il bridge B ha quindi due connettori di rete: uno token ring e uno ethernet. Il segmento ethernet del bridge B è connesso a un Hub (H) dal quale partono sei segmenti ethernet, di tipo punto a punto, verso altrettanti calcolatori. Uno di questi calcolatori, identificato dalla lettera R è un repeater, che propaga e amplifica i segnali verso un
successivo segmento ethernet con topologia a bus, sul quale esistono quattro calcolatori. Al termine del bus esiste un nuovo repeater R, che propaga e amplifica i segnali verso un ultimo segmento ethernet con topologia a bus, al quale è collegato un calcolatore dotato di scheda ethernet con indirizzo MAC B. Al di sopra dei dispositivi citati viene rappresentato il cammino logico di un frame trasmesso dal calcolatore con MAC A al calcolatore con MAC B, passando per i segmenti, i connettori di rete, e i livelli dei protocolli opportuni. In particolare, il bridge B
è l’unico elemento nel quale il frame trasmesso sul segmento token ring sale fino al livello 2, per essere tradotto e ritrasmesso sul segmento uscente adottando il nuovo protocollo MAC ethernet. Nei rimanenti dispositivi hub e repeater, i frame sono semplicemente ricevuti e ri-trasmessi sui segmenti uscenti. Se il bridge avesse dovuto connettere più di due segmenti diversi, allora si sarebbe utilizzato uno switch, che svolge l’attività del bridge gestendo più interfacce di rete e protocolli. Dovrebbe essere chiaro a questo punto come sia possibile connettere diversi segmenti di rete locale, e gestire la trasmissione di frame di dati tra due dispositivi qualsiasi di una rete locale, semplicemente identificando i dispositivi attraverso il loro indirizzo
MAC.</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/computer-networks/">🕸Computer-Networks</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Architettura e livelli 1, 2 on x"
            href="https://x.com/intent/tweet/?text=Architettura%20e%20livelli%201%2c%202&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-e-livelli-1-2%2f&amp;hashtags=%f0%9f%95%b8computer-networks">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Architettura e livelli 1, 2 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-e-livelli-1-2%2f&amp;title=Architettura%20e%20livelli%201%2c%202&amp;summary=Architettura%20e%20livelli%201%2c%202&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-e-livelli-1-2%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Architettura e livelli 1, 2 on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-e-livelli-1-2%2f&title=Architettura%20e%20livelli%201%2c%202">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Architettura e livelli 1, 2 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-e-livelli-1-2%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Architettura e livelli 1, 2 on whatsapp"
            href="https://api.whatsapp.com/send?text=Architettura%20e%20livelli%201%2c%202%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-e-livelli-1-2%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Architettura e livelli 1, 2 on telegram"
            href="https://telegram.me/share/url?text=Architettura%20e%20livelli%201%2c%202&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-e-livelli-1-2%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Architettura e livelli 1, 2 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Architettura%20e%20livelli%201%2c%202&u=https%3a%2f%2fflecart.github.io%2fnotes%2farchitettura-e-livelli-1-2%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
