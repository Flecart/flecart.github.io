<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Central Processing Unit (CPU) | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="üèõcomputer-architecture">
<meta name="description" content="La struttura moderna degli elaboratori sono basati principalmente sull&rsquo;architettura di Von Neuman, l&rsquo;unica differenza √® che gli elementi di questa architettura.
Struttura e funzione della CPU
La CPU si pu√≤ dividere in tre parti principali:

Una unit√† di controllo che coordina i processi
Registri che immagazzinano temporaneamente piccole quantit√† di informazioni
ALU che fa i calcoli ordinategli dalla CPU

Registri Principali

Program Counter o Instruction Pointer

Contiene un pointer all&rsquo;istruzione da eseguire cos√¨ lo prende dalla memoria


Instruction Register

Contiene l&rsquo;istruzione da eseguire


Memory Address Register

Prende l&rsquo;indirizzo del contenuto interessante dalla memoria


Memory Data Register

Prende il contenuto dalla memoria


Program Status Word

Raccoglie lo stato di esecuzione del programma, se fallisce se tutto ok oppure se ci sono errori



ALU
Aritmetic Logic Unit, √® la componente che fa i calcoli.
Per sapere cosa deve fare, √® la Control Unit che collega certe vie dai registri all&rsquo;ALU.
A seconda del genere di architettura pu√≤ collegarsi direttamente in memoria (CISC) oppure sempre passando per i registri (solitamente RISC)">
<meta name="author" content="Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="https://flecart.github.io/notes/central-processing-unit-cpu/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/central-processing-unit-cpu/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>
<script type="text/javascript" async
src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>






      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-WW6NN2QGKF');
        }
      </script><meta property="og:url" content="https://flecart.github.io/notes/central-processing-unit-cpu/">
  <meta property="og:site_name" content="X. Angelo Huang&#39;s Blog">
  <meta property="og:title" content="Central Processing Unit (CPU)">
  <meta property="og:description" content="La struttura moderna degli elaboratori sono basati principalmente sull‚Äôarchitettura di Von Neuman, l‚Äôunica differenza √® che gli elementi di questa architettura.
Struttura e funzione della CPU La CPU si pu√≤ dividere in tre parti principali:
Una unit√† di controllo che coordina i processi Registri che immagazzinano temporaneamente piccole quantit√† di informazioni ALU che fa i calcoli ordinategli dalla CPU Registri Principali Program Counter o Instruction Pointer Contiene un pointer all‚Äôistruzione da eseguire cos√¨ lo prende dalla memoria Instruction Register Contiene l‚Äôistruzione da eseguire Memory Address Register Prende l‚Äôindirizzo del contenuto interessante dalla memoria Memory Data Register Prende il contenuto dalla memoria Program Status Word Raccoglie lo stato di esecuzione del programma, se fallisce se tutto ok oppure se ci sono errori ALU Aritmetic Logic Unit, √® la componente che fa i calcoli. Per sapere cosa deve fare, √® la Control Unit che collega certe vie dai registri all‚ÄôALU. A seconda del genere di architettura pu√≤ collegarsi direttamente in memoria (CISC) oppure sempre passando per i registri (solitamente RISC)">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="notes">
    <meta property="article:tag" content="üèõComputer-Architecture">
      <meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:title" content="Central Processing Unit (CPU)">
<meta name="twitter:description" content="La struttura moderna degli elaboratori sono basati principalmente sull&rsquo;architettura di Von Neuman, l&rsquo;unica differenza √® che gli elementi di questa architettura.
Struttura e funzione della CPU
La CPU si pu√≤ dividere in tre parti principali:

Una unit√† di controllo che coordina i processi
Registri che immagazzinano temporaneamente piccole quantit√† di informazioni
ALU che fa i calcoli ordinategli dalla CPU

Registri Principali

Program Counter o Instruction Pointer

Contiene un pointer all&rsquo;istruzione da eseguire cos√¨ lo prende dalla memoria


Instruction Register

Contiene l&rsquo;istruzione da eseguire


Memory Address Register

Prende l&rsquo;indirizzo del contenuto interessante dalla memoria


Memory Data Register

Prende il contenuto dalla memoria


Program Status Word

Raccoglie lo stato di esecuzione del programma, se fallisce se tutto ok oppure se ci sono errori



ALU
Aritmetic Logic Unit, √® la componente che fa i calcoli.
Per sapere cosa deve fare, √® la Control Unit che collega certe vie dai registri all&rsquo;ALU.
A seconda del genere di architettura pu√≤ collegarsi direttamente in memoria (CISC) oppure sempre passando per i registri (solitamente RISC)">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Central Processing Unit (CPU)",
      "item": "https://flecart.github.io/notes/central-processing-unit-cpu/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Central Processing Unit (CPU)",
  "name": "Central Processing Unit (CPU)",
  "description": "La struttura moderna degli elaboratori sono basati principalmente sull\u0026rsquo;architettura di Von Neuman, l\u0026rsquo;unica differenza √® che gli elementi di questa architettura.\nStruttura e funzione della CPU La CPU si pu√≤ dividere in tre parti principali:\nUna unit√† di controllo che coordina i processi Registri che immagazzinano temporaneamente piccole quantit√† di informazioni ALU che fa i calcoli ordinategli dalla CPU Registri Principali Program Counter o Instruction Pointer Contiene un pointer all\u0026rsquo;istruzione da eseguire cos√¨ lo prende dalla memoria Instruction Register Contiene l\u0026rsquo;istruzione da eseguire Memory Address Register Prende l\u0026rsquo;indirizzo del contenuto interessante dalla memoria Memory Data Register Prende il contenuto dalla memoria Program Status Word Raccoglie lo stato di esecuzione del programma, se fallisce se tutto ok oppure se ci sono errori ALU Aritmetic Logic Unit, √® la componente che fa i calcoli. Per sapere cosa deve fare, √® la Control Unit che collega certe vie dai registri all\u0026rsquo;ALU. A seconda del genere di architettura pu√≤ collegarsi direttamente in memoria (CISC) oppure sempre passando per i registri (solitamente RISC)\n",
  "keywords": [
    "üèõcomputer-architecture"
  ],
  "articleBody": "La struttura moderna degli elaboratori sono basati principalmente sull‚Äôarchitettura di Von Neuman, l‚Äôunica differenza √® che gli elementi di questa architettura.\nStruttura e funzione della CPU La CPU si pu√≤ dividere in tre parti principali:\nUna unit√† di controllo che coordina i processi Registri che immagazzinano temporaneamente piccole quantit√† di informazioni ALU che fa i calcoli ordinategli dalla CPU Registri Principali Program Counter o Instruction Pointer Contiene un pointer all‚Äôistruzione da eseguire cos√¨ lo prende dalla memoria Instruction Register Contiene l‚Äôistruzione da eseguire Memory Address Register Prende l‚Äôindirizzo del contenuto interessante dalla memoria Memory Data Register Prende il contenuto dalla memoria Program Status Word Raccoglie lo stato di esecuzione del programma, se fallisce se tutto ok oppure se ci sono errori ALU Aritmetic Logic Unit, √® la componente che fa i calcoli. Per sapere cosa deve fare, √® la Control Unit che collega certe vie dai registri all‚ÄôALU. A seconda del genere di architettura pu√≤ collegarsi direttamente in memoria (CISC) oppure sempre passando per i registri (solitamente RISC)\nCentral Control Unit Il processore che decide cosa fare, se chiedere qualche altro pezzo dalla memoria seguendo il processo FDE Fetch Decode, Execute, oppure Scrivere qualcosa in memoria e cose simili.\nFilosofie Architetturali Complex Instructions Set Computer and Reduced Instructions Set Computer definiscono delle filosofie di architettura degli elaboratori differenti.\nCISC e microprogrammazione Utilizza una interpretazione che credo sia cosa a cui il prof. ha riferito come microprogrammazione, ovvero una programmazione delle istruzioni a livello molto basso.\nQuesto livello di interpretazione rallentava la macchina, perch√© non era direttamente eseguito sull‚Äôhardware. Inoltre la tendenza ad accedere direttamente la memoria **rendeva questo modello a volte imprevedibile in termini di tempo\nEsempio di microprogramma\nChiaro che se questo interamente fosse considerato una istruzione, ci sarebbe un alto bisogno di cicli di clock (diventarebbe in generale pi√π lento).\nRISC e peculiarit√† Una delle peculiarit√† principali delle architetture RISC √® il numero ridotto di istruzioni necessarie (che per√≤ erano molto veloci perch√© girava direttamente sull‚Äôhardware).\nInoltre ha introdotto un sistema load store con cui affacciarsi alla memoria.\nAlcuni confronti La filosofia attuale √® la RISC, per√≤ a causa della grande presenza di elaboratori CISC, si √® preferito creare architetture ibride che comprendano entrambi: presenza di istruzioni complesse che vengano eseguite su istruzioni harware di RISC. ‚Üí Minore ciclo di Clock e quindi maggiore velocit√†.\nLa differenza principale √® che CISC possiede istruzioni complesse molte dei quali vanno ad accedere la memoria (la parte lenta del processo) invece la RISC possiede soltanto i comandi load and store per accedere alla memoria, il resto delle istruzioni opera all‚Äôinterno del microprocessore.\nVelocit√† CPU Clock e Data Path Cycle Il significato di clock √® spiegato molto meglio nella sezione dei Circuiti Sequenziali\nClock √® tempo per l‚Äôistruzione pi√π corta, se fosse ancora pi√π corta √® molto probabile che la CPU verrebbe indotta in errori molto comuni per cui il computer non funzionerebbe pi√π (un istruzione viene eseguita quando il precedente non √® ancora finito).\nUna Data Path Cycle √® l‚Äôintero processo che comporta lettura dai registri, calcolo e registrazione del risultato\nAumentare la velocit√† Ci sono delle soluzioni per rendere la CPU pi√π veloce:\nMigliori reti elettriche (agli informatici non interessa) Overclocking (per un p√≤) Memoria cache (spesso in RISC) Multi-core Pipelining Parallelismo Esattamente come una linea di assemblaggio di fabbrica, possiamo definire alcune parti per processi specifici. Parallelismo Circa 3-4 volte pi√π veloce e poco costoso per crearlo, in quanto i pezzi sono efficienti, con pipeline di 5 sotto c‚Äô√® bisogno di una sola ALU a differenza di 5 per avere funzionalit√† simili.\nPipelining Spesso alcune istruzioni sono ottimizzate in termini di tempo nel caso sia presente la pipeline o meno, per cui √® interessante poter averlo a mente. Parallelismo livello istruzione\nEsempio:\n5 step.\nCarica l‚Äôistruzione Interpreta l‚Äôistruzione Fetch dei dati necessari Esecuzione dopo aver ricevuto i dati Scrittura del risultato. Ogni singola istruzione passa ogni volta secondo questa pipeline, che lavorano in parallelo, velocizzando il CHIP.\nMulticore - SIMD vs MIMD Ci sono dei computer moderni che contengono molteplici CPU uguali a quanto descritti in 3.1.1\nSIMD Single instruction-stream multiple data-stream *Istruzioni a dati diversi: Tutte le CPU hanno lo stesso stream di dati (magari elaborazione immagini, un qualcosa di ripetitivo su stessa cosa)\nSi guadagna in control unit, unica, fetch unica.\nEsistono anche i processori vettoriali.\nDi solito questo genere di architettura sono utili per istruzioni uguali a dati diversi come l‚Äôelaborazione di un immagine\nMIMD La differenza dal precedente √® che l‚Äôistruction stream √® multiplo, ma un p√≤ pi√π costoso perch√© ci sono molte CPU complete.\nAvere troppe CPU su una memoria condivisa non andrebbe bene, perch√© si dovrebbero aspettare. Meglio avere una rete fra CPU per cose grosse.\nCio√® se collegassi troppe CPU, probabilmente l‚Äôunico bus andrebbe in stallo perch√© tutti cercherebbero ad accedere alla stessa memoria, e le CPU dovrebbero attendersi fra di loro, cosa non buona per la performance.\nRete di Computer Una soluzione che si solito viene utilizzata dalle grandi aziende o comunque chi possiede le risorse √® la costruzione di grandi reti di calcolatori che possano operare all‚Äôunisono, o comunque con certo criterio. Dovrebbero essere un sacco di CPU separate che comunicano con un computer centrale che agisce come da Unit√† di Controllo.\nDi solito Multi-core e reti di computer sono conosiderati parallelismo a livello processore\nLe redi di computer sono solitamente facili da costruire ma difficile da programmare, mentre invece un multicore √® difficile da costruire ma facile da programmare.\nInvece il pipelining √® considerato un parallelismo a livello istruzione.\nPrefetch-istruzioni Questa cosa √® molto simile al prefetch della Memoria cache.\nInstruction Fetch Unit sono elementi di Hardware che caricano l‚Äôistruzione successiva nel momento in cui la presente √® in esecuzione.\nQuesto avviene perch√© il caricamento dell‚Äôistruzione √® spesso molto lenta.\nQuesta instruction cache prefecht pu√≤ essere implementata a due livelli, Hardware o software.\nPipeline (e salti) Esempio di pipeline\nL‚Äôesempio fatto qui √® gi√† considerabile come un primo passo di Pipeline, in cui molteplici passi possono essere fatti allo stesso momento dentro la CPU.\nSolamente la prima esecuzione servono 5-7 clock (a differenza delle parti), quindi basta un ciclo di clock per la fase pi√π lunga per essere sicuri, ecco che riusciamo a completare l‚Äôistruzione in modo molto pi√π veloce.\nSe una singola istruzione dovrebbe fare tutto, saremmo costretti a tenere un clock molto elevato e il computer nel complesso sarebbe molto lento.\nSalti Se faccio un salto allora c‚Äô√® un buco nel pipeline, ossia cose nel pipeline che non eseguono (perch√© devo saltare), cio√® fetch e decode di certe istruzioni non mi devono servire.\n(ho decodato una istruzione) ma nel frattempo ho gi√† caricato 4 e 5 che non mi servono!\nQuesto √® un aspetto principale per processori superscalari, vedi Adv.\nPredizione di salti Possiamo utilizzare certe euristiche (ragionamenti caso per caso) per predire alcuni salti.\nSalti all‚Äôindietro\nSi possono prevedere per cicli while e for dei salti all‚Äôindietro.\nPer salti incondizionati si pu√≤ mettere una instruzione NOP in modo che faccia salti incondizionati senza sprecare istruzioni.\nEsempio data race (read after write)\nAX = 0\nBX = 0\nDX = 0\nAX = DX + 1\nBX = AX - 1\nfetch a decode a, fetch b leggo DX (a) , decode b DX + 1 (a), leggo AX (b) MA STO LEGGENDO TROPPO PRESTO! Quindi devo chiudere AX ed aspettare che AX venga scritto\nA volte, tipico dei processori CISC, si tende a eseguire minicomandi in ordine diverso perch√© ritenuti pi√π efficienti, quindi si mischia un p√≤, proprio come intendi per combinatorio e la fai.\nEntra cisc ma esegue risc.\nEsiste una BPU¬†(Branch Prediction Unit), che cerca di predire l‚Äôesito di un salto, come spiegato in questa pagina di wiki e una BTP (Branch Target Predictor) che controlla le istruzioni nel ramo di arrivo (qui). Questi sono le componenti principali che determinano la predizione dei salti.\nIn alternativa si mettono dei NOP. o di arrivo (qui). Questi sono le componenti principali che determinano la predizione dei salti.\nIn alternativa si mettono dei NOP.\n",
  "wordCount" : "1338",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/central-processing-unit-cpu/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;¬ª&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Central Processing Unit (CPU)
    </h1>
    <div class="post-meta">7 min&nbsp;¬∑&nbsp;Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#struttura-e-funzione-della-cpu" aria-label="Struttura e funzione della CPU">Struttura e funzione della CPU</a><ul>
                        
                <li>
                    <a href="#registri-principali" aria-label="Registri Principali">Registri Principali</a></li>
                <li>
                    <a href="#alu" aria-label="ALU">ALU</a></li>
                <li>
                    <a href="#central-control-unit" aria-label="Central Control Unit">Central Control Unit</a></li></ul>
                </li>
                <li>
                    <a href="#filosofie-architetturali" aria-label="Filosofie Architetturali">Filosofie Architetturali</a><ul>
                        
                <li>
                    <a href="#cisc-e-microprogrammazione" aria-label="CISC e microprogrammazione">CISC e microprogrammazione</a></li>
                <li>
                    <a href="#risc-e-peculiarit%c3%a0" aria-label="RISC e peculiarit√†">RISC e peculiarit√†</a></li>
                <li>
                    <a href="#alcuni-confronti" aria-label="Alcuni confronti">Alcuni confronti</a></li></ul>
                </li>
                <li>
                    <a href="#velocit%c3%a0-cpu" aria-label="Velocit√† CPU">Velocit√† CPU</a><ul>
                        
                <li>
                    <a href="#clock-e-data-path-cycle" aria-label="Clock e Data Path Cycle">Clock e Data Path Cycle</a></li>
                <li>
                    <a href="#aumentare-la-velocit%c3%a0" aria-label="Aumentare la velocit√†">Aumentare la velocit√†</a></li></ul>
                </li>
                <li>
                    <a href="#parallelismo" aria-label="Parallelismo">Parallelismo</a><ul>
                        
                <li>
                    <a href="#pipelining" aria-label="Pipelining">Pipelining</a></li>
                <li>
                    <a href="#multicore---simd-vs-mimd" aria-label="Multicore - SIMD vs MIMD">Multicore - SIMD vs MIMD</a><ul>
                        
                <li>
                    <a href="#simd" aria-label="SIMD">SIMD</a></li>
                <li>
                    <a href="#mimd" aria-label="MIMD">MIMD</a></li></ul>
                </li>
                <li>
                    <a href="#rete-di-computer" aria-label="Rete di Computer">Rete di Computer</a></li>
                <li>
                    <a href="#prefetch-istruzioni" aria-label="Prefetch-istruzioni">Prefetch-istruzioni</a></li>
                <li>
                    <a href="#pipeline-e-salti" aria-label="Pipeline (e salti)">Pipeline (e salti)</a><ul>
                        
                <li>
                    <a href="#salti" aria-label="Salti">Salti</a></li></ul>
                </li>
                <li>
                    <a href="#predizione-di-salti" aria-label="Predizione di salti">Predizione di salti</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>La struttura moderna degli elaboratori sono basati principalmente sull&rsquo;<strong>architettura di Von Neuman,</strong> l&rsquo;unica differenza √® che gli elementi di questa architettura.</p>
<h2 id="struttura-e-funzione-della-cpu">Struttura e funzione della CPU<a hidden class="anchor" aria-hidden="true" href="#struttura-e-funzione-della-cpu">#</a></h2>
<p>La CPU si pu√≤ dividere in tre parti principali:</p>
<ul>
<li>Una unit√† di controllo che coordina i processi</li>
<li>Registri che immagazzinano temporaneamente piccole quantit√† di informazioni</li>
<li>ALU che fa i calcoli ordinategli dalla CPU</li>
</ul>
<h3 id="registri-principali">Registri Principali<a hidden class="anchor" aria-hidden="true" href="#registri-principali">#</a></h3>
<ul>
<li>Program Counter o Instruction Pointer
<ul>
<li>Contiene un pointer all&rsquo;istruzione da eseguire cos√¨ lo prende dalla memoria</li>
</ul>
</li>
<li>Instruction Register
<ul>
<li>Contiene l&rsquo;istruzione da eseguire</li>
</ul>
</li>
<li>Memory Address Register
<ul>
<li>Prende l&rsquo;indirizzo del contenuto interessante dalla memoria</li>
</ul>
</li>
<li>Memory Data Register
<ul>
<li>Prende il contenuto dalla memoria</li>
</ul>
</li>
<li>Program Status Word
<ul>
<li>Raccoglie lo stato di esecuzione del programma, se fallisce se tutto ok oppure se ci sono errori</li>
</ul>
</li>
</ul>
<h3 id="alu">ALU<a hidden class="anchor" aria-hidden="true" href="#alu">#</a></h3>
<p>Aritmetic Logic Unit, √® la componente che fa i calcoli.
Per sapere cosa deve fare, √® la Control Unit che collega certe vie dai registri all&rsquo;ALU.
A seconda del genere di architettura pu√≤ collegarsi direttamente in memoria (CISC) oppure sempre passando per i registri (solitamente RISC)</p>
<h3 id="central-control-unit">Central Control Unit<a hidden class="anchor" aria-hidden="true" href="#central-control-unit">#</a></h3>
<p>Il processore che decide cosa fare, se chiedere qualche altro pezzo dalla memoria seguendo il processo <strong>FDE</strong> Fetch Decode, Execute, oppure Scrivere qualcosa in memoria e cose simili.</p>
<img src="/images/notes/image/universita/ex-notion/CPU e storia degli elaboratori/Untitled.png" alt="image/universita/ex-notion/CPU e storia degli elaboratori/Untitled">
<h2 id="filosofie-architetturali">Filosofie Architetturali<a hidden class="anchor" aria-hidden="true" href="#filosofie-architetturali">#</a></h2>
<p>Complex Instructions Set Computer and Reduced Instructions Set Computer definiscono delle filosofie di architettura degli elaboratori differenti.</p>
<h3 id="cisc-e-microprogrammazione">CISC e microprogrammazione<a hidden class="anchor" aria-hidden="true" href="#cisc-e-microprogrammazione">#</a></h3>
<p>Utilizza una <strong>interpretazione</strong> che credo sia cosa a cui il prof. ha riferito come microprogrammazione, ovvero una programmazione delle istruzioni a livello molto basso.</p>
<p>Questo livello di interpretazione rallentava la macchina, perch√© non era direttamente eseguito sull&rsquo;hardware. Inoltre la tendenza ad accedere direttamente la memoria **rendeva questo modello a volte imprevedibile in termini di tempo</p>
<ul>
<li>
<p>Esempio di microprogramma</p>
  <img src="/images/notes/image/universita/ex-notion/CPU e storia degli elaboratori/Untitled 1.png" alt="image/universita/ex-notion/CPU e storia degli elaboratori/Untitled 1">
<p>Chiaro che se questo interamente fosse considerato una istruzione, ci sarebbe un alto bisogno di cicli di clock (diventarebbe in generale pi√π lento).</p>
</li>
</ul>
<h3 id="risc-e-peculiarit√†">RISC e peculiarit√†<a hidden class="anchor" aria-hidden="true" href="#risc-e-peculiarit√†">#</a></h3>
<p>Una delle peculiarit√† principali delle architetture RISC √® il numero ridotto di istruzioni necessarie (che per√≤ erano molto veloci perch√© girava direttamente sull&rsquo;hardware).</p>
<p>Inoltre ha introdotto un sistema <strong>load store</strong> con cui affacciarsi alla memoria.</p>
<img src="/images/notes/image/universita/ex-notion/CPU e storia degli elaboratori/Untitled 2.png" alt="image/universita/ex-notion/CPU e storia degli elaboratori/Untitled 2">
<h3 id="alcuni-confronti">Alcuni confronti<a hidden class="anchor" aria-hidden="true" href="#alcuni-confronti">#</a></h3>
<p>La filosofia attuale √® la RISC, per√≤ a causa della grande presenza di elaboratori CISC, si √® preferito <strong>creare architetture ibride</strong> che comprendano entrambi: presenza di istruzioni complesse che vengano eseguite su istruzioni harware di RISC. ‚Üí Minore ciclo di Clock e quindi maggiore velocit√†.</p>
<p>La differenza principale √® che <strong>CISC possiede istruzioni complesse</strong> molte dei quali vanno ad accedere la memoria (la parte lenta del processo) invece la <strong>RISC</strong> possiede soltanto i comandi load and store per accedere alla memoria, il resto delle istruzioni opera all&rsquo;interno del microprocessore.</p>
<h2 id="velocit√†-cpu">Velocit√† CPU<a hidden class="anchor" aria-hidden="true" href="#velocit√†-cpu">#</a></h2>
<h3 id="clock-e-data-path-cycle">Clock e Data Path Cycle<a hidden class="anchor" aria-hidden="true" href="#clock-e-data-path-cycle">#</a></h3>
<p>Il significato di clock √® spiegato molto meglio nella sezione dei <a href="/notes/circuiti-sequenziali/">Circuiti Sequenziali</a></p>
<p><strong>Clock</strong> √® tempo per l&rsquo;istruzione pi√π corta, se fosse ancora pi√π corta √® molto probabile che la CPU verrebbe indotta in errori molto comuni per cui il computer non funzionerebbe pi√π (un istruzione viene eseguita quando il precedente non √® ancora finito).</p>
<p>Una <strong>Data Path Cycle</strong> √® l&rsquo;intero processo che comporta lettura dai registri, calcolo e registrazione del risultato</p>
<h3 id="aumentare-la-velocit√†">Aumentare la velocit√†<a hidden class="anchor" aria-hidden="true" href="#aumentare-la-velocit√†">#</a></h3>
<p>Ci sono delle soluzioni per rendere la CPU pi√π veloce:</p>
<ul>
<li>Migliori reti elettriche (agli informatici non interessa)</li>
<li>Overclocking (per un p√≤)</li>
<li>Memoria cache (spesso in RISC)</li>
<li>Multi-core</li>
<li>Pipelining
<ul>
<li>Parallelismo
<ul>
<li>Esattamente come una linea di assemblaggio di fabbrica, possiamo definire alcune parti per processi specifici.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="parallelismo">Parallelismo<a hidden class="anchor" aria-hidden="true" href="#parallelismo">#</a></h2>
<p>Circa 3-4 volte pi√π veloce e poco costoso per crearlo, in quanto i pezzi sono efficienti, con pipeline di 5 sotto c&rsquo;√® bisogno di una sola ALU a differenza di 5 per avere funzionalit√† simili.</p>
<h3 id="pipelining">Pipelining<a hidden class="anchor" aria-hidden="true" href="#pipelining">#</a></h3>
<p>Spesso alcune istruzioni sono ottimizzate in termini di tempo nel caso sia presente la pipeline o meno, per cui √® interessante poter averlo a mente. Parallelismo livello istruzione</p>
<p><strong>Esempio:</strong></p>
<p>5 step.</p>
<ol>
<li>Carica l&rsquo;istruzione</li>
<li>Interpreta l&rsquo;istruzione</li>
<li>Fetch dei dati necessari</li>
<li>Esecuzione dopo aver ricevuto i dati</li>
<li>Scrittura del risultato.</li>
</ol>
<p>Ogni singola istruzione passa ogni volta secondo questa <strong>pipeline</strong>, che lavorano in parallelo, velocizzando il CHIP.</p>
<h3 id="multicore---simd-vs-mimd">Multicore - SIMD vs MIMD<a hidden class="anchor" aria-hidden="true" href="#multicore---simd-vs-mimd">#</a></h3>
<p>Ci sono dei computer moderni che contengono molteplici CPU uguali a quanto descritti in 3.1.1</p>
<h4 id="simd">SIMD<a hidden class="anchor" aria-hidden="true" href="#simd">#</a></h4>
<p><em>Single instruction-stream multiple data-stream</em>
*<em>Istruzioni a dati diversi:</em> Tutte le CPU hanno lo stesso stream di dati (magari elaborazione immagini, un qualcosa di ripetitivo su stessa cosa)</p>
<p>Si guadagna in control unit, unica, fetch unica.</p>
<p>Esistono anche i processori vettoriali.</p>
<img src="/images/notes/image/universita/ex-notion/CPU e storia degli elaboratori/Untitled 3.png" alt="image/universita/ex-notion/CPU e storia degli elaboratori/Untitled 3">
<p>Di solito questo genere di architettura sono utili per istruzioni uguali a dati diversi come l&rsquo;elaborazione di un immagine</p>
<h4 id="mimd">MIMD<a hidden class="anchor" aria-hidden="true" href="#mimd">#</a></h4>
<p>La differenza dal precedente √® che l&rsquo;istruction stream √® multiplo, ma un p√≤ pi√π costoso perch√© ci sono molte CPU complete.</p>
<p>Avere troppe CPU su una memoria condivisa non andrebbe bene, perch√© si dovrebbero aspettare. Meglio avere una rete fra CPU per cose grosse.</p>
<img src="/images/notes/image/universita/ex-notion/CPU e storia degli elaboratori/Untitled 4.png" alt="image/universita/ex-notion/CPU e storia degli elaboratori/Untitled 4">
<p>Cio√® se collegassi troppe CPU, probabilmente <strong>l&rsquo;unico bus andrebbe in stallo</strong> perch√© tutti cercherebbero ad accedere alla stessa memoria, e le CPU dovrebbero attendersi fra di loro, cosa non buona per la performance.</p>
<h3 id="rete-di-computer">Rete di Computer<a hidden class="anchor" aria-hidden="true" href="#rete-di-computer">#</a></h3>
<p>Una soluzione che si solito viene utilizzata dalle grandi aziende o comunque chi possiede le risorse √® la costruzione di grandi reti di calcolatori che possano operare all&rsquo;unisono, o comunque con certo criterio. Dovrebbero essere un sacco di CPU separate che comunicano con un computer centrale che agisce come da Unit√† di Controllo.</p>
<p>Di solito Multi-core e reti di computer sono conosiderati <strong>parallelismo a livello processore</strong></p>
<p>Le redi di computer sono solitamente facili da costruire ma difficile da programmare, mentre invece un multicore √® difficile da costruire ma facile da programmare.</p>
<p>Invece il pipelining √® considerato un <strong>parallelismo a livello istruzione</strong>.</p>
<h3 id="prefetch-istruzioni">Prefetch-istruzioni<a hidden class="anchor" aria-hidden="true" href="#prefetch-istruzioni">#</a></h3>
<p>Questa cosa √® molto simile al prefetch della <a href="/notes/memoria/">Memoria</a> cache.</p>
<p><strong>Instruction Fetch Unit</strong> sono elementi di Hardware che caricano l&rsquo;istruzione successiva nel momento in cui la presente √® in esecuzione.</p>
<p>Questo avviene perch√© il caricamento dell&rsquo;istruzione √® spesso molto lenta.</p>
<p>Questa instruction cache prefecht pu√≤ essere implementata a due livelli, Hardware o software.</p>
<img src="/images/notes/image/universita/ex-notion/CPU e storia degli elaboratori/Untitled 5.png" alt="image/universita/ex-notion/CPU e storia degli elaboratori/Untitled 5">
<h3 id="pipeline-e-salti">Pipeline (e salti)<a hidden class="anchor" aria-hidden="true" href="#pipeline-e-salti">#</a></h3>
<img src="/images/notes/image/universita/ex-notion/CPU e storia degli elaboratori/Untitled 6.png" alt="image/universita/ex-notion/CPU e storia degli elaboratori/Untitled 6">
<p>Esempio di pipeline</p>
<p>L&rsquo;esempio fatto <a href="/notes/qui">qui</a> √® gi√† considerabile come un primo passo di Pipeline, in cui molteplici passi possono essere fatti allo stesso momento dentro la CPU.</p>
<p>Solamente la prima esecuzione servono 5-7 clock (a differenza delle parti), quindi basta un ciclo di clock per la fase pi√π lunga per essere sicuri, ecco che riusciamo a completare l&rsquo;istruzione in modo molto pi√π veloce.</p>
<p>Se una singola istruzione dovrebbe fare tutto, saremmo costretti a tenere un clock molto elevato e il computer nel complesso sarebbe molto lento.</p>
<h4 id="salti">Salti<a hidden class="anchor" aria-hidden="true" href="#salti">#</a></h4>
<p>Se faccio un salto allora c&rsquo;√® un buco nel pipeline, ossia cose nel pipeline che non eseguono (perch√© devo saltare), cio√® fetch e decode di certe istruzioni non mi devono servire.</p>
<p>(ho decodato una istruzione) ma nel frattempo ho gi√† caricato 4 e 5 che non mi servono!</p>
<p>Questo √® un aspetto principale per processori superscalari, vedi <a href="/notes/adv/">Adv</a>.</p>
<h3 id="predizione-di-salti">Predizione di salti<a hidden class="anchor" aria-hidden="true" href="#predizione-di-salti">#</a></h3>
<p>Possiamo utilizzare certe euristiche (ragionamenti caso per caso) per predire alcuni salti.</p>
<p><strong>Salti all&rsquo;indietro</strong></p>
<p>Si possono prevedere per cicli while e for dei salti all&rsquo;indietro.</p>
<p>Per salti incondizionati si pu√≤ mettere una <strong>instruzione NOP</strong> in modo che faccia salti incondizionati senza sprecare istruzioni.</p>
<ul>
<li>
<p>Esempio data race (read after write)</p>
<p>AX = 0</p>
<p>BX = 0</p>
<p>DX = 0</p>
<p>AX = DX + 1</p>
<p>BX = AX - 1</p>
<ol>
<li>fetch a</li>
<li>decode a, fetch b</li>
<li>leggo DX (a) , decode b</li>
<li>DX + 1 (a), leggo AX (b) MA STO LEGGENDO TROPPO PRESTO!</li>
</ol>
<p>Quindi devo chiudere AX ed aspettare che AX venga scritto</p>
</li>
</ul>
<p>A volte, tipico dei processori CISC, si tende a eseguire minicomandi in ordine diverso perch√© ritenuti pi√π efficienti, quindi si mischia un p√≤, proprio come intendi per combinatorio e la fai.</p>
<p>Entra cisc ma esegue risc.</p>
<hr>
<p>Esiste una <strong>BPU</strong>¬†(<em>Branch Prediction Unit</em>), che cerca di predire l&rsquo;esito di un salto, come spiegato <a href="https://it.wikipedia.org/wiki/Predizione_delle_diramazioni">in questa pagina di wiki</a> e una <strong>BTP</strong> (<em>Branch Target Predictor)</em>  che controlla le istruzioni nel ramo di arrivo (<a href="https://it.wikipedia.org/wiki/Branch_target_predictor">qui</a>). Questi sono le componenti principali che determinano la predizione dei salti.</p>
<p>In alternativa si mettono dei NOP.
o di arrivo (<a href="https://it.wikipedia.org/wiki/Branch_target_predictor">qui</a>). Questi sono le componenti principali che determinano la predizione dei salti.</p>
<p>In alternativa si mettono dei NOP.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/computer-architecture/">üèõComputer-Architecture</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Central Processing Unit (CPU) on x"
            href="https://x.com/intent/tweet/?text=Central%20Processing%20Unit%20%28CPU%29&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fcentral-processing-unit-cpu%2f&amp;hashtags=%f0%9f%8f%9bcomputer-architecture">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Central Processing Unit (CPU) on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fcentral-processing-unit-cpu%2f&amp;title=Central%20Processing%20Unit%20%28CPU%29&amp;summary=Central%20Processing%20Unit%20%28CPU%29&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2fcentral-processing-unit-cpu%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Central Processing Unit (CPU) on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2fcentral-processing-unit-cpu%2f&title=Central%20Processing%20Unit%20%28CPU%29">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Central Processing Unit (CPU) on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2fcentral-processing-unit-cpu%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Central Processing Unit (CPU) on whatsapp"
            href="https://api.whatsapp.com/send?text=Central%20Processing%20Unit%20%28CPU%29%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2fcentral-processing-unit-cpu%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Central Processing Unit (CPU) on telegram"
            href="https://telegram.me/share/url?text=Central%20Processing%20Unit%20%28CPU%29&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fcentral-processing-unit-cpu%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Central Processing Unit (CPU) on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Central%20Processing%20Unit%20%28CPU%29&u=https%3a%2f%2fflecart.github.io%2fnotes%2fcentral-processing-unit-cpu%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span> ¬∑ 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
