<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Livello applicazione e socket | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="🕸computer-networks">
<meta name="description" content="Livello trasporto
Protocolli classici
Introduzione a TCP e UPD

Il quarto livello dei protocolli dell’architettura di Internet è il livello trasporto (transport), ed è basato su due protocolli in particolare: il Transmission Control Protocol (TCP) e lo User Data Protocol (UDP), che possono essere usati in alternativa tra loro.
Questo è nel genere di *connession oriented e non, il primo, TCP è connection oriented, l&rsquo;altro no, questa è l’unica differenza fra i due. Questa differenza è spiegata in maggior dettaglio qui [0.3.8 Servizi orientati alla connessione  e non">
<meta name="author" content="Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="https://flecart.github.io/notes/livello-applicazione-e-socket/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/livello-applicazione-e-socket/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>
<script type="text/javascript" async
src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>






      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-WW6NN2QGKF');
        }
      </script><meta property="og:url" content="https://flecart.github.io/notes/livello-applicazione-e-socket/">
  <meta property="og:site_name" content="X. Angelo Huang&#39;s Blog">
  <meta property="og:title" content="Livello applicazione e socket">
  <meta property="og:description" content="Livello trasporto Protocolli classici Introduzione a TCP e UPD Il quarto livello dei protocolli dell’architettura di Internet è il livello trasporto (transport), ed è basato su due protocolli in particolare: il Transmission Control Protocol (TCP) e lo User Data Protocol (UDP), che possono essere usati in alternativa tra loro.
Questo è nel genere di *connession oriented e non, il primo, TCP è connection oriented, l’altro no, questa è l’unica differenza fra i due. Questa differenza è spiegata in maggior dettaglio qui [0.3.8 Servizi orientati alla connessione e non">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="notes">
    <meta property="article:tag" content="🕸Computer-Networks">
      <meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:title" content="Livello applicazione e socket">
<meta name="twitter:description" content="Livello trasporto
Protocolli classici
Introduzione a TCP e UPD

Il quarto livello dei protocolli dell’architettura di Internet è il livello trasporto (transport), ed è basato su due protocolli in particolare: il Transmission Control Protocol (TCP) e lo User Data Protocol (UDP), che possono essere usati in alternativa tra loro.
Questo è nel genere di *connession oriented e non, il primo, TCP è connection oriented, l&rsquo;altro no, questa è l’unica differenza fra i due. Questa differenza è spiegata in maggior dettaglio qui [0.3.8 Servizi orientati alla connessione  e non">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Livello applicazione e socket",
      "item": "https://flecart.github.io/notes/livello-applicazione-e-socket/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Livello applicazione e socket",
  "name": "Livello applicazione e socket",
  "description": "Livello trasporto Protocolli classici Introduzione a TCP e UPD Il quarto livello dei protocolli dell’architettura di Internet è il livello trasporto (transport), ed è basato su due protocolli in particolare: il Transmission Control Protocol (TCP) e lo User Data Protocol (UDP), che possono essere usati in alternativa tra loro.\nQuesto è nel genere di *connession oriented e non, il primo, TCP è connection oriented, l\u0026rsquo;altro no, questa è l’unica differenza fra i due. Questa differenza è spiegata in maggior dettaglio qui [0.3.8 Servizi orientati alla connessione e non\n",
  "keywords": [
    "🕸computer-networks"
  ],
  "articleBody": "Livello trasporto Protocolli classici Introduzione a TCP e UPD Il quarto livello dei protocolli dell’architettura di Internet è il livello trasporto (transport), ed è basato su due protocolli in particolare: il Transmission Control Protocol (TCP) e lo User Data Protocol (UDP), che possono essere usati in alternativa tra loro.\nQuesto è nel genere di *connession oriented e non, il primo, TCP è connection oriented, l’altro no, questa è l’unica differenza fra i due. Questa differenza è spiegata in maggior dettaglio qui [0.3.8 Servizi orientati alla connessione e non\nTCP\nConnection oriented (garantire il ripristino dell’ordinamento dei pacchetti e la ri-trasmissione dei pacchetti perduti) Numero dell’ordine (a cui riceve ack per questo numero) Controllare la velocità di invio → Finestra scorrevole La parte importante di questo è che la congestione si può allargare a macchia d’olio all’interno di internet, e questo è una cosa molto brutta! Quindi prova a risolvere gli errori di comunicazione di rete, cercando di garantire una buona trasmissione. Il problema è l’efficienza, si possono inviare segmenti in più e congestionare la rete.\nSi può dire che questa è la semantica diversa.\nCon la tree-way handshake si apre una connessione socket, quindi una coppia porta IP, per poter comunicare!\nUDP\nÈ semplice perché non fa tutte le cose di TCP (no duplicati, no riordinamento, no checks) Tipo connectionless Socket Slide immagini\nIl protocollo TCP richiede a due dispositivi che intendano comunicare di effettuare preventivamente la configurazione dei parametri del socket TCP, originando in questo modo un canale virtuale di tipo punto a punto tra due socket, ovvero tra due applicazioni di livello superiore alle quali vengono smistati i pacchetti da TCP. Quindi sono degli estremi di comunicazione!\nDef socket\nUn socket è un punto di arrivo o partenza (virtuale) dei dati a livello trasporto, dal quale è in atto l’invio e la ricezione di pacchetti destinati a un’applicazione, ed equivale a una coppia: (indirizzo IP, numero di porta dell’applicazione). Una volta instaurata la configurazione punto a punto tra due socket, attraverso lo scambio di pacchetti di configurazione, può iniziare lo scambio dei dati a livello trasporto. In questo senso si dice che è un trasporto TCP/IP, perché prima configurazione per IP poi effettivamente scambio.\nLa richiesta di connessione\nLa connessione viene instaurata con una richiesta di uno dei due host (il client) nei confronti dell’host server.\nIndirizzo IP del server Numero della porta per l’applicazione (questo viene verificato dal server se qualche servizio ci è aperto, se sì risponde, e il client invia la configurazione). Poi iniziano a dialogare e alla fine liberano la porta, è una connessione punto a punto!. Quando il server riceve il pacchetto, va a verificare se ha la porta aperta, se tutto va bene manda un messaggio di conferma, e il client invia un pacchetto di configurazione, allora possono cominciare a comunicare.\nWelcoming socket and client sockets\nWelcoming è l’unico socket di ricezione di un server, che prende tutto e manda al thread corretto.\nClient sockets sono i molteplici sockets che il server utilizza per comunicare con il singolo client, vengono solitamente istanziati grazie al welcoming socket dopo che ho fatto richiesta di connessione.\nControllo della congestione TCP (2) Questa parte ora è trattata meglio in [[Livello di trasporto](/notes/0.3.8-servizi-orientati-alla-connessione–e-non-\ntcp\n1.-connection-oriented-(garantire-il-ripristino-dell’ordinamento-dei-pacchetti-e-la-ri-trasmissione-dei-pacchetti-perduti) 2.-numero-dell’ordine-(a-cui-riceve-ack-per-questo-numero) 3.-controllare-la-velocità-di-invio-→-finestra-scorrevole la-parte-importante-di-questo-è-che-la-congestione-si-può-allargare-a-macchia-d’olio-all-interno-di-internet,-e-questo-è-una-cosa-molto-brutta!\nquindi-prova-a-risolvere-gli-errori-di-comunicazione-di-rete,-cercando-di-garantire-una-buona-trasmissione.-il-problema-è-l-efficienza,-si-possono-inviare-segmenti-in-più-e-congestionare-la-rete.\nsi-può-dire-che-questa-è-la-semantica-diversa.\ncon-la-tree-way-handshake-si-apre-una-connessione-socket,-quindi-una-coppia-porta-ip,-per-poter-comunicare!\nudp\n1.-è-semplice-perché-non-fa-tutte-le-cose-di-tcp-(no-duplicati,-no-riordinamento,-no-checks) 2.-tipo-connectionless\n###-socket ",
  "wordCount" : "2652",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/livello-applicazione-e-socket/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Livello applicazione e socket
    </h1>
    <div class="post-meta">13 min&nbsp;·&nbsp;Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#livello-trasporto" aria-label="Livello trasporto">Livello trasporto</a><ul>
                        
                <li>
                    <a href="#protocolli-classici" aria-label="Protocolli classici">Protocolli classici</a><ul>
                        
                <li>
                    <a href="#introduzione-a-tcp-e-upd" aria-label="Introduzione a TCP e UPD">Introduzione a TCP e UPD</a></li>
                <li>
                    <a href="#socket" aria-label="Socket">Socket</a></li>
                <li>
                    <a href="#controllo-della-congestione-tcp-2" aria-label="Controllo della congestione TCP (2)">Controllo della congestione TCP (2)</a></li>
                <li>
                    <a href="#finestra-scorrevole" aria-label="Finestra scorrevole">Finestra scorrevole</a></li>
                <li>
                    <a href="#multiplexing-e-demultiplexing-e-porte" aria-label="Multiplexing e Demultiplexing e porte">Multiplexing e Demultiplexing e porte</a></li></ul>
                </li>
                <li>
                    <a href="#applicazione" aria-label="Applicazione">Applicazione</a><ul>
                        
                <li>
                    <a href="#introduzione-livello-applicazione-non-fo" aria-label="Introduzione livello applicazione (non fo)">Introduzione livello applicazione (non fo)</a></li>
                <li>
                    <a href="#http1-non-fare" aria-label="HTTP1 (non fare)">HTTP1 (non fare)</a></li>
                <li>
                    <a href="#domain-name-system" aria-label="Domain Name System">Domain Name System</a><ul>
                        
                <li>
                    <a href="#iterativoricorsivo" aria-label="Iterativo/Ricorsivo">Iterativo/Ricorsivo</a></li>
                <li>
                    <a href="#typosquatting-attack" aria-label="Typosquatting attack">Typosquatting attack</a></li></ul>
                </li>
                <li>
                    <a href="#sulla-connessione" aria-label="Sulla connessione">Sulla connessione</a></li>
                <li>
                    <a href="#architetture-a-livello-applicazione" aria-label="Architetture a livello applicazione">Architetture a livello applicazione</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="livello-trasporto">Livello trasporto<a hidden class="anchor" aria-hidden="true" href="#livello-trasporto">#</a></h1>
<h2 id="protocolli-classici">Protocolli classici<a hidden class="anchor" aria-hidden="true" href="#protocolli-classici">#</a></h2>
<h3 id="introduzione-a-tcp-e-upd">Introduzione a TCP e UPD<a hidden class="anchor" aria-hidden="true" href="#introduzione-a-tcp-e-upd">#</a></h3>
<img src="/images/notes/image/universita/ex-notion/Livello applicazione e socket/Untitled.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Livello applicazione e socket/Untitled">
<p>Il quarto livello dei protocolli dell’architettura di Internet è il livello trasporto (transport), ed è basato su due protocolli in particolare: il Transmission Control Protocol (<strong>TCP</strong>) e lo User Data Protocol (<strong>UDP</strong>), che possono essere usati in alternativa tra loro.</p>
<p>Questo è nel genere di *<em>connession oriented</em> e non, il primo, TCP è connection oriented, l&rsquo;altro no, questa è l’unica differenza fra i due. Questa differenza è spiegata in maggior dettaglio qui [0.3.8 Servizi orientati alla connessione  e non</p>
<p><strong>TCP</strong></p>
<ol>
<li>Connection oriented (garantire il ripristino dell’ordinamento dei pacchetti e la ri-trasmissione dei pacchetti perduti)</li>
<li><strong>Numero</strong> dell’ordine (a cui riceve ack per questo numero)</li>
<li>Controllare la velocità di invio → Finestra scorrevole
La parte importante di questo è che la congestione si può <strong>allargare a macchia d’olio</strong> all&rsquo;interno di internet, e questo è una cosa molto brutta!</li>
</ol>
<p>Quindi prova a risolvere gli errori di comunicazione di rete, cercando di garantire una buona trasmissione. Il problema è l&rsquo;efficienza, si possono inviare segmenti in più e <strong>congestionare la rete</strong>.</p>
<p>Si può dire che questa è la semantica diversa.</p>
<p>Con la <strong>tree-way handshake</strong> si apre una connessione socket, quindi una coppia porta IP, per poter comunicare!</p>
<p><strong>UDP</strong></p>
<ol>
<li>È semplice perché non fa tutte le cose di TCP (no duplicati, no riordinamento, no checks)</li>
<li>Tipo connectionless</li>
</ol>
<h3 id="socket">Socket<a hidden class="anchor" aria-hidden="true" href="#socket">#</a></h3>
<img src="/images/notes/image/universita/ex-notion/Livello applicazione e socket/Untitled 1.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Livello applicazione e socket/Untitled 1">
<ul>
<li>
<p>Slide immagini</p>
  <img src="/images/notes/image/universita/ex-notion/Livello applicazione e socket/Untitled 2.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Livello applicazione e socket/Untitled 2">
</li>
</ul>
<p>Il protocollo TCP richiede a due dispositivi che intendano comunicare di effettuare preventivamente la configurazione dei parametri del socket TCP, originando in questo modo un <strong>canale virtuale di tipo punto a punto tra due socket</strong>, ovvero tra due applicazioni di livello superiore alle quali vengono smistati i pacchetti da TCP. Quindi sono degli estremi di comunicazione!</p>
<p><em>Def socket</em></p>
<p>Un socket è un punto di arrivo o partenza (virtuale) dei dati a livello trasporto, dal quale è in atto l’invio e la ricezione di pacchetti destinati a un’applicazione, ed equivale a una coppia: (<strong>indirizzo IP, numero di porta dell’applicazione</strong>). Una volta instaurata la configurazione punto a punto tra due socket, attraverso lo scambio di pacchetti di configurazione, può iniziare lo scambio dei dati a livello trasporto. In questo senso si dice che è un trasporto TCP/IP, perché prima configurazione per IP poi effettivamente scambio.</p>
<p><em>La richiesta di connessione</em></p>
<p>La connessione viene instaurata con una richiesta di uno dei due host (il client) nei confronti dell’host server.</p>
<ol>
<li>Indirizzo IP del server</li>
<li>Numero della porta per l&rsquo;applicazione (questo viene verificato dal server se qualche servizio ci è aperto, se sì risponde, e il client invia la configurazione).</li>
<li>Poi iniziano a dialogare e alla fine liberano la porta, è una connessione punto a punto!.</li>
</ol>
<p>Quando il server riceve il pacchetto, va a verificare se ha la porta aperta, se tutto va bene manda un messaggio di conferma, e il client invia un pacchetto di configurazione, allora possono cominciare a comunicare.</p>
<p><em>Welcoming socket and client sockets</em></p>
<p>Welcoming è l&rsquo;unico socket di ricezione di un server, che prende tutto e manda al thread corretto.</p>
<p>Client sockets sono i molteplici sockets che il server utilizza per comunicare con il singolo client, vengono solitamente istanziati grazie al welcoming socket dopo che ho fatto richiesta di connessione.</p>
<h3 id="controllo-della-congestione-tcp-2">Controllo della congestione TCP (2)<a hidden class="anchor" aria-hidden="true" href="#controllo-della-congestione-tcp-2">#</a></h3>
<p>Questa parte ora è trattata meglio in [[Livello di trasporto](/notes/0.3.8-servizi-orientati-alla-connessione&ndash;e-non-</p>
<p><strong>tcp</strong></p>
<p>1.-connection-oriented-(garantire-il-ripristino-dell’ordinamento-dei-pacchetti-e-la-ri-trasmissione-dei-pacchetti-perduti)
2.-<strong>numero</strong>-dell’ordine-(a-cui-riceve-ack-per-questo-numero)
3.-controllare-la-velocità-di-invio-→-finestra-scorrevole
la-parte-importante-di-questo-è-che-la-congestione-si-può-<strong>allargare-a-macchia-d’olio</strong>-all-interno-di-internet,-e-questo-è-una-cosa-molto-brutta!</p>
<p>quindi-prova-a-risolvere-gli-errori-di-comunicazione-di-rete,-cercando-di-garantire-una-buona-trasmissione.-il-problema-è-l-efficienza,-si-possono-inviare-segmenti-in-più-e-<strong>congestionare-la-rete</strong>.</p>
<p>si-può-dire-che-questa-è-la-semantica-diversa.</p>
<p>con-la-<strong>tree-way-handshake</strong>-si-apre-una-connessione-socket,-quindi-una-coppia-porta-ip,-per-poter-comunicare!</p>
<p><strong>udp</strong></p>
<p>1.-è-semplice-perché-non-fa-tutte-le-cose-di-tcp-(no-duplicati,-no-riordinamento,-no-checks)
2.-tipo-connectionless</p>
<p>###-socket
&lt;img-src=&quot;/images/notes/image/universita/ex-notion/livello-applicazione-e-socket/untitled-1.png&quot;-style=&ldquo;width:-100%&quot;-class=&ldquo;center&rdquo;-alt=&ldquo;image/universita/ex-notion/livello-applicazione-e-socket/untitled-1&rdquo;&gt;</p>
<p>&ndash;slide-immagini</p>
<p>&mdash;-&lt;img-src=&quot;/images/notes/image/universita/ex-notion/livello-applicazione-e-socket/untitled-2.png&rdquo;-style=&ldquo;width:-100%&quot;-class=&ldquo;center&rdquo;-alt=&ldquo;image/universita/ex-notion/livello-applicazione-e-socket/untitled-2&rdquo;&gt;</p>
<p>il-protocollo-tcp-richiede-a-due-dispositivi-che-intendano-comunicare-di-effettuare-preventivamente-la-configurazione-dei-parametri-del-socket-tcp,-originando-in-questo-modo-un-<strong>canale-virtuale-di-tipo-punto-a-punto-tra-due-socket</strong>,-ovvero-tra-due-applicazioni-di-livello-superiore-alle-quali-vengono-smistati-i-pacchetti-da-tcp.-quindi-sono-degli-estremi-di-comunicazione!</p>
<p><em>def-socket</em></p>
<p>un-socket-è-un-punto-di-arrivo-o-partenza-(virtuale)-dei-dati-a-livello-trasporto,-dal-quale-è-in-atto-l’invio-e-la-ricezione-di-pacchetti-destinati-a-un’applicazione,-ed-equivale-a-una-coppia:-(<strong>indirizzo-ip,-numero-di-porta-dell’applicazione</strong>).-una-volta-instaurata-la-configurazione-punto-a-punto-tra-due-socket,-attraverso-lo-scambio-di-pacchetti-di-configurazione,-può-iniziare-lo-scambio-dei-dati-a-livello-trasporto.-in-questo-senso-si-dice-che-è-un-trasporto-tcp/ip,-perché-prima-configurazione-per-ip-poi-effettivamente-scambio.</p>
<p><em>la-richiesta-di-connessione</em></p>
<p>la-connessione-viene-instaurata-con-una-richiesta-di-uno-dei-due-host-(il-client)-nei-confronti-dell’host-server.</p>
<p>1.-indirizzo-ip-del-server
2.-numero-della-porta-per-l-applicazione-(questo-viene-verificato-dal-server-se-qualche-servizio-ci-è-aperto,-se-sì-risponde,-e-il-client-invia-la-configurazione).
3.-poi-iniziano-a-dialogare-e-alla-fine-liberano-la-porta,-è-una-connessione-punto-a-punto!.</p>
<p>quando-il-server-riceve-il-pacchetto,-va-a-verificare-se-ha-la-porta-aperta,-se-tutto-va-bene-manda-un-messaggio-di-conferma,-e-il-client-invia-un-pacchetto-di-configurazione,-allora-possono-cominciare-a-comunicare.</p>
<p><em>welcoming-socket-and-client-sockets</em></p>
<p>welcoming-è-l-unico-socket-di-ricezione-di-un-server,-che-prende-tutto-e-manda-al-thread-corretto.</p>
<p>client-sockets-sono-i-molteplici-sockets-che-il-server-utilizza-per-comunicare-con-il-singolo-client,-vengono-solitamente-istanziati-grazie-al-welcoming-socket-dopo-che-ho-fatto-richiesta-di-connessione.</p>
<p>###-controllo-della-congestione-tcp-(2)</p>
<p>questa-parte-ora-è-trattata-meglio-in-[[livello-di-trasporto)</p>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Livello applicazione e socket/Untitled 3.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Livello applicazione e socket/Untitled 3">
</li>
<li>
<p>Schema</p>
  <img src="/images/notes/image/universita/ex-notion/Livello applicazione e socket/Untitled 4.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Livello applicazione e socket/Untitled 4">
</li>
</ul>
<p>TCP utilizza un protocollo molto particolare, e a prima vista non intuitivo per gestire la congestione della rete.</p>
<p>L’idea generale è che provo ad aumentare l’invio finché posso, e quando mi accorgo che inizio a perdere <strong>chiudo tutto</strong> e ricomincio dal singolo pacchetto.</p>
<p>Come si è detto in precedenza, TCP richiede una conferma per ogni pacchetto inviato. La distanza tra due dispositivi che scambiano pacchetti a livello trasporto può essere molto significativa. Il tempo per inviare un pacchetto e ottenere la conferma dell’avvenuta ricezione può quindi diventare dell’ordine dei secondi.
Il problema del controllo di flusso dei pacchetti nel protocollo TCP si basa su due scopi apparentemente in contraddizione tra loro.</p>
<ol>
<li>è quello di <strong>saturare</strong> il più possibile la rete di pacchetti, inviandoli a un ritmo elevato. Questo favorisce l’utilizzo delle risorse e le prestazioni della rete (si spediscono e si ricevono tanti bit al secondo). Se si decidesse di inviare un pacchetto e aspettare l’arrivo della conferma, la rete sarebbe usata solo in minima percentuale, e si riuscirebbero a spedire solo pochi bit al secondo. Quindi la rete, pur essendo veloce nell’invio dei bit, verrebbe sfruttata al minimo delle potenzialità. E’ quindi evidente quanto sia opportuno <strong>spedire i pacchetti a un ritmo il più veloce possibile</strong>.</li>
<li><strong>Evitare di saturare la rete</strong> occorre evitare che un ritmo di invio troppo elevato possa causare il sorgere della <strong>congestione</strong> nei router intermedi del cammino dei pacchetti, dal mittente TCP (client) al destinatario TCP (server). Se un router si trova a dover inoltrare troppi
pacchetti, provenienti da flussi TCP diversi, i pacchetti si accumulano fino ad andare perduti e la rete va in crisi. In tal caso si deve ricorrere a una tecnica di controllo della congestione.
Una forma di congestione può comparire anche sul destinatario finale, nel caso in cui esso non sia in grado di ricevere i pacchetti inviati troppo velocemente. In tal caso si deve ricorrere a una tecnica di controllo di flusso.</li>
</ol>
<h3 id="finestra-scorrevole"><strong>Finestra scorrevole</strong><a hidden class="anchor" aria-hidden="true" href="#finestra-scorrevole">#</a></h3>
<p>Si parla di metodi di congestione, viene trattato meglio in <a href="/notes/livello-di-trasporto">Livello di trasporto</a>
<img src="/images/notes/image/universita/ex-notion/Livello applicazione e socket/Untitled 5.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Livello applicazione e socket/Untitled 5"></p>
<p>Osservando l’esempio, partendo con SW uguale a 1, se la conferma è ricevuta, la finestra viene raddoppiata, spedendo due pacchetti al massimo ritmo di invio. Se entrambi i pacchetti vengono confermati, si passa alla finestra di dimensione quattro, inviando quattro pacchetti al massimo ritmo di invio. Se i pacchetti sono confermati si passa a finestra di otto pacchetti. A
questo punto, nell’esempio, almeno uno degli otto pacchetti non viene confermato. Si suppone che questo fatto sia dovuto a un router congestionato e quindi si rallenta il ritmo di invio ripartendo dalla finestra minima (pari a uno). Il massimo grado sostenibile di invio per la rete in esame nell’esempio è stato quindi ottenuto con finestra pari a quattro.</p>
<pre><code>&lt;img src=&quot;/images/notes/image/universita/ex-notion/Livello applicazione e socket/Untitled 6.png&quot; style=&quot;width: 100%&quot; class=&quot;center&quot; alt=&quot;image/universita/ex-notion/Livello applicazione e socket/Untitled 6&quot;&gt;
</code></pre>
<p>TCP usa un meccanismo per il controllo di flusso, detto a finestra scorrevole (sliding window), e un meccanismo per il controllo della congestione, basato sul dimensionamento della finestra scorrevole. Tutto ciò per cercare il massimo ritmo di spedizione che possa garantire l’inoltro dei pacchetti da parte del router più lento del cammino, e prevenire la saturazione del destinatario
finale.</p>
<p><strong>Idea della sliding window</strong></p>
<p>La finestra scorrevole è un <strong>valore intero</strong>, cha parte da un valore minimo (ad esempio il valore uno). L’idea alla base del controllo di flusso a finestra scorrevole è quello di spedire non più di Sliding Window pacchetti consecutivi, a partire dall’ultimo pacchetto non confermato, e quindi attendere la ricezione di una conferma.
Un valore di SW uguale a 1 significa che solo un pacchetto può essere spedito, poi occorre aspettare di ricevere la conferma della ricezione. In questo caso la rete è poco utilizzata. Ogni volta che alcuni pacchetti spediti sono confermati, allora è possibile spedire i pacchetti successivi mantenendosi entro il limite massimo di SW pacchetti dall’ultimo pacchetto non ancora confermato. Eventuali pacchetti non confermati sono rispediti fino al ricevimento della conferma.</p>
<p>Il senso di questo meccanismo è quello di lasciare in sospeso non più di SW pacchetti, per evitare
di saturare il mittente. Questo meccanismo, molto semplificato, realizza il controllo di flusso di TCP.
Se i pacchetti vengono confermati, si può adottare un meccanismo dinamico per accelerare gradualmente il ritmo di invio dei pacchetti, ovvero la dimensione della finestra SW, fino a che non si nota la perdita di almeno un pacchetto tra quelli inviati.</p>
<p><strong>Comportamento a perdita di pacchetti</strong></p>
<p>Se i pacchetti vanno perduti, TCP assume anche che la causa di ciò sia la presenza di un router intermedio congestionato, e quindi rallenta il ritmo di invio dei pacchetti per dare modo al router congestionato di smaltire i pacchetti accumulati. Tale meccanismo, sommariamente descritto, è il meccanismo di controllo della congestione di rete di TCP.</p>
<h3 id="multiplexing-e-demultiplexing-e-porte">Multiplexing e Demultiplexing e porte<a hidden class="anchor" aria-hidden="true" href="#multiplexing-e-demultiplexing-e-porte">#</a></h3>
<p>Questi termini non hanno una traduzione diretta con l&rsquo;italiano, la cosa più simile possibile è aggregare e disaggregare, perché da una unica scheda direte arriva tutto, questa cosa deve essere demultiplexata alla porta corretta, e multiplexata all&rsquo;unica scheda di rete che si ha.</p>
<p>Le well known ports sono di solito minori di 1023.</p>
<p>Le porte alte sono decise da noi, basta che nell ostess ocomputer non ci sia un conflitto di porte.</p>
<p>Multiplexing perché ho molte porte, ma unica scheda di rete, quindi far girare da una unica source tutto il resto. (per il mandante serve0</p>
<p>Demultiplexing perché così posso mandare alla porta corretta, ricevendo</p>
<ul>
<li>
<p>Slide multiplexing</p>
  <img src="/images/notes/image/universita/ex-notion/Livello applicazione e socket/Untitled 7.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Livello applicazione e socket/Untitled 7">
</li>
</ul>
<p>In pratica il server con una singola porta non sarebbe in grado di rispondere a connessioni multiple! Ricorda che socket è end-to-end, non saprei a quale client starei parlando.</p>
<p>Si parla quindi di <strong>welcoming socket</strong> per il server, e quando si stabilisce la connessione ti dice in quale porta andare sopra per continuare a comunicare.</p>
<ul>
<li>
<p>Esempio di demux server</p>
  <img src="/images/notes/image/universita/ex-notion/Livello applicazione e socket/Untitled 8.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Livello applicazione e socket/Untitled 8">
</li>
</ul>
<h2 id="applicazione">Applicazione<a hidden class="anchor" aria-hidden="true" href="#applicazione">#</a></h2>
<h3 id="introduzione-livello-applicazione-non-fo">Introduzione livello applicazione (non fo)<a hidden class="anchor" aria-hidden="true" href="#introduzione-livello-applicazione-non-fo">#</a></h3>
<p>Il livello applicazione dei protocolli di Internet contiene l’implementazione delle funzioni e dei servizi che permettono alle applicazioni di rete in esecuzione sull’host di spedire e ricevere i dati. I protocolli sottostanti di Presentazione e Sessione, previsti dallo Standard ISO/OSI, non sono quasi mai considerati nell’architettura dei protocolli di Internet.</p>
<p>Il livello Applicazione si appoggia direttamente sul livello trasporto e, in particolare, molte applicazioni che richiedono servizi connection-oriented si basano sul protocollo TCP, attraverso numeri di porta che nel tempo sono diventati standard “de facto”.
Ad esempio, la spedizione e il trasferimento dei messaggi di posta elettronica, basati sul protocollo di livello applicazione Simple Mail Transfer Protocol (SMTP) è comunemente associata alla porta di livello applicazione 25. La porta 80 è destinata al protocollo di trasferimento di ipertesti HyperText Transfer Protocol (HTTP) alla base del trasferimento delle pagine di siti del World Wide Web.</p>
<p>Altri esempi di protocolli e servizi che si collocano al livello applicazione sono il protocollo e servizio di Domain Name Service (DNS) e i protocolli IMAP e POP3 per la consegna della posta elettronica.
Una dettagliata illustrazione sul mondo dei servizi e protocolli applicativi di Internet sarà oggetto di un modulo apposito</p>
<h3 id="http1-non-fare">HTTP1 (non fare)<a hidden class="anchor" aria-hidden="true" href="#http1-non-fare">#</a></h3>
<p>All&rsquo;inizio bisognava <strong>aprire connessione</strong> per ogni singolo file che bisognava richiedere, quindi molto lento, ora sappiamo riuscire a creare socket di connessione che non si chiudono subito</p>
<p>Molto bene è descritto in <a href="/notes/http-e-rest">HTTP e REST</a></p>
<h3 id="domain-name-system">Domain Name System<a hidden class="anchor" aria-hidden="true" href="#domain-name-system">#</a></h3>
<img src="/images/notes/image/universita/ex-notion/Livello applicazione e socket/Untitled 9.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Livello applicazione e socket/Untitled 9">
<ul>
<li>Immagine di spiegazione</li>
</ul>
<img src="/images/notes/image/universita/ex-notion/Livello applicazione e socket/Untitled 10.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Livello applicazione e socket/Untitled 10">
<p>Vorremmo avere un metodo molto semplice per umani per poter trovare un sito, ma il livello di rete non li sa gestire, ha bisogno di IP, allora ho bisogno di alcuni server dedicati che mi restituiscono l&rsquo;IP dato un nome di dominio! Questo è <strong>unico</strong>, altrimenti ci sarebbe ambiguità riguardo al nome. E altra cosa, ci sono i server DNS che sappiano dare l’IP corretto a seguito del DNS.</p>
<p><strong>Problema</strong></p>
<p>Gli utenti di Internet preferiscono usare nomi mnemonici per identificare le risorse in rete, ad esempio nomi di host appartenenti a una certa rete, oppure indirizzi di e-mail di utenti di una certa rete. Anche le reti, risultano spesso facilmente identificabili attraverso i nomi di dominio della rete. I nomi di dominio hanno quindi lo stesso senso degli indirizzi IP, e infatti vengono assegnati da enti internazionali, come gli indirizzi IP, per evitare confusione e nomi duplicati. Le risorse appartenenti a un dominio possono avere nomi scelti arbitrariamente (ad esempio nomi di host, indirizzi di e-mail) purchè non siano duplicati all’interno del dominio stesso. Nomi di risorse duplicati sono ammessi in domini diversi, (ad esempio, <a href="mailto:pippo@topolinia.it"><a href="mailto:pippo@topolinia.it">pippo@topolinia.it</a></a> e <a href="mailto:pippo@paperopoli.com"><a href="mailto:pippo@paperopoli.com">pippo@paperopoli.com</a></a>). I nomi di dominio hanno una struttura gerarchica del tipo (nomerisorsa.sottodominio.sottodominio.dominioradice). Ad esempio <a href="http://www.informatica.unibo.it/"><a href="https://www.informatica.unibo.it">www.informatica.unibo.it</a></a> è il nome dell’host che agisce da web server per il sottodominio informatica, del sottodominio Università di Bologna, del sottodominio di livello massimo .it (Italia). In realtà il dominio radice del mondo, che esiste implicitamente, non si scrive mai. Tutto ciò è comodo ma viola le esigenze del livello rete e dei router che pretendono solo indirizzi IP.</p>
<p><strong>DNS per risolvere il problema</strong></p>
<p>Per risolvere il problema, è nato il servizio Domain Name System (DNS) che attraverso una gerarchia di server e un protocollo standard per le richieste permette di risolvere l’associazione tra nome della risorsa e indirizzo IP. Ogni host in rete deve conoscere un server DNS al quale inviare le richieste e ogni server DNS deve conoscere almeno un server DNS di livello superiore. I server di livello superiore conoscono un numero sempre maggiore di nomi e relativi indirizzi IP, ma sono sempre meno per motivi di costo.</p>
<p>L’esempio mostra come viene soddisfatta una richiesta DNS a seconda del punto della rete di server DNS dalla quale parte. Se un server DNS non conosce la risposta passa la richiesta al livello superiore, finché qualcuno non conosce l’indirizzo IP.</p>
<p><strong>Note sull&rsquo;affidabilità</strong></p>
<p>È una cosa molto brutta tenere un singolo server che possieda questo server DNS, perché se fallisce nessuno può più raggiungerlo!. Quindi vogliamo andare a creare una <strong>alta ridondanza</strong> riguardo questo server DNS.</p>
<ol>
<li>Replicare servizi anche in zone differenti (ne basta una su e il servizio apparentemente è su, ecco il sistema distribuito!).</li>
</ol>
<h4 id="iterativoricorsivo">Iterativo/Ricorsivo<a hidden class="anchor" aria-hidden="true" href="#iterativoricorsivo">#</a></h4>
<p>Iterativo il DNS ti risponde col nuovo dns server da contattare per poter avere una risposta</p>
<p>Ricoversivo quando il DNS stesso va a chiedere, e quindi quando ti risponde ti da già il risultato corretto.</p>
<p>Quindi in un caso si pone molto più onere sul client che ha richiesto, nel secondo caso si pone onere sul server DNS. Quindi a seconda di quanto hai bisogno puoi fare l’uno o l’altro direi.</p>
<h4 id="typosquatting-attack">Typosquatting attack<a hidden class="anchor" aria-hidden="true" href="#typosquatting-attack">#</a></h4>
<p>Questo è un attacco sui DNS. Sappiamo che questo servizi risolvono testo in IPs che poi vengono utilizzati per mandare le richieste sulla rete. Però questo approccio è attaccabile da domini che hanno codifiche diverse, ma carattere uguale all&rsquo;utilizzatore.
In questo modo un utente può essere ingannato a cliccare su quell&rsquo;url, anche se il domain name originale è diverso perché invece di A scrive А, per esempio hex-dump di <code>A А</code> è <code>41 20 d0 90 a</code> vediamo chiaramente che la seconda A in cirillico è rappresentato da tre bytes, anche se sembrano esattamente essere uguali. Questo può essere utilizzato e attaccato.</p>
<h3 id="sulla-connessione">Sulla connessione<a hidden class="anchor" aria-hidden="true" href="#sulla-connessione">#</a></h3>
<p>Riassumento, per poterci connettere sulla rete abbiamo bisogno di queste informazioni e stack di rete qui:</p>
<ul>
<li>Stack TCP/IP</li>
<li>firewall</li>
<li>(IP, default router, maschera di rete)</li>
<li>DNS</li>
<li>DHCP</li>
</ul>
<h3 id="architetture-a-livello-applicazione">Architetture a livello applicazione<a hidden class="anchor" aria-hidden="true" href="#architetture-a-livello-applicazione">#</a></h3>
<ul>
<li>Client/server</li>
<li>Peer To peer</li>
</ul>
<p>Le applicazioni e i servizi su Internet possono essere realizzati secondo almeno due modalità architetturali distinte: Architettura Client/Server e architettura Peer to Peer (P2P).</p>
<ol>
<li>
<p><strong>Client/Server</strong>, i Client sono host che spediscono richieste di servizio ai Server. I Server sono i soli host sui quali sono in esecuzione i servizi che permettono di soddisfare le richieste. Un esempio di servizi di tipo Client/Server sono: il servizio DNS, dove ogni host può agire da client spedendo richieste degli indirizzi IP ai DNS server, oppure il servizio World Wide Web,
e il servizio di posta elettronica, entrambi basati su client che chiedono pagine web o spediscono e-mail, e server che mantengono le informazioni o memorizzano le e-mail spedite.</p>
</li>
<li>
<p><strong>Peer to Peer</strong> (P2P), invece, tutti gli host sono contemporaneamente sia client che server. Ogni host agisce da Server cercando di soddisfare, se possibile, le richieste ricevute da altri host. Ogni host agisce da Client quando spedisce ad altri host le sue richieste, o per conto personale, o per cercare di soddisfare richieste di terzi. Un esempio di servizi P2P sono: i
servizi di condivisione dati (file-sharing) basati su protocolli Freenet, Gnutella, Kazaa.
Esistono anche servizi ibridi, nei quali esistono server che aiutano solo a trovare più rapidamente gli host P2P migliori per comunicare e implementare servizi P2P (esempio: file-sharing con Napster).</p>
</li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/computer-networks/">🕸Computer-Networks</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Livello applicazione e socket on x"
            href="https://x.com/intent/tweet/?text=Livello%20applicazione%20e%20socket&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2flivello-applicazione-e-socket%2f&amp;hashtags=%f0%9f%95%b8computer-networks">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Livello applicazione e socket on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2flivello-applicazione-e-socket%2f&amp;title=Livello%20applicazione%20e%20socket&amp;summary=Livello%20applicazione%20e%20socket&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2flivello-applicazione-e-socket%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Livello applicazione e socket on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2flivello-applicazione-e-socket%2f&title=Livello%20applicazione%20e%20socket">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Livello applicazione e socket on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2flivello-applicazione-e-socket%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Livello applicazione e socket on whatsapp"
            href="https://api.whatsapp.com/send?text=Livello%20applicazione%20e%20socket%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2flivello-applicazione-e-socket%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Livello applicazione e socket on telegram"
            href="https://telegram.me/share/url?text=Livello%20applicazione%20e%20socket&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2flivello-applicazione-e-socket%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Livello applicazione e socket on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Livello%20applicazione%20e%20socket&u=https%3a%2f%2fflecart.github.io%2fnotes%2flivello-applicazione-e-socket%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
