<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Common problems in Theoretical CS | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="theoretical-computer-science">
<meta name="description" content="This note is useful to gather in a single place the description of some common problems in CS and their theoretical implications explained in other notes.
The Clique problem Description of the problem This problem is in NP, find all sub-graphs where all nodes are connected (this set of nodes forms a complete graph).
We can prove that the problem is in NP because there is an easy non-deterministic algorithm that computes it.">
<meta name="author" content="Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="https://flecart.github.io/notes/common-problems-in-theoretical-cs/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/common-problems-in-theoretical-cs/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>




<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>
<script type="text/javascript" async
src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>





<script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-WW6NN2QGKF', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Common problems in Theoretical CS" />
<meta property="og:description" content="This note is useful to gather in a single place the description of some common problems in CS and their theoretical implications explained in other notes.
The Clique problem Description of the problem This problem is in NP, find all sub-graphs where all nodes are connected (this set of nodes forms a complete graph).
We can prove that the problem is in NP because there is an easy non-deterministic algorithm that computes it." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://flecart.github.io/notes/common-problems-in-theoretical-cs/" />
<meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png" />
<meta property="article:section" content="notes" />



<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png" />
<meta name="twitter:title" content="Common problems in Theoretical CS"/>
<meta name="twitter:description" content="This note is useful to gather in a single place the description of some common problems in CS and their theoretical implications explained in other notes.
The Clique problem Description of the problem This problem is in NP, find all sub-graphs where all nodes are connected (this set of nodes forms a complete graph).
We can prove that the problem is in NP because there is an easy non-deterministic algorithm that computes it."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Common problems in Theoretical CS",
      "item": "https://flecart.github.io/notes/common-problems-in-theoretical-cs/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Common problems in Theoretical CS",
  "name": "Common problems in Theoretical CS",
  "description": "This note is useful to gather in a single place the description of some common problems in CS and their theoretical implications explained in other notes.\nThe Clique problem Description of the problem This problem is in NP, find all sub-graphs where all nodes are connected (this set of nodes forms a complete graph).\nWe can prove that the problem is in NP because there is an easy non-deterministic algorithm that computes it.",
  "keywords": [
    "theoretical-computer-science"
  ],
  "articleBody": "This note is useful to gather in a single place the description of some common problems in CS and their theoretical implications explained in other notes.\nThe Clique problem Description of the problem This problem is in NP, find all sub-graphs where all nodes are connected (this set of nodes forms a complete graph).\nWe can prove that the problem is in NP because there is an easy non-deterministic algorithm that computes it. See Time and Space Complexity#Clique problem for details of this proof.\nA little more formally: Given a graph $\\langle G, E \\rangle$ we say that the solver for the clique problem returns a list of nodes $N \\subseteq G$ such that that is a complete graph. A subset of this problem is when we need cliques of $k$ nodes. So the problem is to return these $k$ nodes if they exist (or just say they don’t ).\nThe SAT problem SAT stands for SATisfiability.\nBackground notions Boolean formulas We define a language with variables and their negations. Logical and and or operations. Then we assign all possible values to the variables and see their end values after passing to the polynomial problem. But this explodes exponentially. Sometimes the boolean formula is in Logica Proposizionale, another time using Logica del Primo ordine.\nThird conjunct normal form If we have only OR operations, that is a clause. Then we say it is in conjunct normal form if these clauses are linked with AND operations. It’s third when the clauses have exactly tree variables.\nWhy is this problem important Many historical approaches used this problem to think about satisfiability. This problem is also important in constraint programming. TODO: add links in the future when it happens.\nDefinition of 3-SAT problem Given a third conjunct normal form, find assignments such that it satisfies the boolean formula.\n3-SAT $\\leq_{P}$ CLIQUE We prove using the notion of Cook-Levin and Savitch#Poly-reduction that 3-sat is reducible polynomially to clique.\nIn order to do this we need to transform the problem into graph format, and graph format to assignments.\nConversion strategy🟩 For every clause we defines 3 nodes. Then we link every node in this way:\nIf in same clause, don’t link If in other link, link only if it’s not your negation. Example:\nWe can prove that this conversion is polynomial (clear, you can write the algo and prove it 💠).\nWhy does the conversion work? Now, if the 3-SAT formula is satisfiable, then at least one node for each clause is true. We select a single true node for each clause, and this brings us the clique. By construction, this is a complete sub-graph. So this reduction works. Why does it work? Because as we have $k$ clauses, we have selected a node from each clause, and we know that each node is connected to each other node, because if not that wouldn’t be satisfied (by construction there is a link with other node $\\iff$ the node is in other triplet $\\land$ it’s not himself negated).\nWe now have a graph, let’s suppose we have a clique, then the 3-SAT is satisfiable because of similar arguments above (just assign true to those variables).\nTrue quantified Boolean formula Also called TQBF, it is defines as follows:\n$$ TQBF = \\left\\{ \\langle F \\rangle \\mid F \\text{ is a true boolean statement } \\right\\} $$ Where statement is a boolean formula were the values are all bounded. This problem is important for Time and Space Complexity analysis.\nTQBF is PSPACE-complete Remember that a problem is PSPACE complete if it is in PSPACE and every other PSPACE languages can be poly-reduced to this language.\nTQBF is in PSPACE This technique is something similar to Sintassi e RI strutturali technique.\nIf there are no quantifiers, evaluate the statements, and if it is true accept, else reject. If we have a format like $F = \\exists x.G$ Then enumerate all: evaluate the truthfulness given $x = 1$, and then with $x = 0$ if one of them is true then return true. If we have a format like $F = \\forall x. G$ then evaluate both $x= 1$ and $x = 0$ and if both true return true. This is a recursive algorithm, and it is $O(m)$ where $m$ are the terms (max $m$ recursive passes, every recursive pass has at most a single term memorized). $\\square$. TQBF is PSPACE-hard This is difficult to grasp. Go to see (Sipser 2012) Chapter 8.3 pp. 340.\nThe idea is to convert the computation of the TM that decides the given language $L$ using some formulas like $\\phi_{c_{1}, c_{2}, t}$ which means that this is true if it’s possible to go from $c_{1}$ to $c_{2}$ in at most $t$ steps. In this setting $c_{1}$ and $c_{2}$ are different configurations of the Turing Machine.\nThe proof is by induction:\nIf $t=1$ then $c_{1}=c_{2}$ or it’s possible to go into $c_{2}$ using a single step. This is verifiable using the windows argument in the Cook-Levin theorem. Else it’s a little bit more difficult. It’s easy to verify it 🤠. $$ F_{c, c', t} = \\exists m_{1} \\forall(c_{3}, c_{4}) \\in \\left\\{ (c, m_{1}), (m_{1}, c') \\right\\} F_{c_{3}, c_{4}, \\frac{t}{2}} $$ Given this inductive formulation, we can observe that we add only $O(n^{k})$ quantifiers in the recursive proof. So the formula has $\\log (2^{dn^{k}})$ induction steps which is $O(n^{k})$. So this problem is PSPACE-hard. Two player games It is possible to prove that every two player zero-sum game like chess or Go, that uses a minimax tree search strategy can be expressed into a TQBF problem like this (informally): For every move of the opponent, exists one of my moves such that for every move of the opponent …. -\u003e I win. This is a TQBF statement.\nThe Tiling Problem Formalizzazione del problema Definizione formale del tiling Consideriamo una tupla $\\langle \\mathcal{T}, t_{0}, H, V \\rangle$\n$\\mathcal{T}$ è un insieme di piastrelle. $t_{0} \\in \\mathcal{T}$ è la piastrella d’origine. $H \\subseteq \\mathcal{T} \\times \\mathcal{T}$ le regole di adiacenza orizzontali. $V \\subseteq \\mathcal{T} \\times \\mathcal{T}$ le regole di adiacenza verticali. L’obiettivo è vedere se è possibile riempire tutto il piano con queste piastrelle, all’infinito. Sappiamo già che non è sempre possibile farlo. Ci chiediamo se è automatizzabile. Questo problema è stato risolto nel 1966, e sembra non essere riconoscibile nemmeno.\nOssia in matematichese definire la funzione $f : \\mathbb{N} \\times \\mathbb{N} \\to \\mathcal{T}$ Con\n$f(1, 1) = t_{0}$ $\\forall n,m \\in \\mathbb{N}, (f(n, m), f(n + 1, m)) \\in V$ $\\forall n,m \\in \\mathbb{N}, (f(n, m), f(n, m+1)) \\in H$ Strategia di dimostrazione Vogliamo ridurlo da $ETH^{-}$ che abbiamo spiegato in Halting Theorem and Reducibility. Questo è un linguaggio non riconoscibile, perché il suo complemento è riconoscibile in modo banale.\nQuesta dimostrazione avrà un sacco di punti molto tecnici per dire che una macchina di turing deve essere tradotta in un problema di tiling…\nDimostrazione irriconoscibilità del tiling L’idea principale è che con un tiling posso simulare l’esecuzione di una macchina di Turing. E in questo modo riduco il problema a un Halt. Perché sapere tassellare significa sapere dire quando una macchina di Turing finisce.\nCodifica delle regole dei tiling Posso codificare sia i tile disponibili, sia le regole di adiacenza in questo modo.\nPoi vogliamo codificare ogni casella verticale un singolo step di computazione.\nCella di identità Questa cella non fa niente. Celle di transizione Possiamo codificare le funzioni di transizione della macchina di Turing. Poi ho ancora le cose che mantengono il simbolo nella cella di arrivo.\nConclusione sse non si ferma la macchina, allora esiste un tiling (che è una cosa banale perché significa che continua all’infinito, e quindi posso mappare tutto).\nReferences [1] Sipser “Introduction to the Theory of Computation” Cengage Learning 2012\n",
  "wordCount" : "1290",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/common-problems-in-theoretical-cs/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Common problems in Theoretical CS
    </h1>
    <div class="post-meta">7 min&nbsp;·&nbsp;Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul><ul>
                <li>
                    <a href="#the-clique-problem" aria-label="The Clique problem">The Clique problem</a><ul>
                        
                <li>
                    <a href="#description-of-the-problem" aria-label="Description of the problem">Description of the problem</a></li></ul>
                </li>
                <li>
                    <a href="#the-sat-problem" aria-label="The SAT problem">The SAT problem</a><ul>
                        
                <li>
                    <a href="#background-notions" aria-label="Background notions">Background notions</a><ul>
                        
                <li>
                    <a href="#boolean-formulas" aria-label="Boolean formulas">Boolean formulas</a></li>
                <li>
                    <a href="#third-conjunct-normal-form" aria-label="Third conjunct normal form">Third conjunct normal form</a></li>
                <li>
                    <a href="#why-is-this-problem-important" aria-label="Why is this problem important">Why is this problem important</a></li></ul>
                </li>
                <li>
                    <a href="#definition-of-3-sat-problem" aria-label="Definition of 3-SAT problem">Definition of 3-SAT problem</a></li>
                <li>
                    <a href="#3-sat-leq_p--clique" aria-label="3-SAT $\leq_{P}$  CLIQUE">3-SAT $\leq_{P}$  CLIQUE</a><ul>
                        
                <li>
                    <a href="#conversion-strategy" aria-label="Conversion strategy🟩">Conversion strategy🟩</a></li>
                <li>
                    <a href="#why-does-the-conversion-work" aria-label="Why does the conversion work?">Why does the conversion work?</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#true-quantified-boolean-formula" aria-label="True quantified Boolean formula">True quantified Boolean formula</a><ul>
                        
                <li>
                    <a href="#tqbf-is-pspace-complete" aria-label="TQBF is PSPACE-complete">TQBF is PSPACE-complete</a><ul>
                        
                <li>
                    <a href="#tqbf-is-in-pspace" aria-label="TQBF is in PSPACE">TQBF is in PSPACE</a></li>
                <li>
                    <a href="#tqbf-is-pspace-hard" aria-label="TQBF is PSPACE-hard">TQBF is PSPACE-hard</a></li></ul>
                </li>
                <li>
                    <a href="#two-player-games" aria-label="Two player games">Two player games</a></li></ul>
                </li>
                <li>
                    <a href="#the-tiling-problem" aria-label="The Tiling Problem">The Tiling Problem</a><ul>
                        
                <li>
                    <a href="#formalizzazione-del-problema" aria-label="Formalizzazione del problema">Formalizzazione del problema</a><ul>
                        
                <li>
                    <a href="#definizione-formale-del-tiling" aria-label="Definizione formale del tiling">Definizione formale del tiling</a></li>
                <li>
                    <a href="#strategia-di-dimostrazione" aria-label="Strategia di dimostrazione">Strategia di dimostrazione</a></li></ul>
                </li>
                <li>
                    <a href="#dimostrazione-irriconoscibilit%c3%a0-del-tiling" aria-label="Dimostrazione irriconoscibilità del tiling">Dimostrazione irriconoscibilità del tiling</a><ul>
                        
                <li>
                    <a href="#codifica-delle-regole-dei-tiling" aria-label="Codifica delle regole dei tiling">Codifica delle regole dei tiling</a></li>
                <li>
                    <a href="#cella-di-identit%c3%a0" aria-label="Cella di identità">Cella di identità</a></li>
                <li>
                    <a href="#celle-di-transizione" aria-label="Celle di transizione">Celle di transizione</a></li>
                <li>
                    <a href="#conclusione" aria-label="Conclusione">Conclusione</a></li></ul>
                </li></ul>
                </li></ul>
                    
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>This note is useful to gather in a single place the description of some common problems in CS and their theoretical implications explained in other notes.</p>
<h2 id="the-clique-problem">The Clique problem<a hidden class="anchor" aria-hidden="true" href="#the-clique-problem">#</a></h2>
<h3 id="description-of-the-problem">Description of the problem<a hidden class="anchor" aria-hidden="true" href="#description-of-the-problem">#</a></h3>
<p>This problem is in NP, find all sub-graphs where all nodes are connected (this set of nodes forms a complete graph).</p>
<p>We can prove that the problem is in NP because there is an easy non-deterministic algorithm that computes it.
See <a href="/notes/time-and-space-complexity/#clique-problem">Time and Space Complexity#Clique problem</a> for details of this proof.</p>
<p>A little more formally:
Given a graph $\langle G, E \rangle$ we say that the solver for the clique problem returns a list of nodes $N \subseteq G$ such that that is a complete graph.
A subset of this problem is when we need cliques of $k$ nodes. So the problem is to return these $k$ nodes if they exist (or just say they don&rsquo;t ).</p>
<h2 id="the-sat-problem">The SAT problem<a hidden class="anchor" aria-hidden="true" href="#the-sat-problem">#</a></h2>
<p>SAT stands for SATisfiability.</p>
<h3 id="background-notions">Background notions<a hidden class="anchor" aria-hidden="true" href="#background-notions">#</a></h3>
<h4 id="boolean-formulas">Boolean formulas<a hidden class="anchor" aria-hidden="true" href="#boolean-formulas">#</a></h4>
<p>We define a language with variables and their negations. Logical and and or operations.
Then we assign all possible values to the variables and see their end values after passing to the polynomial problem.
But this <strong>explodes</strong> exponentially.
Sometimes the boolean formula is in <a href="/notes/logica-proposizionale/">Logica Proposizionale</a>, another time using <a href="/notes/logica-del-primo-ordine/">Logica del Primo ordine</a>.</p>
<h4 id="third-conjunct-normal-form">Third conjunct normal form<a hidden class="anchor" aria-hidden="true" href="#third-conjunct-normal-form">#</a></h4>
<p>If we have only OR operations, that is a <em>clause</em>.
Then we say it is in conjunct normal form if these clauses are linked with AND operations.
It&rsquo;s <em>third</em> when the clauses have exactly tree variables.</p>
<h4 id="why-is-this-problem-important">Why is this problem important<a hidden class="anchor" aria-hidden="true" href="#why-is-this-problem-important">#</a></h4>
<p>Many historical approaches used this problem to think about satisfiability. This problem is also important in constraint programming.
TODO: add links in the future when it happens.</p>
<h3 id="definition-of-3-sat-problem">Definition of 3-SAT problem<a hidden class="anchor" aria-hidden="true" href="#definition-of-3-sat-problem">#</a></h3>
<p>Given a third conjunct normal form, find assignments such that it satisfies the boolean formula.</p>
<h3 id="3-sat-leq_p--clique">3-SAT $\leq_{P}$  CLIQUE<a hidden class="anchor" aria-hidden="true" href="#3-sat-leq_p--clique">#</a></h3>
<p>We prove using the notion of <a href="/notes/cook-levin-and-savitch/#poly-reduction">Cook-Levin and Savitch#Poly-reduction</a> that 3-sat is reducible polynomially to clique.</p>
<p>In order to do this we need to transform the problem into graph format, and graph format to assignments.</p>
<h4 id="conversion-strategy">Conversion strategy🟩<a hidden class="anchor" aria-hidden="true" href="#conversion-strategy">#</a></h4>
<p>For every clause we defines 3 nodes.
Then we link every node in this way:</p>
<ol>
<li>If in same clause, don&rsquo;t link</li>
<li>If in other link, link only if it&rsquo;s not your negation.</li>
</ol>
<p>Example:</p>
<img src="/images/notes/Common problems in Theoretical CS-20240410121141341.webp" alt="Common problems in Theoretical CS-20240410121141341">
<p>We can prove that this conversion is polynomial (clear, you can write the algo and prove it 💠).</p>
<h4 id="why-does-the-conversion-work">Why does the conversion work?<a hidden class="anchor" aria-hidden="true" href="#why-does-the-conversion-work">#</a></h4>
<p>Now, if the 3-SAT formula is satisfiable, then at least one node for each clause is true. We select a single true node for each clause, and this brings us the clique.
By construction, this is a complete sub-graph. So this reduction works. Why does it work? Because as we have $k$ clauses, we have selected a node from each clause, and we know that each node is connected to each other node, because if not that wouldn&rsquo;t be satisfied (by construction there is a link with other node $\iff$ the node is in other triplet $\land$ it&rsquo;s not himself negated).</p>
<p>We now have a graph, let&rsquo;s suppose we have a clique, then the 3-SAT is satisfiable because of similar arguments above (just assign true to those variables).</p>
<h2 id="true-quantified-boolean-formula">True quantified Boolean formula<a hidden class="anchor" aria-hidden="true" href="#true-quantified-boolean-formula">#</a></h2>
<p>Also called TQBF, it is defines as follows:</p>
$$
TQBF = \left\{ \langle F \rangle \mid F \text{ is a true boolean statement } \right\} 
$$
<p>
Where statement is a boolean formula were the values are all bounded.
This problem is important for <a href="/notes/time-and-space-complexity/">Time and Space Complexity</a> analysis.</p>
<h3 id="tqbf-is-pspace-complete">TQBF is PSPACE-complete<a hidden class="anchor" aria-hidden="true" href="#tqbf-is-pspace-complete">#</a></h3>
<p>Remember that a problem is PSPACE complete if it is in PSPACE and every other PSPACE languages can be poly-reduced to this language.</p>
<h4 id="tqbf-is-in-pspace">TQBF is in PSPACE<a hidden class="anchor" aria-hidden="true" href="#tqbf-is-in-pspace">#</a></h4>
<p>This technique is something similar to <a href="/notes/sintassi-e-ri-strutturali/">Sintassi e RI strutturali</a> technique.</p>
<ol>
<li>If there are no quantifiers, evaluate the statements, and if it is true accept, else reject.</li>
<li>If we have a format like $F = \exists x.G$ Then enumerate all: evaluate the truthfulness given $x = 1$, and then with $x = 0$ if one of them is true then return true.</li>
<li>If we have a format like $F = \forall x. G$ then evaluate both $x= 1$ and $x = 0$ and if both true return true.
This is a recursive algorithm, and it is $O(m)$ where $m$ are the terms (max $m$ recursive passes, every recursive pass has at most a single term memorized). $\square$.</li>
</ol>
<h4 id="tqbf-is-pspace-hard">TQBF is PSPACE-hard<a hidden class="anchor" aria-hidden="true" href="#tqbf-is-pspace-hard">#</a></h4>
<p>This is difficult to grasp. Go to see <a href="https://books.google.it/books/about/Introduction_to_the_Theory_of_Computatio.html?id=P3f6CAAAQBAJ">(Sipser 2012)</a> Chapter 8.3 pp. 340.</p>
<p>The idea is to convert the computation of the TM that decides the given language $L$ using some formulas like $\phi_{c_{1}, c_{2}, t}$ which means that this is true if it&rsquo;s possible to go from $c_{1}$ to $c_{2}$ in at most $t$ steps.
In this setting $c_{1}$ and $c_{2}$ are different configurations of the Turing Machine.</p>
<p>The proof is by induction:</p>
<ol>
<li>If $t=1$ then $c_{1}=c_{2}$ or it&rsquo;s possible to go into $c_{2}$ using a single step. This is verifiable using the windows argument in the <a href="/notes/cook-levin-and-savitch/#cook-levin-theorem">Cook-Levin theorem</a>.
Else it&rsquo;s a little bit more difficult.
It&rsquo;s easy to verify it 🤠.
$$
F_{c, c', t} = \exists m_{1} \forall(c_{3}, c_{4}) \in \left\{ (c, m_{1}), (m_{1}, c') \right\} F_{c_{3}, c_{4}, \frac{t}{2}}
$$
Given this inductive formulation, we can observe that we add only $O(n^{k})$ quantifiers in the recursive proof. So the formula has $\log (2^{dn^{k}})$ induction steps which is $O(n^{k})$. So this problem is PSPACE-hard.</li>
</ol>
<h3 id="two-player-games">Two player games<a hidden class="anchor" aria-hidden="true" href="#two-player-games">#</a></h3>
<p>It is possible to prove that every two player zero-sum game like chess or Go, that uses a minimax tree search strategy can be expressed into a TQBF problem like this (informally):
For every move of the opponent, exists one of my moves such that for every move of the opponent &hellip;. -&gt; I win.
This is a TQBF statement.</p>
<h2 id="the-tiling-problem">The Tiling Problem<a hidden class="anchor" aria-hidden="true" href="#the-tiling-problem">#</a></h2>
<h3 id="formalizzazione-del-problema">Formalizzazione del problema<a hidden class="anchor" aria-hidden="true" href="#formalizzazione-del-problema">#</a></h3>
<h4 id="definizione-formale-del-tiling">Definizione formale del tiling<a hidden class="anchor" aria-hidden="true" href="#definizione-formale-del-tiling">#</a></h4>
<p>Consideriamo una tupla $\langle \mathcal{T}, t_{0}, H, V \rangle$</p>
<ol>
<li>$\mathcal{T}$ è un insieme di piastrelle.</li>
<li>$t_{0} \in \mathcal{T}$ è la piastrella d&rsquo;origine.</li>
<li>$H \subseteq \mathcal{T} \times \mathcal{T}$ le regole di adiacenza orizzontali.</li>
<li>$V \subseteq \mathcal{T} \times \mathcal{T}$ le regole di adiacenza verticali.</li>
</ol>
<p>L&rsquo;obiettivo è vedere se è possibile riempire tutto il piano con queste piastrelle, all&rsquo;infinito. Sappiamo già che non è sempre possibile farlo. Ci chiediamo se è automatizzabile. Questo problema è stato risolto nel 1966, e sembra non essere riconoscibile nemmeno.</p>
<p>Ossia in matematichese definire la funzione
$f : \mathbb{N} \times \mathbb{N} \to \mathcal{T}$
Con</p>
<ol>
<li>$f(1, 1) = t_{0}$</li>
<li>$\forall n,m \in \mathbb{N}, (f(n, m), f(n + 1, m)) \in V$</li>
<li>$\forall n,m \in \mathbb{N}, (f(n, m), f(n, m+1)) \in H$</li>
</ol>
<h4 id="strategia-di-dimostrazione">Strategia di dimostrazione<a hidden class="anchor" aria-hidden="true" href="#strategia-di-dimostrazione">#</a></h4>
<p>Vogliamo ridurlo da $ETH^{-}$ che abbiamo spiegato in <a href="/notes/halting-theorem-and-reducibility/">Halting Theorem and Reducibility</a>.
Questo è un linguaggio non riconoscibile, perché il suo complemento è riconoscibile in modo banale.</p>
<p>Questa dimostrazione avrà un sacco di punti molto tecnici per dire che una macchina di turing deve essere tradotta in un problema di tiling&hellip;</p>
<h3 id="dimostrazione-irriconoscibilità-del-tiling">Dimostrazione irriconoscibilità del tiling<a hidden class="anchor" aria-hidden="true" href="#dimostrazione-irriconoscibilità-del-tiling">#</a></h3>
<p>L&rsquo;idea principale è che con un tiling posso <strong>simulare l&rsquo;esecuzione</strong> di una macchina di Turing.
E in questo modo riduco il problema a un Halt. Perché sapere tassellare significa sapere dire quando una macchina di Turing finisce.</p>
<h4 id="codifica-delle-regole-dei-tiling">Codifica delle regole dei tiling<a hidden class="anchor" aria-hidden="true" href="#codifica-delle-regole-dei-tiling">#</a></h4>
<p>Posso codificare sia i tile disponibili, sia le regole di adiacenza in questo modo.</p>
<img src="/images/notes/Tiling problem-20240307134015081.webp" alt="Tiling problem-20240307134015081">
<p>Poi vogliamo codificare ogni casella verticale <strong>un singolo step di computazione</strong>.</p>
<h4 id="cella-di-identità">Cella di identità<a hidden class="anchor" aria-hidden="true" href="#cella-di-identità">#</a></h4>
<p>Questa cella non fa niente.
<img src="/images/notes/Tiling problem-20240307134139688.webp" alt="Tiling problem-20240307134139688"></p>
<h4 id="celle-di-transizione">Celle di transizione<a hidden class="anchor" aria-hidden="true" href="#celle-di-transizione">#</a></h4>
<p>Possiamo codificare le funzioni di transizione della macchina di Turing.
Poi ho ancora le cose che mantengono il simbolo nella cella di arrivo.</p>
<img src="/images/notes/Tiling problem-20240307134228290.webp" alt="Tiling problem-20240307134228290">
<h4 id="conclusione">Conclusione<a hidden class="anchor" aria-hidden="true" href="#conclusione">#</a></h4>
<p>sse non si ferma la macchina, allora esiste un tiling (che è una cosa banale perché significa che continua all&rsquo;infinito, e quindi posso mappare tutto).</p>
<img src="/images/notes/Tiling problem-20240307134959316.webp" alt="Tiling problem-20240307134959316">
<h1 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h1>
<p>[1] Sipser <a href="https://books.google.it/books/about/Introduction_to_the_Theory_of_Computatio.html?id=P3f6CAAAQBAJ">“Introduction to the Theory of Computation”</a> Cengage Learning 2012</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/theoretical-computer-science/">Theoretical-Computer-Science</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Common problems in Theoretical CS on x"
            href="https://x.com/intent/tweet/?text=Common%20problems%20in%20Theoretical%20CS&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fcommon-problems-in-theoretical-cs%2f&amp;hashtags=theoretical-computer-science">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Common problems in Theoretical CS on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fcommon-problems-in-theoretical-cs%2f&amp;title=Common%20problems%20in%20Theoretical%20CS&amp;summary=Common%20problems%20in%20Theoretical%20CS&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2fcommon-problems-in-theoretical-cs%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Common problems in Theoretical CS on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2fcommon-problems-in-theoretical-cs%2f&title=Common%20problems%20in%20Theoretical%20CS">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Common problems in Theoretical CS on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2fcommon-problems-in-theoretical-cs%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Common problems in Theoretical CS on whatsapp"
            href="https://api.whatsapp.com/send?text=Common%20problems%20in%20Theoretical%20CS%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2fcommon-problems-in-theoretical-cs%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Common problems in Theoretical CS on telegram"
            href="https://telegram.me/share/url?text=Common%20problems%20in%20Theoretical%20CS&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fcommon-problems-in-theoretical-cs%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Common problems in Theoretical CS on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Common%20problems%20in%20Theoretical%20CS&u=https%3a%2f%2fflecart.github.io%2fnotes%2fcommon-problems-in-theoretical-cs%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2025 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
