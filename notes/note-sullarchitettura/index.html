<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Note sull&#39;architettura | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="sistemi-operativi">
<meta name="description" content="Interrupt
Descrizione iniziale
Di interrupt e trap se n’è parlato un pò in Livello ISA di architettura, ora andiamo ad approfondire come viene gestito a livello SO.
Un interrupt è un segnale che viene mandato o da un dispositivo hardware (di solito dopo la fine di un processo input output) oppure da software, in questo caso viene chiamato trap che è un interrupt software sincrono..


Slide Interrupt Hardware e software
  


Questi segnali sono utilizzati per indicare eventi che dovrebbero essere gestiti (come end of I/O, divisione per 0, ma anche semplicemente syscall e passare livello kernel).">
<meta name="author" content="Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="https://flecart.github.io/notes/note-sullarchitettura/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/note-sullarchitettura/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>
<script type="text/javascript" async
src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>






      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-WW6NN2QGKF');
        }
      </script><meta property="og:url" content="https://flecart.github.io/notes/note-sullarchitettura/">
  <meta property="og:site_name" content="X. Angelo Huang&#39;s Blog">
  <meta property="og:title" content="Note sull&#39;architettura">
  <meta property="og:description" content="Interrupt Descrizione iniziale Di interrupt e trap se n’è parlato un pò in Livello ISA di architettura, ora andiamo ad approfondire come viene gestito a livello SO.
Un interrupt è un segnale che viene mandato o da un dispositivo hardware (di solito dopo la fine di un processo input output) oppure da software, in questo caso viene chiamato trap che è un interrupt software sincrono..
Slide Interrupt Hardware e software
Questi segnali sono utilizzati per indicare eventi che dovrebbero essere gestiti (come end of I/O, divisione per 0, ma anche semplicemente syscall e passare livello kernel).">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="notes">
    <meta property="article:tag" content="Sistemi-Operativi">
      <meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:title" content="Note sull&#39;architettura">
<meta name="twitter:description" content="Interrupt
Descrizione iniziale
Di interrupt e trap se n’è parlato un pò in Livello ISA di architettura, ora andiamo ad approfondire come viene gestito a livello SO.
Un interrupt è un segnale che viene mandato o da un dispositivo hardware (di solito dopo la fine di un processo input output) oppure da software, in questo caso viene chiamato trap che è un interrupt software sincrono..


Slide Interrupt Hardware e software
  


Questi segnali sono utilizzati per indicare eventi che dovrebbero essere gestiti (come end of I/O, divisione per 0, ma anche semplicemente syscall e passare livello kernel).">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Note sull'architettura",
      "item": "https://flecart.github.io/notes/note-sullarchitettura/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Note sull'architettura",
  "name": "Note sull\u0027architettura",
  "description": "Interrupt Descrizione iniziale Di interrupt e trap se n’è parlato un pò in Livello ISA di architettura, ora andiamo ad approfondire come viene gestito a livello SO.\nUn interrupt è un segnale che viene mandato o da un dispositivo hardware (di solito dopo la fine di un processo input output) oppure da software, in questo caso viene chiamato trap che è un interrupt software sincrono..\nSlide Interrupt Hardware e software\nQuesti segnali sono utilizzati per indicare eventi che dovrebbero essere gestiti (come end of I/O, divisione per 0, ma anche semplicemente syscall e passare livello kernel).\n",
  "keywords": [
    "sistemi-operativi"
  ],
  "articleBody": "Interrupt Descrizione iniziale Di interrupt e trap se n’è parlato un pò in Livello ISA di architettura, ora andiamo ad approfondire come viene gestito a livello SO.\nUn interrupt è un segnale che viene mandato o da un dispositivo hardware (di solito dopo la fine di un processo input output) oppure da software, in questo caso viene chiamato trap che è un interrupt software sincrono..\nSlide Interrupt Hardware e software\nQuesti segnali sono utilizzati per indicare eventi che dovrebbero essere gestiti (come end of I/O, divisione per 0, ma anche semplicemente syscall e passare livello kernel).\nIl segnale solitamente implica la interruzione di quanto viene svolto in questo momento, per gestire l’interrupt corrente, e poi tornare all’istruzione precedente. Solitamente perché potrebbe anche essere che il processo non sia interrompibile, e quindi l’interrupt dovrebbe essere rischedulato.\nPer poter ripristinare lo stato precedente solitamente ci si devono salvare l’immagine dei registri del programma, tutte le informazioni utili a far runnare il processo (di solito messe nelle PCB), e l’istruzione di ritorno.\nQuando ci si ritorna sopra basta mettere nel PC l’indirizzo della istruzione corretta.\nProcedimento classico di gestione interrupt Praticamente durante il Ciclo va a fare un check per vedere se il filo dell’interrupt è settato, se sì carica istruzioni a un certo indirizzo (e si deve salvare l’istruzione attuale).\nMasked se si sta facendo qualcosa che non si può interrompere, quindi è delayed. (quando il processore non può essere interrotto, ad esempio quando sei in Sezioni Critiche, o quando arrivano interrupt dello stesso tipo, se ogni interrupt ha una stack propria, andrebbe a sovrascrivere).\nSe tutto va bene e non è delayed ed esiste un interrupt, ad alto livello fa:\nSospende (in un modo che possa essere ripreso) il processo corrente Salta all’istruzione definito in interrupt vector **(**tabella fissa così è più veloce) Esegue l’interrupt Si ritorna al processo precedente, o altro (scheduling potrebbe far andare in altro processo). Slides passi ad alto livello\nSlides passi a basso livello (!!!)\nFino a qui tutte le operazioni sono HARDWARE. Da ora in poi viene ripreso il ciclo FDE con il controllo dell Interrupt handler.\nTipologie di gestione di interrupt Multipli (2) Quando ho interrupt multipli diventa leggermente più difficile gestire questi interrupt. Potrebbero interagire, che succede quando mi arriva un interrupt da device 1 mentre sto runnando l’interrupt handler di device 2???\nDisabilitazione degli interrupt\nQuesta è la forma più semplice per la gestione dell’interrupt, in pratica quando sto gestendo un interrupt, li disabilito, in modo che non possa riceverne altri, così sono sicuro che non posso ricevere nessun altro interrupt. Una soluzione simile per le CS ne abbiamo discusso in Sezioni Critiche\nQuando sto per finire riattivo gli interrupt e così posso vedere se ce ne erano alcuni pendenti.\nHo alcuni svantaggi come:\nNon ho un concetto di priorità degli interrupt a questo livello Slide idea di gestione\nAnnidamento degli interrupt\nQuesta è la soluzione più moderna, ed è anche la più efficiente che permette di\nAvere un concetto di priorità di interrupts Necessita di stack separati (se gli interrupt utilizzano la stessa stack, potrebbero sovrascriversi alcune informazioni!) quindi più difficile da implementare. Forse ogni interrupt ha una propria stack, se viene stetsso tipo di interrupt sono maskerati! PI/O, or Interrupt based I/O PI/O In questo caso la CPU setta tutti i valori utili al controllore del device driver. e poi fa polling per chiedere al driver se ha finito o meno (attraverso un controllo sul registro di stato del driver).\nSe il driver ha finito, la CPU si mette a copiare i dati di output del device alla propria memoria. Un chiaro svantaggio è che il polling è molto inefficiente per la soluzione di questo tipo di problemi.\nInterrupt Driven I/O Questa è la soluzione moderna, quella più utilizzata, dato che ora è il dispositivo driver a comunicare quando un processo I/O è stato completato o men, così la CPU è a conoscenza di questo evento e può comportarsi di conseguenza. (quindi quando gestire l’interrupt, e poi effettivamente runnare il codice corrispondente quando l’interrupt è avvenuto).\nMemoria Vedi Memoria.\nDirect Memory Access Per copiare alcuni dati utili per I/O dalla memoria RAM alla memoria del controllore bisognerebbe spendere tanti cicli di clock della CPU, di solito questa è una operazione molto lenta.\nDMA ci permette di accedere direttamente alla memoria, quindi il controllore stesso è programmato con l’indirizzo su cui andare a prelevare la memoria corretta, sollevando la CPU da questo primo lavoro.\nChiaramente il vantaggio principale di questo metodo è la velocità, dato che abbiamo più cicli di clock per la CPU, oltre a questo, crea una interfaccia più facile da gestire, quindi i drivers sono più semplici.\nUno svantaggio è la contesa del BUS, che per trasferire c’è bisogno che il bus sia libero.\nSicurezza\nQuesto è un possibile falla di sicurezza, infatti se il codice del controller è malevolo potrebbe fare attacchi al sistema di certo tipo.\nSecondo Renzo sarebbe meglio che questo codice fosse open, in modo che sia molto probabile di trovare cose maligne.\nRam È semplificata da poche istruzioni di accesso, che di solito sono solo LOAD E STORE. (Tutti i dettagli fisici sono astratti, la CPU non si interessa di questi, sono built-in del calcolatore!).\nDi solito (in modi che non so), sono gestiti da MMU.\nNOTA: ci mettono un pò i condensatori a scaricarsi. (possibile recuperare un pò di informazioni se tipo congeli la RAM subito).\nLe ROM esistono ancora, ma sono per cose basilari, come per la parte del boot.\nMemory Mapped I/O Alcune aree di memoria, come quelle del video grafico, sono scritti e letti subito da alcuni driver e sono utilizzati per sapere cosa mostrare sullo schermo per esempio.\nMa dato che 2 componenti (read and write) devono sincronizzarci nella lettura. Questa sincronizzazione di solito è fatta a livello hardware.\nDischi e SSD Abbiamo spiegato meglio questa parte in Devices OS\nDischi memorizzano in maniera magnetica, e lo fanno in maniera non-volatile, cioè possiamo ritrovare i nostri dati.\nSono a accesso diretto, in contrasto con i nastri che erano sequenziali. leggermente accennato in Memoria. E per capire dove leggere e scrivere si devono impostante movimenti di settore del cilindro e testina per leggere il settore corretto. Settore si aspetta che giri, testina si aspetta che si sposti. È lento, nell’ordine dei microsecondi.\nOperazioni possibili dei Dischi READ, WRITE e anche Seek (quando vado a spostare la testina da altre parti!) Sulla velocità Non ci converrebbe avere uno stesso file messo in posti molto diversi fra di loro all’intenro del disco!\nCose di scheduling in modo da leggere cose che siano vicine. (Ma anche il filesystem, in modo che cose che cose che vengono utilizzate spesso siano vicine, ma questa roba la vedremo dopo)\nSolid State Disk Anche conosciuti come SSD, questi sono per cose non volatili.\nSolitamente scrivono ad insieme di blocchi! e lo si fa in cicli di scrittura perché non scrive ad ogni singola scrittura, ma sono in un buffer, e saranno scritti insieme in tutti in un ciclo di scrittura, questo è per rendere più efficiente questa operazione.\nPer ssd a volte tengo la RAM come una cache intermedia per la scrittura.\nGerarchie di memoria L’altro argomento si parlerebbe di Cache, ma penso sia trattato già benissimo in Memoria#4.2 Memoria Cache.\nQuindi guardare lì, guardare la piramide della memoria il tradeoff velocità e quantità di memoria, il costo di accesso (in termini di tempo ed energia).\nSicurezza Il processo\nNon dovrebbe accedere ad aree di memoria a cui non dovrebbe accedere Non dovrebbe accedere direttamente ai dispositivi I/O, altrimenti potrei accedere e modificare qualunque cosa sui driver, e qualunque processo potrebbe farlo. È importante garantire la sicurezza anche per l’affidabilità del sistema, anche per proteggere il programmatore stesso, quando fa qualcosa in modo accidentale, in modo da evitare danni brutti. al sistema\nMode Bit nella realtà le protezioni principali sono due, messe a livello hardware\nUn Mode bit che sta a specificare se il CPU è in Kernel mode o user mode. Questi metodi sono importanti perché il modo kernel permette accesso totale controllo totale sulla memoria, sull’IO, mentre user solamente gli indirizzi a lui illegali. Questo metodo permette di entrare in kernel mode in modo controllato, in modo che riesca sempre a gestire questa protezione. Ovviamente il cambio del mode bit è privilegiato, un programma normalmente non può cambiare mode con una singola istruzione, deve passare con system call che sono le interrupt software o trap, con una istruzione specifica per mandare interrupt. È l’unico modo!. Nota: ovviamente quando il computer parte, in boostrap è in modalità kernel, che appena finisce tornerà in User Mode (è il processo INIT!) Una mappatura a indirizzi illegali per il programma, in modo che possa accedere solamente a quello a cui dovrebbe accedere. Protezione memoria Questo pezzo di hardware ha il ruolo di tradurre indirizzi logici in fisici, e gestire l’accesso (ritorna l’errore se non si potrebbe fare).\nÈ importante che sia in Hardware perché:\nDeve essere molto veloce, perché sono operazioni molto veloci Si potrebbe bypassare e allora avresti accesso a tutta la memoria ugualmente. System call La sistem call è una unica istruzione, mediante la quale è possibile accedere al kernel mode, in grado di accedere a tutto, utile per la protezione e affidabilità del sistema, e non permettere programmi di fare tutto.\nEsistono convenzioni di chiamata, perché si aspetta in un certo registro la presenza di un codice che specifichi la tipologia di system call, poi la sistem call ritornerà il valore corretto in un certo registro.\n",
  "wordCount" : "1591",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/note-sullarchitettura/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Note sull&#39;architettura
    </h1>
    <div class="post-meta">8 min&nbsp;·&nbsp;Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#interrupt" aria-label="Interrupt">Interrupt</a><ul>
                        
                <li>
                    <a href="#descrizione-iniziale" aria-label="Descrizione iniziale">Descrizione iniziale</a></li>
                <li>
                    <a href="#procedimento-classico-di-gestione-interrupt" aria-label="Procedimento classico di gestione interrupt">Procedimento classico di gestione interrupt</a></li>
                <li>
                    <a href="#tipologie-di-gestione-di-interrupt-multipli-2" aria-label="Tipologie di gestione di interrupt Multipli (2)">Tipologie di gestione di interrupt Multipli (2)</a></li>
                <li>
                    <a href="#pio-or-interrupt-based-io" aria-label="PI/O, or Interrupt based I/O">PI/O, or Interrupt based I/O</a><ul>
                        
                <li>
                    <a href="#pio" aria-label="PI/O">PI/O</a></li>
                <li>
                    <a href="#interrupt-driven-io" aria-label="Interrupt Driven I/O">Interrupt Driven I/O</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#memoria" aria-label="Memoria">Memoria</a><ul>
                        
                <li>
                    <a href="#direct-memory-access" aria-label="Direct Memory Access">Direct Memory Access</a></li>
                <li>
                    <a href="#ram" aria-label="Ram">Ram</a></li>
                <li>
                    <a href="#memory-mapped-io" aria-label="Memory Mapped I/O">Memory Mapped I/O</a></li>
                <li>
                    <a href="#dischi-e-ssd" aria-label="Dischi e SSD">Dischi e SSD</a><ul>
                        
                <li>
                    <a href="#operazioni-possibili-dei-dischi" aria-label="Operazioni possibili dei Dischi">Operazioni possibili dei Dischi</a></li>
                <li>
                    <a href="#sulla-velocit%c3%a0" aria-label="Sulla velocità">Sulla velocità</a></li>
                <li>
                    <a href="#solid-state-disk" aria-label="Solid State Disk">Solid State Disk</a></li></ul>
                </li>
                <li>
                    <a href="#gerarchie-di-memoria" aria-label="Gerarchie di memoria">Gerarchie di memoria</a></li></ul>
                </li>
                <li>
                    <a href="#sicurezza" aria-label="Sicurezza">Sicurezza</a><ul>
                        
                <li>
                    <a href="#mode-bit" aria-label="Mode Bit">Mode Bit</a></li>
                <li>
                    <a href="#protezione-memoria" aria-label="Protezione memoria">Protezione memoria</a></li>
                <li>
                    <a href="#system-call" aria-label="System call">System call</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="interrupt">Interrupt<a hidden class="anchor" aria-hidden="true" href="#interrupt">#</a></h2>
<h3 id="descrizione-iniziale">Descrizione iniziale<a hidden class="anchor" aria-hidden="true" href="#descrizione-iniziale">#</a></h3>
<p>Di interrupt e trap se n’è parlato un pò in <a href="/notes/livello-isa">Livello ISA</a> di architettura, ora andiamo ad approfondire come viene gestito a livello SO.</p>
<p>Un interrupt è un <strong>segnale</strong> che viene mandato o da un dispositivo hardware (di solito dopo la fine di un processo input output) oppure da software, in questo caso viene chiamato <strong>trap</strong> che è un interrupt software sincrono..</p>
<ul>
<li>
<p>Slide Interrupt Hardware e software</p>
  <img src="/images/notes/image/universita/ex-notion/Note sull’architettura/Untitled.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Note sull’architettura/Untitled">
</li>
</ul>
<p>Questi segnali sono utilizzati per <strong>indicare eventi</strong> che dovrebbero essere gestiti (come end of I/O, divisione per 0, ma anche semplicemente syscall e passare livello kernel).</p>
<p>Il segnale solitamente implica la interruzione di quanto viene svolto in questo momento, per gestire l’interrupt corrente, e poi tornare all’istruzione precedente. Solitamente perché potrebbe anche essere che il processo non sia interrompibile, e quindi l’interrupt dovrebbe essere rischedulato.</p>
<p>Per poter ripristinare lo stato precedente solitamente ci si devono salvare l’immagine dei registri del programma, tutte le informazioni utili a far runnare il processo (di solito messe nelle PCB), e l’istruzione di ritorno.</p>
<p>Quando ci si ritorna sopra basta mettere nel PC l’indirizzo della istruzione corretta.</p>
<h3 id="procedimento-classico-di-gestione-interrupt">Procedimento classico di gestione interrupt<a hidden class="anchor" aria-hidden="true" href="#procedimento-classico-di-gestione-interrupt">#</a></h3>
<p>Praticamente durante il Ciclo va a fare un check per vedere se il filo dell’interrupt è settato, se sì carica istruzioni a un certo indirizzo (e si deve salvare l’istruzione attuale).</p>
<p>Masked se si sta facendo qualcosa che non si può interrompere, quindi è <strong>delayed</strong>. (quando il processore non può essere interrotto, ad esempio quando sei in <a href="/notes/sezioni-critiche">Sezioni Critiche</a>, o quando arrivano interrupt dello stesso tipo, se ogni interrupt ha una stack propria, andrebbe a sovrascrivere).</p>
<p>Se tutto va bene e non è delayed ed esiste un interrupt, ad alto livello fa:</p>
<ol>
<li>Sospende (in un modo che possa essere ripreso) il processo corrente</li>
<li>Salta all’istruzione definito in <strong>interrupt vector</strong> **(**tabella fissa così è più veloce)</li>
<li>Esegue l’interrupt</li>
<li>Si ritorna al processo precedente, o altro (scheduling potrebbe far andare in altro processo).</li>
</ol>
<ul>
<li>
<p>Slides passi ad alto livello</p>
  <img src="/images/notes/image/universita/ex-notion/Note sull’architettura/Untitled 1.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Note sull’architettura/Untitled 1">
  <img src="/images/notes/image/universita/ex-notion/Note sull’architettura/Untitled 2.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Note sull’architettura/Untitled 2">
</li>
<li>
<p>Slides passi a basso livello (!!!)</p>
  <img src="/images/notes/image/universita/ex-notion/Note sull’architettura/Untitled 3.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Note sull’architettura/Untitled 3">
  <img src="/images/notes/image/universita/ex-notion/Note sull’architettura/Untitled 4.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Note sull’architettura/Untitled 4">
<p>Fino a qui <strong>tutte le operazioni sono HARDWARE</strong>. Da ora in poi viene ripreso il ciclo FDE con il controllo dell Interrupt handler.</p>
  <img src="/images/notes/image/universita/ex-notion/Note sull’architettura/Untitled 5.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Note sull’architettura/Untitled 5">
</li>
</ul>
<h3 id="tipologie-di-gestione-di-interrupt-multipli-2">Tipologie di gestione di interrupt Multipli (2)<a hidden class="anchor" aria-hidden="true" href="#tipologie-di-gestione-di-interrupt-multipli-2">#</a></h3>
<p>Quando ho interrupt multipli diventa leggermente più difficile gestire questi interrupt. Potrebbero interagire, che succede quando mi arriva un interrupt da device 1 mentre sto runnando l’interrupt handler di device 2???</p>
<p><strong>Disabilitazione degli interrupt</strong></p>
<p>Questa è la forma più semplice per la gestione dell’interrupt, in pratica quando sto gestendo un interrupt, li disabilito, in modo che non possa riceverne altri, così sono sicuro che non posso ricevere nessun altro interrupt. Una soluzione simile per le CS ne abbiamo discusso in <a href="/notes/sezioni-critiche">Sezioni Critiche</a></p>
<p>Quando sto per finire riattivo gli interrupt e così posso vedere se ce ne erano alcuni pendenti.</p>
<p>Ho alcuni svantaggi come:</p>
<ol>
<li>Non ho un concetto di priorità degli interrupt a questo livello</li>
</ol>
<ul>
<li>
<p>Slide idea di gestione</p>
  <img src="/images/notes/image/universita/ex-notion/Note sull’architettura/Untitled 6.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Note sull’architettura/Untitled 6">
</li>
</ul>
<p><strong>Annidamento degli interrupt</strong></p>
<p>Questa è la soluzione più moderna, ed è anche la più efficiente che permette di</p>
<ol>
<li>Avere un concetto di priorità di interrupts</li>
<li>Necessita di stack separati (se gli interrupt utilizzano la stessa stack, potrebbero sovrascriversi alcune informazioni!) quindi più difficile da implementare.
<ol>
<li>Forse ogni interrupt ha una propria stack, se viene stetsso tipo di interrupt sono maskerati!</li>
</ol>
</li>
</ol>
<h3 id="pio-or-interrupt-based-io">PI/O, or Interrupt based I/O<a hidden class="anchor" aria-hidden="true" href="#pio-or-interrupt-based-io">#</a></h3>
<h4 id="pio">PI/O<a hidden class="anchor" aria-hidden="true" href="#pio">#</a></h4>
<p>In questo caso la CPU setta tutti i valori utili al controllore del device driver. e poi fa <strong>polling</strong> per chiedere al driver se ha finito o meno (attraverso un controllo sul registro di stato del driver).</p>
<p>Se il driver ha finito, la CPU si mette a copiare i dati di output del device alla propria memoria.
Un chiaro svantaggio è che il polling è molto inefficiente per la soluzione di questo tipo di problemi.</p>
<h4 id="interrupt-driven-io">Interrupt Driven I/O<a hidden class="anchor" aria-hidden="true" href="#interrupt-driven-io">#</a></h4>
<p>Questa è la soluzione moderna, quella più utilizzata, dato che ora è il dispositivo driver a comunicare quando un processo I/O è stato completato o men, così la CPU è a conoscenza di questo evento e può comportarsi di conseguenza. (quindi quando gestire l’interrupt, e poi effettivamente runnare il codice corrispondente quando l’interrupt è avvenuto).</p>
<h2 id="memoria">Memoria<a hidden class="anchor" aria-hidden="true" href="#memoria">#</a></h2>
<p>Vedi <a href="/notes/memoria">Memoria</a>.</p>
<h3 id="direct-memory-access">Direct Memory Access<a hidden class="anchor" aria-hidden="true" href="#direct-memory-access">#</a></h3>
<p>Per copiare alcuni dati utili per I/O dalla memoria RAM alla memoria del controllore bisognerebbe spendere tanti cicli di clock della CPU, di solito questa è una operazione molto lenta.</p>
<p>DMA ci permette di accedere direttamente alla memoria, quindi il controllore stesso è programmato con l’indirizzo su cui andare a prelevare la memoria corretta, sollevando la CPU da questo primo lavoro.</p>
<p>Chiaramente il vantaggio principale di questo metodo è la velocità, dato che abbiamo più cicli di clock per la CPU, oltre a questo, crea una interfaccia più facile da gestire, quindi i drivers sono più semplici.</p>
<p>Uno svantaggio è la contesa del BUS, che per trasferire c’è bisogno che il bus sia libero.</p>
<p><strong>Sicurezza</strong></p>
<p>Questo è un possibile falla di sicurezza, infatti se il codice del controller è malevolo potrebbe fare attacchi al sistema di certo tipo.</p>
<p>Secondo Renzo sarebbe meglio che questo codice fosse open, in modo che sia molto probabile di trovare cose maligne.</p>
<h3 id="ram">Ram<a hidden class="anchor" aria-hidden="true" href="#ram">#</a></h3>
<p>È semplificata da poche istruzioni di accesso, che di solito sono solo LOAD E STORE. (Tutti i dettagli fisici sono astratti, la CPU non si interessa di questi, sono built-in del calcolatore!).</p>
<p>Di solito (in modi che non so), sono gestiti da MMU.</p>
<p>NOTA: ci mettono un pò i condensatori a scaricarsi. (possibile recuperare un pò di informazioni se tipo congeli la RAM subito).</p>
<p>Le <strong>ROM</strong> esistono ancora, ma sono per cose basilari, come per la parte del boot.</p>
<h3 id="memory-mapped-io">Memory Mapped I/O<a hidden class="anchor" aria-hidden="true" href="#memory-mapped-io">#</a></h3>
<p>Alcune aree di memoria, come quelle del video grafico, sono scritti e letti subito da alcuni driver e sono utilizzati per sapere cosa mostrare sullo schermo per esempio.</p>
<p>Ma dato che 2 componenti (read and write) devono <strong>sincronizzarci</strong> nella lettura. Questa sincronizzazione di solito è fatta a livello hardware.</p>
<h3 id="dischi-e-ssd">Dischi e SSD<a hidden class="anchor" aria-hidden="true" href="#dischi-e-ssd">#</a></h3>
<p>Abbiamo spiegato meglio questa parte in <a href="/notes/devices-os">Devices OS</a></p>
<p>Dischi memorizzano in maniera magnetica, e lo fanno in maniera non-volatile, cioè possiamo ritrovare i nostri dati.</p>
<p>Sono a accesso diretto, in contrasto con i nastri che erano sequenziali. leggermente accennato in <a href="/notes/memoria">Memoria</a>. E per capire dove leggere e scrivere si devono impostante movimenti di settore del cilindro e testina per leggere il settore corretto. Settore si aspetta che giri, testina si aspetta che si sposti. È lento, nell’ordine dei microsecondi.</p>
<h4 id="operazioni-possibili-dei-dischi">Operazioni possibili dei Dischi<a hidden class="anchor" aria-hidden="true" href="#operazioni-possibili-dei-dischi">#</a></h4>
<p>READ, WRITE e anche Seek (quando vado a spostare la testina da altre parti!)
<img src="/images/notes/image/universita/ex-notion/Note sull’architettura/Untitled 7.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Note sull’architettura/Untitled 7"></p>
<h4 id="sulla-velocità">Sulla velocità<a hidden class="anchor" aria-hidden="true" href="#sulla-velocità">#</a></h4>
<p>Non ci converrebbe avere uno stesso file messo in posti molto diversi fra di loro all’intenro del disco!</p>
<p>Cose di scheduling in modo da leggere cose che siano vicine. (Ma anche il filesystem, in modo che cose che cose che vengono utilizzate spesso siano vicine, ma questa roba la vedremo dopo)</p>
<h4 id="solid-state-disk">Solid State Disk<a hidden class="anchor" aria-hidden="true" href="#solid-state-disk">#</a></h4>
<p>Anche conosciuti come SSD, questi sono per cose non volatili.</p>
<p>Solitamente scrivono ad insieme di blocchi! e lo si fa in <strong>cicli di scrittura</strong> perché non scrive ad ogni singola scrittura, ma sono in un buffer, e saranno scritti insieme in tutti in un ciclo di scrittura, questo è per rendere più efficiente questa operazione.</p>
<p>Per ssd a volte tengo la RAM come una cache intermedia per la scrittura.</p>
<h3 id="gerarchie-di-memoria">Gerarchie di memoria<a hidden class="anchor" aria-hidden="true" href="#gerarchie-di-memoria">#</a></h3>
<img src="/images/notes/image/universita/ex-notion/Note sull’architettura/Untitled 8.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Note sull’architettura/Untitled 8">
<img src="/images/notes/image/universita/ex-notion/Note sull’architettura/Untitled 9.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Note sull’architettura/Untitled 9">
<p>L’altro argomento si parlerebbe di Cache, ma penso sia trattato già benissimo in <a href="/notes/memoria#4.2-memoria-cache">Memoria#4.2 Memoria Cache</a>.</p>
<p>Quindi guardare lì, guardare la piramide della memoria il tradeoff velocità e quantità di memoria, il costo di accesso (in termini di tempo ed energia).</p>
<h2 id="sicurezza">Sicurezza<a hidden class="anchor" aria-hidden="true" href="#sicurezza">#</a></h2>
<p>Il processo</p>
<ul>
<li>Non dovrebbe accedere ad aree di memoria a cui non dovrebbe accedere</li>
<li>Non dovrebbe accedere direttamente ai dispositivi I/O, altrimenti potrei accedere e modificare qualunque cosa sui driver, e qualunque processo potrebbe farlo.</li>
</ul>
<p>È importante garantire la sicurezza anche per l’<strong>affidabilità del sistema</strong>, anche per proteggere il programmatore stesso, quando fa qualcosa in modo accidentale, in modo da evitare danni brutti. al sistema</p>
<h3 id="mode-bit">Mode Bit<a hidden class="anchor" aria-hidden="true" href="#mode-bit">#</a></h3>
<p>nella realtà le protezioni principali sono due, messe a livello hardware</p>
<ol>
<li>Un <strong>Mode bit</strong> che sta a specificare se il <strong>CPU è in Kernel mode o user mode</strong>.
<ol>
<li>Questi metodi sono importanti perché il modo kernel permette accesso totale controllo totale sulla memoria, sull’IO, mentre user solamente gli indirizzi a lui illegali. Questo metodo permette di entrare in kernel mode in modo controllato, in modo che riesca sempre a gestire questa protezione.</li>
<li>Ovviamente il cambio del mode bit è privilegiato, un programma normalmente non può cambiare mode con una singola istruzione, deve passare con system call che sono le interrupt software o trap, con una istruzione specifica per mandare interrupt. È l&rsquo;unico modo!.</li>
<li>Nota: ovviamente quando il computer parte, in <strong>boostrap</strong> è in modalità kernel, che appena finisce tornerà in User Mode (è il processo INIT!)</li>
</ol>
</li>
<li>Una mappatura a indirizzi illegali per il programma, in modo che possa accedere solamente a quello a cui dovrebbe accedere.</li>
</ol>
<h3 id="protezione-memoria">Protezione memoria<a hidden class="anchor" aria-hidden="true" href="#protezione-memoria">#</a></h3>
<img src="/images/notes/image/universita/ex-notion/Note sull’architettura/Untitled 10.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Note sull’architettura/Untitled 10">
<p>Questo pezzo di hardware ha il ruolo di <strong>tradurre indirizzi logici in fisici</strong>, e gestire l&rsquo;accesso (ritorna l’errore se non si potrebbe fare).</p>
<p>È importante che sia in Hardware perché:</p>
<ol>
<li>Deve essere molto veloce, perché sono operazioni molto veloci</li>
<li>Si potrebbe bypassare e allora avresti accesso a tutta la memoria ugualmente.</li>
</ol>
<h3 id="system-call">System call<a hidden class="anchor" aria-hidden="true" href="#system-call">#</a></h3>
<p>La sistem call è una unica istruzione, mediante la quale è possibile accedere al kernel mode, in grado di accedere a tutto, utile per la protezione e affidabilità del sistema, e non permettere programmi di fare tutto.</p>
<p>Esistono convenzioni di chiamata, perché si aspetta in un certo registro la presenza di un codice che specifichi la tipologia di system call, poi la sistem call ritornerà il valore corretto in un certo registro.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/sistemi-operativi/">Sistemi-Operativi</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Note sull&#39;architettura on x"
            href="https://x.com/intent/tweet/?text=Note%20sull%27architettura&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fnote-sullarchitettura%2f&amp;hashtags=sistemi-operativi">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Note sull&#39;architettura on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fnote-sullarchitettura%2f&amp;title=Note%20sull%27architettura&amp;summary=Note%20sull%27architettura&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2fnote-sullarchitettura%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Note sull&#39;architettura on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2fnote-sullarchitettura%2f&title=Note%20sull%27architettura">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Note sull&#39;architettura on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2fnote-sullarchitettura%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Note sull&#39;architettura on whatsapp"
            href="https://api.whatsapp.com/send?text=Note%20sull%27architettura%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2fnote-sullarchitettura%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Note sull&#39;architettura on telegram"
            href="https://telegram.me/share/url?text=Note%20sull%27architettura&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fnote-sullarchitettura%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Note sull&#39;architettura on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Note%20sull%27architettura&u=https%3a%2f%2fflecart.github.io%2fnotes%2fnote-sullarchitettura%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
