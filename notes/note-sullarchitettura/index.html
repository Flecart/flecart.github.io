<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Note sullâ€™architettura | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="no-tags">
<meta name="description" content="Ripasso Prox: 30 Ripasso: June 1, 2023 Ultima modifica: April 16, 2023 12:33 PM Primo Abbozzo: February 23, 2023 5:13 PM Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ• Studi Personali: No
Elementi di ripasso Chiedi chiarimenti sul perchÃ© Ã¨ necessario avere stack separati per la gestione di interrupt multipli annidati. Non basterebbe aggiungere sulla stack che ho giÃ ? Poi quando finisco lâ€™interrupt elimino quanto mi ha aggiunto lâ€™ultimo interrupt, e la roba vecchia câ€™Ã¨ ancora. Note sullâ€™architettura Interrupt Descrizione iniziale ðŸŸ© Di interrupt e trap se nâ€™Ã¨ parlato un pÃ² in Livello ISA di architettura, ora andiamo ad approfondire come viene gestito a livello SO.">
<meta name="author" content="Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="https://flecart.github.io/notes/note-sullarchitettura/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/note-sullarchitettura/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>


<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-WW6NN2QGKF', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Note sullâ€™architettura" />
<meta property="og:description" content="Ripasso Prox: 30 Ripasso: June 1, 2023 Ultima modifica: April 16, 2023 12:33 PM Primo Abbozzo: February 23, 2023 5:13 PM Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ• Studi Personali: No
Elementi di ripasso Chiedi chiarimenti sul perchÃ© Ã¨ necessario avere stack separati per la gestione di interrupt multipli annidati. Non basterebbe aggiungere sulla stack che ho giÃ ? Poi quando finisco lâ€™interrupt elimino quanto mi ha aggiunto lâ€™ultimo interrupt, e la roba vecchia câ€™Ã¨ ancora. Note sullâ€™architettura Interrupt Descrizione iniziale ðŸŸ© Di interrupt e trap se nâ€™Ã¨ parlato un pÃ² in Livello ISA di architettura, ora andiamo ad approfondire come viene gestito a livello SO." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://flecart.github.io/notes/note-sullarchitettura/" />
<meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png" />
<meta property="article:section" content="notes" />



<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png" />
<meta name="twitter:title" content="Note sullâ€™architettura"/>
<meta name="twitter:description" content="Ripasso Prox: 30 Ripasso: June 1, 2023 Ultima modifica: April 16, 2023 12:33 PM Primo Abbozzo: February 23, 2023 5:13 PM Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ• Studi Personali: No
Elementi di ripasso Chiedi chiarimenti sul perchÃ© Ã¨ necessario avere stack separati per la gestione di interrupt multipli annidati. Non basterebbe aggiungere sulla stack che ho giÃ ? Poi quando finisco lâ€™interrupt elimino quanto mi ha aggiunto lâ€™ultimo interrupt, e la roba vecchia câ€™Ã¨ ancora. Note sullâ€™architettura Interrupt Descrizione iniziale ðŸŸ© Di interrupt e trap se nâ€™Ã¨ parlato un pÃ² in Livello ISA di architettura, ora andiamo ad approfondire come viene gestito a livello SO."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Note sullâ€™architettura",
      "item": "https://flecart.github.io/notes/note-sullarchitettura/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Note sullâ€™architettura",
  "name": "Note sullâ€™architettura",
  "description": "Ripasso Prox: 30 Ripasso: June 1, 2023 Ultima modifica: April 16, 2023 12:33 PM Primo Abbozzo: February 23, 2023 5:13 PM Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ• Studi Personali: No\nElementi di ripasso Chiedi chiarimenti sul perchÃ© Ã¨ necessario avere stack separati per la gestione di interrupt multipli annidati. Non basterebbe aggiungere sulla stack che ho giÃ ? Poi quando finisco lâ€™interrupt elimino quanto mi ha aggiunto lâ€™ultimo interrupt, e la roba vecchia câ€™Ã¨ ancora. Note sullâ€™architettura Interrupt Descrizione iniziale ðŸŸ© Di interrupt e trap se nâ€™Ã¨ parlato un pÃ² in Livello ISA di architettura, ora andiamo ad approfondire come viene gestito a livello SO.",
  "keywords": [
    "no-tags"
  ],
  "articleBody": "Ripasso Prox: 30 Ripasso: June 1, 2023 Ultima modifica: April 16, 2023 12:33 PM Primo Abbozzo: February 23, 2023 5:13 PM Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ• Studi Personali: No\nElementi di ripasso Chiedi chiarimenti sul perchÃ© Ã¨ necessario avere stack separati per la gestione di interrupt multipli annidati. Non basterebbe aggiungere sulla stack che ho giÃ ? Poi quando finisco lâ€™interrupt elimino quanto mi ha aggiunto lâ€™ultimo interrupt, e la roba vecchia câ€™Ã¨ ancora. Note sullâ€™architettura Interrupt Descrizione iniziale ðŸŸ© Di interrupt e trap se nâ€™Ã¨ parlato un pÃ² in Livello ISA di architettura, ora andiamo ad approfondire come viene gestito a livello SO.\nUn interrupt Ã¨ un segnale che viene mandato o da un dispositivo hardware (di solito dopo la fine di un processo input output) oppure da software, in questo caso viene chiamato trap che Ã¨ un interrupt software sincrono..\nSlide Interrupt Hardware e software\nQuesti segnali sono utilizzati per indicare eventi che dovrebbero essere gestiti (come end of I/O, divisione per 0, ma anche semplicemente syscall e passare livello kernel).\nIl segnale solitamente implica la interruzione di quanto viene svolto in questo momento, per gestire lâ€™interrupt corrente, e poi tornare allâ€™istruzione precedente. Solitamente perchÃ© potrebbe anche essere che il processo non sia interrompibile, e quindi lâ€™interrupt dovrebbe essere rischedulato.\nPer poter ripristinare lo stato precedente solitamente ci si devono salvare lâ€™immagine dei registri del programma, tutte le informazioni utili a far runnare il processo (di solito messe nelle PCB), e lâ€™istruzione di ritorno.\nQuando ci si ritorna sopra basta mettere nel PC lâ€™indirizzo della istruzione corretta.\nProcedimento classico di gestione interrupt ðŸŸ© Praticamente durante il Ciclo va a fare un check per vedere se il filo dellâ€™interrupt Ã¨ settato, se sÃ¬ carica istruzioni a un certo indirizzo (e si deve salvare lâ€™istruzione attuale).\nMasked se si sta facendo qualcosa che non si puÃ² interrompere, quindi Ã¨ delayed. (quando il processore non puÃ² essere interrotto, ad esempio quando sei in Sezioni Critiche, o quando arrivano interrupt dello stesso tipo, se ogni interrupt ha una stack propria, andrebbe a sovrascrivere).\nSe tutto va bene e non Ã¨ delayed ed esiste un interrupt, ad alto livello fa:\nSospende (in un modo che possa essere ripreso) il processo corrente Salta allâ€™istruzione definito in interrupt vector **(**tabella fissa cosÃ¬ Ã¨ piÃ¹ veloce) Esegue lâ€™interrupt Si ritorna al processo precedente, o altro (scheduling potrebbe far andare in altro processo). Slides passi ad alto livello\nSlides passi a basso livello (!!!)\nFino a qui tutte le operazioni sono HARDWARE. Da ora in poi viene ripreso il ciclo FDE con il controllo dell Interrupt handler.\nTipologie di gestione di interrupt Multipli (2) ðŸŸ© Quando ho interrupt multipli diventa leggermente piÃ¹ difficile gestire questi interrupt. Potrebbero interagire, che succede quando mi arriva un interrupt da device 1 mentre sto runnando lâ€™interrupt handler di device 2???\nDisabilitazione degli interrupt\nQuesta Ã¨ la forma piÃ¹ semplice per la gestione dellâ€™interrupt, in pratica quando sto gestendo un interrupt, li disabilito, in modo che non possa riceverne altri, cosÃ¬ sono sicuro che non posso ricevere nessun altro interrupt. Una soluzione simile per le CS ne abbiamo discusso in Sezioni Critiche\nQuando sto per finire riattivo gli interrupt e cosÃ¬ posso vedere se ce ne erano alcuni pendenti.\nHo alcuni svantaggi come:\nNon ho un concetto di prioritÃ  degli interrupt a questo livello Slide idea di gestione\nAnnidamento degli interrupt\nQuesta Ã¨ la soluzione piÃ¹ moderna, ed Ã¨ anche la piÃ¹ efficiente che permette di\nAvere un concetto di prioritÃ  di interrupts Necessita di stack separati (se gli interrupt utilizzano la stessa stack, potrebbero sovrascriversi alcune informazioni!) quindi piÃ¹ difficile da implementare. Forse ogni interrupt ha una propria stack, se viene stetsso tipo di interrupt sono maskerati! PI/O, or Interrupt based I/O ðŸŸ© PI/O\nIn questo caso la CPU setta tutti i valori utili al controllore del device driver. e poi fa polling per chiedere al driver se ha finito o meno (attraverso un controllo sul registro di stato del driver).\nSe il driver ha finito, la CPU si mette a copiare i dati di output del device alla propria memoria.\nUn chiaro svantaggio Ã¨ che il polling Ã¨ molto inefficiente per la soluzione di questo tipo di problemi.\nInterrupt driven I/O\nQuesta Ã¨ la soluzione moderna, quella piÃ¹ utilizzata, dato che ora Ã¨ il dispositivo driver a comunicare quando un processo I/O Ã¨ stato completato o men, cosÃ¬ la CPU Ã¨ a conoscenza di questo evento e puÃ² comportarsi di conseguenza. (quindi quando gestire lâ€™interrupt, e poi effettivamente runnare il codice corrispondente quando lâ€™interrupt Ã¨ avvenuto).\nMemoria Direct Memory Access ðŸŸ© Per copiare alcuni dati utili per I/O dalla memoria RAM alla memoria del controllore bisognerebbe spendere tanti cicli di clock della CPU, di solito questa Ã¨ una operazione molto lenta.\nDMA ci permette di accedere direttamente alla memoria, quindi il controllore stesso Ã¨ programmato con lâ€™indirizzo su cui andare a prelevare la memoria corretta, sollevando la CPU da questo primo lavoro.\nChiaramente il vantaggio principale di questo metodo Ã¨ la velocitÃ , dato che abbiamo piÃ¹ cicli di clock per la CPU, oltre a questo, crea una interfaccia piÃ¹ facile da gestire, quindi i drivers sono piÃ¹ semplici.\nUno svantaggio Ã¨ la contesa del BUS, che per trasferire câ€™Ã¨ bisogno che il bus sia libero.\nSicurezza\nQuesto Ã¨ un possibile falla di sicurezza, infatti se il codice del controller Ã¨ malevolo potrebbe fare attacchi al sistema di certo tipo.\nSecondo Renzo sarebbe meglio che questo codice fosse open, in modo che sia molto probabile di trovare cose maligne.\nRam ðŸŸ© Ãˆ semplificata da poche istruzioni di accesso, che di solito sono solo LOAD E STORE. (Tutti i dettagli fisici sono astratti, la CPU non si interessa di questi, sono built-in del calcolatore!).\nDi solito (in modi che non so), sono gestiti da MMU.\nNOTA: ci mettono un pÃ² i condensatori a scaricarsi. (possibile recuperare un pÃ² di informazioni se tipo congeli la RAM subito).\nLe ROM esistono ancora, ma sono per cose basilari, come per la parte del boot.\nMemory Mapped I/O ðŸŸ©- Alcune aree di memoria, come quelle del video grafico, sono scritti e letti subito da alcuni driver e sono utilizzati per sapere cosa mostrare sullo schermo per esempio.\nMa dato che 2 componenti (read and write) devono sincronizzarci nella lettura. Questa sincronizzazione di solito Ã¨ fatta a livello hardware.\nDischi e SSD ðŸŸ© Abbiamo spiegato meglio questa parte in Devices OS\nDischi memorizzano in maniera magnetica, e lo fanno in maniera non-volatile, cioÃ¨ possiamo ritrovare i nostri dati.\nSono a accesso diretto, in contrasto con i nastri che erano sequenziali. leggermente accennato in Memoria. E per capire dove leggere e scrivere si devono impostante movimenti di settore del cilindro e testina per leggere il settore corretto. Settore si aspetta che giri, testina si aspetta che si sposti. Ãˆ lento, nellâ€™ordine dei microsecondi.\nOperazioni possibili\nREAD, WRITE e anche Seek (quando vado a spostare la testina da altre parti!)\nSlide\nOsservazioni sulla velocitÃ \nNon ci converrebbe avere uno stesso file messo in posti molto diversi fra di loro allâ€™intenro del disco!\nCose di scheduling in modo da leggere cose che siano vicine. (Ma anche il filesystem, in modo che cose che cose che vengono utilizzate spesso siano vicine, ma questa roba la vedremo dopo)\nSSD, Solid State Disk\nAnche questi sono per cose non volatili.\nSolitamente scrivono ad insieme di blocchi! e lo si fa in cicli di scrittura perchÃ© non scrive ad ogni singola scrittura, ma sono in un buffer, e saranno scritti insieme in tutti in un ciclo di scrittura, questo Ã¨ per rendere piÃ¹ efficiente questa operazione.\nPer ssd a volte tengo la RAM come una cache intermedia per la scrittura.\nGerarchie di memoria ðŸŸ© Slide piramide\nLâ€™altro argomento si parlerebbe di Cache, ma penso sia trattato giÃ  benissimo in 4.2 Memoria Cache\nQuindi guardare lÃ¬, guardare la piramide della memoria il tradeoff velocitÃ  e quantitÃ  di memoria, il costo di accesso (in termini di tempo ed energia).\nSicurezza Il processo\nNon dovrebbe accedere ad aree di memoria a cui non dovrebbe accedere Non dovrebbe accedere direttamente ai dispositivi I/O, altrimenti potrei accedere e modificare qualunque cosa sui driver, e qualunque processo potrebbe farlo. Ãˆ importante garantire la sicurezza anche per lâ€™affidabilitÃ  del sistema, anche per proteggere il programmatore stesso, quando fa qualcosa in modo accidentale, in modo da evitare danni brutti. al sistema\nMode Bit ðŸŸ© nella realtÃ  le protezioni principali sono due, messe a livello hardware\nUn Mode bit che sta a specificare se il CPU Ã¨ in Kernel mode o user mode. Questi metodi sono importanti perchÃ© il modo kernel permette accesso totale controllo totale sulla memoria, sullâ€™IO, mentre user solamente gli indirizzi a lui illegali. Questo metodo permette di entrare in kernel mode in modo controllato, in modo che riesca sempre a gestire questa protezione. Ovviamente il cambio del mode bit Ã¨ privilegiato, un programma normalmente non puÃ² cambiare mode con una singola istruzione, deve passare con system call che sono le interrupt software o trap, con una istruzione specifica per mandare interrupt. Ãˆ lâ€™unico modo!. Nota: ovviamente quando il computer parte, in boostrap Ã¨ in modalitÃ  kernel, che appena finisce tornerÃ  in User Mode (Ã¨ il processo INIT!) Una mappatura a indirizzi illegali per il programma, in modo che possa accedere solamente a quello a cui dovrebbe accedere. Protezione memoria ðŸŸ©- Slide protezione Memoria MMU\nQuesto pezzo di hardware ha il ruolo di tradurre indirizzi logici in fisici, e gestire lâ€™accesso (ritorna lâ€™errore se non si potrebbe fare).\nÃˆimportante che sia in Hardware perchÃ©:\nDeve essere molto veloce, perchÃ© sono operazioni molto veloci Si potrebbe bypassare e allora avresti accesso a tutta la memoria ugualmente. System call ðŸŸ©- La sistem call Ã¨ una unica istruzione, mediante la quale Ã¨ possibile accedere al kernel mode, in grado di accedere a tutto, utile per la protezione e affidabilitÃ  del sistema, e non permettere programmi di fare tutto.\nEsistono convenzioni di chiamata, perchÃ© si aspetta in un certo registro la presenza di un codice che specifichi la tipologia di system call, poi la sistem call ritornerÃ  il valore corretto in un certo registro.\n",
  "wordCount" : "1676",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/note-sullarchitettura/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;Â»&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Note sullâ€™architettura
    </h1>
    <div class="post-meta">8 min&nbsp;Â·&nbsp;Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#elementi-di-ripasso" aria-label="Elementi di ripasso">Elementi di ripasso</a></li>
                <li>
                    <a href="#note-sullarchitettura" aria-label="Note sullâ€™architettura">Note sullâ€™architettura</a><ul>
                        
                <li>
                    <a href="#interrupt" aria-label="Interrupt">Interrupt</a><ul>
                        
                <li>
                    <a href="#descrizione-iniziale-" aria-label="Descrizione iniziale ðŸŸ©">Descrizione iniziale ðŸŸ©</a></li>
                <li>
                    <a href="#procedimento-classico-di-gestione-interrupt-" aria-label="Procedimento classico di gestione interrupt ðŸŸ©">Procedimento classico di gestione interrupt ðŸŸ©</a></li>
                <li>
                    <a href="#tipologie-di-gestione-di-interrupt-multipli-2-" aria-label="Tipologie di gestione di interrupt Multipli (2) ðŸŸ©">Tipologie di gestione di interrupt Multipli (2) ðŸŸ©</a></li>
                <li>
                    <a href="#pio-or-interrupt-based-io-" aria-label="PI/O, or Interrupt based I/O ðŸŸ©">PI/O, or Interrupt based I/O ðŸŸ©</a></li></ul>
                </li>
                <li>
                    <a href="#memoria" aria-label="Memoria">Memoria</a><ul>
                        
                <li>
                    <a href="#direct-memory-access-" aria-label="Direct Memory Access ðŸŸ©">Direct Memory Access ðŸŸ©</a></li>
                <li>
                    <a href="#ram-" aria-label="Ram ðŸŸ©">Ram ðŸŸ©</a></li>
                <li>
                    <a href="#memory-mapped-io--" aria-label="Memory Mapped I/O ðŸŸ©-">Memory Mapped I/O ðŸŸ©-</a></li>
                <li>
                    <a href="#dischi-e-ssd-" aria-label="Dischi e SSD ðŸŸ©">Dischi e SSD ðŸŸ©</a></li>
                <li>
                    <a href="#gerarchie-di-memoria-" aria-label="Gerarchie di memoria ðŸŸ©">Gerarchie di memoria ðŸŸ©</a></li></ul>
                </li>
                <li>
                    <a href="#sicurezza" aria-label="Sicurezza">Sicurezza</a><ul>
                        
                <li>
                    <a href="#mode-bit-" aria-label="Mode Bit ðŸŸ©">Mode Bit ðŸŸ©</a></li>
                <li>
                    <a href="#protezione-memoria--" aria-label="Protezione memoria ðŸŸ©-">Protezione memoria ðŸŸ©-</a></li>
                <li>
                    <a href="#system-call--" aria-label="System call ðŸŸ©-">System call ðŸŸ©-</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Ripasso Prox: 30
Ripasso: June 1, 2023
Ultima modifica: April 16, 2023 12:33 PM
Primo Abbozzo: February 23, 2023 5:13 PM
Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•
Studi Personali: No</p>
<h1 id="elementi-di-ripasso">Elementi di ripasso<a hidden class="anchor" aria-hidden="true" href="#elementi-di-ripasso">#</a></h1>
<ul>
<li>Chiedi chiarimenti sul perchÃ©  Ã¨ necessario avere stack separati per la gestione di interrupt multipli annidati. Non basterebbe aggiungere sulla stack che ho giÃ ? Poi quando finisco lâ€™interrupt elimino quanto mi ha aggiunto lâ€™ultimo interrupt, e la roba vecchia câ€™Ã¨ ancora.</li>
</ul>
<h1 id="note-sullarchitettura">Note sullâ€™architettura<a hidden class="anchor" aria-hidden="true" href="#note-sullarchitettura">#</a></h1>
<h2 id="interrupt">Interrupt<a hidden class="anchor" aria-hidden="true" href="#interrupt">#</a></h2>
<h3 id="descrizione-iniziale-">Descrizione iniziale ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#descrizione-iniziale-">#</a></h3>
<p>Di interrupt e trap se nâ€™Ã¨ parlato un pÃ² in <a href="//notes/livello-isa">Livello ISA</a> di architettura, ora andiamo ad approfondire come viene gestito a livello SO.</p>
<p>Un interrupt Ã¨ un <strong>segnale</strong> che viene mandato o da un dispositivo hardware (di solito dopo la fine di un processo input output) oppure da software, in questo caso viene chiamato <strong>trap</strong> che Ã¨ un interrupt software sincrono..</p>
<ul>
<li>
<p>Slide Interrupt Hardware e software</p>
  <img src="/images/notes/image/universita/ex-notion/Note sullâ€™architettura/Untitled.png" alt="image/universita/ex-notion/Note sullâ€™architettura/Untitled">
</li>
</ul>
<p>Questi segnali sono utilizzati per <strong>indicare eventi</strong> che dovrebbero essere gestiti (come end of I/O, divisione per 0, ma anche semplicemente syscall e passare livello kernel).</p>
<p>Il segnale solitamente implica la interruzione di quanto viene svolto in questo momento, per gestire lâ€™interrupt corrente, e poi tornare allâ€™istruzione precedente. Solitamente perchÃ© potrebbe anche essere che il processo non sia interrompibile, e quindi lâ€™interrupt dovrebbe essere rischedulato.</p>
<p>Per poter ripristinare lo stato precedente solitamente ci si devono salvare lâ€™immagine dei registri del programma, tutte le informazioni utili a far runnare il processo (di solito messe nelle PCB), e lâ€™istruzione di ritorno.</p>
<p>Quando ci si ritorna sopra basta mettere nel PC lâ€™indirizzo della istruzione corretta.</p>
<h3 id="procedimento-classico-di-gestione-interrupt-">Procedimento classico di gestione interrupt ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#procedimento-classico-di-gestione-interrupt-">#</a></h3>
<p>Praticamente durante il Ciclo va a fare un check per vedere se il filo dellâ€™interrupt Ã¨ settato, se sÃ¬ carica istruzioni a un certo indirizzo (e si deve salvare lâ€™istruzione attuale).</p>
<p>Masked se si sta facendo qualcosa che non si puÃ² interrompere, quindi Ã¨ <strong>delayed</strong>. (quando il processore non puÃ² essere interrotto, ad esempio quando sei in <a href="//notes/sezioni-critiche">Sezioni Critiche</a>, o quando arrivano interrupt dello stesso tipo, se ogni interrupt ha una stack propria, andrebbe a sovrascrivere).</p>
<p>Se tutto va bene e non Ã¨ delayed ed esiste un interrupt, ad alto livello fa:</p>
<ol>
<li>Sospende (in un modo che possa essere ripreso) il processo corrente</li>
<li>Salta allâ€™istruzione definito in <strong>interrupt vector</strong> **(**tabella fissa cosÃ¬ Ã¨ piÃ¹ veloce)</li>
<li>Esegue lâ€™interrupt</li>
<li>Si ritorna al processo precedente, o altro (scheduling potrebbe far andare in altro processo).</li>
</ol>
<ul>
<li>
<p>Slides passi ad alto livello</p>
  <img src="/images/notes/image/universita/ex-notion/Note sullâ€™architettura/Untitled 1.png" alt="image/universita/ex-notion/Note sullâ€™architettura/Untitled 1">
  <img src="/images/notes/image/universita/ex-notion/Note sullâ€™architettura/Untitled 2.png" alt="image/universita/ex-notion/Note sullâ€™architettura/Untitled 2">
</li>
<li>
<p>Slides passi a basso livello (!!!)</p>
  <img src="/images/notes/image/universita/ex-notion/Note sullâ€™architettura/Untitled 3.png" alt="image/universita/ex-notion/Note sullâ€™architettura/Untitled 3">
  <img src="/images/notes/image/universita/ex-notion/Note sullâ€™architettura/Untitled 4.png" alt="image/universita/ex-notion/Note sullâ€™architettura/Untitled 4">
<p>Fino a qui <strong>tutte le operazioni sono HARDWARE</strong>. Da ora in poi viene ripreso il ciclo FDE con il controllo dell Interrupt handler.</p>
  <img src="/images/notes/image/universita/ex-notion/Note sullâ€™architettura/Untitled 5.png" alt="image/universita/ex-notion/Note sullâ€™architettura/Untitled 5">
</li>
</ul>
<h3 id="tipologie-di-gestione-di-interrupt-multipli-2-">Tipologie di gestione di interrupt Multipli (2) ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#tipologie-di-gestione-di-interrupt-multipli-2-">#</a></h3>
<p>Quando ho interrupt multipli diventa leggermente piÃ¹ difficile gestire questi interrupt. Potrebbero interagire, che succede quando mi arriva un interrupt da device 1 mentre sto runnando lâ€™interrupt handler di device 2???</p>
<p><strong>Disabilitazione degli interrupt</strong></p>
<p>Questa Ã¨ la forma piÃ¹ semplice per la gestione dellâ€™interrupt, in pratica quando sto gestendo un interrupt, li disabilito, in modo che non possa riceverne altri, cosÃ¬ sono sicuro che non posso ricevere nessun altro interrupt. Una soluzione simile per le CS ne abbiamo discusso in <a href="//notes/sezioni-critiche">Sezioni Critiche</a></p>
<p>Quando sto per finire riattivo gli interrupt e cosÃ¬ posso vedere se ce ne erano alcuni pendenti.</p>
<p>Ho alcuni svantaggi come:</p>
<ol>
<li>Non ho un concetto di prioritÃ  degli interrupt a questo livello</li>
</ol>
<ul>
<li>
<p>Slide idea di gestione</p>
  <img src="/images/notes/image/universita/ex-notion/Note sullâ€™architettura/Untitled 6.png" alt="image/universita/ex-notion/Note sullâ€™architettura/Untitled 6">
</li>
</ul>
<p><strong>Annidamento degli interrupt</strong></p>
<p>Questa Ã¨ la soluzione piÃ¹ moderna, ed Ã¨ anche la piÃ¹ efficiente che permette di</p>
<ol>
<li>Avere un concetto di prioritÃ  di interrupts</li>
<li>Necessita di stack separati (se gli interrupt utilizzano la stessa stack, potrebbero sovrascriversi alcune informazioni!) quindi piÃ¹ difficile da implementare.
<ol>
<li>Forse ogni interrupt ha una propria stack, se viene stetsso tipo di interrupt sono maskerati!</li>
</ol>
</li>
</ol>
<h3 id="pio-or-interrupt-based-io-">PI/O, or Interrupt based I/O ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#pio-or-interrupt-based-io-">#</a></h3>
<p><strong>PI/O</strong></p>
<p>In questo caso la CPU setta tutti i valori utili al controllore del device driver. e poi fa <strong>polling</strong> per chiedere al driver se ha finito o meno (attraverso un controllo sul registro di stato del driver).</p>
<p>Se il driver ha finito, la CPU si mette a copiare i dati di output del device alla propria memoria.</p>
<p>Un chiaro svantaggio Ã¨ che il polling Ã¨ molto inefficiente per la soluzione di questo tipo di problemi.</p>
<p><strong>Interrupt driven I/O</strong></p>
<p>Questa Ã¨ la soluzione moderna, quella piÃ¹ utilizzata, dato che ora Ã¨ il dispositivo driver a comunicare quando un processo I/O Ã¨ stato completato o men, cosÃ¬ la CPU Ã¨ a conoscenza di questo evento e puÃ² comportarsi di conseguenza. (quindi quando gestire lâ€™interrupt, e poi effettivamente runnare il codice corrispondente quando lâ€™interrupt Ã¨ avvenuto).</p>
<h2 id="memoria">Memoria<a hidden class="anchor" aria-hidden="true" href="#memoria">#</a></h2>
<h3 id="direct-memory-access-">Direct Memory Access ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#direct-memory-access-">#</a></h3>
<p>Per copiare alcuni dati utili per I/O dalla memoria RAM alla memoria del controllore bisognerebbe spendere tanti cicli di clock della CPU, di solito questa Ã¨ una operazione molto lenta.</p>
<p>DMA ci permette di accedere direttamente alla memoria, quindi il controllore stesso Ã¨ programmato con lâ€™indirizzo su cui andare a prelevare la memoria corretta, sollevando la CPU da questo primo lavoro.</p>
<p>Chiaramente il vantaggio principale di questo metodo Ã¨ la velocitÃ , dato che abbiamo piÃ¹ cicli di clock per la CPU, oltre a questo, crea una interfaccia piÃ¹ facile da gestire, quindi i drivers sono piÃ¹ semplici.</p>
<p>Uno svantaggio Ã¨ la contesa del BUS, che per trasferire câ€™Ã¨ bisogno che il bus sia libero.</p>
<p><strong>Sicurezza</strong></p>
<p>Questo Ã¨ un possibile falla di sicurezza, infatti se il codice del controller Ã¨ malevolo potrebbe fare attacchi al sistema di certo tipo.</p>
<p>Secondo Renzo sarebbe meglio che questo codice fosse open, in modo che sia molto probabile di trovare cose maligne.</p>
<h3 id="ram-">Ram ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#ram-">#</a></h3>
<p>Ãˆ semplificata da poche istruzioni di accesso, che di solito sono solo LOAD E STORE. (Tutti i dettagli fisici sono astratti, la CPU non si interessa di questi, sono built-in del calcolatore!).</p>
<p>Di solito (in modi che non so), sono gestiti da MMU.</p>
<p>NOTA: ci mettono un pÃ² i condensatori a scaricarsi. (possibile recuperare un pÃ² di informazioni se tipo congeli la RAM subito).</p>
<p>Le <strong>ROM</strong> esistono ancora, ma sono per cose basilari, come per la parte del boot.</p>
<h3 id="memory-mapped-io--">Memory Mapped I/O ðŸŸ©-<a hidden class="anchor" aria-hidden="true" href="#memory-mapped-io--">#</a></h3>
<p>Alcune aree di memoria, come quelle del video grafico, sono scritti e letti subito da alcuni driver e sono utilizzati per sapere cosa mostrare sullo schermo per esempio.</p>
<p>Ma dato che 2 componenti (read and write) devono <strong>sincronizzarci</strong> nella lettura. Questa sincronizzazione di solito Ã¨ fatta a livello hardware.</p>
<h3 id="dischi-e-ssd-">Dischi e SSD ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#dischi-e-ssd-">#</a></h3>
<p>Abbiamo spiegato meglio questa parte in <a href="//notes/devices-os">Devices OS</a></p>
<p>Dischi memorizzano in maniera magnetica, e lo fanno in maniera non-volatile, cioÃ¨ possiamo ritrovare i nostri dati.</p>
<p>Sono a accesso diretto, in contrasto con i nastri che erano sequenziali. leggermente accennato in <a href="//notes/memoria">Memoria</a>. E per capire dove leggere e scrivere si devono impostante movimenti di settore del cilindro e testina per leggere il settore corretto. Settore si aspetta che giri, testina si aspetta che si sposti. Ãˆ lento, nellâ€™ordine dei microsecondi.</p>
<p><strong>Operazioni possibili</strong></p>
<p>READ, WRITE e anche Seek (quando vado a spostare la testina da altre parti!)</p>
<ul>
<li>
<p>Slide</p>
  <img src="/images/notes/image/universita/ex-notion/Note sullâ€™architettura/Untitled 7.png" alt="image/universita/ex-notion/Note sullâ€™architettura/Untitled 7">
</li>
</ul>
<p><strong>Osservazioni sulla velocitÃ </strong></p>
<p>Non ci converrebbe avere uno stesso file messo in posti molto diversi fra di loro allâ€™intenro del disco!</p>
<p>Cose di scheduling in modo da leggere cose che siano vicine. (Ma anche il filesystem, in modo che cose che cose che vengono utilizzate spesso siano vicine, ma questa roba la vedremo dopo)</p>
<p><strong>SSD, Solid State Disk</strong></p>
<p>Anche questi sono per cose non volatili.</p>
<p>Solitamente scrivono ad insieme di blocchi! e lo si fa in <strong>cicli di scrittura</strong> perchÃ© non scrive ad ogni singola scrittura, ma sono in un buffer, e saranno scritti insieme in tutti in un ciclo di scrittura, questo Ã¨ per rendere piÃ¹ efficiente questa operazione.</p>
<p>Per ssd a volte tengo la RAM come una cache intermedia per la scrittura.</p>
<h3 id="gerarchie-di-memoria-">Gerarchie di memoria ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#gerarchie-di-memoria-">#</a></h3>
<ul>
<li>
<p>Slide piramide</p>
  <img src="/images/notes/image/universita/ex-notion/Note sullâ€™architettura/Untitled 8.png" alt="image/universita/ex-notion/Note sullâ€™architettura/Untitled 8">
  <img src="/images/notes/image/universita/ex-notion/Note sullâ€™architettura/Untitled 9.png" alt="image/universita/ex-notion/Note sullâ€™architettura/Untitled 9">
</li>
</ul>
<p>Lâ€™altro argomento si parlerebbe di Cache, ma penso sia trattato giÃ  benissimo in 4.2 Memoria Cache</p>
<p>Quindi guardare lÃ¬, guardare la piramide della memoria il tradeoff velocitÃ  e quantitÃ  di memoria, il costo di accesso (in termini di tempo ed energia).</p>
<h2 id="sicurezza">Sicurezza<a hidden class="anchor" aria-hidden="true" href="#sicurezza">#</a></h2>
<p>Il processo</p>
<ul>
<li>Non dovrebbe accedere ad aree di memoria a cui non dovrebbe accedere</li>
<li>Non dovrebbe accedere direttamente ai dispositivi I/O, altrimenti potrei accedere e modificare qualunque cosa sui driver, e qualunque processo potrebbe farlo.</li>
</ul>
<p>Ãˆ importante garantire la sicurezza anche per lâ€™<strong>affidabilitÃ  del sistema</strong>, anche per proteggere il programmatore stesso, quando fa qualcosa in modo accidentale, in modo da evitare danni brutti. al sistema</p>
<h3 id="mode-bit-">Mode Bit ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#mode-bit-">#</a></h3>
<p>nella realtÃ  le protezioni principali sono due, messe a livello hardware</p>
<ol>
<li>Un <strong>Mode bit</strong> che sta a specificare se il <strong>CPU Ã¨ in Kernel mode o user mode</strong>.
<ol>
<li>Questi metodi sono importanti perchÃ© il modo kernel permette accesso totale controllo totale sulla memoria, sullâ€™IO, mentre user solamente gli indirizzi a lui illegali. Questo metodo permette di entrare in kernel mode in modo controllato, in modo che riesca sempre a gestire questa protezione.</li>
<li>Ovviamente il cambio del mode bit Ã¨ privilegiato, un programma normalmente non puÃ² cambiare mode con una singola istruzione, deve passare con system call che sono le interrupt software o trap, con una istruzione specifica per mandare interrupt. Ãˆ l&rsquo;unico modo!.</li>
<li>Nota: ovviamente quando il computer parte, in <strong>boostrap</strong> Ã¨ in modalitÃ  kernel, che appena finisce tornerÃ  in User Mode (Ã¨ il processo INIT!)</li>
</ol>
</li>
<li>Una mappatura a indirizzi illegali per il programma, in modo che possa accedere solamente a quello a cui dovrebbe accedere.</li>
</ol>
<h3 id="protezione-memoria--">Protezione memoria ðŸŸ©-<a hidden class="anchor" aria-hidden="true" href="#protezione-memoria--">#</a></h3>
<ul>
<li>
<p>Slide protezione Memoria MMU</p>
  <img src="/images/notes/image/universita/ex-notion/Note sullâ€™architettura/Untitled 10.png" alt="image/universita/ex-notion/Note sullâ€™architettura/Untitled 10">
</li>
</ul>
<p>Questo pezzo di hardware ha il ruolo di <strong>tradurre indirizzi logici in fisici</strong>, e gestire l&rsquo;accesso (ritorna lâ€™errore se non si potrebbe fare).</p>
<p>Ãˆimportante che sia in Hardware perchÃ©:</p>
<ol>
<li>Deve essere molto veloce, perchÃ© sono operazioni molto veloci</li>
<li>Si potrebbe bypassare e allora avresti accesso a tutta la memoria ugualmente.</li>
</ol>
<h3 id="system-call--">System call ðŸŸ©-<a hidden class="anchor" aria-hidden="true" href="#system-call--">#</a></h3>
<p>La sistem call Ã¨ una unica istruzione, mediante la quale Ã¨ possibile accedere al kernel mode, in grado di accedere a tutto, utile per la protezione e affidabilitÃ  del sistema, e non permettere programmi di fare tutto.</p>
<p>Esistono convenzioni di chiamata, perchÃ© si aspetta in un certo registro la presenza di un codice che specifichi la tipologia di system call, poi la sistem call ritornerÃ  il valore corretto in un certo registro.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/no-tags/">No-Tags</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Note sullâ€™architettura on x"
            href="https://x.com/intent/tweet/?text=Note%20sull%e2%80%99architettura&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fnote-sullarchitettura%2f&amp;hashtags=no-tags">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Note sullâ€™architettura on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fnote-sullarchitettura%2f&amp;title=Note%20sull%e2%80%99architettura&amp;summary=Note%20sull%e2%80%99architettura&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2fnote-sullarchitettura%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Note sullâ€™architettura on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2fnote-sullarchitettura%2f&title=Note%20sull%e2%80%99architettura">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Note sullâ€™architettura on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2fnote-sullarchitettura%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Note sullâ€™architettura on whatsapp"
            href="https://api.whatsapp.com/send?text=Note%20sull%e2%80%99architettura%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2fnote-sullarchitettura%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Note sullâ€™architettura on telegram"
            href="https://telegram.me/share/url?text=Note%20sull%e2%80%99architettura&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fnote-sullarchitettura%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Note sullâ€™architettura on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Note%20sull%e2%80%99architettura&u=https%3a%2f%2fflecart.github.io%2fnotes%2fnote-sullarchitettura%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
