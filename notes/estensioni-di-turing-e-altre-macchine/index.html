<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Estensioni di Turing e altre macchine | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="theoretical-computer-science">
<meta name="description" content="Sono variazioni possibili equivalenti: • Nastri addizionali • Testine addizionali • Nastri infiniti su entrambi i lati • Non-determinismo • Scelta probabilistica • Scelta quantistica
Turing con nastri addizionali Questo è presente in modo abbastanza facile sul Sipser.
La computazione comincia con l’input sul primo nastro, e tutti gli altri nastri vuoti. Macchine di Turing con nastri addizionali In ciascun passo di computazione, ogni testina é nello stesso stato, ma può essere in una posizione diversa, leggere un simbolo differente, e compiere un’azione diversa.">
<meta name="author" content="Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="https://flecart.github.io/notes/estensioni-di-turing-e-altre-macchine/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/estensioni-di-turing-e-altre-macchine/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>




<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>
<script type="text/javascript" async
src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>





<script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-WW6NN2QGKF', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Estensioni di Turing e altre macchine" />
<meta property="og:description" content="Sono variazioni possibili equivalenti: • Nastri addizionali • Testine addizionali • Nastri infiniti su entrambi i lati • Non-determinismo • Scelta probabilistica • Scelta quantistica
Turing con nastri addizionali Questo è presente in modo abbastanza facile sul Sipser.
La computazione comincia con l’input sul primo nastro, e tutti gli altri nastri vuoti. Macchine di Turing con nastri addizionali In ciascun passo di computazione, ogni testina é nello stesso stato, ma può essere in una posizione diversa, leggere un simbolo differente, e compiere un’azione diversa." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://flecart.github.io/notes/estensioni-di-turing-e-altre-macchine/" />
<meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png" />
<meta property="article:section" content="notes" />



<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png" />
<meta name="twitter:title" content="Estensioni di Turing e altre macchine"/>
<meta name="twitter:description" content="Sono variazioni possibili equivalenti: • Nastri addizionali • Testine addizionali • Nastri infiniti su entrambi i lati • Non-determinismo • Scelta probabilistica • Scelta quantistica
Turing con nastri addizionali Questo è presente in modo abbastanza facile sul Sipser.
La computazione comincia con l’input sul primo nastro, e tutti gli altri nastri vuoti. Macchine di Turing con nastri addizionali In ciascun passo di computazione, ogni testina é nello stesso stato, ma può essere in una posizione diversa, leggere un simbolo differente, e compiere un’azione diversa."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Estensioni di Turing e altre macchine",
      "item": "https://flecart.github.io/notes/estensioni-di-turing-e-altre-macchine/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Estensioni di Turing e altre macchine",
  "name": "Estensioni di Turing e altre macchine",
  "description": "Sono variazioni possibili equivalenti: • Nastri addizionali • Testine addizionali • Nastri infiniti su entrambi i lati • Non-determinismo • Scelta probabilistica • Scelta quantistica\nTuring con nastri addizionali Questo è presente in modo abbastanza facile sul Sipser.\nLa computazione comincia con l’input sul primo nastro, e tutti gli altri nastri vuoti. Macchine di Turing con nastri addizionali In ciascun passo di computazione, ogni testina é nello stesso stato, ma può essere in una posizione diversa, leggere un simbolo differente, e compiere un’azione diversa.",
  "keywords": [
    "theoretical-computer-science"
  ],
  "articleBody": "Sono variazioni possibili equivalenti: • Nastri addizionali • Testine addizionali • Nastri infiniti su entrambi i lati • Non-determinismo • Scelta probabilistica • Scelta quantistica\nTuring con nastri addizionali Questo è presente in modo abbastanza facile sul Sipser.\nLa computazione comincia con l’input sul primo nastro, e tutti gli altri nastri vuoti. Macchine di Turing con nastri addizionali In ciascun passo di computazione, ogni testina é nello stesso stato, ma può essere in una posizione diversa, leggere un simbolo differente, e compiere un’azione diversa. Se si raggiunge uno stato finale, l’output é letto dal primo nastro.\n#### Definizione formalismo 🟩 L'unica differenza formale è che questa macchina è **parallela** cioè ho molte macchine di turing che vanno allo stesso momento $$ \\delta: (Q - H) \\times \\Sigma^{k} \\to Q \\times(\\Sigma \\times \\left\\{ \\to, \\leftarrow \\right\\} )^{k} $$ Il restante delle tuple resta uguale. L'altra osservazione è che lo stato esterno è **unico**. In un certo senso è una **pila con macchina di turing** [Linguaggi liberi e PDA](/notes/linguaggi-liberi-e-pda). Teorema di equivalenza 🟩 Dimostriamo che questo formalismo è equivalente con La macchina di Turing. È ovvio il caso in cui nastro addizionale -\u003e Turing. Ossia che\nTermina quando il l’altro non termina Se termina hanno stesso output. Si può formalizzare però alla fine è quello.\nL’altra freccia è provare a simulare con La macchina di Turing tutti i nastri aggiuntivi del nostro multinastro, con un simbolo in più che identifichiamo con $\\#$. Cominciamo (dimostrazione intuitiva): Supponiamo di avere una macchina multi nastro $\\mathcal{M}$, costruiamo con l’altra macchina $\\mathcal{M}'$ con singolo nastro che sia equivalente al primo, in questo modo dimostriamo che una TM è anche uguale alla versione multi-nastro. Prendiamo $$ \\Sigma' = \\Sigma \\cup \\left\\{ \\# \\right\\} \\cup \\left\\{ \\bar{a} : a \\in \\Sigma \\right\\} $$ Allora I molteplici passi di computazione su molti nastri che sono un singolo passo per la multinastro possono essere simulati sul singolo nastro. La lettere barretta ci permette di mantenere il pointer sul nastro originale. Se c’è bisogno di spazio in più su un nastro, debbo postare tutto a destra (tanto è infinito e posso farlo). (nota che per questo teorema è necessario l’infinito!!) Alla fine cancello tutto dopo il primo cancelletto e ritorno quello.\nEnumerators Questo è un argomento extra non trattato a lezione 3.2 del Sipser viene trattato. Si può dire che è una altra cosa equivalente alla La macchina di Turing. In modo informale, un enumeratore è una macchina di turing con una stampante, che può esser considerato l’output della nostra macchina. Poi c’è un work tape che può essere utilizzato come cache. Da un punto di vista formale non è altro che una macchina di turing con 2 nastri\nMacchine di Turing non deterministiche Descrizione formalismo non deterministico 🟩 L’unica differenza con La macchina di Turing, è che invece di funzione abbiamo una relazione! Oltre a questo anche lo stato di accettazione, se un qualunque ramo accetta, allora questa macchina accetta.\nIn un certo senso questo non determinismo è simile a quanto fatto in Grammatiche Regolari e Linguaggi liberi e PDA. Per il non determinismo. Solo che lì il prof. li faceva più formali.\nSulle slides c’è un esempio di MTnd molto semplice per dimostrare che la primalità di un numero è calcolabile. (idea prendo in modo non deterministico un numero minore di $n$ e calcolo il modulo).\nSketch di dimostrazione di equivalenza 🟨++ Supponendo che abbiamo l’albero di computazione, posso esplorare con Grafi#BFS tutto l’albero di computazione e avere alla fine lo stesso risultato.\nQui c’è un albero di computazione. (poi probabilmente bisognerà codificare un backtracking) Altre Una altra macchina di Turing di interesse che non trattiamo qui è il prefix turing machine, che trattiamo in Kolmogorov complexity.\nMacchine a registri Chiamato anche URM unlimited register machine, è un formalismo più simile a come sono fatti i computer moderni perché utilizzano i regsitri. Definito in (Shepherdson \u0026 Sturgis 1963).\nDescrizione Unlimited Register Machine 🟨++ Supponiamo di avere $R_{1}, R_{2}, R_{3}, \\dots$ registri, ogni registro ha un numero naturale indicato con $r_{n}$ (contenuto di registro $n$) Se la computazione finisce, questa viene messa in $R_{1}$ (simile a RAX in archietture intel). L’input $N^{k}$ è messo in tutti i registri in ordine (se non definito sono a 0).\nEsistono un sistema di istruzioni che muovono e modificano le cose dei registri:\nZero $Z(n)$ il registro $n$ è messo a 0. Successor $S(n)$ il registro $n$ è aumentato a $n$ Move $R(n, m)$ $m$ è messo uguale a $n$ (sono registri) Jump $J(n, m, p)$ Salta a istruzione $I_{p}$ se i registri $n$ e $m$ sono uguali. altrimenti ignora istruzione. Ora possiamo definire una specie di ALU che è la cosa classica di programma imperativo.\nEnunciato equivalenza 🟩 Vogliamo passare in questo caso a dimostrare la calcolabilità di funzioni parziali, ossia funzioni $$ \\mathbb{N}^{k} \\to \\mathbb{N} $$ Che possono anche non terminare (in questo caso parziale).\nUna funzione parziale è calcolabile in URM sse è calcolabile su TM\nIdea TM =\u003e URM 🟨 Uso il risultato in #Turing con nastri addizionali, ho tanti nastri che fanno cose:\nFa instruction pointer e punta all’istruzione attuale Ha il codice del programma Ha il valore dei registri in notazione unaria (che è equivalente), separati da U. Altri registri sono cache. Allora posso usare il contenuto del nastro 1 per trovare l’istruzione, poi uso altro per interpretarla ed eseguirla. Alla fine uso il primo valore del terzo nastro per avere il risultato. Per la modifica dei registri posso usare nastri ausiliari.\nIdea TM \u003c= URM 🟨 Supponiamo di avere un URM, vogliamo simulare una macchina di turing con la classica tupla $\\Sigma, Q, q_{0}, H, \\delta$\nChiamo un registro TAPE che conterrà i valori presenti su un nastro di Turing. Inoltre dobbiamo ricordarci che questa macchina contiene numeri naturali per questo motivo abbiamo bisogno di una codifica. Scegliamo $\\Sigma = \\left\\{ 0, 1, U \\right\\}$ dove $U$ sta per empty. Allora possiamo usare la notazione in base $3$ per decodificare il numero, assumendo $code(0) = 0$, $code(1) = 1$, $code(U) = 2$.\nPoi introduciamo registri per codificare $\\delta$ la funzione di transizione. Modello WHILE Questo è un formalismo più simile a uno di alto livello (quindi programma normale).Descritto in\nKfoury, Moll, Arbib - A programming approach to computability.\nDescrizione del modello WHILE (3) 🟩 Questo è simile a quanto descritto per la Semantica di un linguaggio per la parte procedurale. Abbiamo:\nAssegnazione Cicli while seguenziamento Possiamo definirlo in Sintassi e RI strutturali#4.2 Backus-Naur Form Ci sono tre forme di assegnazione, uno zero, uno successivo, uno uguale credo. Non viene fatta la parte della semantica che abbiamo fatto tempo fa a linguaggi.\nDimostrazione equivalenza 🟩 Una funzione (parziale) é computabile da un programma WHILE se e solo se é computabile da una macchina di Turing.\nSi dimostra per induzione strutturale sulla BNF lì precedente. I casi base sono i 3 assegnamenti (zero, successore, e predecessore) e il programma vuoto.\nPer il caso base, utilizzo un nastro separato come ho fatto per #Turing con nastri addizionali, su questo ci metto le variabili di interesse. Su questo posso codificare i casi base accennati di sopra.\nPoi caso induttivo è while e sequenza di istruzioni. Poi per codificare la sequenza, basta concatenare molte macchine di turing normali, ognuna che codifica l’istruzione. Sappiamo che queste esistono per ipotesi induttiva. Per il while possiamo usare due macchine, una per il test, una per il corpo del while e dire che accetta quando esco dal ciclo. È interessante osservare come siano uguali questi.\nReferences [1] Shepherdson \u0026 Sturgis “Computability of Recursive Functions” Journal of the ACM Vol. 10(2), pp. 217–255 1963\n",
  "wordCount" : "1267",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/estensioni-di-turing-e-altre-macchine/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Estensioni di Turing e altre macchine
    </h1>
    <div class="post-meta">6 min&nbsp;·&nbsp;Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul><ul><ul>
                <li>
                    <a href="#turing-con-nastri-addizionali" aria-label="Turing con nastri addizionali">Turing con nastri addizionali</a><ul>
                        
                <li>
                    <a href="#teorema-di-equivalenza-" aria-label="Teorema di equivalenza 🟩">Teorema di equivalenza 🟩</a></li>
                <li>
                    <a href="#enumerators" aria-label="Enumerators">Enumerators</a></li></ul>
                </li>
                <li>
                    <a href="#macchine-di-turing-non-deterministiche" aria-label="Macchine di Turing non deterministiche">Macchine di Turing non deterministiche</a><ul>
                        
                <li>
                    <a href="#descrizione-formalismo-non-deterministico-" aria-label="Descrizione formalismo non deterministico 🟩">Descrizione formalismo non deterministico 🟩</a></li>
                <li>
                    <a href="#sketch-di-dimostrazione-di-equivalenza-" aria-label="Sketch di dimostrazione di equivalenza 🟨&#43;&#43;">Sketch di dimostrazione di equivalenza 🟨++</a></li></ul>
                </li>
                <li>
                    <a href="#altre" aria-label="Altre">Altre</a></li>
                <li>
                    <a href="#macchine-a-registri" aria-label="Macchine a registri">Macchine a registri</a><ul>
                        
                <li>
                    <a href="#descrizione-unlimited-register-machine-" aria-label="Descrizione Unlimited Register Machine 🟨&#43;&#43;">Descrizione Unlimited Register Machine 🟨++</a></li>
                <li>
                    <a href="#enunciato-equivalenza-" aria-label="Enunciato equivalenza 🟩">Enunciato equivalenza 🟩</a></li>
                <li>
                    <a href="#idea-tm--urm-" aria-label="Idea TM =&gt; URM 🟨">Idea TM =&gt; URM 🟨</a></li>
                <li>
                    <a href="#idea-tm--urm--1" aria-label="Idea TM &lt;= URM 🟨">Idea TM &lt;= URM 🟨</a></li></ul>
                </li>
                <li>
                    <a href="#modello-while" aria-label="Modello WHILE">Modello WHILE</a><ul>
                        
                <li>
                    <a href="#descrizione-del-modello-while-3-" aria-label="Descrizione del modello WHILE (3) 🟩">Descrizione del modello WHILE (3) 🟩</a></li>
                <li>
                    <a href="#dimostrazione-equivalenza-" aria-label="Dimostrazione equivalenza 🟩">Dimostrazione equivalenza 🟩</a></li></ul>
                </li></ul>
                    </ul>
                    
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Sono variazioni possibili equivalenti:
• Nastri addizionali • Testine addizionali • Nastri infiniti su entrambi i lati • Non-determinismo • Scelta probabilistica • Scelta quantistica</p>
<h3 id="turing-con-nastri-addizionali">Turing con nastri addizionali<a hidden class="anchor" aria-hidden="true" href="#turing-con-nastri-addizionali">#</a></h3>
<p>Questo è presente in modo abbastanza facile sul Sipser.</p>
<blockquote>
<p>La computazione comincia con l’input sul primo nastro, e tutti gli altri nastri vuoti. Macchine di Turing con nastri addizionali In ciascun passo di computazione, ogni testina é nello stesso stato, ma può essere in una posizione diversa, leggere un simbolo differente, e compiere un’azione diversa. Se si raggiunge uno stato finale, l’output é letto dal primo nastro.</p>
</blockquote>
<img src="/images/notes/Estensioni di Turing e altre macchine-20240222123223011.webp" alt="Estensioni di Turing e altre macchine-20240222123223011">
#### Definizione formalismo 🟩
L'unica differenza formale è che questa macchina è **parallela** cioè ho molte macchine di turing che vanno allo stesso momento
$$
\delta: (Q - H) \times \Sigma^{k} \to Q \times(\Sigma \times \left\{ \to, \leftarrow \right\} )^{k}
$$
Il restante delle tuple resta uguale. L'altra osservazione è che lo stato esterno è **unico**.
In un certo senso è una **pila con macchina di turing** [Linguaggi liberi e PDA](/notes/linguaggi-liberi-e-pda).
<h4 id="teorema-di-equivalenza-">Teorema di equivalenza 🟩<a hidden class="anchor" aria-hidden="true" href="#teorema-di-equivalenza-">#</a></h4>
<p>Dimostriamo che questo formalismo è equivalente con <a href="/notes/la-macchina-di-turing/">La macchina di Turing</a>.
È ovvio il caso in cui <em>nastro addizionale</em> -&gt; <em>Turing</em>.
Ossia che</p>
<ol>
<li>Termina quando il l&rsquo;altro non termina</li>
<li>Se termina hanno stesso output.</li>
</ol>
<p>Si può formalizzare però alla fine è quello.</p>
<p>L&rsquo;altra freccia è provare a simulare con <a href="/notes/la-macchina-di-turing/">La macchina di Turing</a> tutti i nastri aggiuntivi del nostro multinastro, con un simbolo in più che identifichiamo con $\#$.
Cominciamo (dimostrazione intuitiva):
Supponiamo di avere una macchina multi nastro $\mathcal{M}$, costruiamo con l&rsquo;altra macchina $\mathcal{M}'$ con singolo nastro che sia equivalente al primo, in questo modo dimostriamo che una TM è anche uguale alla versione multi-nastro.
Prendiamo
</p>
$$
\Sigma' =  \Sigma \cup \left\{ \# \right\}  \cup \left\{ \bar{a} : a \in \Sigma \right\} 
$$
<p>
Allora
<img src="/images/notes/Estensioni di Turing e altre macchine-20240222124050098.webp" alt="Estensioni di Turing e altre macchine-20240222124050098">
I molteplici passi di computazione su molti nastri che sono un singolo passo per la multinastro possono essere simulati sul singolo nastro.
La lettere barretta ci permette di mantenere il pointer sul nastro originale. Se c&rsquo;è bisogno di spazio in più su un nastro, debbo postare tutto a destra (tanto è infinito e posso farlo). (nota che per questo teorema è necessario l&rsquo;infinito!!)
Alla fine cancello tutto dopo il primo cancelletto e ritorno quello.</p>
<h4 id="enumerators">Enumerators<a hidden class="anchor" aria-hidden="true" href="#enumerators">#</a></h4>
<p>Questo è un argomento extra non trattato a lezione 3.2 del Sipser viene trattato.
Si può dire che è una altra cosa equivalente alla <a href="/notes/la-macchina-di-turing/">La macchina di Turing</a>.
In modo informale, un enumeratore è una macchina di turing con una stampante, che può esser considerato l&rsquo;output della nostra macchina.
Poi c&rsquo;è un work tape che può essere utilizzato come cache.
Da un punto di vista formale non è altro che una macchina di turing con 2 nastri</p>
<h3 id="macchine-di-turing-non-deterministiche">Macchine di Turing non deterministiche<a hidden class="anchor" aria-hidden="true" href="#macchine-di-turing-non-deterministiche">#</a></h3>
<h4 id="descrizione-formalismo-non-deterministico-">Descrizione formalismo non deterministico 🟩<a hidden class="anchor" aria-hidden="true" href="#descrizione-formalismo-non-deterministico-">#</a></h4>
<p>L&rsquo;unica differenza con <a href="/notes/la-macchina-di-turing/">La macchina di Turing</a>, è che invece di funzione abbiamo una <strong>relazione</strong>!
Oltre a questo anche lo stato di accettazione, se un qualunque ramo accetta, allora questa macchina accetta.</p>
<p>In un certo senso questo non determinismo è simile a quanto fatto in <a href="/notes/grammatiche-regolari/">Grammatiche Regolari</a> e <a href="/notes/linguaggi-liberi-e-pda/">Linguaggi liberi e PDA</a>. Per il non determinismo. Solo che lì il prof. li faceva più formali.</p>
<p>Sulle slides c&rsquo;è un esempio di MTnd molto semplice per dimostrare che la primalità di un numero è calcolabile. (idea prendo in modo non deterministico un numero minore di $n$ e calcolo il modulo).</p>
<h4 id="sketch-di-dimostrazione-di-equivalenza-">Sketch di dimostrazione di equivalenza 🟨++<a hidden class="anchor" aria-hidden="true" href="#sketch-di-dimostrazione-di-equivalenza-">#</a></h4>
<p>Supponendo che abbiamo l&rsquo;albero di computazione, posso esplorare con <a href="/notes/grafi/#bfs">Grafi#BFS</a> tutto l&rsquo;albero di computazione e avere alla fine lo stesso risultato.</p>
<p>Qui c&rsquo;è un albero di computazione. (poi probabilmente bisognerà codificare un backtracking)
<img src="/images/notes/Estensioni di Turing e altre macchine-20240222125426485.webp" alt="Estensioni di Turing e altre macchine-20240222125426485"></p>
<h3 id="altre">Altre<a hidden class="anchor" aria-hidden="true" href="#altre">#</a></h3>
<p>Una altra macchina di Turing di interesse che non trattiamo qui è il prefix turing machine, che trattiamo in <a href="/notes/kolmogorov-complexity/">Kolmogorov complexity</a>.</p>
<h3 id="macchine-a-registri">Macchine a registri<a hidden class="anchor" aria-hidden="true" href="#macchine-a-registri">#</a></h3>
<p>Chiamato anche <strong>URM</strong> <em>unlimited register machine</em>, è un formalismo più simile a come sono fatti i computer moderni perché utilizzano i regsitri.
Definito in <a href="https://dl.acm.org/doi/10.1145/321160.321170">(Shepherdson &amp; Sturgis 1963)</a>.</p>
<h4 id="descrizione-unlimited-register-machine-">Descrizione Unlimited Register Machine 🟨++<a hidden class="anchor" aria-hidden="true" href="#descrizione-unlimited-register-machine-">#</a></h4>
<p>Supponiamo di avere $R_{1}, R_{2}, R_{3}, \dots$ registri, ogni registro ha un numero naturale indicato con $r_{n}$ (contenuto di registro $n$)
Se la computazione finisce, questa viene messa in $R_{1}$ (simile a RAX in archietture intel).
L&rsquo;input $N^{k}$ è messo in tutti i registri in ordine (se non definito sono a 0).</p>
<p>Esistono un sistema di istruzioni che muovono e modificano le cose dei registri:</p>
<ol>
<li><strong>Zero</strong> $Z(n)$ il registro $n$ è messo a 0.</li>
<li><strong>Successor</strong> $S(n)$ il registro $n$ è aumentato a $n$</li>
<li><strong>Move</strong> $R(n, m)$ $m$ è messo uguale a $n$ (sono registri)</li>
<li><strong>Jump</strong> $J(n, m, p)$ Salta a istruzione $I_{p}$ se i registri $n$ e $m$ sono uguali. altrimenti ignora istruzione.</li>
</ol>
<p>Ora possiamo definire una specie di <a href="/notes/cpu-e-storia-degli-elaboratori/#3.1.2-alu">ALU</a> che è la cosa classica di programma imperativo.</p>
<h4 id="enunciato-equivalenza-">Enunciato equivalenza 🟩<a hidden class="anchor" aria-hidden="true" href="#enunciato-equivalenza-">#</a></h4>
<p>Vogliamo passare in questo caso a dimostrare la calcolabilità di funzioni parziali, ossia funzioni
</p>
$$
\mathbb{N}^{k} \to \mathbb{N}
$$
<p>
Che possono anche non terminare (in questo caso parziale).</p>
<blockquote>
<p>Una funzione parziale è calcolabile in URM sse è calcolabile su TM</p>
</blockquote>
<h4 id="idea-tm--urm-">Idea TM =&gt; URM 🟨<a hidden class="anchor" aria-hidden="true" href="#idea-tm--urm-">#</a></h4>
<p>Uso il risultato in <a href="/notes/estensioni-di-turing-e-altre-macchine/#turing-con-nastri-addizionali">#Turing con nastri addizionali</a>, ho tanti nastri che fanno cose:</p>
<ol>
<li>Fa <em>instruction pointer</em> e punta all&rsquo;istruzione attuale</li>
<li>Ha il codice del programma</li>
<li>Ha il valore dei registri in notazione unaria (che è equivalente), separati da U.</li>
<li>Altri registri sono cache.</li>
</ol>
<p>Allora posso usare il contenuto del nastro 1 per trovare l&rsquo;istruzione, poi uso altro per interpretarla ed eseguirla. Alla fine uso il primo valore del terzo nastro per avere il risultato.
Per la modifica dei registri posso usare nastri ausiliari.</p>
<h4 id="idea-tm--urm--1">Idea TM &lt;= URM 🟨<a hidden class="anchor" aria-hidden="true" href="#idea-tm--urm--1">#</a></h4>
<p>Supponiamo di avere un URM, vogliamo simulare una macchina di turing con la classica tupla $\Sigma, Q, q_{0}, H, \delta$<br>
Chiamo un registro <em>TAPE</em> che conterrà i valori presenti su un nastro di Turing.
Inoltre dobbiamo ricordarci che questa macchina contiene <strong>numeri naturali</strong> per questo motivo abbiamo bisogno di una codifica.
Scegliamo $\Sigma = \left\{ 0, 1, U \right\}$ dove $U$ sta per empty.
Allora possiamo usare la notazione in base $3$ per decodificare il numero, assumendo $code(0) = 0$, $code(1) = 1$, $code(U) = 2$.</p>
<p>Poi introduciamo registri per codificare $\delta$ la funzione di transizione.
<img src="/images/notes/Estensioni di Turing e altre macchine-20240222133448285.webp" alt="Estensioni di Turing e altre macchine-20240222133448285"></p>
<h3 id="modello-while">Modello WHILE<a hidden class="anchor" aria-hidden="true" href="#modello-while">#</a></h3>
<p>Questo è un formalismo più simile a uno di alto livello (quindi programma normale).Descritto in</p>
<blockquote>
<p>Kfoury, Moll, Arbib - A programming approach to computability.</p>
</blockquote>
<h4 id="descrizione-del-modello-while-3-">Descrizione del modello WHILE (3) 🟩<a hidden class="anchor" aria-hidden="true" href="#descrizione-del-modello-while-3-">#</a></h4>
<p>Questo è simile a quanto descritto per la <a href="/notes/semantica-di-un-linguaggio/">Semantica di un linguaggio</a> per la parte procedurale.
Abbiamo:</p>
<ol>
<li>Assegnazione</li>
<li>Cicli while</li>
<li>seguenziamento</li>
</ol>
<p>Possiamo definirlo in <a href="/notes/sintassi-e-ri-strutturali/#4.2-backus-naur-form">Sintassi e RI strutturali#4.2 Backus-Naur Form</a>
<img src="/images/notes/Estensioni di Turing e altre macchine-20240222133654619.webp" width="464" alt="Estensioni di Turing e altre macchine-20240222133654619"></p>
<p>Ci sono tre forme di assegnazione, uno zero, uno successivo, uno uguale credo.
Non viene fatta la parte della semantica che abbiamo fatto tempo fa a linguaggi.</p>
<h4 id="dimostrazione-equivalenza-">Dimostrazione equivalenza 🟩<a hidden class="anchor" aria-hidden="true" href="#dimostrazione-equivalenza-">#</a></h4>
<blockquote>
<p>Una funzione (parziale) é computabile da un programma WHILE se e solo se é computabile da una macchina di Turing.</p>
</blockquote>
<p>Si dimostra per <a href="/notes/sintassi-e-ri-strutturali/#4.7-induzione-strutturale">induzione strutturale</a> sulla BNF lì precedente.
I casi base sono i 3 assegnamenti (zero, successore, e predecessore) e il programma vuoto.</p>
<p>Per il caso base, utilizzo un nastro separato come ho fatto per <a href="/notes/estensioni-di-turing-e-altre-macchine/#turing-con-nastri-addizionali">#Turing con nastri addizionali</a>, su questo ci metto le variabili di interesse.
Su questo posso codificare i casi base accennati di sopra.</p>
<p>Poi caso induttivo è while e sequenza di istruzioni.
Poi per codificare la sequenza, basta concatenare molte macchine di turing normali, ognuna che codifica l&rsquo;istruzione. Sappiamo che queste esistono per ipotesi induttiva.
<img src="/images/notes/Estensioni di Turing e altre macchine-20240228131640133.webp" alt="Estensioni di Turing e altre macchine-20240228131640133">
Per il while possiamo usare due macchine, una per il test, una per il corpo del while e dire che accetta quando esco dal ciclo.
<img src="/images/notes/Estensioni di Turing e altre macchine-20240228131659027.webp" alt="Estensioni di Turing e altre macchine-20240228131659027">
È interessante osservare come siano uguali questi.</p>
<h1 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h1>
<p>[1] Shepherdson &amp; Sturgis <a href="https://dl.acm.org/doi/10.1145/321160.321170">“Computability of Recursive Functions”</a> Journal of the ACM Vol. 10(2), pp. 217&ndash;255 1963</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/theoretical-computer-science/">Theoretical-Computer-Science</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Estensioni di Turing e altre macchine on x"
            href="https://x.com/intent/tweet/?text=Estensioni%20di%20Turing%20e%20altre%20macchine&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2festensioni-di-turing-e-altre-macchine%2f&amp;hashtags=theoretical-computer-science">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Estensioni di Turing e altre macchine on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2festensioni-di-turing-e-altre-macchine%2f&amp;title=Estensioni%20di%20Turing%20e%20altre%20macchine&amp;summary=Estensioni%20di%20Turing%20e%20altre%20macchine&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2festensioni-di-turing-e-altre-macchine%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Estensioni di Turing e altre macchine on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2festensioni-di-turing-e-altre-macchine%2f&title=Estensioni%20di%20Turing%20e%20altre%20macchine">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Estensioni di Turing e altre macchine on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2festensioni-di-turing-e-altre-macchine%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Estensioni di Turing e altre macchine on whatsapp"
            href="https://api.whatsapp.com/send?text=Estensioni%20di%20Turing%20e%20altre%20macchine%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2festensioni-di-turing-e-altre-macchine%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Estensioni di Turing e altre macchine on telegram"
            href="https://telegram.me/share/url?text=Estensioni%20di%20Turing%20e%20altre%20macchine&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2festensioni-di-turing-e-altre-macchine%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Estensioni di Turing e altre macchine on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Estensioni%20di%20Turing%20e%20altre%20macchine&u=https%3a%2f%2fflecart.github.io%2fnotes%2festensioni-di-turing-e-altre-macchine%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
