<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Relational Algebra | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="📙basi-di-dati">
<meta name="description" content="Introduzione all&rsquo;algebra relazionale
Confronto con relazioni matematiche
Le relazioni come le intendiamo in database sono leggermente diverse rispetto a quelle presenti per le relazioni matematiche:

Non conta l&rsquo;ordine
Ci sono gli attributi

Per il resto se introduciamo questo sistema per tenere conto delle astrazioni, possiamo analizzarle matematicamente, e questo ci fornisce qualche sicurezza in più diciamo.
Four types of operations

Set operations: union, intersection, difference
Filter queries: Projecting or selecting
Renaming queries: renames
Join: correlare tuple di relazioni diverse

Definition of tuples 🟩
Le relazioni sono esattamente quelle definite in matematica, però noi aggiungiamo anche gli attributi, in modo da poter considerare l&rsquo;ordine delle colonne non importante.">
<meta name="author" content="Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="https://flecart.github.io/notes/relational-algebra/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/relational-algebra/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>
<script type="text/javascript" async
src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>






      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-WW6NN2QGKF');
        }
      </script><meta property="og:url" content="https://flecart.github.io/notes/relational-algebra/">
  <meta property="og:site_name" content="X. Angelo Huang&#39;s Blog">
  <meta property="og:title" content="Relational Algebra">
  <meta property="og:description" content="Introduzione all’algebra relazionale Confronto con relazioni matematiche Le relazioni come le intendiamo in database sono leggermente diverse rispetto a quelle presenti per le relazioni matematiche:
Non conta l’ordine Ci sono gli attributi Per il resto se introduciamo questo sistema per tenere conto delle astrazioni, possiamo analizzarle matematicamente, e questo ci fornisce qualche sicurezza in più diciamo.
Four types of operations Set operations: union, intersection, difference Filter queries: Projecting or selecting Renaming queries: renames Join: correlare tuple di relazioni diverse Definition of tuples 🟩 Le relazioni sono esattamente quelle definite in matematica, però noi aggiungiamo anche gli attributi, in modo da poter considerare l’ordine delle colonne non importante.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="notes">
    <meta property="article:tag" content="📙Basi-Di-Dati">
      <meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:title" content="Relational Algebra">
<meta name="twitter:description" content="Introduzione all&rsquo;algebra relazionale
Confronto con relazioni matematiche
Le relazioni come le intendiamo in database sono leggermente diverse rispetto a quelle presenti per le relazioni matematiche:

Non conta l&rsquo;ordine
Ci sono gli attributi

Per il resto se introduciamo questo sistema per tenere conto delle astrazioni, possiamo analizzarle matematicamente, e questo ci fornisce qualche sicurezza in più diciamo.
Four types of operations

Set operations: union, intersection, difference
Filter queries: Projecting or selecting
Renaming queries: renames
Join: correlare tuple di relazioni diverse

Definition of tuples 🟩
Le relazioni sono esattamente quelle definite in matematica, però noi aggiungiamo anche gli attributi, in modo da poter considerare l&rsquo;ordine delle colonne non importante.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Relational Algebra",
      "item": "https://flecart.github.io/notes/relational-algebra/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Relational Algebra",
  "name": "Relational Algebra",
  "description": "Introduzione all\u0026rsquo;algebra relazionale Confronto con relazioni matematiche Le relazioni come le intendiamo in database sono leggermente diverse rispetto a quelle presenti per le relazioni matematiche:\nNon conta l\u0026rsquo;ordine Ci sono gli attributi Per il resto se introduciamo questo sistema per tenere conto delle astrazioni, possiamo analizzarle matematicamente, e questo ci fornisce qualche sicurezza in più diciamo.\nFour types of operations Set operations: union, intersection, difference Filter queries: Projecting or selecting Renaming queries: renames Join: correlare tuple di relazioni diverse Definition of tuples 🟩 Le relazioni sono esattamente quelle definite in matematica, però noi aggiungiamo anche gli attributi, in modo da poter considerare l\u0026rsquo;ordine delle colonne non importante.\n",
  "keywords": [
    "📙basi-di-dati"
  ],
  "articleBody": "Introduzione all’algebra relazionale Confronto con relazioni matematiche Le relazioni come le intendiamo in database sono leggermente diverse rispetto a quelle presenti per le relazioni matematiche:\nNon conta l’ordine Ci sono gli attributi Per il resto se introduciamo questo sistema per tenere conto delle astrazioni, possiamo analizzarle matematicamente, e questo ci fornisce qualche sicurezza in più diciamo.\nFour types of operations Set operations: union, intersection, difference Filter queries: Projecting or selecting Renaming queries: renames Join: correlare tuple di relazioni diverse Definition of tuples 🟩 Le relazioni sono esattamente quelle definite in matematica, però noi aggiungiamo anche gli attributi, in modo da poter considerare l’ordine delle colonne non importante.\nPer prendere anche gli attributi possiamo definire così:\nTupla = funzione che associa attributo (una stringa) a un valore del dominio dell’attributo, definito da una funzione esterna Relazione è un insieme di tuple. Facendo in questo modo ho risolto il problema dell’ordine Set operations Possiamo modellare l’algebra come se\nUnions Intersections 🟩 Vengono indicati con i simboli classici presenti nella teoria degli insiemi $\\cap ,\\cup$ Questa parte non ho capito perché deve esistere… Che scopo ha?\nOperazioni principali Renaming Sintassi e semantica 🟩 Questo è un operatore unario.\nIt produces changes on the schema that keep the underlying data un-altered\nDa questa immagine è abbastanza intuitivo la sintassi utilizzata. $$ \\rho_{end \\impliedby start} (table) $$ **Semantica:** Un attributo del dataset viene richiamato con altro nome. ### Selection Anche questo è un **operatore unario**. #### Proprietà della selection (3) 🟨+ 1. Schema dell'output è lo stesso 2. L'output soddisfa un predicato (logico). 3. L'output è solamente un subset. **Concatenazione**: $$ \\sigma_{a}(\\sigma_{b}(R)) = \\sigma_{a \\land b }(R) $$ $$ \\sigma_{a}(R_{1}\\cup R_{2}) = \\sigma_{a}(R_{1}) \\cup \\sigma_{a}(R_{2}) $$$$ \\sigma_{a}(R_{1} - R_{2}) = \\sigma_{a}(R_{1}) - \\sigma_{a}(R_{2}) $$Altro con insiemi Possiamo notare che operano proprio come se fossero dei set, nel senso unione per or, intersezione per and, e anche intersezione col contrario con il meno.\nSintassi e semantica 🟩 $$ \\sigma_{predicate}(Relation) $$ Semantica: un insieme che soddisfa le #Proprietà della selection\nProjection Anche questo è un unary operator.\nSemantica e sintassi 🟩 $$ \\pi_{attribute}(Relation) $$Semantica: viene ritornato un insieme con numero tuple della relazione iniziale (o minore per ripetizioni), ma solo con gli attributi di riferimento.\n$$ \\pi_{Y}(r) = \\left\\{ t[Y] | t \\in r \\right\\} $$ Ossia prendo i valori della tupla che corrispondono a quegli attributi, per ogni singola tupla presente in relazione\nCaso ripetizioni 🟩 Questa è una cosa da notare, a differenza di Structured Query Language le cose ripetute vengono scartate, si ha unico, in questo caso, perché qui siamo nel reame degli insiemi\nProprietà di proiezioni 🟩 $$ \\pi_{x}(R) = \\pi_{x}(\\pi_{xy}(R)) $$ Se lo applico più volte (anche con cose leggermente diverse rimane uguale)\n$$ \\pi_{x}(R_{1} \\cup R_{2}) = \\pi_{x}(R_{1}) \\cup \\pi_{x}(R_{2}) $$Join La join è necessaria nel caso vogliamo creare correlazione fra tuple presenti in relazioni diverse fra di loro, mentre con #Projection e #Selection possiamo farlo solamente sulla prima.\nFull and empty joins 🟩 Full -\u003e Every tuple is used (not full is some is used) Empty -\u003e with no outputs Questo è direttamente dipendente da quali chiavi abbiamo usato durante la join ! 500\nTypes of Joins (2) 🟩- $$ R_{1} \\bowtie R_{2} = \\left\\{ t \\text{ on } X_{1} \\cup X_{2} | \\exists t_{1} \\in R_{1} \\text{ and } \\exists t_{2} \\in R_{2} \\text{ with } t[X_{1}] = t_{1} \\text{ and } t[X_{2}] = t_{2}\\right\\} $$ Ossia data una tupla nella nuova relazione così creata, se prendo i attributi appartenenti alla prima relazione avrò che esiste effettivamente uguale per il secondo.\nOuter joins: Che sono le stesse spiegate in Structured Query Language, ossia andiamo a considerare left, right and full $A ⟕ B, A ⟖B , A⟗B$, sono i simboli utilizzati, ma userò sempre $\\bowtie$ con pedice l, r, f per indicarne il tipo, per semplicità di notazione.\nLa semantica di questi è la stessa per SQL, la descriviamo prevemente, sarà left outer, nel caso in cui ho la garanzia che solamente le tuple della relazione 1 ci sarà, contrario per right, per il full outer, ho la garanzia che una data tupla finale, sarà presente in almeno uno dei due iniziali, ma non so quale.\nProprietà (2) 🟩 Push selection ! 500\n$$ R \\bowtie(R_{1} \\cup R_{2}) = (R \\bowtie R_{1}) \\cup(R\\bowtie R_{2}) $$Theta Join 🟩- Il theta join viene motivato grazie al fatto che solitamente bisogna sempre rinominare prima di fare una selection, o bisogna fare sempre selection, per questo motivo. Solo che questo è possibile fare solo se sono una #Cartesian product, ossia non abbiano attributi in comune.\nLa sintassi ammessa nella condizione sono solamente and e relazioni booleane binarie (minore, maggiore, uguale e combinazione fra questi). Altra cosa necesssaria per la theta join, è che non ci siano attributi in comune fra le due relazioni.\nE si può notare sulle slides che questo è molto simile alla natural join dopo renaming espresso in #Types of Joins (2)) in precedenza.\nEqui Join 🟩 Quello più interessante sono le equi-join che accade quando ho relazioni di equivalenza, questo si manifesta solamente quando la theta join di sopra è fatta da atomi di uguaglianza, questo mi dovrebbe garantire per certo tale proprietà.\nCartesian product Si può considerare come una join naturale su relazioni senza attributi in comune (quindi tutto si può combinare con tutto!).\nViews Introduzione alle data-views 🟩- Sono delle rappresentazioni diverse dello stesso genere di data, solitamente utili per fare view diverse (e.g. dipartimento altro avrà necessità diverse), abbiamo accennato a questa necessità durante la nostra Introduction to databases. Nel caso preciso di SQL ne andiamo a parlare in Advanced SQL.\nNel caso di algebra relazionale, è soltanto una specie di dichiarazione di variabile con un altro nome, che specifica quale è il risultato della sua query.\nView utilization Questa è una cosa classica in informatica, il concetto di astrazione implementazione presente come descritto in Astrazione sul controllo#Significato di astrazione E dividere in questo modo quello che è effettivamente memorizzato da quello che l’utente deve volere vedere.\nMaterialized views 🟩– La differenza con l’altra tipologia di view che viene proposta è che questa view è storata fisicamente sui dispositivi di memorizzazione.\nPros:\nVeloce da leggere (non da creare ogni volta) Cons:\nRidondanza dei dati update deve essere doppio (problemi di coerenza) Non supportati dai DBMS. Virtual views 🟨 Al fine di creare la view viene fatto una query sul database. Non so esattamente se questi possono essere fatti sempre o meno.\nView update 🟩 Nel caso di sql possiamo andare a definire due valori local o cascade, con il primo la view non aggiorna le tabelle effettivamente presenti, mentre con cascade sì. Ma credo non si possa sempre fare e bisogna sempre stare leggermente attenti.\nSome notes on update difficulties È molto più difficile updatare la view, perché questo update deve essere coerente con la versione originale che era esistente! Per questo motivo non tutti gli update sono disponibili per update.\nRelational calculi 🟥 Si differenzia leggermente dall’al\nIntroduction to relational calculi Alla fine si basano tutti su Logica del Primo ordine, Questo è sempre un modo per modellare le relazioni che sono molto comuni nei casi che abbiamo trovato di relational databases, ma invece di utilizzare algebra utilizzano una logica, descritta sotto.\nQuesto è molto più vicino all’approccio logico, sviluppato durante gli anni 70-80 con knowledge bases in AI.\nGeneral form 🟨+ $$ \\left\\{ A_{1}: x_{1}, \\dots A_{k} : x_{k} | f \\right\\} $$In cui abbiamo\n$f$ che è una formula che probabilmente da un booleano per decidere se prenderlo o meno. $A_{i}$ che sono degli attributi $x_{i}$ che sono delle variabili Avremo come output una tupla di $(x_{1}, \\dots x_{n})$ che soddisfano $f$ Esempi: Esistono forme anche leggermente più complicate, ma dobbiamo introdurre gli esistenziali: Esistono anche i de morgan rules che si possono applicare, perché in pratica è logica.\nRelational calculi, considerations Aspetti negativi (2) 🟨 Moltissime variabili inutili (troppo verboso scriverci). Presenza di espressioni senza senso e dipendenti dal dominio questo significa che se cambiamo il dominio di definizione cambiamo anche i valori che sono possibilmente denotati (non ho capito perché questa dovrebbe essere una caratteristica negativa poi). Per risolvere il primo problema si aggiunge una sintassi più compatta, presentata come “range declaration syntax” (ma non è espressivo quanto algebra, in qualche modo si dimostra)…\nRange declaration syntax 🟨 Pagina 78 del libro ne parla meglio, dovrei approfondire quello. #### Indipendenza da dominio 🟨 $$ A_{1} : x_{1} | not R(A_{1} : x_{1}) $$ È dipendente dal dominio, perché prende l’insieme degli elementi nel dominio, tali che non sono presenti nella relazione. Abbiamo bisogno di questa proprietà perché se è dipendente dal dominio si potrebbero produrre risultati enormi, che rendono l’applicazione pratica nulla.\nEquivalenza con Algebra relazionale 🟩 Si può dimostrare che se ci limitiamo alle espressioni indipendenti col dominio, i due modelli sono esattamente uguali, ossia possiamo dire che possiamo creare una espressione di algebra, partendo da calcolo, e viceversa.\nLa dimostrazione (che non facciamo) andrà per induzione strutturale, quella che trovi in Logica in Deduzione naturale.\nPossiamo notare che l’algebra è indipendente dal dominio, perché lì non è mai esplicitata la relazione in che dominio sia (abbiamo operazioni chiuse si può dire).\n",
  "wordCount" : "1532",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/relational-algebra/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Relational Algebra
    </h1>
    <div class="post-meta">8 min&nbsp;·&nbsp;Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduzione-allalgebra-relazionale" aria-label="Introduzione all&rsquo;algebra relazionale">Introduzione all&rsquo;algebra relazionale</a><ul>
                        
                <li>
                    <a href="#confronto-con-relazioni-matematiche" aria-label="Confronto con relazioni matematiche">Confronto con relazioni matematiche</a><ul>
                        
                <li>
                    <a href="#four-types-of-operations" aria-label="Four types of operations">Four types of operations</a></li>
                <li>
                    <a href="#definition-of-tuples-" aria-label="Definition of tuples 🟩">Definition of tuples 🟩</a></li></ul>
                </li>
                <li>
                    <a href="#set-operations" aria-label="Set operations">Set operations</a><ul>
                        
                <li>
                    <a href="#unions-intersections-" aria-label="Unions Intersections 🟩">Unions Intersections 🟩</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#operazioni-principali" aria-label="Operazioni principali">Operazioni principali</a><ul>
                        
                <li>
                    <a href="#renaming" aria-label="Renaming">Renaming</a><ul>
                        
                <li>
                    <a href="#sintassi-e-semantica-" aria-label="Sintassi e semantica 🟩">Sintassi e semantica 🟩</a></li>
                <li>
                    <a href="#sintassi-e-semantica--" aria-label="Sintassi e semantica  🟩">Sintassi e semantica  🟩</a></li></ul>
                </li>
                <li>
                    <a href="#projection" aria-label="Projection">Projection</a><ul>
                        
                <li>
                    <a href="#semantica-e-sintassi-" aria-label="Semantica e sintassi 🟩">Semantica e sintassi 🟩</a></li>
                <li>
                    <a href="#caso-ripetizioni-" aria-label="Caso ripetizioni 🟩">Caso ripetizioni 🟩</a></li>
                <li>
                    <a href="#propriet%c3%a0-di-proiezioni-" aria-label="Proprietà di proiezioni 🟩">Proprietà di proiezioni 🟩</a></li></ul>
                </li>
                <li>
                    <a href="#join" aria-label="Join">Join</a><ul>
                        
                <li>
                    <a href="#full-and-empty-joins-" aria-label="Full and empty joins 🟩">Full and empty joins 🟩</a></li>
                <li>
                    <a href="#types-of-joins-2--" aria-label="Types of Joins (2) 🟩-">Types of Joins (2) 🟩-</a></li>
                <li>
                    <a href="#propriet%c3%a0--2-" aria-label="Proprietà  (2) 🟩">Proprietà  (2) 🟩</a></li>
                <li>
                    <a href="#theta-join--" aria-label="Theta Join 🟩-">Theta Join 🟩-</a></li>
                <li>
                    <a href="#equi-join-" aria-label="Equi Join 🟩">Equi Join 🟩</a></li></ul>
                </li>
                <li>
                    <a href="#cartesian-product" aria-label="Cartesian product">Cartesian product</a></li></ul>
                </li>
                <li>
                    <a href="#views" aria-label="Views">Views</a><ul>
                        
                <li>
                    <a href="#introduzione-alle-data-views--" aria-label="Introduzione alle data-views 🟩-">Introduzione alle data-views 🟩-</a></li>
                <li>
                    <a href="#view-utilization" aria-label="View utilization">View utilization</a><ul>
                        
                <li>
                    <a href="#materialized-views---" aria-label="Materialized views 🟩&ndash;">Materialized views 🟩&ndash;</a></li>
                <li>
                    <a href="#virtual-views-" aria-label="Virtual views 🟨">Virtual views 🟨</a></li></ul>
                </li>
                <li>
                    <a href="#view-update-" aria-label="View update 🟩">View update 🟩</a><ul>
                        
                <li>
                    <a href="#some-notes-on-update-difficulties" aria-label="Some notes on update difficulties">Some notes on update difficulties</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#relational-calculi-" aria-label="Relational calculi 🟥">Relational calculi 🟥</a><ul>
                        
                <li>
                    <a href="#introduction-to-relational-calculi" aria-label="Introduction to relational calculi">Introduction to relational calculi</a><ul>
                        
                <li>
                    <a href="#general-form-" aria-label="General form 🟨&#43;">General form 🟨+</a></li></ul>
                </li>
                <li>
                    <a href="#relational-calculi-considerations" aria-label="Relational calculi, considerations">Relational calculi, considerations</a><ul>
                        
                <li>
                    <a href="#aspetti-negativi-2-" aria-label="Aspetti negativi (2) 🟨">Aspetti negativi (2) 🟨</a></li>
                <li>
                    <a href="#range-declaration-syntax-" aria-label="Range declaration syntax 🟨">Range declaration syntax 🟨</a></li>
                <li>
                    <a href="#equivalenza-con-algebra-relazionale-" aria-label="Equivalenza con Algebra relazionale 🟩">Equivalenza con Algebra relazionale 🟩</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="introduzione-allalgebra-relazionale">Introduzione all&rsquo;algebra relazionale<a hidden class="anchor" aria-hidden="true" href="#introduzione-allalgebra-relazionale">#</a></h2>
<h3 id="confronto-con-relazioni-matematiche">Confronto con relazioni matematiche<a hidden class="anchor" aria-hidden="true" href="#confronto-con-relazioni-matematiche">#</a></h3>
<p>Le relazioni come le intendiamo in database sono leggermente diverse rispetto a quelle presenti per le relazioni matematiche:</p>
<ol>
<li>Non conta l&rsquo;ordine</li>
<li>Ci sono gli attributi</li>
</ol>
<p>Per il resto se introduciamo questo sistema per tenere conto delle astrazioni, possiamo analizzarle matematicamente, e questo ci fornisce qualche sicurezza in più diciamo.</p>
<h4 id="four-types-of-operations">Four types of operations<a hidden class="anchor" aria-hidden="true" href="#four-types-of-operations">#</a></h4>
<ul>
<li><strong>Set operations</strong>: union, intersection, difference</li>
<li><strong>Filter queries</strong>: Projecting or selecting</li>
<li><strong>Renaming queries</strong>: renames</li>
<li><strong>Join</strong>: correlare tuple di relazioni diverse</li>
</ul>
<h4 id="definition-of-tuples-">Definition of tuples 🟩<a hidden class="anchor" aria-hidden="true" href="#definition-of-tuples-">#</a></h4>
<p>Le relazioni sono esattamente quelle definite in matematica, però noi aggiungiamo anche gli attributi, in modo da poter considerare l&rsquo;ordine delle colonne non importante.</p>
<p>Per prendere anche gli attributi possiamo definire così:</p>
<ol>
<li>Tupla = funzione che associa attributo (una stringa) a un valore del dominio dell&rsquo;attributo, definito da una funzione esterna</li>
<li>Relazione è un insieme di tuple.
Facendo in questo modo ho risolto il problema dell&rsquo;ordine</li>
</ol>
<h3 id="set-operations">Set operations<a hidden class="anchor" aria-hidden="true" href="#set-operations">#</a></h3>
<p>Possiamo modellare l&rsquo;algebra come se</p>
<h4 id="unions-intersections-">Unions Intersections 🟩<a hidden class="anchor" aria-hidden="true" href="#unions-intersections-">#</a></h4>
<p>Vengono indicati con i simboli classici presenti nella teoria degli insiemi $\cap ,\cup$
Questa parte non ho capito perché deve esistere&hellip; Che scopo ha?</p>
<h2 id="operazioni-principali">Operazioni principali<a hidden class="anchor" aria-hidden="true" href="#operazioni-principali">#</a></h2>
<h3 id="renaming">Renaming<a hidden class="anchor" aria-hidden="true" href="#renaming">#</a></h3>
<h4 id="sintassi-e-semantica-">Sintassi e semantica 🟩<a hidden class="anchor" aria-hidden="true" href="#sintassi-e-semantica-">#</a></h4>
<p>Questo è un <strong>operatore unario</strong>.</p>
<blockquote>
<p>It produces <strong>changes on the schema</strong> that keep the underlying data un-altered</p></blockquote>
<img src="/images/notes/Algebra Relazionale-1697018900717.jpeg" style="width: 100%" class="center" alt="Algebra Relazionale-1697018900717">
Da questa immagine è abbastanza intuitivo la sintassi utilizzata.
$$
\rho_{end \impliedby start} (table)
$$
**Semantica:** Un attributo del dataset viene richiamato con altro nome.
### Selection
Anche questo è un **operatore unario**. 
#### Proprietà della selection (3) 🟨+
1. Schema dell'output è lo stesso
2. L'output soddisfa un predicato (logico).
3. L'output è solamente un subset.
**Concatenazione**:
$$
\sigma_{a}(\sigma_{b}(R)) = \sigma_{a \land b }(R)
$$
$$
\sigma_{a}(R_{1}\cup R_{2}) = \sigma_{a}(R_{1}) \cup \sigma_{a}(R_{2})
$$$$
\sigma_{a}(R_{1} - R_{2}) = \sigma_{a}(R_{1}) - \sigma_{a}(R_{2})
$$<p><strong>Altro con insiemi</strong>
<img src="/images/notes/Algebra Relazionale-1697203550926.jpeg" style="width: 100%" class="center" alt="Algebra Relazionale-1697203550926">
Possiamo notare che operano proprio come se fossero dei set, nel senso unione per or, intersezione per and, e anche intersezione col contrario con il meno.</p>
<h4 id="sintassi-e-semantica--">Sintassi e semantica  🟩<a hidden class="anchor" aria-hidden="true" href="#sintassi-e-semantica--">#</a></h4>
$$
\sigma_{predicate}(Relation)
$$<p>
<strong>Semantica:</strong> un insieme che soddisfa le <a href="/notes#proprietà-della-selection">#Proprietà della selection</a></p>
<h3 id="projection">Projection<a hidden class="anchor" aria-hidden="true" href="#projection">#</a></h3>
<p>Anche questo è un <strong>unary operator</strong>.</p>
<h4 id="semantica-e-sintassi-">Semantica e sintassi 🟩<a hidden class="anchor" aria-hidden="true" href="#semantica-e-sintassi-">#</a></h4>
$$
\pi_{attribute}(Relation)
$$<p><strong>Semantica:</strong> viene ritornato un insieme con numero tuple della relazione iniziale (o minore per ripetizioni), ma <em>solo con gli attributi di riferimento</em>.</p>
$$
\pi_{Y}(r) = \left\{ t[Y] | t \in r \right\} 
$$<p>
Ossia prendo i valori della tupla che corrispondono a quegli attributi, per ogni singola tupla presente in relazione</p>
<h4 id="caso-ripetizioni-">Caso ripetizioni 🟩<a hidden class="anchor" aria-hidden="true" href="#caso-ripetizioni-">#</a></h4>
<p>Questa è una cosa da notare, a differenza di <a href="/notes/structured-query-language">Structured Query Language</a> le cose ripetute vengono scartate, si ha <strong>unico</strong>, in questo caso, perché qui siamo nel reame degli insiemi</p>
<h4 id="proprietà-di-proiezioni-">Proprietà di proiezioni 🟩<a hidden class="anchor" aria-hidden="true" href="#proprietà-di-proiezioni-">#</a></h4>
$$
\pi_{x}(R) = \pi_{x}(\pi_{xy}(R))
$$<p>
Se lo applico più volte (anche con cose leggermente diverse rimane uguale)</p>
$$
\pi_{x}(R_{1} \cup R_{2}) = \pi_{x}(R_{1}) \cup \pi_{x}(R_{2})
$$<h3 id="join">Join<a hidden class="anchor" aria-hidden="true" href="#join">#</a></h3>
<p>La join è necessaria nel caso vogliamo <strong>creare correlazione</strong> fra tuple presenti in relazioni diverse fra di loro, mentre con <a href="/notes#projection">#Projection</a> e <a href="/notes#selection">#Selection</a> possiamo farlo solamente sulla prima.</p>
<h4 id="full-and-empty-joins-">Full and empty joins 🟩<a hidden class="anchor" aria-hidden="true" href="#full-and-empty-joins-">#</a></h4>
<ul>
<li>Full -&gt; Every tuple is used (not full is some is used)</li>
<li>Empty -&gt; with no outputs</li>
</ul>
<p>Questo è direttamente dipendente da <strong>quali chiavi abbiamo usato</strong> durante la join
!<a href="/notes/algebra-relazionale-1697201413808.jpeg-"> 500</a></p>
<h4 id="types-of-joins-2--">Types of Joins (2) 🟩-<a hidden class="anchor" aria-hidden="true" href="#types-of-joins-2--">#</a></h4>
$$
R_{1} \bowtie R_{2} = \left\{ t \text{ on } X_{1} \cup X_{2} | \exists t_{1} \in R_{1} \text{ and } \exists t_{2} \in R_{2} \text{ with } t[X_{1}] = t_{1} \text{ and } t[X_{2}] = t_{2}\right\} 
$$<p>
Ossia data una tupla nella nuova relazione così creata, se prendo i attributi appartenenti alla prima relazione avrò che esiste effettivamente uguale per il secondo.</p>
<p><strong>Outer joins</strong>:
Che sono le stesse spiegate in <a href="/notes/structured-query-language">Structured Query Language</a>, ossia andiamo a considerare <strong>left, right and full</strong>
$A ⟕ B, A ⟖B , A⟗B$, sono i simboli utilizzati, ma userò sempre $\bowtie$ con pedice l, r, f per indicarne il tipo,  per semplicità di notazione.</p>
<p>La semantica di questi è la stessa per <a href="/notes/structured-query-language">SQL</a>, la descriviamo prevemente, sarà left outer, nel caso in cui ho la garanzia che solamente le tuple della relazione 1 ci sarà, contrario per right, per il full outer, ho la garanzia che una data tupla finale, sarà presente in almeno uno dei due iniziali, ma non so quale.</p>
<h4 id="proprietà--2-">Proprietà  (2) 🟩<a hidden class="anchor" aria-hidden="true" href="#proprietà--2-">#</a></h4>
<p><strong>Push selection</strong>
!<a href="/notes/algebra-relazionale-1697203223889.jpeg-"> 500</a></p>
$$
R \bowtie(R_{1} \cup R_{2}) = (R \bowtie R_{1}) \cup(R\bowtie R_{2})
$$<h4 id="theta-join--">Theta Join 🟩-<a hidden class="anchor" aria-hidden="true" href="#theta-join--">#</a></h4>
<p>Il theta join viene motivato grazie al fatto che solitamente bisogna sempre rinominare prima di fare una selection, o bisogna fare sempre selection, per questo motivo.
Solo che questo è possibile fare solo se sono una <a href="/notes#cartesian-product">#Cartesian product</a>, ossia non abbiano attributi in comune.</p>
<p>La sintassi ammessa nella condizione sono solamente <em>and</em> e relazioni booleane binarie (minore, maggiore, uguale e combinazione fra questi).
Altra cosa necesssaria per la theta join, è che <strong>non ci siano attributi in comune</strong> fra le due relazioni.</p>
<p>E si può notare sulle slides che questo è molto simile alla <strong>natural join</strong> <em>dopo renaming</em> espresso in <a href="/notes#types-of-joins-(2">#Types of Joins (2)</a>) in precedenza.</p>
<h4 id="equi-join-">Equi Join 🟩<a hidden class="anchor" aria-hidden="true" href="#equi-join-">#</a></h4>
<p>Quello più interessante sono le <strong>equi-join</strong> che accade quando ho relazioni di equivalenza, questo si manifesta solamente quando la theta join di sopra è fatta da <strong>atomi di uguaglianza</strong>, questo mi dovrebbe garantire per certo tale proprietà.</p>
<h3 id="cartesian-product">Cartesian product<a hidden class="anchor" aria-hidden="true" href="#cartesian-product">#</a></h3>
<p>Si può considerare come una <strong>join naturale</strong> su relazioni senza attributi in comune (quindi tutto si può combinare con tutto!).</p>
<h2 id="views">Views<a hidden class="anchor" aria-hidden="true" href="#views">#</a></h2>
<h3 id="introduzione-alle-data-views--">Introduzione alle data-views 🟩-<a hidden class="anchor" aria-hidden="true" href="#introduzione-alle-data-views--">#</a></h3>
<p>Sono delle <strong>rappresentazioni diverse dello stesso genere di data</strong>, solitamente utili per fare view diverse (e.g. dipartimento altro avrà necessità diverse), abbiamo accennato a questa necessità durante la nostra <a href="/notes/introduction-to-databases">Introduction to databases</a>.
<img src="/images/notes/Algebra Relazionale-1697203991206.jpeg" width="500" class="center" alt="Algebra Relazionale-1697203991206"/></p>
<p>Nel caso preciso di SQL ne andiamo a parlare in <a href="/notes/advanced-sql">Advanced SQL</a>.</p>
<p>Nel caso di algebra relazionale, è soltanto una specie di <strong>dichiarazione di variabile</strong> con un altro nome, che specifica quale è il risultato della sua query.</p>
<h3 id="view-utilization">View utilization<a hidden class="anchor" aria-hidden="true" href="#view-utilization">#</a></h3>
<p>Questa è una cosa classica in informatica, il concetto di astrazione implementazione presente come descritto in <a href="/notes/astrazione-sul-controllo#significato-di-astrazione">Astrazione sul controllo#Significato di astrazione</a>
E dividere in questo modo quello che è effettivamente memorizzato da quello che l&rsquo;utente deve volere vedere.</p>
<h4 id="materialized-views---">Materialized views 🟩&ndash;<a hidden class="anchor" aria-hidden="true" href="#materialized-views---">#</a></h4>
<p>La differenza con l&rsquo;altra tipologia di view che viene proposta è che questa view è <strong>storata fisicamente</strong> sui dispositivi di memorizzazione.</p>
<p>Pros:</p>
<ol>
<li>Veloce da leggere (non da creare ogni volta)</li>
</ol>
<p>Cons:</p>
<ol>
<li>Ridondanza dei dati</li>
<li>update deve essere doppio (problemi di coerenza)</li>
<li>Non supportati dai DBMS.</li>
</ol>
<h4 id="virtual-views-">Virtual views 🟨<a hidden class="anchor" aria-hidden="true" href="#virtual-views-">#</a></h4>
<p>Al fine di creare la view viene fatto una <strong>query sul database</strong>. Non so esattamente se questi possono essere fatti sempre o meno.</p>
<h3 id="view-update-">View update 🟩<a hidden class="anchor" aria-hidden="true" href="#view-update-">#</a></h3>
<p>Nel caso di sql possiamo andare a definire due valori <em>local</em> o <em>cascade</em>, con il primo la view non aggiorna le tabelle effettivamente presenti, mentre con cascade sì. Ma credo non si possa sempre fare e bisogna sempre stare leggermente attenti.</p>
<h4 id="some-notes-on-update-difficulties">Some notes on update difficulties<a hidden class="anchor" aria-hidden="true" href="#some-notes-on-update-difficulties">#</a></h4>
<p>È molto più difficile updatare la view, perché questo update deve essere coerente con la versione originale che era esistente!
Per questo motivo non tutti gli update sono disponibili per update.</p>
<h2 id="relational-calculi-">Relational calculi 🟥<a hidden class="anchor" aria-hidden="true" href="#relational-calculi-">#</a></h2>
<p>Si differenzia leggermente dall&rsquo;al</p>
<h3 id="introduction-to-relational-calculi">Introduction to relational calculi<a hidden class="anchor" aria-hidden="true" href="#introduction-to-relational-calculi">#</a></h3>
<p>Alla fine si basano tutti su <a href="/notes/logica-del-primo-ordine">Logica del Primo ordine</a>, Questo è sempre un modo per modellare le relazioni che sono molto comuni nei casi che abbiamo trovato di relational databases, ma invece di utilizzare algebra utilizzano una <strong>logica</strong>, descritta sotto.</p>
<p>Questo è molto più vicino all&rsquo;approccio logico, sviluppato durante gli anni 70-80 con knowledge bases in AI.</p>
<h4 id="general-form-">General form 🟨+<a hidden class="anchor" aria-hidden="true" href="#general-form-">#</a></h4>
$$
 \left\{ A_{1}: x_{1}, \dots A_{k} : x_{k} | f \right\} 
$$<p>In cui abbiamo</p>
<ul>
<li>$f$ che è una formula che probabilmente da un booleano per decidere se prenderlo o meno.</li>
<li>$A_{i}$ che sono degli attributi</li>
<li>$x_{i}$ che sono delle variabili
Avremo come output una tupla di $(x_{1}, \dots x_{n})$ che soddisfano $f$</li>
</ul>
<p><strong>Esempi:</strong>
<img src="/images/notes/Relational calculi-1697206768057.jpeg" width="500" class="center" alt="Relational calculi-1697206768057"/></p>
<p>Esistono forme anche leggermente più complicate, ma dobbiamo introdurre gli esistenziali:
<img src="/images/notes/Relational calculi-1697206819394.jpeg" width="500" class="center" alt="Relational calculi-1697206819394"/></p>
<p>Esistono anche i <a href="/notes/logica-del-primo-ordine#10.7.4-de-morgan"> de morgan rules </a> che si possono applicare, perché in pratica è logica.</p>
<h3 id="relational-calculi-considerations">Relational calculi, considerations<a hidden class="anchor" aria-hidden="true" href="#relational-calculi-considerations">#</a></h3>
<h4 id="aspetti-negativi-2-">Aspetti negativi (2) 🟨<a hidden class="anchor" aria-hidden="true" href="#aspetti-negativi-2-">#</a></h4>
<ul>
<li>Moltissime variabili inutili (troppo verboso scriverci).</li>
<li>Presenza di espressioni senza senso e <strong>dipendenti dal dominio</strong> questo significa che se cambiamo il dominio di definizione cambiamo anche i valori che sono possibilmente denotati (non ho capito perché questa dovrebbe essere una caratteristica negativa poi).</li>
</ul>
<p>Per risolvere il primo problema si aggiunge una sintassi più compatta, presentata come &ldquo;range declaration syntax&rdquo; (ma non è espressivo quanto algebra, in qualche modo si dimostra)&hellip;</p>
<h4 id="range-declaration-syntax-">Range declaration syntax 🟨<a hidden class="anchor" aria-hidden="true" href="#range-declaration-syntax-">#</a></h4>
<img src="/images/notes/Relational Algebra-1697207297421.jpeg" style="width: 100%" class="center" alt="Relational Algebra-1697207297421">
Pagina 78 del libro ne parla meglio, dovrei approfondire quello.
#### Indipendenza da dominio 🟨
$$
A_{1} : x_{1} | not R(A_{1} : x_{1})
$$<p>
È dipendente dal dominio, perché prende l&rsquo;insieme degli elementi nel dominio, tali che non sono presenti nella relazione.
Abbiamo bisogno di questa proprietà perché se è dipendente dal dominio si potrebbero produrre risultati enormi, che rendono l&rsquo;applicazione pratica nulla.</p>
<h4 id="equivalenza-con-algebra-relazionale-">Equivalenza con Algebra relazionale 🟩<a hidden class="anchor" aria-hidden="true" href="#equivalenza-con-algebra-relazionale-">#</a></h4>
<p>Si può dimostrare che se ci limitiamo alle espressioni indipendenti col dominio, i due modelli sono esattamente uguali, ossia possiamo dire che possiamo creare una espressione di algebra, partendo da calcolo, e viceversa.</p>
<p>La dimostrazione (che non facciamo) andrà per induzione strutturale, quella che trovi in Logica in <a href="/notes/deduzione-naturale">Deduzione naturale</a>.</p>
<p>Possiamo notare che l&rsquo;algebra è indipendente dal dominio, perché lì non è mai esplicitata la relazione in che dominio sia (abbiamo operazioni chiuse si può dire).</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/basi-di-dati/">📙Basi-Di-Dati</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Relational Algebra on x"
            href="https://x.com/intent/tweet/?text=Relational%20Algebra&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2frelational-algebra%2f&amp;hashtags=%f0%9f%93%99basi-di-dati">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Relational Algebra on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2frelational-algebra%2f&amp;title=Relational%20Algebra&amp;summary=Relational%20Algebra&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2frelational-algebra%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Relational Algebra on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2frelational-algebra%2f&title=Relational%20Algebra">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Relational Algebra on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2frelational-algebra%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Relational Algebra on whatsapp"
            href="https://api.whatsapp.com/send?text=Relational%20Algebra%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2frelational-algebra%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Relational Algebra on telegram"
            href="https://telegram.me/share/url?text=Relational%20Algebra&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2frelational-algebra%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Relational Algebra on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Relational%20Algebra&u=https%3a%2f%2fflecart.github.io%2fnotes%2frelational-algebra%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
