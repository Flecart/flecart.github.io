<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Document Stores | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="üììbig-data">
<meta name="description" content="p&gt; Document stores provide a native database management system for semi-structured data. Document stores also scale to Gigabytes or Terabytes of data, and typically millions or billions of records (a record being a JSON object or an XML document).
Introduction to Document Stores

A document store, unlike a data lake, manages the data directly and the users do not see the physical layout.
Unlike data lakes, using document stores prevent us from breaking data independence and reading the data file directly: it offers an automatic manager service for semi-structured data that we need to throw and read quickly.">
<meta name="author" content="
By Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="https://flecart.github.io/notes/document-stores/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f790d9af969c56c079c1ce2d5972a04486bf3d6144295d5fba319830e1e55a7a.css" integrity="sha256-95DZr5acVsB5wc4tWXKgRIa/PWFEKV1fujGYMOHlWno=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/document-stores/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>
<script type="text/javascript" async
src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>






      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-WW6NN2QGKF');
        }
      </script><meta property="og:url" content="https://flecart.github.io/notes/document-stores/">
  <meta property="og:site_name" content="X. Angelo Huang&#39;s Blog">
  <meta property="og:title" content="Document Stores">
  <meta property="og:description" content="p&gt; Document stores provide a native database management system for semi-structured data. Document stores also scale to Gigabytes or Terabytes of data, and typically millions or billions of records (a record being a JSON object or an XML document).
Introduction to Document Stores A document store, unlike a data lake, manages the data directly and the users do not see the physical layout.
Unlike data lakes, using document stores prevent us from breaking data independence and reading the data file directly: it offers an automatic manager service for semi-structured data that we need to throw and read quickly.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="notes">
    <meta property="article:tag" content="üììBig-Data">
      <meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:title" content="Document Stores">
<meta name="twitter:description" content="p&gt; Document stores provide a native database management system for semi-structured data. Document stores also scale to Gigabytes or Terabytes of data, and typically millions or billions of records (a record being a JSON object or an XML document).
Introduction to Document Stores

A document store, unlike a data lake, manages the data directly and the users do not see the physical layout.
Unlike data lakes, using document stores prevent us from breaking data independence and reading the data file directly: it offers an automatic manager service for semi-structured data that we need to throw and read quickly.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Document Stores",
      "item": "https://flecart.github.io/notes/document-stores/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Document Stores",
  "name": "Document Stores",
  "description": "p\u0026gt; Document stores provide a native database management system for semi-structured data. Document stores also scale to Gigabytes or Terabytes of data, and typically millions or billions of records (a record being a JSON object or an XML document).\nIntroduction to Document Stores A document store, unlike a data lake, manages the data directly and the users do not see the physical layout.\nUnlike data lakes, using document stores prevent us from breaking data independence and reading the data file directly: it offers an automatic manager service for semi-structured data that we need to throw and read quickly.\n",
  "keywords": [
    "üììbig-data"
  ],
  "articleBody": "p\u003e Document stores provide a native database management system for semi-structured data. Document stores also scale to Gigabytes or Terabytes of data, and typically millions or billions of records (a record being a JSON object or an XML document).\nIntroduction to Document Stores A document store, unlike a data lake, manages the data directly and the users do not see the physical layout.\nUnlike data lakes, using document stores prevent us from breaking data independence and reading the data file directly: it offers an automatic manager service for semi-structured data that we need to throw and read quickly.\nIn this case, we would like an efficient manner to store documents, as original relational databases did, while offering a relaxed version of the integrity properties.\nThe documents in a document store are organized into collections. Each collection can have millions or billions of documents, while each single document weighs no more than 16 MB. Collections need not to have a schema, but could.\nOn the need of an unstructured document manager In some cases, it is quite easy to convert a tree given in XML or JSON format into a structured format. The problems comes when we have nestedness. For these kind of documents, sometimes is possible to insert them using different tables. Sometimes is possible to insert into relational databases heterogeneous data too. But we need to insert a lot of NULL to make up for the heterogeneity. This creates the kind of impendance mismatch, the difference between the format of data we would like to have, between what we actually store, that adds up a load. In this context, document stores like MongoDB comes naturally into play.\nSize of the documents a collection can have millions or billions of documents, while each single document weighs no more than 16 MB\nThis is why document stores can scale up to Gigabytes or terabytes of data. Somewhat similar to HDFS, where each block size had maximum of 128 megabytes. The size limit, is quite close to the limit set by Wide Column Storage of 10 MB.\nEnforcing Schemas Document stores leverage the so called schema on read pattern: the schema is enforced when the data is read, not when it is written. This is a relaxed, more flexible, version of the schema on write pattern, that is used in relational databases. In document stores, the schema is often discovered.\noffer query functionality to find out which keys appear in the data, what kind of value is associated with each key, etc; or even functionality that directly infers a schema\nMongoDB MongoDB is one of the most famous document storage engines. This database management system is more comparable to standard database management systems where ETL is the standard, instead of read from file paradigms like Hadoop or Spark.\nThe Architecture Replication If we store petabytes of data, replication is a necessary feature. In MongoDB the collections are partitioned into shards, and each partition has a Replica Set. Each replica set has a primary server and a set of secondary servers. The primary server is the one that accepts write operations, while the secondary servers replicate the data from the primary server. Usually a MongoDBcluster has not many machines.\nWhen writing to the primary servery, a simple optimization is the following: clients may wait only for a certain number of acknowledgements by the second server. Then the other replicas can continue asynchronously. This is for making it faster for the user. This is somewhat similar to the $R$ parameter in Dynamo Cloud Storage#Key-value stores.\nThe main difference with systems like HDFS is that here we have a series of nodes with exactly the same data, while in HDFS, it is quite improbable, as the blocks are replicated independently.\nPhysical Storage Documents in MongoDB are usually stored in BSON format, an equivalent method to JSON (see Markup) but in binary format as it is usually more efficient.\nIndices While Spark would look at all the data in parallel to find a single point data for a certain query, the main advantage with ETL (so MongoDBs) is by having the possibility of creating indexes. With indexes we can look data quite faster. We have studied something similar for relational database in Index, B-trees and hashes\nTypes of indices There are mainly two types of indices, hash and B-trees. , both have been extensively studied in this node Index, B-trees and hashes, and it‚Äôs exactly the same.\nDrawbacks of hash indices\nCannot answer for range queries. Space requirement for collisions. The upside is that this indices are quite fast. If no collisions then it is $\\mathcal{O}(1)$ While B-trees are slower, they can answer range queries. The complexity is $\\mathcal{O}(\\log_{n}(N))$ where $n$ is the branching factor.\nDefault indices MongoDB creates by default a hash indice for the primary key _id.\nBenefiting queries Certain queries can benefit quite more by having indices:\nPoint queries (hash makes this quite fast, while trees make this logarithmic). Range queries Creating an Index If we want a tree index\ndb.collection.createIndex({\"field\": 1}) Else:\ndb.collection.createIndex({\"field\": \"hash\"}) Post-filtering If we have a query with some keys that have an index, others that do not have an index MongoDB will first look for the indexed keys, and then post-filter the rest of the keys, making the query faster anyways. Under the hood, it creates many plans, estimates the cost of every plan and then executes one.\nThis is particularly needed for indexes that have more than one index. It is important to remember how the indexes are made!\nOperations Similarly to HTML APIs, MongoDB offers CRUD operations. It is important to know the syntax of these operations.\nRead operations For example:\ndb.collection.find({ \"field\": \"value\", $or: [ {\"field2\": \"value2\"}, {\"field3\": \"value3\"} ], \"field4\": {$gte: 10}, \"field5.subfield\": \"value4\" }).project({field: 1}).sort({\"field\": 1}).skip(10).limit(10) We filter the collection by the field value, and we project only the field we are interested in. Having AND conjunctions is easy, just put in the object. Fields that start with ‚Äú$‚Äù are treated by MongoDB differently. And can encode different operations. Other dollar operations are\n$or, $in, $nin $gte $lt And similar.\nThe Above proejction operator just works for cursors, in our case, the projection is often found inside the find function, as a second argument.\nWe can index into arrays and objects using dot notation inside the find query.\nTo query nested structures we need to use the dot syntax. If we don‚Äôt do it that way and add a dictionary in the place of value4 instead, it will match exactly the dictionary.\nAggregate queries Aggregation query\ndb.collection.aggregate([ {$match: {\"field\": \"value\"}}, {$group: {_id: \"$field\", \"count\": {$sum: 1}}}, {$sort: {\"count\": -1}}, {$limit: 10} ]) Which is very similar to a Spark RDD pipeline.\nInsertion, Update and Delete Insertion is quite straighforward: insertOne:\ndb.collection.insertOne({\"field\": \"value\"}) insertMany:\ndb.collection.insertMany([{\"field\": \"value\"}, {\"field\": \"value2\"}]) There are the same equivalent for update and delete operations.\nThen we attempt to create indices for the most common query searches. It often depends on the query code and the website traffic (if it‚Äôs a database for a website). But you don‚Äôt have advantage if you can‚Äôt fit the indices in the random access memory. Another disadvantage is a slower update: we need to update the index for every update on the table. Just 2ms for a single lookup! Which is much faster than HDFS and Spark.\n",
  "wordCount" : "1222",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/document-stores/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;¬ª&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Document Stores
    </h1>
    <div class="post-meta">Reading Time: 6 minutes&nbsp;¬∑&nbsp;
By Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul><ul>
                <li>
                    <a href="#introduction-to-document-stores" aria-label="Introduction to Document Stores">Introduction to Document Stores</a><ul>
                        
                <li>
                    <a href="#on-the-need-of-an-unstructured-document-manager" aria-label="On the need of an unstructured document manager">On the need of an unstructured document manager</a></li>
                <li>
                    <a href="#size-of-the-documents" aria-label="Size of the documents">Size of the documents</a></li>
                <li>
                    <a href="#enforcing-schemas" aria-label="Enforcing Schemas">Enforcing Schemas</a></li></ul>
                </li></ul>
                    
                <li>
                    <a href="#mongodb" aria-label="MongoDB">MongoDB</a><ul>
                        
                <li>
                    <a href="#the-architecture" aria-label="The Architecture">The Architecture</a><ul>
                        
                <li>
                    <a href="#replication" aria-label="Replication">Replication</a></li>
                <li>
                    <a href="#physical-storage" aria-label="Physical Storage">Physical Storage</a></li></ul>
                </li>
                <li>
                    <a href="#indices" aria-label="Indices">Indices</a><ul>
                        
                <li>
                    <a href="#types-of-indices" aria-label="Types of indices">Types of indices</a></li>
                <li>
                    <a href="#default-indices" aria-label="Default indices">Default indices</a></li>
                <li>
                    <a href="#benefiting-queries" aria-label="Benefiting queries">Benefiting queries</a></li>
                <li>
                    <a href="#creating-an-index" aria-label="Creating an Index">Creating an Index</a></li>
                <li>
                    <a href="#post-filtering" aria-label="Post-filtering">Post-filtering</a></li></ul>
                </li>
                <li>
                    <a href="#operations" aria-label="Operations">Operations</a><ul>
                        
                <li>
                    <a href="#read-operations" aria-label="Read operations">Read operations</a></li>
                <li>
                    <a href="#aggregate-queries" aria-label="Aggregate queries">Aggregate queries</a></li>
                <li>
                    <a href="#insertion-update-and-delete" aria-label="Insertion, Update and Delete">Insertion, Update and Delete</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>p&gt; Document stores provide a native database management system for <strong>semi-structured</strong> data. Document stores also scale to Gigabytes or Terabytes of data, and typically millions or billions of records (a record being a JSON object or an XML document).</p>
<h3 id="introduction-to-document-stores">Introduction to Document Stores<a hidden class="anchor" aria-hidden="true" href="#introduction-to-document-stores">#</a></h3>
<blockquote>
<p>A document store, unlike a data lake, manages the data <em>directly</em> and the users do not see the physical layout.</p></blockquote>
<p>Unlike data lakes, using document stores prevent us from breaking data independence and reading the data file directly: it offers an automatic manager service for <strong>semi-structured</strong> data that we need to throw and read quickly.</p>
<p>In this case, we would like an <em>efficient</em> manner to store documents, as original relational databases did, while offering a relaxed version of the <em>integrity</em> properties.</p>
<p>The documents in a document store are organized into <strong>collections</strong>. Each collection can have millions or billions of documents, while each single document weighs no more than 16 MB.
Collections need not to have a schema, but could.</p>
<h4 id="on-the-need-of-an-unstructured-document-manager">On the need of an unstructured document manager<a hidden class="anchor" aria-hidden="true" href="#on-the-need-of-an-unstructured-document-manager">#</a></h4>
<p>In some cases, it is quite easy to convert a tree given in XML or JSON format into a structured format. The problems comes when we have <em>nestedness</em>. For these kind of documents, sometimes is possible to insert them using different tables.
Sometimes is possible to insert into relational databases heterogeneous data too. But we need to insert a lot of NULL to make up for the heterogeneity.
This creates the kind of <strong>impendance mismatch</strong>, the difference between the format of data we would like to have, between what we actually store, that adds up a load.
In this context, document stores like MongoDB comes naturally into play.</p>
<h4 id="size-of-the-documents">Size of the documents<a hidden class="anchor" aria-hidden="true" href="#size-of-the-documents">#</a></h4>
<blockquote>
<p>a collection can have millions or billions of documents, while each single document weighs no more than 16 MB</p></blockquote>
<p>This is why document stores can scale up to Gigabytes or terabytes of data.
Somewhat similar to HDFS, where each block size had maximum of 128 megabytes.
The size limit, is quite close to the limit set by <a href="/notes/wide-column-storage">Wide Column Storage</a> of 10 MB.</p>
<h4 id="enforcing-schemas">Enforcing Schemas<a hidden class="anchor" aria-hidden="true" href="#enforcing-schemas">#</a></h4>
<p>Document stores leverage the so called <strong>schema on read pattern</strong>: the schema is enforced when the data is read, not when it is written. This is a relaxed, more flexible, version of the schema on write pattern, that is used in relational databases.
In document stores, the schema is often <strong>discovered</strong>.</p>
<blockquote>
<p>offer query functionality to find out which keys appear in the data, what kind of value is associated with each key, etc; or even functionality that directly infers a schema</p></blockquote>
<h2 id="mongodb">MongoDB<a hidden class="anchor" aria-hidden="true" href="#mongodb">#</a></h2>
<p>MongoDB is one of the most famous document storage engines. This database management system is more comparable to standard database management systems where ETL is the standard, instead of read from file paradigms like Hadoop or Spark.</p>
<h3 id="the-architecture">The Architecture<a hidden class="anchor" aria-hidden="true" href="#the-architecture">#</a></h3>
<h4 id="replication">Replication<a hidden class="anchor" aria-hidden="true" href="#replication">#</a></h4>
<p>If we store petabytes of data, replication is a necessary feature.
In MongoDB the collections are partitioned into <strong>shards</strong>, and each partition has a <strong>Replica Set</strong>.
Each replica set has a primary server and a set of secondary servers. The primary server is the one that accepts write operations, while the secondary servers replicate the data from the primary server. Usually a MongoDBcluster has not many machines.</p>
<p>When writing to the primary servery, a simple optimization is the following: clients may wait only for a <em>certain</em> number of acknowledgements by the second server. Then the other replicas can continue asynchronously. This is for making it faster for the user. This is somewhat similar to the $R$ parameter in Dynamo <a href="/notes/cloud-storage#key-value-stores">Cloud Storage#Key-value stores</a>.</p>
<p>The main difference with systems like <a href="/notes/distributed-file-systems">HDFS</a> is that here we have a series of nodes with exactly the same data, while in HDFS, it is quite improbable, as the blocks are replicated independently.</p>
<h4 id="physical-storage">Physical Storage<a hidden class="anchor" aria-hidden="true" href="#physical-storage">#</a></h4>
<p>Documents in MongoDB are usually stored in BSON format, an equivalent method to JSON (see <a href="/notes/markup">Markup</a>) but in <strong>binary</strong> format as it is usually more <em>efficient</em>.</p>
<h3 id="indices">Indices<a hidden class="anchor" aria-hidden="true" href="#indices">#</a></h3>
<p>While <a href="/notes/massive-parallel-processing">Spark</a> would look at all the data in parallel to find a single point data for a certain query, the main advantage with ETL (so MongoDBs) is by having the possibility of creating <strong>indexes</strong>. With indexes we can look data quite faster. We have studied something similar for relational database in <a href="/notes/index,-b-trees-and-hashes">Index, B-trees and hashes</a></p>
<h4 id="types-of-indices">Types of indices<a hidden class="anchor" aria-hidden="true" href="#types-of-indices">#</a></h4>
<p>There are mainly two types of indices, hash and B-trees. , both have been extensively studied in this node <a href="/notes/index,-b-trees-and-hashes">Index, B-trees and hashes</a>, and it&rsquo;s exactly the same.</p>
<p>Drawbacks of hash indices</p>
<ol>
<li>Cannot answer for range queries.</li>
<li>Space requirement for collisions.
The upside is that this indices are quite fast. If no collisions then it is $\mathcal{O}(1)$</li>
</ol>
<p>While B-trees are slower, they can answer range queries. The complexity is $\mathcal{O}(\log_{n}(N))$ where $n$ is the branching factor.</p>
<h4 id="default-indices">Default indices<a hidden class="anchor" aria-hidden="true" href="#default-indices">#</a></h4>
<p>MongoDB creates by default a hash indice for the primary key <code>_id</code>.</p>
<h4 id="benefiting-queries">Benefiting queries<a hidden class="anchor" aria-hidden="true" href="#benefiting-queries">#</a></h4>
<p>Certain queries can benefit quite more by having indices:</p>
<ol>
<li>Point queries (hash makes this quite fast, while trees make this logarithmic).</li>
<li>Range queries</li>
</ol>
<h4 id="creating-an-index">Creating an Index<a hidden class="anchor" aria-hidden="true" href="#creating-an-index">#</a></h4>
<p>If we want a tree index</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="err">db.collection.createIndex(</span><span class="p">{</span><span class="nt">&#34;field&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span><span class="err">)</span>
</span></span></code></pre></div><p>Else:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="err">db.collection.createIndex(</span><span class="p">{</span><span class="nt">&#34;field&#34;</span><span class="p">:</span> <span class="s2">&#34;hash&#34;</span><span class="p">}</span><span class="err">)</span>
</span></span></code></pre></div><h4 id="post-filtering">Post-filtering<a hidden class="anchor" aria-hidden="true" href="#post-filtering">#</a></h4>
<p>If we have a query with some keys that have an index, others that do not have an index MongoDB will first look for the indexed keys, and then post-filter the rest of the keys, making the query faster anyways.
Under the hood, it creates many plans, estimates the cost of every plan and then executes one.</p>
<p>This is particularly needed for indexes that have more than one index. It is important to remember how the indexes are made!</p>
<h3 id="operations">Operations<a hidden class="anchor" aria-hidden="true" href="#operations">#</a></h3>
<p>Similarly to HTML APIs, MongoDB offers CRUD operations.
It is important to know the syntax of these operations.</p>
<h4 id="read-operations">Read operations<a hidden class="anchor" aria-hidden="true" href="#read-operations">#</a></h4>
<p>For example:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="err">db.collection.find(</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&#34;field&#34;</span><span class="p">:</span> <span class="s2">&#34;value&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="err">$or:</span> <span class="err">[</span>
</span></span><span class="line"><span class="cl">	    <span class="err">{</span><span class="nt">&#34;field2&#34;</span><span class="p">:</span> <span class="s2">&#34;value2&#34;</span><span class="p">}</span><span class="err">,</span>
</span></span><span class="line"><span class="cl">	    <span class="p">{</span><span class="nt">&#34;field3&#34;</span><span class="p">:</span> <span class="s2">&#34;value3&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="err">],</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;field4&#34;</span><span class="err">:</span> <span class="p">{</span><span class="err">$gte:</span> <span class="err">10</span><span class="p">}</span><span class="err">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;field5.subfield&#34;</span><span class="err">:</span> <span class="s2">&#34;value4&#34;</span>
</span></span><span class="line"><span class="cl"><span class="err">}).project(</span><span class="p">{</span><span class="err">field:</span> <span class="err">1</span><span class="p">}</span><span class="err">).sort(</span><span class="p">{</span><span class="nt">&#34;field&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span><span class="err">).skip(</span><span class="mi">10</span><span class="err">).limit(</span><span class="mi">10</span><span class="err">)</span>
</span></span></code></pre></div><p>We filter the collection by the field value, and we project only the field we are interested in.
Having <em>AND</em> conjunctions is easy, just put in the object. Fields that start with &ldquo;$&rdquo; are treated by MongoDB differently. And can encode different operations. Other dollar operations are</p>
<ul>
<li>$or, $in, $nin</li>
<li>$gte</li>
<li>$lt</li>
<li></li>
</ul>
<p>And similar.</p>
<p>The Above proejction operator just works for cursors, in our case, the projection is often found inside the find function, as a second argument.</p>
<p>We can index into arrays and objects using dot notation inside the find query.</p>
<p>To query nested structures we need to use the dot syntax. If we don&rsquo;t do it that way and add a dictionary in the place of value4 instead, it will match exactly the dictionary.</p>
<h4 id="aggregate-queries">Aggregate queries<a hidden class="anchor" aria-hidden="true" href="#aggregate-queries">#</a></h4>
<p>Aggregation query</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="err">db.collection.aggregate(</span><span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span><span class="err">$match:</span> <span class="err">{</span><span class="nt">&#34;field&#34;</span><span class="p">:</span> <span class="s2">&#34;value&#34;</span><span class="p">}</span><span class="err">}</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span><span class="err">$group:</span> <span class="err">{_id:</span> <span class="nt">&#34;$field&#34;</span><span class="p">,</span> <span class="nt">&#34;count&#34;</span><span class="p">:</span> <span class="p">{</span><span class="err">$sum:</span> <span class="err">1</span><span class="p">}}</span><span class="err">}</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span><span class="err">$sort:</span> <span class="err">{</span><span class="nt">&#34;count&#34;</span><span class="p">:</span> <span class="mi">-1</span><span class="p">}</span><span class="err">}</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span><span class="err">$limit:</span> <span class="err">10</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span><span class="err">)</span>
</span></span></code></pre></div><p>Which is very similar to a Spark RDD pipeline.</p>
<h4 id="insertion-update-and-delete">Insertion, Update and Delete<a hidden class="anchor" aria-hidden="true" href="#insertion-update-and-delete">#</a></h4>
<p>Insertion is quite straighforward:
insertOne:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="err">db.collection.insertOne(</span><span class="p">{</span><span class="nt">&#34;field&#34;</span><span class="p">:</span> <span class="s2">&#34;value&#34;</span><span class="p">}</span><span class="err">)</span>
</span></span></code></pre></div><p>insertMany:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="err">db.collection.insertMany(</span><span class="p">[{</span><span class="nt">&#34;field&#34;</span><span class="p">:</span> <span class="s2">&#34;value&#34;</span><span class="p">},</span> <span class="p">{</span><span class="nt">&#34;field&#34;</span><span class="p">:</span> <span class="s2">&#34;value2&#34;</span><span class="p">}]</span><span class="err">)</span>
</span></span></code></pre></div><p>There are the same equivalent for update and delete operations.</p>
<p>Then we attempt to create indices for the most common query searches. It often depends on the query code and the website traffic (if it&rsquo;s a database for a website).
But you don&rsquo;t have advantage if you can&rsquo;t fit the indices in the random access memory. Another disadvantage is a slower update: we need to update the index for every update on the table.
Just 2ms for a single lookup! Which is much faster than HDFS and Spark.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/big-data/">üììBig-Data</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Document Stores on x"
            href="https://x.com/intent/tweet/?text=Document%20Stores&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fdocument-stores%2f&amp;hashtags=%f0%9f%93%93big-data">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Document Stores on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fdocument-stores%2f&amp;title=Document%20Stores&amp;summary=Document%20Stores&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2fdocument-stores%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Document Stores on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2fdocument-stores%2f&title=Document%20Stores">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Document Stores on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2fdocument-stores%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Document Stores on whatsapp"
            href="https://api.whatsapp.com/send?text=Document%20Stores%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2fdocument-stores%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Document Stores on telegram"
            href="https://telegram.me/share/url?text=Document%20Stores&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fdocument-stores%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Document Stores on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Document%20Stores&u=https%3a%2f%2fflecart.github.io%2fnotes%2fdocument-stores%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span> ¬∑ 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
