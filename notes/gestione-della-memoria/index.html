<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Gestione della memoria | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="no-tags">
<meta name="description" content="Ripasso Prox: 60 Ripasso: June 1, 2023 Ultima modifica: May 29, 2023 3:34 PM Primo Abbozzo: February 27, 2023 9:07 AM Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ• Studi Personali: No
Elementi di ripasso Gestione della memoria Memoria statica Elementi in memoria statica (4) ðŸŸ©- Variabili globali Istruzioni macchina Costanti (Variabili locali, paramentri e ritorno di funzione?) Le primi tre elementi descritti di sopra sono sicuramente presenti dopo la fase di compilazione, infatti sono allocati dal compilatore in una zona presente nellâ€™eseguibile (un esempio Ã¨ il READONLY per le stringhe in C).">
<meta name="author" content="Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="https://flecart.github.io/notes/gestione-della-memoria/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/gestione-della-memoria/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>


<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-WW6NN2QGKF', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Gestione della memoria" />
<meta property="og:description" content="Ripasso Prox: 60 Ripasso: June 1, 2023 Ultima modifica: May 29, 2023 3:34 PM Primo Abbozzo: February 27, 2023 9:07 AM Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ• Studi Personali: No
Elementi di ripasso Gestione della memoria Memoria statica Elementi in memoria statica (4) ðŸŸ©- Variabili globali Istruzioni macchina Costanti (Variabili locali, paramentri e ritorno di funzione?) Le primi tre elementi descritti di sopra sono sicuramente presenti dopo la fase di compilazione, infatti sono allocati dal compilatore in una zona presente nellâ€™eseguibile (un esempio Ã¨ il READONLY per le stringhe in C)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://flecart.github.io/notes/gestione-della-memoria/" />
<meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png" />
<meta property="article:section" content="notes" />



<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png" />
<meta name="twitter:title" content="Gestione della memoria"/>
<meta name="twitter:description" content="Ripasso Prox: 60 Ripasso: June 1, 2023 Ultima modifica: May 29, 2023 3:34 PM Primo Abbozzo: February 27, 2023 9:07 AM Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ• Studi Personali: No
Elementi di ripasso Gestione della memoria Memoria statica Elementi in memoria statica (4) ðŸŸ©- Variabili globali Istruzioni macchina Costanti (Variabili locali, paramentri e ritorno di funzione?) Le primi tre elementi descritti di sopra sono sicuramente presenti dopo la fase di compilazione, infatti sono allocati dal compilatore in una zona presente nellâ€™eseguibile (un esempio Ã¨ il READONLY per le stringhe in C)."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Gestione della memoria",
      "item": "https://flecart.github.io/notes/gestione-della-memoria/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Gestione della memoria",
  "name": "Gestione della memoria",
  "description": "Ripasso Prox: 60 Ripasso: June 1, 2023 Ultima modifica: May 29, 2023 3:34 PM Primo Abbozzo: February 27, 2023 9:07 AM Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ• Studi Personali: No\nElementi di ripasso Gestione della memoria Memoria statica Elementi in memoria statica (4) ðŸŸ©- Variabili globali Istruzioni macchina Costanti (Variabili locali, paramentri e ritorno di funzione?) Le primi tre elementi descritti di sopra sono sicuramente presenti dopo la fase di compilazione, infatti sono allocati dal compilatore in una zona presente nellâ€™eseguibile (un esempio Ã¨ il READONLY per le stringhe in C).",
  "keywords": [
    "no-tags"
  ],
  "articleBody": "Ripasso Prox: 60 Ripasso: June 1, 2023 Ultima modifica: May 29, 2023 3:34 PM Primo Abbozzo: February 27, 2023 9:07 AM Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ• Studi Personali: No\nElementi di ripasso Gestione della memoria Memoria statica Elementi in memoria statica (4) ðŸŸ©- Variabili globali Istruzioni macchina Costanti (Variabili locali, paramentri e ritorno di funzione?) Le primi tre elementi descritti di sopra sono sicuramente presenti dopo la fase di compilazione, infatti sono allocati dal compilatore in una zona presente nellâ€™eseguibile (un esempio Ã¨ il READONLY per le stringhe in C).\nQuindi se vogliamo\nAvere funzioni ricorsive Potere allocare e deallocare variabili in modo dinamico Abbiamo bisogno di far uso di Pila o Heap, che riescano a cresere e restringersi in modo dinamico.\nImplementazione di funzioni statiche ðŸŸ© Si potrebbe anche utilizzare la memoria statica per implementare le funzioni, ma questo ha il fortissimo drawback che non permette la ricorsione in quanto stiamo assumento che in ogni momento di esecuzione la funzione Ã¨ chiamata una singola volta. (ho un unico indirizzo di memoria per lâ€™indirizzo di ritorno.\nInfatti se chiamassimo in modo ricorsivo questa funzione, perderemmo alcuni valori, come lâ€™indirizzo di ritorno, il valore di ritorno precedente, e porterebbe in uno stato invalido.\nOltre a questo avremmo un elevato uso della memoria nel caso in cui il numero di chiamate di funzioni sia in media minore del numero di dichiarazioni di funzione (avremmo un sacco di funzioni inutilizzate).\nSlide di quanto memorizzato per la funzione statica\nFigura 7.1 Gestione della memoria statica. per le funzioni\nSullâ€™efficienza\nSolitamente se utilizziamo questo metodo il compilatore solitamente Ã¨ in grado di accedere a delle variabili utilizzando un OFFSET senza dover stare a fare risoluzione di nomi simbolici (una volta che abbiamo un frame o RdA, possiamo calcolare la posizione della variabile locale, o parametro attraverso lâ€™offset sul base pointer, che qui Ã¨ anche chiamato puntatore di RdA). Qualcosina in piÃ¹ forse câ€™Ã¨ da fare sulle variabili non locali\nUn altra ottimizzazione Ã¨ memorizzare i risultati intermedi su REGISTRI invece che utilizzare la stack. In generale ci sono moltissimi modi di ottimizzare, quindi non andiamo a parlare di questo.\nGestione della pila La pila Ã¨ la struttura piÃ¹ comoda per la gestione dei blocchi di codice, che come abbiamo descritto in Nomi e Scope, devono essere LIFO, ossia il blocco piÃ¹ annidato deve finire prima di uscire. Questo Ã¨ il motivo per cui possiamo giustificare la gestione della pila. Ecco che si giustifica lâ€™idea di creazione della pila di sistema.* Che Ã¨ in grado di stabilire le posizioni delle variabili locale, dei parametri attraverso un Offset rispetto al base pointer del frame.\nRecord di attivazione di blocchi (3) ðŸŸ© Ne abbiamo accennato in 8.4.1 Activation record, parlando anche lÃ¬ dei record di attivazione, in questo momento andremo a parlarne in modo piÃ¹ approfondito.\nOra parliamo brevemente di record attivazione di blocchi, per questi quando entriamo in un nuovo blocco vogliamo creare spazio per queste cose:\nVariabili intermedie (per storare calcolo intermedio) Variabili locali nuove Catena dinamica che mi dice in quale blocco sono, ed Ã¨ utilizzato per eliminare tutto il nuovo spazio allocato in questo blocco. Esempio:\nFigura 7 .3 Allocazione del record di attivazione per I blocchi A e B nellâ€™Esempio 7.2.\nRecord di attivazione per funzioni (7) ðŸŸ© Questi record di attivazione, anche chiamate RdA in modo abbreviato hanno lo stesso concetto per i record di attivazione per i blocchi, ma devono avere qualche informazione in piÃ¹ per indirizzo di ritorno e modo di ritornare la variabile di output.\nTutti i 3 punti per i RdA dei blocchi Catena statica per gli scope (che attualmente non so in che modo venga utilizzata) Indirizzo di ritorno, per il program counter Indirizzo per il Valore di ritorno I parametri di chiamata della funzione. Figura 7.7 Struttura del record di attivazione per una procedura.\nGestione della pila a runtime (!!!) ðŸŸ¨++ In questa parte andiamo a parlare di alcune istruzioni che sono utili per implementare questo sistema di RdA in un linguaggio classico.\nAndiamo a parlare di sequenza di chiamata per lâ€™insieme di procedure che deve eseguire il chiamante prima di entrare nel blocco della funzioen chiamata, e una sequenza di ritorno per uscire dal blocco, poi di prologo e epilogo per lâ€™uscita. ora nel pezzo sequente andiamo a descrivere alcune istruzioni da eseguire per entrare ed uscire da un blocco di RdA di una funzione.\nQuesta divisione Ã¨ necessaria perchÃ© alcune cose possono essere fatte solo dal chiamante, e altre solo dal chiamato!\nChiamata di funzione\nQuesta parte interessa la parte di sequenza di chiamata e il prologo della funzione.\nAllocazione dello spazio necessario nella stack (per parametri, variabili locali, e risultati intermedi, e catene statiche e dinamiche). Passare i parametri (di solito copiati nella nuova RdA) Aggiornare il puntatore di RdA al nuovo, in C di solito Ã¨ il base pointer, anche chiamato frame pointer. Salvare quanto necessario dai registri (e.g. il chiamante deve settare lâ€™indirizzo di ritorno della funzione). Salvare il PC precedente, e settare il nuovo PC. Eseguire codice di inizializzazione specifico del linguaggio, se câ€™Ã¨ (anche in C mi pare ci fossero alcune istruzioni, di solito erano nel prologo, come dei push rbp). Ritorno del controllo al programma chiamante\nRipristinare i valori dei registri precedenti. Risettare il PC precedente Copiare il valore di ritorno nellâ€™indirizzo giusto ripristinare il puntatore di RdA Deallocare la parte della stack che non utilizziamo piÃ¹. Esecuzione di codice di uscita. Gestione della heap Per la heap non Ã¨ possibile utilizzare stack perchÃ© in questo caso lâ€™utilizzo non soddisfa la proprietÃ  LIFO tipida della stack, posso freeare una cosa anche prima di una cosa allocata dopo diciamo. Bisogna quindi creare un metodo di gestione dinamica della memoria differente.\nQuesto Ã¨ solamente una zona contigua di memoria diversa dalla stack, in cui possiamo allocare e deallocare dinamicamente cose, non câ€™entra niente con la struttura di dati!\nDimensione fissa ðŸŸ© Questa Ã¨ lâ€™implementazione della heap piÃ¹ semplice, in pratica divido tutto il mio array disponibile in blocchi liberi disponibili.\nQuando vado ad allocare un blocco, vado a togliere questo blocco e metterlo a disposizione al chiamante, a chi ha allocato il blocco, e tolgo questo blocco dai liberi, ora la lista dei liberi punterÃ  al prossimo blocco libero.\nQuando vado a deallocare il blocco non faccio altro che marcare come libero il blocco, reinserendolo nella lista dei liberi.\nDimensione variabile ðŸŸ©- Questa Ã¨ una soluzione molto piÃ¹ bella per quanto riguarda la soluzione della frammentazione interna, ossia quanta parte di memoria ho ancora inutilizzato, se ho richiesto un blocco (e.g. prima se avevo blocchi da 256, anche se volevo un singolo byte, mi dava un blocco da 256 e gran parte della memoria sarebbe stata sprecata per allocazione dinamica.)\nOra vorrei dividere tutta la memoria che ho secondo una certa logica, solitamente si puÃ² dividere in due modi di gestire questa cosa:\nHeap dimensione variabile a liste multiple\nQuesta Ã¨ una gestione della lista in cui ho piÃ¹ liste di una certa grandezza, i sistemi principali sono a buddy system o fibonacci heap. Discuteremo solamente il primo sistema, il secondo sistema Ã¨ molto simile, con una leggera efficienza in piÃ¹ perchÃ© utilizzando i numeri di fibonacci si ha minore frammentazione interna**.**\nAllora se richiedo un blocco di grandezza n, vado a cercare il blocco libero nella lista di k, con grandezza piÃ¹ grande di n (in buddy system le liste sono tutte di grandezze di potenze di due).\nSe trovo una lista allora alloco e restituisco. Se invece non câ€™Ã¨, allora vado a cercare nelle liste piÃ¹ grosse se câ€™Ã¨. Se lo trovo, allora lo spezzo a metÃ , creando i buddies, uno lo aggiungo alla lista dei liberi della lista precedente, lâ€™altra la restituisco come blocco allocato.\nin fase di deallocazione vado a controllare se ho dei buddies spezzati, se esistono e sono liberi allora li ricompongo e li metto nella lista grossa originale, altrimenti rimane nella lista libera piÃ¹ piccola!\nHeap a singola lista ðŸŸ© Anche in questo caso possiamo avere dei problemi di frammentazione quando allochiamo e deallochiamo gli elementi della lista libera che possediamo, ne abbiamo parlato sempre in architettura quando abbiamo accennato alla paginazione: 9.3.2 In memoria: frammentazione esterna. Infatti anche qui possiamo andare a parlare di politiche di first and best FIT. Questi sono entrambi metodi di inserimento lineare, il primo favorisce il tempo, il secondo lâ€™efficienza in memoria.\nCon questo sistema ho un blocco di spazio UNICO disponibile. Quindi se chiedo n, posso effettivamente allocarti un blocco grosso n, senza nessuna frammentazione. Questo posso continuare finchÃ© non finisco la memoria. Quando la finisco potrei gestirla in due modi praticamente.\nLista dei liberi\nIn questo caso quando faccio free faccio append di tutti i blocchi deallocati alla lista dei liberi. Posso inserire controlli che quando ho due blocchi contigui nei liberi li compatto assieme. Questo Ã¨ la compattazione parziale.\nPoi quando finisco la memoria utilizzo direttamente la lista dei liberi per allocare nuovi blocchi, questo puÃ² portare al problema di frammentazione interna o esterna. Ci metto in tempo lineare ad allocare. (oppure posso tenere i blocchi ordinati, se utilizzo alberi ordinati allora log(n) per tirare via ed inserire.) Ma in generale ci sono molti modi per gestire questa struttura di dati.\nCompattazione della memoria libera\nQuando finisco la memoria, risolvo la frammentazione esterna rimettendo assieme tutti i blocchi allocati, e poi posso continuare lâ€™algoritmo di sopra, allocando esattamente quando mi richiede.\nIl problema di questo metodo Ã¨ che difficilmente posso spostare le cose, che Ã¨ una precondizione per poter utilizzare questo metodo.\nImplementazione delle regole di scope Abbiamo parlato per la prima volta di scope in Nomi e Scope.\nScope statico ðŸŸ© Per implementare lo scope statico vogliamo utilizzare la catena statica presente allâ€™interno del record di attivazione per poter risalire al blocco giusto.\nIn particolare dividiamo in due casi, il caso in cui il nome chiamato sia presente nellâ€™ambiente locale del chiamante, e il caso in cui non lo sia. Questo Ã¨ importante perchÃ© nella fase di sequenza di chiamata dovrebbe essere il lavoro del chiamante per impostare il puntatore di catena statica del chiamato. Notare che in questa sezione utilizziamo nomi come chiamante chiamato, ma il chiamato potrebbe anche essere riferimento al nome di una variabile, il concetto di risalita Ã¨ comune.\nCaso presente nellâ€™ambiente locale\nQuesto Ã¨ il caso semplice, so che la catena statica deve puntare al chiamante, quindi basta inserirla nel record di attivazione del chiamato!\nCaso non presente\nQuesto Ã¨ una cosa leggermente piÃ¹ complessa, se io so che il chiamato Ã¨ a livello di annidamento statico n (per tenersi queste informazioni probabilmente si utilizzano informazioni di annidamento e di ambienti locale, che sono comunque presenti nella struttura (statica), e quindi le posso calcolare al momento di compilazione)), e il chiamante a livello di m, devo percorrere k = m - n, livelli per trovare il puntatore di catena statica del chiamato e settarlo puntatore di catena statica del nuovo RdA che mi ritrovo dopo aver risalito di k sulla catena statica.\nQuesto lo so perchÃ© dato che il chiamato Ã¨ esterno, so che Ã¨ presente nellâ€™ambiente non locale, quindi non puÃ² che essere a livello di annidamento inferiore, quindi risalire la catena statica Ã¨ corretto.\nChiaramente Ã¨ una cosa molto inefficiente fare k dereferenziazioni di pointer per arrivare fino al punto che mi interessa, vedremo subito dopo un metodo per velocizzare questo sistema di scope statico.\nEsempio funzionamento\n!\nFigura 7.14 Catena statica per la struttura precedente e la sequenza di chiamate A, B, C, D, E, C.\nstatico: Il display ðŸŸ© Vogliamo trovare un metodo piÃ¹ veloce per settare il RdA nel campo della catena statica, tanto che possiamo ridurre a k dereferenziazioni a solamente un numero costante piccolo (2, ma poi il problema precedente non Ã¨ brutto dato che il numero di annidamenti per linguaggi reali sta molto piccolo in generale, di solito 3).\nAllora un modo per fare questo Ã¨ tenersi un altro array, che contenga un puntatore a seconda del livello di annidamento!\nIdea: tenersi una struttura ausiliaria che viene aggiornato ad ogni cambio di ambiente che contenga il puntatore alla struttura statica di riferimento a ogni livello. (chiaramente il livello massimo si annidamento, va a determinare la lunghezza del display).\nDue accessi, uno nel display per trovare il RdA corretto, lâ€™altro accesso per trovare lâ€™index della variabile locale corretta.\nFunzionamento generale\nSia m il livello di annidamento del chiamato, allora salvo il valore che câ€™era prima, perchÃ© il display sarÃ  comune a tutti i livelli diversi da m.\nQuando ritorno ripristino il vecchio valore, in questo senso il display contiene tutte le RdA statiche a seconda del livello di annidamento, e posso utilizzare questo per capire il puntatore di catena statica.\nEsempio display\n!\nFigura 7.15 Display per la struttura di Figura 7.13 e la sequenza di chiamate A,' B, C, D, E, C.\nScope dinamico: La ricerca per nome ðŸŸ© Questa Ã¨ la soluzione piÃ¹ lenta che potrebbe esistere, che Ã¨ quella della ricerca per nome negli RdA, in pratica risalgo i record fin quando non lo trovo o lo trovo.\nUn problema diventa andare ad attivare o disattivare le variabili a seconda del fatto di averlo giÃ  visto o meno, e dello scope.\nSlide descrive questo metodo\nScope dinamico lista associazioni ðŸŸ© Una cosa banale Ã¨ tenersi una lista di associazioni globale, chiamata A-list (che viene usato in lisp) che si tiene conto di tutte le associazioni attive. Un entrare e uscire da un certo ambiente non si tratta altro che andare a manipolare questa lista globale di associazioni.\nCercare un valore dellâ€™associazione a runtime non sarebbe altro che andare a scorrersi la lista fino a trovare il simbolo di mio interesse, alla prima occorrenza, perchÃ© quella Ã¨ la piÃ¹ recente.\nEntro in nuovo ambiente non faccio altro che aggiungere nella A-list i valori locali\nEsco dallâ€™ambiente non faccio altro che poppare i valori locali\nRicerca simboli non faccio che scorrere tutta la A-list per trovare il valore corretto.\nChiaramente questo runtime non Ã¨ che sia molto invitante (nella pratica perÃ² Ã¨ sufficiente, anche se non avrei comunque una efficienza di C), quindi vorremmo trovare anche metodi migliori per implementare lo scope dinamico.\nUn altro metodo comparabile per inefficienza Ã¨ scorrersi le RdA finchÃ© non troviamo il simbolo di nostro interesse..\nSvantaggi\nDevo memorizzare i nomi in momento di esecuzione, per poter ritrovare lâ€™istanza. Lentezza ad accedere valori globali, che sono in cima alla lista. Entrambi questi svantaggi sono risolti con la CRT esposta nella squenza successiva.\nCentral Referencing environment Table ðŸŸ© Durante lâ€™esecuzione e durante le entrate in ogni ambiente locale, posso tenermi un array di tutti i simboli che posso avere (oppure una hastable). Questo mi permette di accedere al simbolo in tempo costante, e se a tempo di compilazione conosco tutte le variabili a mia disposizione, poi mi basta accedere con offset, e non mi serve sapere il nome originario! (se invece non Ã¨ nota bisogna utilizzare la hastable).\nIn questo modo ho un leggere overhead in piÃ¹ per uscire ed entrare in un blocco. PerchÃ© devo aggiornare lâ€™array globale di liste, perÃ² mi implementa in modo semplice questo scope dinamico.\nPer tenere conto dei valori vecchi abbiamo principalmente due metodi:\nTenersi la stack degli elementi nascosti che viene ripristinata quando usciamo dal blocco (quindi Ã¨ temporaneo per tenere i vecchi valori) Lista dei vecchi valori, ossia ogni elemento si tiene una lista, che possiamo interpretarla come stack per ogni valore, che contiene i vecchi valori, in testa solamente il valore piÃ¹ recente. Esempio stack elementi nascosti\nEsempio lista vecchi valori\n",
  "wordCount" : "2591",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/gestione-della-memoria/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;Â»&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Gestione della memoria
    </h1>
    <div class="post-meta">13 min&nbsp;Â·&nbsp;Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#elementi-di-ripasso" aria-label="Elementi di ripasso">Elementi di ripasso</a></li>
                <li>
                    <a href="#gestione-della-memoria" aria-label="Gestione della memoria">Gestione della memoria</a><ul>
                        
                <li>
                    <a href="#memoria-statica" aria-label="Memoria statica">Memoria statica</a><ul>
                        
                <li>
                    <a href="#elementi-in-memoria-statica-4--" aria-label="Elementi in memoria statica (4) ðŸŸ©-">Elementi in memoria statica (4) ðŸŸ©-</a></li>
                <li>
                    <a href="#implementazione-di-funzioni-statiche-" aria-label="Implementazione di funzioni statiche ðŸŸ©">Implementazione di funzioni statiche ðŸŸ©</a></li></ul>
                </li>
                <li>
                    <a href="#gestione-della-pila" aria-label="Gestione della pila">Gestione della pila</a><ul>
                        
                <li>
                    <a href="#record-di-attivazione-di-blocchi-3-" aria-label="Record di attivazione di blocchi (3) ðŸŸ©">Record di attivazione di blocchi (3) ðŸŸ©</a></li>
                <li>
                    <a href="#record-di-attivazione-per-funzioni-7-" aria-label="Record di attivazione per funzioni (7) ðŸŸ©">Record di attivazione per funzioni (7) ðŸŸ©</a></li>
                <li>
                    <a href="#gestione-della-pila-a-runtime--" aria-label="Gestione della pila a runtime (!!!) ðŸŸ¨&#43;&#43;">Gestione della pila a runtime (!!!) ðŸŸ¨++</a></li></ul>
                </li>
                <li>
                    <a href="#gestione-della-heap" aria-label="Gestione della heap">Gestione della heap</a><ul>
                        
                <li>
                    <a href="#dimensione-fissa-" aria-label="Dimensione fissa ðŸŸ©">Dimensione fissa ðŸŸ©</a></li>
                <li>
                    <a href="#dimensione-variabile--" aria-label="Dimensione variabile ðŸŸ©-">Dimensione variabile ðŸŸ©-</a></li>
                <li>
                    <a href="#heap-a-singola-lista-" aria-label="Heap a singola lista ðŸŸ©">Heap a singola lista ðŸŸ©</a></li></ul>
                </li>
                <li>
                    <a href="#implementazione-delle-regole-di-scope" aria-label="Implementazione delle regole di scope">Implementazione delle regole di scope</a><ul>
                        
                <li>
                    <a href="#scope-statico-" aria-label="Scope statico ðŸŸ©">Scope statico ðŸŸ©</a></li>
                <li>
                    <a href="#statico-il-display-" aria-label="statico: Il display ðŸŸ©">statico: Il display ðŸŸ©</a></li>
                <li>
                    <a href="#scope-dinamico-la-ricerca-per-nome-" aria-label="Scope dinamico: La ricerca per nome ðŸŸ©">Scope dinamico: La ricerca per nome ðŸŸ©</a></li>
                <li>
                    <a href="#scope-dinamico-lista-associazioni-" aria-label="Scope dinamico lista associazioni ðŸŸ©">Scope dinamico lista associazioni ðŸŸ©</a></li>
                <li>
                    <a href="#central-referencing-environment-table-" aria-label="Central Referencing environment Table ðŸŸ©">Central Referencing environment Table ðŸŸ©</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Ripasso Prox: 60
Ripasso: June 1, 2023
Ultima modifica: May 29, 2023 3:34 PM
Primo Abbozzo: February 27, 2023 9:07 AM
Stato: ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•ðŸŒ•
Studi Personali: No</p>
<h1 id="elementi-di-ripasso">Elementi di ripasso<a hidden class="anchor" aria-hidden="true" href="#elementi-di-ripasso">#</a></h1>
<h1 id="gestione-della-memoria">Gestione della memoria<a hidden class="anchor" aria-hidden="true" href="#gestione-della-memoria">#</a></h1>
<h2 id="memoria-statica">Memoria statica<a hidden class="anchor" aria-hidden="true" href="#memoria-statica">#</a></h2>
<h3 id="elementi-in-memoria-statica-4--">Elementi in memoria statica (4) ðŸŸ©-<a hidden class="anchor" aria-hidden="true" href="#elementi-in-memoria-statica-4--">#</a></h3>
<ul>
<li>Variabili globali</li>
<li>Istruzioni macchina</li>
<li>Costanti</li>
<li>(Variabili locali, paramentri e ritorno di funzione?)</li>
</ul>
<p>Le primi tre elementi descritti di sopra sono sicuramente presenti dopo la fase di compilazione, infatti sono allocati dal compilatore in una zona presente nellâ€™eseguibile (un esempio Ã¨ il READONLY per le stringhe in C).</p>
<p>Quindi se vogliamo</p>
<ul>
<li>Avere funzioni ricorsive</li>
<li>Potere allocare e deallocare variabili in modo dinamico</li>
</ul>
<p>Abbiamo bisogno di far uso di Pila o Heap, che riescano a cresere e restringersi in modo dinamico.</p>
<h3 id="implementazione-di-funzioni-statiche-">Implementazione di funzioni statiche ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#implementazione-di-funzioni-statiche-">#</a></h3>
<p>Si potrebbe anche utilizzare la memoria statica per implementare le funzioni, ma questo ha il fortissimo drawback che <strong>non permette la ricorsione</strong> in quanto stiamo assumento che in ogni momento di esecuzione la funzione Ã¨ chiamata una singola volta. (ho un unico indirizzo di memoria per l&rsquo;indirizzo di ritorno.</p>
<p>Infatti se chiamassimo in modo ricorsivo questa funzione, perderemmo alcuni valori, come l&rsquo;indirizzo di ritorno, il valore di ritorno precedente, e porterebbe in uno stato invalido.</p>
<p>Oltre a questo avremmo un <strong>elevato uso della memoria</strong> nel caso in cui il numero di chiamate di funzioni sia in media minore del numero di dichiarazioni di funzione (avremmo un sacco di funzioni inutilizzate).</p>
<ul>
<li>
<p>Slide di quanto memorizzato per la funzione statica</p>
  <img src="/images/notes/image/universita/ex-notion/Gestione della memoria/Untitled.png" alt="image/universita/ex-notion/Gestione della memoria/Untitled">
<p>Figura 7.1 Gestione della memoria statica. per le <strong>funzioni</strong></p>
</li>
</ul>
<p><strong>Sull&rsquo;efficienza</strong></p>
<p>Solitamente se utilizziamo questo metodo il compilatore solitamente Ã¨ in grado di accedere a delle variabili utilizzando un OFFSET senza dover stare a fare risoluzione di nomi simbolici (una volta che abbiamo un frame o RdA, possiamo calcolare la posizione della variabile locale, o parametro attraverso lâ€™offset sul base pointer, che qui Ã¨ anche chiamato puntatore di RdA). Qualcosina in piÃ¹ forse c&rsquo;Ã¨ da fare sulle variabili non locali</p>
<p>Un altra ottimizzazione Ã¨ memorizzare i risultati intermedi su REGISTRI invece che utilizzare la stack. In generale ci sono moltissimi modi di ottimizzare, quindi non andiamo a parlare di questo.</p>
<h2 id="gestione-della-pila">Gestione della pila<a hidden class="anchor" aria-hidden="true" href="#gestione-della-pila">#</a></h2>
<p>La pila Ã¨ la struttura piÃ¹ comoda per la gestione dei blocchi di codice, che come abbiamo descritto in <a href="//notes/nomi-e-scope">Nomi e Scope</a>, devono essere LIFO, ossia il blocco piÃ¹ annidato deve finire prima di uscire. Questo Ã¨ il motivo per cui possiamo giustificare la gestione della pila. Ecco che si giustifica l&rsquo;idea di creazione della <strong>pila di sistema</strong>.* Che Ã¨ in grado di stabilire le posizioni delle variabili locale, dei parametri attraverso un Offset rispetto al base pointer del frame.</p>
<h3 id="record-di-attivazione-di-blocchi-3-">Record di attivazione di blocchi (3) ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#record-di-attivazione-di-blocchi-3-">#</a></h3>
<p>Ne abbiamo accennato in 8.4.1 Activation record, parlando anche lÃ¬ dei record di attivazione, in questo momento andremo a parlarne in modo piÃ¹ approfondito.</p>
<p>Ora parliamo brevemente di record attivazione di blocchi, per questi quando entriamo in un nuovo blocco vogliamo creare spazio per queste cose:</p>
<ol>
<li>Variabili intermedie (per storare calcolo intermedio)</li>
<li>Variabili locali nuove</li>
<li><strong>Catena dinamica</strong> che mi dice in quale blocco sono, ed Ã¨ utilizzato per eliminare tutto il nuovo spazio allocato in questo blocco.</li>
</ol>
<p>Esempio:</p>
<img src="/images/notes/image/universita/ex-notion/Gestione della memoria/Untitled 1.png" alt="image/universita/ex-notion/Gestione della memoria/Untitled 1">
<p>Figura 7 .3 Allocazione del record di attivazione per I blocchi A e B nell&rsquo;Esempio 7.2.</p>
<h3 id="record-di-attivazione-per-funzioni-7-">Record di attivazione per funzioni (7) ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#record-di-attivazione-per-funzioni-7-">#</a></h3>
<p>Questi record di attivazione, anche chiamate RdA in modo abbreviato hanno lo stesso concetto per i record di attivazione per i blocchi, ma devono avere qualche informazione in piÃ¹ per indirizzo di ritorno e modo di ritornare la variabile di output.</p>
<ol>
<li>Tutti i 3 punti per i RdA dei blocchi</li>
<li><strong>Catena statica</strong> per gli scope (che attualmente non so in che modo venga utilizzata)</li>
<li>Indirizzo di ritorno, per il program counter</li>
<li>Indirizzo per il Valore di ritorno</li>
<li>I parametri di chiamata della funzione.</li>
</ol>
<img src="/images/notes/image/universita/ex-notion/Gestione della memoria/Untitled 2.png" alt="image/universita/ex-notion/Gestione della memoria/Untitled 2">
<p>Figura 7.7 Struttura del record di attivazione per una procedura.</p>
<h3 id="gestione-della-pila-a-runtime--">Gestione della pila a runtime (!!!) ðŸŸ¨++<a hidden class="anchor" aria-hidden="true" href="#gestione-della-pila-a-runtime--">#</a></h3>
<p>In questa parte andiamo a parlare di alcune istruzioni che sono utili per implementare questo sistema di RdA in un linguaggio classico.</p>
<p>Andiamo a parlare di <strong>sequenza di chiamata</strong> per l&rsquo;insieme di procedure che deve eseguire il chiamante prima di entrare nel blocco della funzioen chiamata, e una <strong>sequenza di ritorno</strong> per uscire dal blocco, poi di <strong>prologo e epilogo</strong> per lâ€™uscita. ora nel pezzo sequente andiamo a descrivere alcune istruzioni da eseguire per entrare ed uscire da un blocco di RdA di una funzione.</p>
<p>Questa divisione Ã¨ necessaria perchÃ© alcune cose possono essere fatte solo dal chiamante, e altre solo dal chiamato!</p>
<p><strong>Chiamata di funzione</strong></p>
<p>Questa parte interessa la parte di sequenza di chiamata e il prologo della funzione.</p>
<ul>
<li>Allocazione dello spazio necessario nella stack (per parametri, variabili locali, e risultati intermedi, e catene statiche e dinamiche).</li>
<li>Passare i parametri (di solito copiati nella nuova RdA)</li>
<li>Aggiornare il puntatore di RdA al nuovo, in C di solito Ã¨ il base pointer, anche chiamato <strong>frame pointer</strong>.</li>
<li>Salvare quanto necessario dai registri (e.g. il chiamante deve settare lâ€™indirizzo di ritorno della funzione).</li>
<li>Salvare il PC precedente, e settare il nuovo PC.</li>
<li>Eseguire codice di inizializzazione specifico del linguaggio, se c&rsquo;Ã¨ (anche in C  mi pare ci fossero alcune istruzioni, di solito erano nel prologo, come dei push rbp).</li>
</ul>
<p><strong>Ritorno del controllo al programma chiamante</strong></p>
<ul>
<li>Ripristinare i valori dei registri precedenti.</li>
<li>Risettare il PC precedente</li>
<li>Copiare il valore di ritorno nell&rsquo;indirizzo giusto</li>
<li>ripristinare il puntatore di RdA</li>
<li>Deallocare la parte della stack che non utilizziamo piÃ¹.</li>
<li>Esecuzione di codice di uscita.</li>
</ul>
<h2 id="gestione-della-heap">Gestione della heap<a hidden class="anchor" aria-hidden="true" href="#gestione-della-heap">#</a></h2>
<p>Per la heap non Ã¨ possibile utilizzare stack perchÃ© in questo caso l&rsquo;utilizzo non soddisfa la proprietÃ  LIFO tipida della stack, posso freeare una cosa anche prima di una cosa allocata dopo diciamo. Bisogna quindi creare un metodo di gestione dinamica della memoria differente.</p>
<p>Questo Ã¨ solamente una <strong>zona contigua di memoria</strong> diversa dalla stack, in cui possiamo allocare e deallocare dinamicamente cose, non câ€™entra niente con la struttura di dati!</p>
<h3 id="dimensione-fissa-">Dimensione fissa ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#dimensione-fissa-">#</a></h3>
<p>Questa Ã¨ l&rsquo;implementazione della heap piÃ¹ semplice, in pratica divido tutto il mio array disponibile in blocchi liberi disponibili.</p>
<p>Quando vado ad allocare un blocco, vado a togliere questo blocco e metterlo a disposizione al chiamante, a chi ha allocato il blocco, e <strong>tolgo questo blocco dai liberi</strong>, ora la lista dei liberi punterÃ  al prossimo blocco libero.</p>
<p>Quando vado a deallocare il blocco non faccio altro che <strong>marcare come libero</strong> il blocco, reinserendolo nella lista dei liberi.</p>
<h3 id="dimensione-variabile--">Dimensione variabile ðŸŸ©-<a hidden class="anchor" aria-hidden="true" href="#dimensione-variabile--">#</a></h3>
<p>Questa Ã¨ una soluzione molto piÃ¹ bella per quanto riguarda la soluzione della <strong>frammentazione interna</strong>, ossia quanta parte di memoria ho ancora inutilizzato, se ho richiesto un blocco (e.g. prima se avevo blocchi da 256, anche se volevo un singolo byte, mi dava un blocco da 256 e gran parte della memoria sarebbe stata sprecata per allocazione dinamica.)</p>
<p>Ora vorrei dividere tutta la memoria che ho secondo una certa logica, solitamente si puÃ² dividere in due modi di gestire questa cosa:</p>
<p><strong>Heap dimensione variabile a liste multiple</strong></p>
<p>Questa Ã¨ una gestione della lista in cui ho piÃ¹ liste di una certa grandezza, i sistemi principali sono a <strong>buddy system o fibonacci heap</strong>. Discuteremo solamente il primo sistema, il secondo sistema Ã¨ molto simile, con una leggera efficienza in piÃ¹ perchÃ© utilizzando i numeri di fibonacci si ha minore frammentazione interna**.**</p>
<p>Allora se richiedo un blocco di grandezza n, vado a cercare il blocco libero nella lista di k, con grandezza piÃ¹ grande di n (in buddy system le liste sono tutte di grandezze di potenze di due).</p>
<p>Se trovo una lista allora alloco e restituisco. Se invece non c&rsquo;Ã¨, allora vado a cercare nelle liste piÃ¹ grosse se c&rsquo;Ã¨. Se lo trovo, allora <strong>lo spezzo a metÃ </strong>, creando i buddies, uno lo aggiungo alla lista dei liberi della lista precedente, l&rsquo;altra la restituisco come blocco allocato.</p>
<p>in fase di deallocazione vado a controllare se ho dei buddies spezzati, se esistono e sono liberi allora li ricompongo e li metto nella lista grossa originale, altrimenti rimane nella lista libera piÃ¹ piccola!</p>
<h3 id="heap-a-singola-lista-">Heap a singola lista ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#heap-a-singola-lista-">#</a></h3>
<p>Anche in questo caso possiamo avere dei problemi di <strong>frammentazione</strong> quando allochiamo e deallochiamo gli elementi della lista libera che possediamo, ne abbiamo parlato sempre in architettura quando abbiamo accennato alla paginazione: 9.3.2 In memoria: frammentazione esterna. Infatti anche qui possiamo andare a parlare di politiche di <strong>first and best FIT</strong>. Questi sono entrambi metodi di inserimento lineare, il primo favorisce il tempo, il secondo lâ€™efficienza in memoria.</p>
<p>Con questo sistema ho un blocco di spazio UNICO disponibile. Quindi se chiedo n, posso effettivamente allocarti un blocco grosso n, senza nessuna frammentazione. Questo posso continuare finchÃ© non finisco la memoria. Quando la finisco potrei gestirla in due modi praticamente.</p>
<p><strong>Lista dei liberi</strong></p>
<p>In questo caso quando faccio free faccio append di tutti i blocchi deallocati alla lista dei liberi. Posso inserire controlli che quando ho due blocchi contigui nei liberi li compatto assieme. Questo Ã¨ la <strong>compattazione parziale</strong>.</p>
<p>Poi quando finisco la memoria utilizzo direttamente la lista dei liberi per allocare nuovi blocchi, questo puÃ² portare al problema di frammentazione interna o esterna. Ci metto in tempo lineare ad allocare. (oppure posso tenere i blocchi ordinati, se utilizzo alberi ordinati allora log(n) per tirare via ed inserire.) Ma in generale ci sono molti modi per gestire questa struttura di dati.</p>
<p><strong>Compattazione della memoria libera</strong></p>
<p>Quando finisco la memoria, risolvo la frammentazione esterna rimettendo assieme tutti i blocchi allocati, e poi posso continuare l&rsquo;algoritmo di sopra, allocando esattamente quando mi richiede.</p>
<p>Il problema di questo metodo Ã¨ che difficilmente posso spostare le cose, che Ã¨ una precondizione per poter utilizzare questo metodo.</p>
<h2 id="implementazione-delle-regole-di-scope">Implementazione delle regole di scope<a hidden class="anchor" aria-hidden="true" href="#implementazione-delle-regole-di-scope">#</a></h2>
<p>Abbiamo parlato per la prima volta di scope in <a href="//notes/nomi-e-scope">Nomi e Scope</a>.</p>
<h3 id="scope-statico-">Scope statico ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#scope-statico-">#</a></h3>
<p>Per implementare lo scope statico vogliamo utilizzare <strong>la catena statica</strong> presente all&rsquo;interno del record di attivazione per poter risalire al blocco giusto.</p>
<p>In particolare dividiamo in due casi, il caso in cui il nome chiamato sia presente nell&rsquo;ambiente locale del chiamante, e il caso in cui non lo sia. Questo Ã¨ importante perchÃ© nella fase di sequenza di chiamata dovrebbe essere il lavoro del chiamante per impostare il puntatore di catena statica del chiamato. Notare che in questa sezione utilizziamo nomi come chiamante chiamato, ma il chiamato potrebbe anche essere riferimento al nome di una variabile, il concetto di risalita Ã¨ comune.</p>
<p><strong>Caso presente nellâ€™ambiente locale</strong></p>
<p>Questo Ã¨ il caso semplice, so che la catena statica deve puntare al chiamante, quindi basta inserirla nel record di attivazione del chiamato!</p>
<p><strong>Caso non presente</strong></p>
<p>Questo Ã¨ una cosa leggermente piÃ¹ complessa, se io so che il chiamato Ã¨ a livello di annidamento statico n (per tenersi queste informazioni probabilmente si utilizzano informazioni di annidamento e di ambienti locale, che sono comunque presenti nella struttura (statica), e quindi le posso calcolare al momento di compilazione)), e il chiamante a livello di m, devo percorrere k = m - n, livelli per trovare il puntatore di catena statica del chiamato e settarlo puntatore di catena statica del nuovo RdA che mi ritrovo dopo aver risalito di k sulla catena statica.</p>
<p>Questo lo so perchÃ© dato che il chiamato Ã¨ esterno, so che Ã¨ presente nellâ€™ambiente non locale, quindi non puÃ² che essere a livello di annidamento inferiore, quindi risalire la catena statica Ã¨ corretto.</p>
<p>Chiaramente Ã¨ una cosa molto inefficiente fare k dereferenziazioni di pointer per arrivare fino al punto che mi interessa, vedremo subito dopo un metodo per velocizzare questo sistema di scope statico.</p>
<ul>
<li>
<p>Esempio funzionamento</p>
<p>!<img src="/images/notes/image/universita/ex-notion/Gestione della memoria/Untitled 3.png" alt="image/universita/ex-notion/Gestione della memoria/Untitled 3"></p>
  <img src="/images/notes/image/universita/ex-notion/Gestione della memoria/Untitled 4.png" alt="image/universita/ex-notion/Gestione della memoria/Untitled 4">
<p>Figura 7.14 Catena statica per la struttura precedente e la sequenza di chiamate
A, B, C, D, E, C.</p>
</li>
</ul>
<h3 id="statico-il-display-">statico: Il display ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#statico-il-display-">#</a></h3>
<p>Vogliamo trovare un metodo piÃ¹ veloce per settare il RdA nel campo della catena statica, tanto che possiamo ridurre a k dereferenziazioni a solamente un numero costante piccolo (2, ma poi il problema precedente non Ã¨ brutto dato che il numero di annidamenti per linguaggi reali sta molto piccolo in generale, di solito 3).</p>
<p>Allora un modo per fare questo Ã¨ tenersi un altro array, che contenga un puntatore a seconda del livello di annidamento!</p>
<p><strong>Idea</strong>: tenersi una struttura ausiliaria che viene aggiornato ad ogni cambio di ambiente che contenga il puntatore alla struttura statica di riferimento a ogni livello. (chiaramente il livello massimo si annidamento, va a determinare la lunghezza del display).</p>
<p><strong>Due accessi</strong>, uno nel display per trovare il RdA corretto, l&rsquo;altro accesso per trovare lâ€™index della variabile locale corretta.</p>
<p><strong>Funzionamento generale</strong></p>
<p>Sia m il livello di annidamento del chiamato, allora salvo il valore che c&rsquo;era prima, perchÃ© il display sarÃ  comune a tutti i livelli diversi da m.</p>
<p>Quando ritorno ripristino il vecchio valore, in questo senso il display contiene tutte le RdA statiche a seconda del livello di annidamento, e posso utilizzare questo per capire il puntatore di catena statica.</p>
<ul>
<li>
<p>Esempio display</p>
<p>!<img src="/images/notes/image/universita/ex-notion/Gestione della memoria/Untitled 3.png" alt="image/universita/ex-notion/Gestione della memoria/Untitled 3"></p>
  <img src="/images/notes/image/universita/ex-notion/Gestione della memoria/Untitled 5.png" alt="image/universita/ex-notion/Gestione della memoria/Untitled 5">
</li>
</ul>
<p>Figura 7.15 Display per la struttura di Figura 7.13 e la sequenza di chiamate A,'
B, C, D, E, C.</p>
<h3 id="scope-dinamico-la-ricerca-per-nome-">Scope dinamico: La ricerca per nome ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#scope-dinamico-la-ricerca-per-nome-">#</a></h3>
<p>Questa Ã¨ la soluzione piÃ¹ lenta che potrebbe esistere, che Ã¨ quella della ricerca per nome negli RdA, in pratica risalgo i record fin quando non lo trovo o lo trovo.</p>
<p>Un problema diventa andare ad attivare o disattivare le variabili a seconda del fatto di averlo giÃ  visto o meno, e dello scope.</p>
<ul>
<li>
<p>Slide descrive questo metodo</p>
  <img src="/images/notes/image/universita/ex-notion/Gestione della memoria/Untitled 6.png" alt="image/universita/ex-notion/Gestione della memoria/Untitled 6">
</li>
</ul>
<h3 id="scope-dinamico-lista-associazioni-">Scope dinamico lista associazioni ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#scope-dinamico-lista-associazioni-">#</a></h3>
<p>Una cosa banale Ã¨ tenersi una lista di associazioni globale, chiamata <strong>A-list (che viene usato in lisp)</strong> che si tiene conto di tutte le associazioni attive. Un entrare e uscire da un certo ambiente non si tratta altro che andare a manipolare questa lista globale di associazioni.</p>
<p>Cercare un valore dellâ€™associazione a runtime non sarebbe altro che andare a scorrersi la lista fino a trovare il simbolo di mio interesse, alla prima occorrenza, perchÃ© quella Ã¨ la piÃ¹ recente.</p>
<p><strong>Entro in nuovo ambiente</strong> non faccio altro che aggiungere nella A-list i valori locali</p>
<p><strong>Esco dallâ€™ambiente</strong> non faccio altro che poppare i valori locali</p>
<p><strong>Ricerca simboli</strong> non faccio che scorrere tutta la A-list per trovare il valore corretto.</p>
<p>Chiaramente questo runtime non Ã¨ che sia molto invitante (nella pratica perÃ² Ã¨ sufficiente, anche se non avrei comunque una efficienza di C), quindi vorremmo trovare anche metodi migliori per implementare lo scope dinamico.</p>
<p>Un  altro metodo comparabile per inefficienza Ã¨ scorrersi le RdA finchÃ© non troviamo il simbolo di nostro interesse..</p>
<p><strong>Svantaggi</strong></p>
<ul>
<li>Devo memorizzare i nomi in momento di esecuzione, per poter ritrovare l&rsquo;istanza.</li>
<li>Lentezza ad accedere valori globali, che sono in cima alla lista.</li>
</ul>
<p>Entrambi questi svantaggi sono risolti con la CRT esposta nella squenza successiva.</p>
<h3 id="central-referencing-environment-table-">Central Referencing environment Table ðŸŸ©<a hidden class="anchor" aria-hidden="true" href="#central-referencing-environment-table-">#</a></h3>
<p>Durante l&rsquo;esecuzione e durante le entrate in ogni ambiente locale, posso tenermi un array di tutti i simboli che posso avere (oppure una hastable). Questo mi permette di accedere al simbolo in tempo costante, e se a tempo di compilazione conosco tutte le variabili a mia disposizione, poi mi basta accedere con offset, e non mi serve sapere il nome originario! (se invece non Ã¨ nota bisogna utilizzare la hastable).</p>
<p>In questo modo ho un leggere overhead in piÃ¹ per uscire ed entrare in un blocco. PerchÃ© devo aggiornare l&rsquo;array globale di liste, perÃ² mi implementa in modo semplice questo scope dinamico.</p>
<p>Per tenere conto dei valori vecchi abbiamo principalmente due metodi:</p>
<ol>
<li>Tenersi la <strong>stack degli elementi nascosti</strong> che viene ripristinata quando usciamo dal blocco (quindi Ã¨ temporaneo per tenere i vecchi valori)</li>
<li><strong>Lista dei vecchi valori</strong>, ossia ogni elemento si tiene una lista, che possiamo interpretarla come stack per ogni valore, che contiene i vecchi valori, in testa solamente il valore piÃ¹ recente.</li>
</ol>
<ul>
<li>
<p>Esempio stack elementi nascosti</p>
  <img src="/images/notes/image/universita/ex-notion/Gestione della memoria/Untitled 7.png" alt="image/universita/ex-notion/Gestione della memoria/Untitled 7">
</li>
<li>
<p>Esempio lista vecchi valori</p>
  <img src="/images/notes/image/universita/ex-notion/Gestione della memoria/Untitled 8.png" alt="image/universita/ex-notion/Gestione della memoria/Untitled 8"></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/no-tags/">No-Tags</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Gestione della memoria on x"
            href="https://x.com/intent/tweet/?text=Gestione%20della%20memoria&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fgestione-della-memoria%2f&amp;hashtags=no-tags">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Gestione della memoria on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fgestione-della-memoria%2f&amp;title=Gestione%20della%20memoria&amp;summary=Gestione%20della%20memoria&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2fgestione-della-memoria%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Gestione della memoria on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2fgestione-della-memoria%2f&title=Gestione%20della%20memoria">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Gestione della memoria on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2fgestione-della-memoria%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Gestione della memoria on whatsapp"
            href="https://api.whatsapp.com/send?text=Gestione%20della%20memoria%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2fgestione-della-memoria%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Gestione della memoria on telegram"
            href="https://telegram.me/share/url?text=Gestione%20della%20memoria&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fgestione-della-memoria%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Gestione della memoria on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Gestione%20della%20memoria&u=https%3a%2f%2fflecart.github.io%2fnotes%2fgestione-della-memoria%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
