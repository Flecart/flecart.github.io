<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Memoria | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="üèõcomputer-architecture">
<meta name="description" content="4.1 Caratteristiche della Memoria

La gerarchia della memoria, pi√π si va gi√π pi√π spazio si ha, pi√π √® lento il caricamento delle informazioni
4.1.1 Catalogazione della memoria
Le tipologie di memoria sono presenti a fianco.
In generale pi√π la memoria √® veloce da riprendere, pi√π √® costosa da memorizzare (c&rsquo;√® poco spazio)

4.1.2 Byte e Word
Il libro a pagina 74 parte con la discussione del perch√© si √® preferito evitare la BCD (Binary coded decimal, in cui i numeri da 0 a 9 erano codificato da 4 bit), per questioni di efficienza.">
<meta name="author" content="Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="https://flecart.github.io/notes/memoria/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/memoria/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>
<script type="text/javascript" async
src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>






      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-WW6NN2QGKF');
        }
      </script><meta property="og:url" content="https://flecart.github.io/notes/memoria/">
  <meta property="og:site_name" content="X. Angelo Huang&#39;s Blog">
  <meta property="og:title" content="Memoria">
  <meta property="og:description" content="4.1 Caratteristiche della Memoria La gerarchia della memoria, pi√π si va gi√π pi√π spazio si ha, pi√π √® lento il caricamento delle informazioni
4.1.1 Catalogazione della memoria Le tipologie di memoria sono presenti a fianco.
In generale pi√π la memoria √® veloce da riprendere, pi√π √® costosa da memorizzare (c‚Äô√® poco spazio)
4.1.2 Byte e Word Il libro a pagina 74 parte con la discussione del perch√© si √® preferito evitare la BCD (Binary coded decimal, in cui i numeri da 0 a 9 erano codificato da 4 bit), per questioni di efficienza.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="notes">
    <meta property="article:tag" content="üèõComputer-Architecture">
      <meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:title" content="Memoria">
<meta name="twitter:description" content="4.1 Caratteristiche della Memoria

La gerarchia della memoria, pi√π si va gi√π pi√π spazio si ha, pi√π √® lento il caricamento delle informazioni
4.1.1 Catalogazione della memoria
Le tipologie di memoria sono presenti a fianco.
In generale pi√π la memoria √® veloce da riprendere, pi√π √® costosa da memorizzare (c&rsquo;√® poco spazio)

4.1.2 Byte e Word
Il libro a pagina 74 parte con la discussione del perch√© si √® preferito evitare la BCD (Binary coded decimal, in cui i numeri da 0 a 9 erano codificato da 4 bit), per questioni di efficienza.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Memoria",
      "item": "https://flecart.github.io/notes/memoria/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Memoria",
  "name": "Memoria",
  "description": "4.1 Caratteristiche della Memoria La gerarchia della memoria, pi√π si va gi√π pi√π spazio si ha, pi√π √® lento il caricamento delle informazioni\n4.1.1 Catalogazione della memoria Le tipologie di memoria sono presenti a fianco.\nIn generale pi√π la memoria √® veloce da riprendere, pi√π √® costosa da memorizzare (c\u0026rsquo;√® poco spazio)\n4.1.2 Byte e Word Il libro a pagina 74 parte con la discussione del perch√© si √® preferito evitare la BCD (Binary coded decimal, in cui i numeri da 0 a 9 erano codificato da 4 bit), per questioni di efficienza.\n",
  "keywords": [
    "üèõcomputer-architecture"
  ],
  "articleBody": "4.1 Caratteristiche della Memoria La gerarchia della memoria, pi√π si va gi√π pi√π spazio si ha, pi√π √® lento il caricamento delle informazioni\n4.1.1 Catalogazione della memoria Le tipologie di memoria sono presenti a fianco.\nIn generale pi√π la memoria √® veloce da riprendere, pi√π √® costosa da memorizzare (c‚Äô√® poco spazio)\n4.1.2 Byte e Word Il libro a pagina 74 parte con la discussione del perch√© si √® preferito evitare la BCD (Binary coded decimal, in cui i numeri da 0 a 9 erano codificato da 4 bit), per questioni di efficienza.\nLa memoria √®, in modo spiccio, una serie di cellette numerate, ognuno pu√≤ contenere qualche informazione.\nNacque nel 1960 circa con IBM 360 nacque la definizione di byte.\nWord √® una seguenza di byte ‚Üí unit√† di dato che non stanno solamente in un singolo indirizzo.\n4.1.3 Endianess Questi termini descrivono l‚Äôorganizzazione dei bytes all‚Äôinterno della memoria. A volte √® molto conveniente netere i bytes al contrario per facilit√† di accesso.\n4.1.4 RAM Abbiamo presentato il funzionamento hardware della RAM nel momento in cui abbiamo descritto il funzionamento di Circuiti Sequenziali come LATCH SR, D, DFF.\n4.1.5 Paginazione - Caricamento Una altra funzione della gerarchia di memoria √® utilizzare la paginazione, ossia il caricamento di risorse utili nella ram veloce e scaricamento nella memoria secondaria di ci√≤ che non viene utilizzato.\n√à gestito dal sistema operativo.\nSono dei blocchi di data nella memoria principale che vengono caricati nella memoria principale nel momento del bisogno.\nQuindi ci sono proprio degli algoritmi per caricare e scaricare le pagine di memoria dalla memoria principale, gestiti dal sistema operativo.\n4.2 Memoria Cache La cache √® una zona di memoria condivisa alle CPU, di facile accesso (meno facile in confronto ai registri, ma comunque veloce) ma senza molto spazio.\n√à sempre consultata ** prima di andare nella memoria.\nSe va a cercare un word in memoria, questa viene messa nella cache dopo essere ritrovata.\nUna caratteristica principale della cache √® che non √® necessario al programmatore sapere che esiste o meno, √® solo qualcosa che si interpone in modo TRASPARENTE che pu√≤ rispondere subito nel caso possieda una certa informazione.\nMa l‚Äôidea di tenere una memoria pi√π veloce intermedia per dati pi√π utili del prossimo futuro √® una idea che si utilizza anche in altri ambiti (come Disco, accesso messaggi, e simili) e migliora molto la velocit√†.\n4.2.1 Livelli memoria Cache 4.2.2 Principio di localit√† spaziale e temporale Programmi eseguiti vicini nel tempo sono messi in luoghi in memoria vicini\nSi spera di guadagnare tempo in questo modo, cos√¨ √® pi√π facile ritrovare delle informazioni utili quando si eseguono dei comandi vicini nella cache.\nChiaramente se un programma continua a saltare da un indirizzo della memoria a un altro questo principio non ha pi√π senso e la cache servirebbe a poco.\nLocalit√† spaziale e temporale Un programma naturale di solito utilizza la cache (un programma potrebbe essere progettato in modo che usi 0 cache, ma sarebbe uno spreco di risorse).\nTemporale: la stessa cella viene acceduta a breve distanza di tempo (come Stack). Spaziale: celle vicine possono essere prese a breve tempo di distanza. (per esempio accedere ad un array, accesso sequenziale che ha un nome suo di localit√† sequenziale).\n√à molto facile che la cache debba accedere alla stessa risorsa in termini brevi di tempo\nLocalit√† secondo WIKI 4.2.3 Efficienza della cache La velocit√† d‚Äôaccesso alla cache √® di granlunga minore rispetto a quello della memoria, di solito il tempo speso per memorizzare qualcosa qui viene sempre recuperato.\nUsiamo un p√≤ di matematica ora per descrivere questa cosa un pochino pi√π rigorosamente:\n$c \u003c\u003c m$ con $c$ il tempo per accedere alla cache e $m$ il tempo per accedere alla memoria.\nAllora si ha che il tempo medio per accedere alle informazioni, tenendo $h$ come hit rate √® di:\n$$ hc + (1 - h)(c + m) = c + (1-h)m $$4.2.4 Cache ad accesso diretto Linee di cache, vanno k mod n, ogni linea di cache di dimensione m. ok? √à una cosa temporale, a seconda di cosa ci sia ora.\nData: √® effettivamente il data che sto prendendo n √® il numero di linee di cache (che decide quanto grande sia la cache). Tag serve per sapere quale blocco sto utilizzando (quindi se 0-31 oppure 65536 e simili) Valid se √® un blocco valido, se √® 0 vuol dire che non √® roba interessante.\nEsempio di query cache Teniamo 5 bit per l‚Äôindicizzazione dentro i 32 bit di data. 11 bit per sapere quale linea di cache utilizzare 16 bit per confrontare con il tag e vedere se √® giusto oppure no. Cos√¨ riesco a trovare in modo univoco la linea di cache che mi serve. 4.2.5 Cache hit and miss Si dice che si ha un cache hit oppure cache miss a seconda del caso in cui la cache √® riuscita a dare la richiesta oppure meno.\nMiss\nRiportare la cache in memoria centrale in quanto potrebbe essere modificata ora, √® un aggiornamento della roba nella memoria centrale Caricare la nuova memoria. Se per√≤ si tenta di accedere alla cache allo stesso momento, si possono esserci data race e quindi bisognerebbe bloccare l‚Äôaccesso all‚Äôinizio\nSe vuoi approfondire su algoritmi per la gestione della cache:\nhttps://en.wikipedia.org/wiki/Cache-oblivious_algorithm\ne altro ancora\n4.3 Memoria secondaria Storicamente le velocit√† delle CPU si sono sviluppate molto pi√π velocemente rispetto alle memorie secondarie.\n4.3.1 Hard Disk (4) I dischi magnetici oppure Hard disk sono generalmente in tre parti:\nSettore √® il nome di una traccia specifica di memoria di dimensione fissata. Traccia √® una sequenza di bit circolari Testina che magnetizza e modifica il contenuto nel disco. Controllore Disco . Ogni settore comincia con un preamble che dovrebbe aiutare a diminuire gli errori di lettura.\nPer dare un senso, circa in un centimetro di Hard Disk ci possono stare parecchi giga di informazioni.\nI dati posso essere messi in due modi:\nStessa densit√† per angolo (pi√π rientri pi√π hai i dati in modo compatto) Diverso numero di settori (la parte esterna del disco contiene pi√π settori) Processo di recupero di dati:\nLa CPU dice di andare a recuperare un blocco in un certo indirizzo di memoria La testina gira e va fisicamente a recuperare la zona di memoria 4.3.2 SSD SSD or Solid State drive non hanno nessuna parte che si muove quindi sono meno soliti a rompersi meccanicamente, tutto elettronico.\nStoricamente sono state utilizzate per portatili per resistenza ad urti, ma poi si possono utilizzare anche per altro data la loro velocit√† (per minore spazio).\n4.4 RAID https://en.wikipedia.org/wiki/Standard_RAID_levels\nRedundant array of indipendend disks (originariamente inexpensive, per contrapporla a Single Large Expensive Disk ossia SLED, ma poi hanno scoperto che anche RAID costa, LMAO.\n4.4.1 Vantaggi generali Redundant Array of Inexpensive Disks.\nRidurre il gap di efficienza fra CPU e HD Utilizzo di pi√π dischi in contemporanea + lettura di dati Facilit√† di correttezza di dati e verifica errori 4.4.2 6 Tipologie di RAID See Cloud Reliability and Memoria.\nDiminuire di 1 l‚Äôintera lista, perch√© RAID va da 0\nNon redundant data striping (C‚Äô√® solo una copia di dati nel disco) Velocit√†, no info retrieval\nRedundant, c‚Äô√® una copia esatta dei RAID e sono entrambi striped\nC‚Äô√® bisogno di una grande sincronizzazione in quanto i dati sono divisi fra i dischi a livello bit.\nPossono avere solamente una richiesta, a differenza di RAID 1 che pu√≤ gestirne tanti Unico raid mai utilizzato, per√≤ introduce Hamming per la corrrezione!\nUguale al terzo ma c‚Äô√® un bit di parit√† per controllo errori invece che codice hamming, spesso bit di parit√† √® bastato.\nSolo una richiesta A RAID¬†4 setup with dedicated¬†parity¬†disk with each color representing the group of blocks in the respective¬†parity¬†block (a stripe)\nRitornano gli stripe, ma stavolta un intero disco √® utilizzato per verificare che la scrittura √® stata corretta,\n√® brutto se vogliamo scriverci Anche questo utilizzato poco Diagram of a RAID¬†3 setup of six-byte blocks and two¬†parity¬†bytes, shown are two blocks of data in different colors.\nRisolve una lentezza del punto 5 distribuendo le sezioni di controllo sui vari dischi.\nRAID¬†5 layout with each color representing the group of data blocks and associated¬†parity¬†block (a stripe). This diagram shows¬†Left Asynchronous¬†layout\nNon so quale sia la differenza con il 5, per saperlo vai a leggere i raid su Devices OS. In pratica fault tolerance maggiore.\n4.5 Errori Controllare come sono causati gli errori E tipologie di errori\nQuesta parte √® scritta molto meglio in Rappresentazione delle informazioni\ndove si parla di hamming distance e correzione errori.\n4.5.1 Cause degli errori Gli errori possono essere causati da:\nRaggi cosmici provenienti dal sole Vibrazioni fisiche Esistono codici per correggere gli errori, puoi trovare pi√π informazioni qui: Rappresentazione delle informazioni\n4.6 Altri dispositivi 4.6.1 Dischi ottici Un laser va a leggere i pattern di Pit-land e Land-pit, pit-pit presenti sul compact disk.\nI dischi sono sostanzialmente uguali per quanto riguarda l‚Äôencoding di 1 e 0 ma sono diversi per quanto riguarda il materiale impiegato, il raggio impiegato **lo spazio presente fra le varie linee di informazioni (la compattezza dei bit) e simili.\n4.6.2 Output-Input Per gestire tutti i pixel c‚Äô√® la necessit√† di avere architetture molto complicate, circa devono fare update di milioni di pixel in decimi di secondo (altrimenti l‚Äôocchio capisce che c‚Äô√® la distanza)\nCore complessi per la gestione di di milioni di Pixel. Linguaggi di programmazione specifici perch√© pi√π efficienti della CPU per programmi non grafici e.g. Cuda-C. 4.6.3 Bus per dispositivi sono legati tramite BUS, collegamenti elettrici.\nBUS di dati BUS di indirizzi I bus trasportano piccole quantit√† di informazioni. Si possono dividere in sotto-bus.\nI bus si sono evoluti nel tempo, partendo da standard ISA (industry standard architetture) sono state creati moderni bus molto pi√π veloci PCI, PCIe e simili.\nCollegamento con memoria e CPU\nController collega gli attacchi ai dispositivi ai Bus che si collegano all‚Äôunit√† di controllo. (la scrittura sul bus √® controllata dalla CPU) Altri dispositivi parlano direttamente alla memoria DMA mandano e ricevono degli interrupt. (se non usasse interrupt altra soluzione sarebbe continuamente inviare delle richieste per chiedere se sta ancora andando o meno) Direct Memory Access\nDi questo ne parliamo un p√≤ meglio, anche se alla fine √® lo stesso concetto in Note sull‚Äôarchitettura\nPer saperne di pi√π su interrupt e trap\nSarebbe molto inefficiente leggere e inviare continuamente, quindi mettiamo un trasferimento RAM ‚Üí Disco senza passare dalla CPU. Quando finisce il trasferimento il dispositivo invia un Interrupt che viene gestito subito dalla CPU interrompendo il processo corrente, iniziando un interrupt handler che gestisca eventuali errori del dispositivo e informa il sistema operativo che √® finito il processo di I/O. l processo corrente, iniziando un interrupt handler che gestisca eventuali errori del dispositivo e informa il sistema operativo che √® finito il processo di I/O.\n",
  "wordCount" : "1810",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/memoria/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;¬ª&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Memoria
    </h1>
    <div class="post-meta">9 min&nbsp;¬∑&nbsp;Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#41-caratteristiche-della-memoria" aria-label="4.1 Caratteristiche della Memoria">4.1 Caratteristiche della Memoria</a><ul>
                        
                <li>
                    <a href="#411-catalogazione-della-memoria" aria-label="4.1.1 Catalogazione della memoria">4.1.1 Catalogazione della memoria</a></li>
                <li>
                    <a href="#412-byte-e-word" aria-label="4.1.2 Byte e Word">4.1.2 Byte e Word</a></li>
                <li>
                    <a href="#413-endianess" aria-label="4.1.3 Endianess">4.1.3 Endianess</a></li>
                <li>
                    <a href="#414-ram" aria-label="4.1.4 RAM">4.1.4 RAM</a></li>
                <li>
                    <a href="#415-paginazione---caricamento" aria-label="4.1.5 Paginazione - Caricamento">4.1.5 Paginazione - Caricamento</a></li></ul>
                </li>
                <li>
                    <a href="#42-memoria-cache" aria-label="4.2 Memoria Cache">4.2 Memoria Cache</a><ul>
                        
                <li>
                    <a href="#421-livelli-memoria-cache" aria-label="4.2.1 Livelli memoria Cache">4.2.1 Livelli memoria Cache</a></li>
                <li>
                    <a href="#422-principio-di-localit%c3%a0-spaziale-e-temporale" aria-label="4.2.2 Principio di localit√† spaziale e temporale">4.2.2 Principio di localit√† spaziale e temporale</a><ul>
                        
                <li>
                    <a href="#localit%c3%a0-spaziale-e-temporale" aria-label="Localit√† spaziale e temporale">Localit√† spaziale e temporale</a></li></ul>
                </li>
                <li>
                    <a href="#423-efficienza-della-cache" aria-label="4.2.3 Efficienza della cache">4.2.3 Efficienza della cache</a></li>
                <li>
                    <a href="#424-cache-ad-accesso-diretto" aria-label="4.2.4 Cache ad accesso diretto">4.2.4 Cache ad accesso diretto</a></li>
                <li>
                    <a href="#425-cache-hit-and-miss" aria-label="4.2.5 Cache hit and miss">4.2.5 Cache hit and miss</a></li></ul>
                </li>
                <li>
                    <a href="#43-memoria-secondaria" aria-label="4.3 Memoria secondaria">4.3 Memoria secondaria</a><ul>
                        
                <li>
                    <a href="#431-hard-disk-4" aria-label="4.3.1 Hard Disk (4)">4.3.1 Hard Disk (4)</a></li>
                <li>
                    <a href="#432-ssd" aria-label="4.3.2 SSD">4.3.2 SSD</a></li></ul>
                </li>
                <li>
                    <a href="#44-raid" aria-label="4.4 RAID">4.4 RAID</a><ul>
                        
                <li>
                    <a href="#441-vantaggi-generali" aria-label="4.4.1 Vantaggi generali">4.4.1 Vantaggi generali</a></li>
                <li>
                    <a href="#442-6-tipologie-di-raid" aria-label="4.4.2 6 Tipologie di RAID">4.4.2 6 Tipologie di RAID</a></li></ul>
                </li>
                <li>
                    <a href="#45-errori" aria-label="4.5 Errori">4.5 Errori</a><ul>
                        
                <li>
                    <a href="#451-cause-degli-errori" aria-label="4.5.1 Cause degli errori">4.5.1 Cause degli errori</a></li></ul>
                </li>
                <li>
                    <a href="#46-altri-dispositivi" aria-label="4.6 Altri dispositivi">4.6 Altri dispositivi</a><ul>
                        
                <li>
                    <a href="#461-dischi-ottici" aria-label="4.6.1 Dischi ottici">4.6.1 Dischi ottici</a></li>
                <li>
                    <a href="#462-output-input" aria-label="4.6.2 Output-Input">4.6.2 Output-Input</a></li>
                <li>
                    <a href="#463-bus-per-dispositivi" aria-label="4.6.3 Bus per dispositivi">4.6.3 Bus per dispositivi</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="41-caratteristiche-della-memoria">4.1 Caratteristiche della Memoria<a hidden class="anchor" aria-hidden="true" href="#41-caratteristiche-della-memoria">#</a></h2>
<img src="/images/notes/image/universita/ex-notion/Memoria/Untitled.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria/Untitled">
<p>La gerarchia della memoria, pi√π si va gi√π pi√π spazio si ha, pi√π √® lento il caricamento delle informazioni</p>
<h3 id="411-catalogazione-della-memoria">4.1.1 Catalogazione della memoria<a hidden class="anchor" aria-hidden="true" href="#411-catalogazione-della-memoria">#</a></h3>
<p>Le tipologie di memoria sono presenti a fianco.</p>
<p>In generale pi√π la memoria √® veloce da riprendere, pi√π √® costosa da memorizzare (c&rsquo;√® poco spazio)</p>
<img src="/images/notes/image/universita/ex-notion/Memoria/Untitled 1.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria/Untitled 1">
<h3 id="412-byte-e-word">4.1.2 Byte e Word<a hidden class="anchor" aria-hidden="true" href="#412-byte-e-word">#</a></h3>
<p>Il libro a pagina 74 parte con la discussione del perch√© si √® preferito <strong>evitare la BCD</strong> (Binary coded decimal, in cui i numeri da 0 a 9 erano codificato da 4 bit), per questioni di efficienza.</p>
<p>La memoria √®, in modo spiccio, <strong>una serie di cellette numerate</strong>, ognuno pu√≤ contenere qualche informazione.</p>
<p>Nacque nel 1960 circa con IBM 360 nacque la definizione di <strong>byte</strong>.</p>
<p><strong>Word</strong> √® una seguenza di byte ‚Üí unit√† di dato che non stanno solamente in un singolo indirizzo.</p>
<img src="/images/notes/image/universita/ex-notion/Memoria/Untitled 2.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria/Untitled 2">
<h3 id="413-endianess">4.1.3 Endianess<a hidden class="anchor" aria-hidden="true" href="#413-endianess">#</a></h3>
<p>Questi termini descrivono l&rsquo;organizzazione dei bytes all&rsquo;interno della memoria. A volte √® molto conveniente netere i bytes al contrario per facilit√† di accesso.</p>
<h3 id="414-ram">4.1.4 RAM<a hidden class="anchor" aria-hidden="true" href="#414-ram">#</a></h3>
<p>Abbiamo presentato il funzionamento hardware della RAM nel momento in cui abbiamo descritto il funzionamento di <a href="/notes/circuiti-sequenziali">Circuiti Sequenziali</a> come LATCH SR, D, DFF.</p>
<h3 id="415-paginazione---caricamento">4.1.5 Paginazione - Caricamento<a hidden class="anchor" aria-hidden="true" href="#415-paginazione---caricamento">#</a></h3>
<p>Una altra funzione della gerarchia di memoria √® utilizzare la paginazione, ossia il caricamento di risorse utili nella ram veloce e scaricamento nella memoria secondaria di ci√≤ che non viene utilizzato.</p>
<p>√à gestito dal sistema operativo.</p>
<p>Sono dei blocchi di data nella memoria principale che vengono caricati nella memoria principale nel momento del bisogno.</p>
<p>Quindi ci sono proprio degli <strong>algoritmi per caricare e scaricare</strong> le pagine di memoria dalla memoria principale, gestiti dal sistema operativo.</p>
<h2 id="42-memoria-cache">4.2 Memoria Cache<a hidden class="anchor" aria-hidden="true" href="#42-memoria-cache">#</a></h2>
<p>La cache √® una zona di memoria condivisa alle CPU, di facile accesso (meno facile in confronto ai registri, ma comunque veloce) ma senza molto spazio.</p>
<p>√à <em>sempre consultata</em> ** prima di andare nella memoria.</p>
<p>Se va a cercare un word in memoria, questa viene messa nella cache dopo essere ritrovata.</p>
<p>Una caratteristica principale della cache √® che non √® necessario al programmatore sapere che esiste o meno, √® solo <strong>qualcosa che si interpone in modo TRASPARENTE</strong> che pu√≤ rispondere subito nel caso possieda una certa informazione.</p>
<p>Ma l‚Äôidea di tenere una memoria pi√π veloce intermedia per dati pi√π utili del prossimo futuro √® una idea che si utilizza anche in altri ambiti (come Disco, accesso messaggi, e simili) e <strong>migliora molto la velocit√†</strong>.</p>
<h3 id="421-livelli-memoria-cache">4.2.1 Livelli memoria Cache<a hidden class="anchor" aria-hidden="true" href="#421-livelli-memoria-cache">#</a></h3>
<img src="/images/notes/image/universita/ex-notion/Memoria/Untitled 3.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria/Untitled 3">
<img src="/images/notes/image/universita/ex-notion/Memoria/Untitled 4.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria/Untitled 4">
<h3 id="422-principio-di-localit√†-spaziale-e-temporale">4.2.2 Principio di localit√† spaziale e temporale<a hidden class="anchor" aria-hidden="true" href="#422-principio-di-localit√†-spaziale-e-temporale">#</a></h3>
<blockquote>
<p>Programmi eseguiti vicini nel tempo sono messi in luoghi in memoria vicini</p></blockquote>
<p>Si spera di guadagnare tempo in questo modo, cos√¨ √® pi√π facile ritrovare delle informazioni utili quando si eseguono dei comandi vicini nella cache.</p>
<p>Chiaramente se un programma continua a saltare da un indirizzo della memoria a un altro questo principio non ha pi√π senso e la cache servirebbe a poco.</p>
<h4 id="localit√†-spaziale-e-temporale">Localit√† spaziale e temporale<a hidden class="anchor" aria-hidden="true" href="#localit√†-spaziale-e-temporale">#</a></h4>
<p>Un programma naturale di solito utilizza la cache (un programma potrebbe essere progettato in modo che usi 0 cache, ma sarebbe uno spreco di risorse).</p>
<p><strong>Temporale:</strong> la stessa cella viene acceduta a breve distanza di tempo (come Stack).
<strong>Spaziale:</strong> celle vicine possono essere prese a breve tempo di distanza. (per esempio accedere ad un array, accesso sequenziale che ha un nome suo di localit√† sequenziale).</p>
<p>√à molto facile che la cache debba accedere alla stessa risorsa in termini brevi di tempo</p>
<p><strong>Localit√† secondo <a href="https://en.wikipedia.org/wiki/Locality_of_reference">WIKI</a></strong>
<img src="/images/notes/image/universita/ex-notion/Memoria/Untitled 5.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria/Untitled 5"></p>
<h3 id="423-efficienza-della-cache">4.2.3 Efficienza della cache<a hidden class="anchor" aria-hidden="true" href="#423-efficienza-della-cache">#</a></h3>
<p>La velocit√† d&rsquo;accesso alla cache √® di granlunga minore rispetto a quello della memoria, di solito il tempo speso per memorizzare qualcosa qui viene sempre recuperato.</p>
<p>Usiamo un p√≤ di matematica ora per descrivere questa cosa un pochino pi√π rigorosamente:</p>
<p>$c << m$ con $c$ il tempo per accedere alla cache e $m$ il tempo per accedere alla memoria.</p>
<p>Allora si ha che il tempo medio per accedere alle informazioni, tenendo $h$ come <em>hit rate</em> √® di:</p>
$$
hc + (1 - h)(c + m) = c + (1-h)m
$$<h3 id="424-cache-ad-accesso-diretto">4.2.4 Cache ad accesso diretto<a hidden class="anchor" aria-hidden="true" href="#424-cache-ad-accesso-diretto">#</a></h3>
<p>Linee di cache, vanno k mod n, ogni linea di cache di dimensione m. ok? √à una cosa temporale, a seconda di cosa ci sia ora.</p>
<p>Data: √® effettivamente il data che sto prendendo
n √® il numero di linee di cache (che decide quanto grande sia la cache).
Tag serve per sapere quale blocco sto utilizzando (quindi se 0-31 oppure 65536 e simili)
Valid se √® un blocco valido, se √® 0 vuol dire che non √® roba interessante.</p>
<ul>
<li>Esempio di query cache
Teniamo 5 bit per l&rsquo;indicizzazione dentro i 32 bit di data.
11 bit per sapere quale linea di cache utilizzare
16 bit per confrontare con il tag e vedere se √® giusto oppure no.
Cos√¨ riesco a trovare in modo univoco la linea di cache che mi serve.</li>
</ul>
<img src="/images/notes/image/universita/ex-notion/Memoria/Untitled 6.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria/Untitled 6">
<h3 id="425-cache-hit-and-miss">4.2.5 Cache hit and miss<a hidden class="anchor" aria-hidden="true" href="#425-cache-hit-and-miss">#</a></h3>
<p>Si dice che si ha un cache hit oppure cache miss a seconda del caso in cui la cache √® riuscita a dare la richiesta oppure meno.</p>
<p><strong>Miss</strong></p>
<ol>
<li><strong>Riportare la cache in memoria centrale</strong> in quanto potrebbe essere modificata ora, √® un aggiornamento della roba nella memoria centrale</li>
<li><strong>Caricare la nuova memoria</strong>.</li>
</ol>
<p>Se per√≤ si tenta di accedere alla cache allo stesso momento, si possono esserci <strong>data race</strong> e quindi bisognerebbe bloccare l&rsquo;accesso all&rsquo;inizio</p>
<p>Se vuoi approfondire su algoritmi per la gestione della cache:</p>
<p><a href="https://en.wikipedia.org/wiki/Cache-oblivious_algorithm"><a href="https://en.wikipedia.org/wiki/Cache-oblivious_algorithm">https://en.wikipedia.org/wiki/Cache-oblivious_algorithm</a></a></p>
<p>e altro ancora</p>
<h2 id="43-memoria-secondaria">4.3 Memoria secondaria<a hidden class="anchor" aria-hidden="true" href="#43-memoria-secondaria">#</a></h2>
<p>Storicamente le velocit√† delle CPU si sono sviluppate molto pi√π velocemente rispetto alle memorie secondarie.</p>
<h3 id="431-hard-disk-4">4.3.1 Hard Disk (4)<a hidden class="anchor" aria-hidden="true" href="#431-hard-disk-4">#</a></h3>
<p>I dischi magnetici oppure <strong>Hard disk</strong> sono generalmente in tre parti:</p>
<ul>
<li><strong>Settore</strong> √® il nome di una traccia specifica di memoria di dimensione fissata.</li>
<li><strong>Traccia</strong> √® una sequenza di bit circolari</li>
<li><strong>Testina</strong> che magnetizza e modifica il contenuto nel disco.</li>
<li><strong>Controllore Disco</strong> .</li>
</ul>
<p>Ogni settore comincia con un preamble che dovrebbe aiutare a diminuire gli errori di lettura.</p>
<p>Per dare un senso, circa in un centimetro di Hard Disk ci possono stare parecchi giga di informazioni.</p>
<p>I dati posso essere messi in due modi:</p>
<ul>
<li>Stessa densit√† per angolo (pi√π rientri pi√π hai i dati in modo compatto)</li>
<li>Diverso numero di settori (la parte esterna del disco contiene pi√π settori)</li>
</ul>
<p><strong>Processo di recupero di dati:</strong></p>
<ol>
<li>La CPU dice di andare a recuperare un blocco in un certo indirizzo di memoria</li>
<li>La testina gira e va fisicamente a recuperare la zona di memoria</li>
</ol>
<h3 id="432-ssd">4.3.2 SSD<a hidden class="anchor" aria-hidden="true" href="#432-ssd">#</a></h3>
<p><strong>SSD</strong> or Solid State drive non hanno nessuna parte che si muove quindi sono meno soliti a rompersi meccanicamente, <em>tutto elettronico</em>.</p>
<p>Storicamente sono state utilizzate per portatili per resistenza ad urti, ma poi si possono utilizzare anche per altro data la loro velocit√† (per minore spazio).</p>
<h2 id="44-raid">4.4 <strong>RAID</strong><a hidden class="anchor" aria-hidden="true" href="#44-raid">#</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Standard_RAID_levels"><a href="https://en.wikipedia.org/wiki/Standard_RAID_levels">https://en.wikipedia.org/wiki/Standard_RAID_levels</a></a></p>
<p>Redundant array of indipendend disks (originariamente inexpensive, per contrapporla a Single Large Expensive Disk ossia SLED, ma poi hanno scoperto che anche RAID costa, LMAO.</p>
<h3 id="441-vantaggi-generali">4.4.1 Vantaggi generali<a hidden class="anchor" aria-hidden="true" href="#441-vantaggi-generali">#</a></h3>
<p>Redundant Array of Inexpensive Disks.</p>
<ul>
<li>Ridurre il gap di efficienza fra CPU e HD</li>
<li>Utilizzo di pi√π dischi in contemporanea + lettura di dati</li>
<li>Facilit√† di correttezza di dati e verifica errori</li>
</ul>
<h3 id="442-6-tipologie-di-raid">4.4.2 6 Tipologie di RAID<a hidden class="anchor" aria-hidden="true" href="#442-6-tipologie-di-raid">#</a></h3>
<p>See <a href="/notes/cloud-reliability">Cloud Reliability</a> and <a href="/notes/memoria">Memoria</a>.</p>
<p>Diminuire di 1 l&rsquo;intera lista, perch√© RAID va da 0</p>
<p>Non redundant data striping (C&rsquo;√® solo una copia di dati nel disco) <strong>Velocit√†</strong>, no info retrieval</p>
<img src="/images/notes/image/universita/ex-notion/Memoria/Untitled 7.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria/Untitled 7">
<p>Redundant, c&rsquo;√® una copia esatta dei RAID e sono <strong>entrambi striped</strong></p>
<img src="/images/notes/image/universita/ex-notion/Memoria/Untitled 8.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria/Untitled 8">
<p>C&rsquo;√® bisogno di una grande sincronizzazione in quanto i dati sono divisi fra i dischi a livello bit.</p>
<ol>
<li>Possono avere solamente una richiesta, a differenza di RAID 1 che pu√≤ gestirne tanti</li>
</ol>
<img src="/images/notes/image/universita/ex-notion/Memoria/Untitled 9.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria/Untitled 9">
<p>Unico raid mai utilizzato, per√≤ introduce Hamming per la corrrezione!</p>
<p>Uguale al terzo ma c&rsquo;√® un bit di parit√† per controllo errori invece che codice hamming, spesso bit di parit√† √® bastato.</p>
<ol>
<li>Solo una richiesta</li>
</ol>
<p>A RAID¬†4 setup with dedicated¬†<a href="https://en.wikipedia.org/wiki/Parity_bit">parity</a>¬†disk with each color representing the group of blocks in the respective¬†<a href="https://en.wikipedia.org/wiki/Parity_bit">parity</a>¬†block (a stripe)</p>
<p>Ritornano gli stripe, ma stavolta un intero disco √® utilizzato per verificare che la scrittura √® stata corretta,</p>
<ol>
<li>√® brutto se vogliamo scriverci</li>
</ol>
<p>Anche questo utilizzato poco
Diagram of a RAID¬†3 setup of six-byte blocks and two¬†<a href="https://en.wikipedia.org/wiki/Parity_bit">parity</a>¬†bytes, shown are two blocks of data in different colors.</p>
<p>Risolve una lentezza del punto 5 distribuendo le sezioni di controllo sui vari dischi.</p>
<p>RAID¬†5 layout with each color representing the group of data blocks and associated¬†<a href="https://en.wikipedia.org/wiki/Parity_bit">parity</a>¬†block (a stripe). This diagram shows¬†<em>Left Asynchronous</em>¬†layout</p>
<p>Non so quale sia la differenza con il 5, per saperlo vai a leggere i raid su <a href="/notes/devices-os">Devices OS</a>. In pratica fault tolerance maggiore.</p>
<img src="/images/notes/image/universita/ex-notion/Memoria/Untitled 13.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria/Untitled 13">
<h2 id="45-errori">4.5 Errori<a hidden class="anchor" aria-hidden="true" href="#45-errori">#</a></h2>
<p>Controllare come sono causati gli errori
E tipologie di errori</p>
<p>Questa parte √® scritta molto meglio in <a href="/notes/rappresentazione-delle-informazioni">Rappresentazione delle informazioni</a></p>
<p>dove si parla di hamming distance e correzione errori.</p>
<h3 id="451-cause-degli-errori">4.5.1 Cause degli errori<a hidden class="anchor" aria-hidden="true" href="#451-cause-degli-errori">#</a></h3>
<p>Gli errori possono essere causati da:</p>
<ul>
<li>Raggi cosmici provenienti dal sole</li>
<li>Vibrazioni fisiche</li>
</ul>
<p>Esistono codici per correggere gli errori, puoi trovare pi√π informazioni qui: <a href="/notes/rappresentazione-delle-informazioni">Rappresentazione delle informazioni</a></p>
<h2 id="46-altri-dispositivi">4.6 Altri dispositivi<a hidden class="anchor" aria-hidden="true" href="#46-altri-dispositivi">#</a></h2>
<h3 id="461-dischi-ottici">4.6.1 Dischi ottici<a hidden class="anchor" aria-hidden="true" href="#461-dischi-ottici">#</a></h3>
<p>Un laser va a leggere i pattern di Pit-land e Land-pit, pit-pit presenti sul compact disk.</p>
<p>I dischi sono sostanzialmente uguali per quanto riguarda l&rsquo;encoding di 1 e 0 ma sono diversi per quanto riguarda <em>il materiale impiegato</em>, il raggio impiegato **lo spazio presente fra le varie linee di informazioni (la compattezza dei bit) e simili.</p>
<img src="/images/notes/image/universita/ex-notion/Memoria/Untitled 14.png" style="width: 100%" class="center" alt="image/universita/ex-notion/Memoria/Untitled 14">
<h3 id="462-output-input">4.6.2 Output-Input<a hidden class="anchor" aria-hidden="true" href="#462-output-input">#</a></h3>
<p>Per gestire tutti i pixel c&rsquo;√® la necessit√† di avere architetture molto complicate, circa devono fare update di milioni di pixel in decimi di secondo (altrimenti l&rsquo;occhio capisce che c&rsquo;√® la distanza)</p>
<ul>
<li>Core complessi per la gestione di di milioni di Pixel.</li>
<li>Linguaggi di programmazione specifici perch√© pi√π efficienti della CPU per programmi non grafici e.g. Cuda-C.</li>
</ul>
<h3 id="463-bus-per-dispositivi">4.6.3 Bus per dispositivi<a hidden class="anchor" aria-hidden="true" href="#463-bus-per-dispositivi">#</a></h3>
<p>sono legati tramite BUS, collegamenti elettrici.</p>
<ul>
<li>BUS di dati</li>
<li>BUS di indirizzi</li>
</ul>
<p>I bus trasportano piccole quantit√† di informazioni. Si possono dividere in <strong>sotto-bus.</strong></p>
<p>I bus si sono evoluti nel tempo, partendo da standard ISA (industry standard architetture) sono state creati moderni bus molto pi√π veloci PCI, PCIe e simili.</p>
<p><strong>Collegamento con memoria e CPU</strong></p>
<ul>
<li>Controller collega gli attacchi ai dispositivi ai Bus che si collegano all&rsquo;unit√† di controllo. (la scrittura sul bus √® controllata dalla CPU)</li>
<li>Altri dispositivi parlano direttamente alla memoria <strong>DMA</strong> mandano e ricevono degli interrupt. (se non usasse interrupt altra soluzione sarebbe continuamente inviare delle richieste per chiedere se sta ancora andando o meno)</li>
</ul>
<p><strong>Direct Memory Access</strong></p>
<p>Di questo ne parliamo un p√≤ meglio, anche se alla fine √® lo stesso concetto in <a href="/notes/note-sull‚Äôarchitettura">Note sull‚Äôarchitettura</a></p>
<p>Per saperne di pi√π su interrupt e trap</p>
<p>Sarebbe molto inefficiente leggere e inviare continuamente, quindi mettiamo un trasferimento RAM ‚Üí Disco senza passare dalla CPU. Quando finisce il trasferimento il dispositivo invia un <strong>Interrupt</strong> che viene gestito subito dalla CPU interrompendo il processo corrente, iniziando un <strong>interrupt handler</strong> che gestisca eventuali errori del dispositivo e informa il sistema operativo che √® finito il processo di I/O.
l processo corrente, iniziando un <strong>interrupt handler</strong> che gestisca eventuali errori del dispositivo e informa il sistema operativo che √® finito il processo di I/O.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/computer-architecture/">üèõComputer-Architecture</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Memoria on x"
            href="https://x.com/intent/tweet/?text=Memoria&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fmemoria%2f&amp;hashtags=%f0%9f%8f%9bcomputer-architecture">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Memoria on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fmemoria%2f&amp;title=Memoria&amp;summary=Memoria&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2fmemoria%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Memoria on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2fmemoria%2f&title=Memoria">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Memoria on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2fmemoria%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Memoria on whatsapp"
            href="https://api.whatsapp.com/send?text=Memoria%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2fmemoria%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Memoria on telegram"
            href="https://telegram.me/share/url?text=Memoria&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fmemoria%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Memoria on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Memoria&u=https%3a%2f%2fflecart.github.io%2fnotes%2fmemoria%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span> ¬∑ 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
