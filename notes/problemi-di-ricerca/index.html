<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Problemi di ricerca | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="no-tags">
<meta name="description" content="Ripasso Prox: 36 Ultima modifica: December 29, 2022 3:24 PM Primo Abbozzo: June 30, 2022 2:38 PM Stato: üåïüåïüåïüåïüåó Studi Personali: No
Elementi di ripasso September 10, 2022
Mi sono scordato gli stati possibili. Quasi niente sulla ricerca per algoritmi non deterministici e non osservabili. 2 Problemi di ricerca In questa prima parte si tratta di ricerca semplice, ossia si utilizza un modello basato su obiettivi, di struttura atomica, in un ambiente che risulti singolo-agente, episodico, totalmente osservabile, deterministico, statico, discreto, conosciuto.">
<meta name="author" content="Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="https://flecart.github.io/notes/problemi-di-ricerca/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/problemi-di-ricerca/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>


<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-WW6NN2QGKF', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Problemi di ricerca" />
<meta property="og:description" content="Ripasso Prox: 36 Ultima modifica: December 29, 2022 3:24 PM Primo Abbozzo: June 30, 2022 2:38 PM Stato: üåïüåïüåïüåïüåó Studi Personali: No
Elementi di ripasso September 10, 2022
Mi sono scordato gli stati possibili. Quasi niente sulla ricerca per algoritmi non deterministici e non osservabili. 2 Problemi di ricerca In questa prima parte si tratta di ricerca semplice, ossia si utilizza un modello basato su obiettivi, di struttura atomica, in un ambiente che risulti singolo-agente, episodico, totalmente osservabile, deterministico, statico, discreto, conosciuto." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://flecart.github.io/notes/problemi-di-ricerca/" />
<meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png" />
<meta property="article:section" content="notes" />



<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png" />
<meta name="twitter:title" content="Problemi di ricerca"/>
<meta name="twitter:description" content="Ripasso Prox: 36 Ultima modifica: December 29, 2022 3:24 PM Primo Abbozzo: June 30, 2022 2:38 PM Stato: üåïüåïüåïüåïüåó Studi Personali: No
Elementi di ripasso September 10, 2022
Mi sono scordato gli stati possibili. Quasi niente sulla ricerca per algoritmi non deterministici e non osservabili. 2 Problemi di ricerca In questa prima parte si tratta di ricerca semplice, ossia si utilizza un modello basato su obiettivi, di struttura atomica, in un ambiente che risulti singolo-agente, episodico, totalmente osservabile, deterministico, statico, discreto, conosciuto."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Problemi di ricerca",
      "item": "https://flecart.github.io/notes/problemi-di-ricerca/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Problemi di ricerca",
  "name": "Problemi di ricerca",
  "description": "Ripasso Prox: 36 Ultima modifica: December 29, 2022 3:24 PM Primo Abbozzo: June 30, 2022 2:38 PM Stato: üåïüåïüåïüåïüåó Studi Personali: No\nElementi di ripasso September 10, 2022\nMi sono scordato gli stati possibili. Quasi niente sulla ricerca per algoritmi non deterministici e non osservabili. 2 Problemi di ricerca In questa prima parte si tratta di ricerca semplice, ossia si utilizza un modello basato su obiettivi, di struttura atomica, in un ambiente che risulti singolo-agente, episodico, totalmente osservabile, deterministico, statico, discreto, conosciuto.",
  "keywords": [
    "no-tags"
  ],
  "articleBody": "Ripasso Prox: 36 Ultima modifica: December 29, 2022 3:24 PM Primo Abbozzo: June 30, 2022 2:38 PM Stato: üåïüåïüåïüåïüåó Studi Personali: No\nElementi di ripasso September 10, 2022\nMi sono scordato gli stati possibili. Quasi niente sulla ricerca per algoritmi non deterministici e non osservabili. 2 Problemi di ricerca In questa prima parte si tratta di ricerca semplice, ossia si utilizza un modello basato su obiettivi, di struttura atomica, in un ambiente che risulti singolo-agente, episodico, totalmente osservabile, deterministico, statico, discreto, conosciuto.\n2.1 Il problema Vogliamo cercare di enunciare in un modo che possa essere formale, senza nessuna ambiguit√† il concetto di problema di ricerca.\n2.1.1 Framework di soluzione Individuiamo 4 fasi principali per un problema di ricerca, questo √® un framework molto generico.\nFormulazione dell‚Äôobiettivo (si cerca di individuare l‚Äôobiettivo della nostra ricerca). Individuazione del problema (in cui si va a trascrivere il problema utilizzando una impostazione formale, solitamente astraendo dettagli non interessanti, il formato √® descritto subito dopo nella sezione articolazione) Ricerca della soluzione (in cui si cerca una effettiva soluzione per il problema di ricerca, probabilmente √® la parte pi√π dispendiosa di algoritmica). esecuzione della soluzione (in cui gli attuatori eseguino la soluzione del problema trovato) 2.1.2 Articolazione Vogliamo cercare di formalizzare il problema di ricerca nel modo pi√π chiaro possibile, lo facciamo separando le funzioni e dati necessari per definire tutti gli aspetti di un problema di ricerca:\nStati possibili Stato iniziale Stati obiettivo Funzione di azioni (da quale stato posso muovermi a quale stato) Funzione di costo (il movimento da questo stato a quello quanto mi costa ?) Funzione di transizione (mi muovo da uno stato all‚Äôaltro) 2.1.3 Problemi standarizzati e reali Questi problemi sono standarizzati proprio perch√© rappresentano un modello su cui comparare altre soluzioni che verranno in seguito sviluppate. Sono un cardine per vedere l‚Äôefficienza di una propria soluzione, e simili.\nInvece i problemi reali possono avere una formulazione vaga, che cio√® √® dipendente dal contesto, o comunque da ci√≤ che sia necessario al momento.\nEsempi di standard problems:\n15/8 tile problem Knuth factorial problem (partendo da 4, e applicando fattoriale e radici, si pu√≤ fare qualunque numero) Esempi problemi reali\nTravelling salesman Chip VSLI 2.2 Note generali 2.2.1 Percorsi ridondanti Possiamo andare a definire un percorso ridondante, ogni percorso per cui se togli una tappa, il costo √® minore (ricordiamo che in questo libro parliamo sempre di percorsi con un peso positivo), quindi ridondanti sono cicli, o percorsi con qualche tappa in pi√π. Si pu√≤ considerare come se fosse un concetto pi√π generale di ciclo questo.\nOvviare alle ridondanze\nNon vogliamo trovare percorsi che siano alla fine ridondati, vogliamo in qualche modo ricordare il nostro percorso:\nAvere una tavola che ci dica se abbiamo gi√† fatto quel percorso o meno Avere una struttura, o formulazione del problema che non abbia questo problema di ridondanze (ad esempio una ricerca tipo-albero) Ovviare solo ai cicli, e non alle ridondanze in generale, come vi adi mezzo. 2.2.2 Valutazione dell‚Äôalgoritmo In generale si valuta l‚Äôalgoritmo secondo le risorse utilizzate, nel caso della ricerca in AI potrebbe essere il costo in soldi e in carburante, oltre alla classica memoria e tempo. Si propongono quindi 4 valori su cui valutare ci√≤:\nCompletezza (se esiste una soluzione perfetta la trovo sempre? Se non esiste so che non c‚Äô√®?) Ottimalit√† del costo della soluzione (es soldi etc). Costo in tempo Costo in memoria Di particolare interesse sarebbe valutare la completezza dell‚Äôalgoritmo.\n2.3 Algoritmi disinformati Pseudocodice best-first-search\n2.3.1 Perch√© sono disinformati Chiamiamo questi algoritmi come disinformati perch√© non hanno idea di come √® fatta la struttura del campo di ricerca.\nIn pratica cercano con informazioni fortemente limitate sulla topologia del proprio ambiente.\nDirei che vadano a cercare valutando solamente il costo, o indiscretamente nodi quasi casuali dell‚Äôambiente circostante.\n2.3.2 Carrellata di algos Non mi √® piaciuto molto questa parte, perch√© la maggior parte degli algoritmi esposti √® presente nel corso di Algoritmi e Strutture fanno all‚Äôuni.\nBFS DFS Dept-limited dfs Dijkstra/uniform-cost-search Iterative deepening 2.4 Algoritmi informati Questi algoritmi informati sono molto pi√π interessanti rispetto agli algoritmi scorsi, per cui ne diamo pi√π larga discussione\nIl fatto che siano informati ci sta a significare soltanto che utilizzano un euristica per decidere meglio in che modo espandersi.\n2.4.1 Euristiche Bisogna cercare di definire in modo migliore le caratteristiche che ci potrebbero interessare delle euristiche: euristica ammissibile significa che la funzione di euristica √® sempre minore del costo effettivo.\nConsistente invece √® in pratica soltanto una forma della disuguaglianza triangolare.\nTrovare un euristica √® come risolvere una versione pi√π rilassata del problema, questa √® una delle osservazioni fondamentali per quando si va a trattare di euristiche.\nAltre soluzioni possibili sono Landmarks e pattern databases di cui rispettivamente i primi sono dei punti cardine, in cui si calcola tutto passando prima di quelli (come se mi chiedessi tipo: quanto ci metto se per andare da A a C, passo prima per il landmark B?) prima si calcolano questi landmark e si prendono decisioni in funzione di quanto mi danno ci√≤.\nI pattern databases sono solamente un modo per cercare soluzioni gi√† precomputate di pattern che ci sono solito. Si √® utilizzato un pattern database per 8-puzzle e funzionava distintamente bene.\nContours\nCome se fossero dei piano di livello di una montagna, anche per dijkstra si potrebbe disegnare un contour, ci indica in pratica in modo semplice in che modo si sta espandendo l‚Äôalgoritmo di ricerca.\n2.4.2 Carrellata algoritmi informati quella pi√π bella, usata in tutte le salse √® l‚Äôalgoritmo di A* Search, che in pratica √® un uniform cost search, che invece di utilizzare solamente la funzione costo g(n) che rappresenta quanto effettivamente si paga per raggiungere il nodo n, tiene in considerazione anche una funzione h(n) che cerca di stimare il costo da n a un goal.\nUna variante studiata √® il greedy-first-search che praticamente tiene in conto solamente dell‚Äôeuristica, senza la funzione di costo.\nAltre varianti come WEIGHTED A* search applicano un fattore di peso sull‚Äôeuristica, spesso rendendola non ammissibile o perfino inconsistente (non ho capito bene in che modo l‚Äôammissibilit√† e la consistenza modificano le caratteristiche dell‚Äôeuristica).\nTecniche che tengono molto in conto la memoria\nAltre studiate possono essere la RBFS (Recursive best first search, che √® simile a un MINIMAX con pruning, ma singolo agente, in pratica si espande sempre il nodo migliore, tenendo in conto il secondo valore migliore tra questi vicini, io continuo ad esplorare in profondit√† finch√© non mi converrebbe di pi√π cominciare ad esplorare qualcosa a un livello molto meno profondo).\nOppure la SMA* la simple memory A star, che in pratica tiene in considerazione un numero massimo di nodi in memoria, se nel momento in cui va ad espandere lo ha finito, rimuove il nodo pi√π vecchio, tenendo per√≤ un informazione riguardo quando costava esplorare quella via. (questo comunque pu√≤ condurre a problemi simili al thrashing, in cui continua a switchare percorsi, restando cos√¨ quasi bloccato).\nBEAM SEARCH va in modo molto focalizzato verso una direzione sviluppando solamente i primi k nodi migliori sulla frontiera, invece A* si sviluppa nel suo territorio (quindi ++ sui contorni)\n2.5 Interesse stato finale In questi problemi non ci importa pi√π di avere un percorso che ci porta alla soluzione, ma solamente la soluzione stessa. Non ci conviene pi√π utilizzare gli algoritmi di ricerca presentati al capitolo precedente in Problemi di ricerca. Quindi si sono sviluppati algoritmi che si comportassero bene per massimizzare anche gli obiettivi di questi.\nTermini importanti per parlare di questi ambienti:\nMassimo locale Ridge (che rende algoritmi greedy molto difficili da essere efficienti) Plateau, parti piatte 2.5.1 Hill Climbing Hill Climb in breve (pseudoalgo)\nQuesto √® uno degli algoritmi pi√π semplici per quanto riguarda la ricerca in questi ambienti, l‚Äôidea principale √® scegliere il migliore fra i propri successori, e seguire quella strada finch√© si pu√≤ migliorare.\nIl problema principale √® che questa versione semplice di Hill Climbing si blocca molto facilmente su minimi locali, o piani. Poi l‚Äôambiente di Ridge √® una cosa di difficilissima navigazione.\nQuindi si sono inventati variazioni che tentavano di risolvere questo problema:\nRandom restart, ricominciare da un punto random, prendendo alla fine la migliore fra tutte Local beam search, in cui si tengono ogni step i k migliori successori fra i k punti iniziali. Stochastic local beam search in cui randomicamente si considerano alcuni nodi anche lontani rispetto a questi, per cercare di sfavorire il fatto che tutti i punti migliori si ammassino su uno stesso punto. Stochastic hill climbing, in cui in cui si seleziona un punto a caso, e lo si segue sempre se √® migliore, e solo a volte se √® peggiore Simulated Annealing in cui la probabilit√† di scegliere il punto peggiore dall‚Äôaltra parte scende col tempo, con una funzione che decade esponenzialmente. 2.5.2 Algoritmi genetici Pseudoalgo\nLe caratteristiche generali di un algoritmo genetico sono in breve queste:\nDimensione della popolazione Rappresentazione della stringa genetica in caratteristiche della popolazione Funzione scelta dei n elementi pi√π adatti tra la popolazione Generazione di un figlio da coppie, o singola persona, o anche pi√π persone di queste. (crossover) Mutazione randomica di caratteri cos√¨ generati Elitismo o abbattimento di individui non adatti (a volte aiuta a velocizzare il processo). Ripetizione di ci√≤ fino a tempo finito o caratteristiche cercate trovate. La differenza principale con lo stochastic local beam search √® il momento di generazione di un nodo successore, che in questo caso, in quanto giustificato dalla biologica, o almeno da una forma contorta di biologia perch√© io personalmente credo che sia una forma eccessivamente semplificata, nonostante riconosco che √® un buon punto di partenza) √® generata da una ricombinazione di pi√π individui.\nSCHEMAS\nSi √® notato nel tempo (e lo si √® anche dimostrato) che gli algoritmi genetici hanno un senso solo se pattern vicini codificano informazioni importanti cio√® se i caratteri vicini non hanno nessuna relazione, √® totalmente inutile utilizzare un algoritmo genetico.\nPoi si √® notato che se un pattern specifico aiuta il progenito a sopravvivere, effettivamente √® probabile che si mandi alla generazione successiva. Ciononostante √® doveroso tenere a mente che non tutti i pattern necessari vengono trasferiti, e non tutti i pattern inutili vengono eliminati, leggere l‚Äôapprofondimento in biologia a pagina 136 dell‚Äôedizione cartacea che possiedi.\n2.5.3 In ambienti continui Se l‚Äôambiente √® continuo, √® di gran lunga di pi√π di interesse matematico. Si pu√≤ vedere come un problema di calcolo numerico nella ricerca di un punto di minimo come il Newton-Raphson-method, che si pu√≤ estendere anche a pi√π dimensioni.\nOppure si pu√≤ vedere come un problema di ottimizzazione-constrained, che si pu√≤ risolvere con programmazione lineare, cose che riguardano analisi di superfici convesse. In pratica idee e cose altamente tecniche che non conosco ancora.\nL‚Äôidea principale di questa parte comunque resta il fatto che si pu√≤ discretizzare l‚Äôambiente continuo, o cercando di aggiornarlo con passi piccoli, delta alla volta, in ogni direzione, o campionando lo spazio, dividendolo in tanti quadrettini lunghi delta, alla fine credo che questi approcci siano equivalenti.\n2.6 non-deterministiche e not-fully observable Introduciamo ora il concetto di belief state ossia una rappresentazione interna degli stati possibili dell‚Äôambiente. Per gli algoritmi presentati in Problemi di ricerca ogni singolo stato esterno corrispondeva lo stato di belief state interno, ossia c‚Äôera una corrispondenza, invece in questo caso andiamo a rilassare questo assunto, il determinismo, ossia il fatto che a una singola azione vada a corrispondere un singolo stato, ossia andiamo a dire che a singola azione, possono risultare una serie di stati differenti, maggiori di 1.\n2.6.1 And-Or tree (non-det) Con la possibilit√† di avere pi√π stati a seguito di una singola azione cerchiamo di dividere cose che sono sotto il controllo dell‚Äôagente e cosa non lo √®\nOR-node, √® una cosa che dipende dall‚Äôazione dell‚Äôagente AND-node, √® una cosa che dipende dalla reazione dell‚Äôambiente in seguito ad azioni dell‚Äôagente. Avendo questi due tipologie di nodi, possiamo andare a rappresentare l‚Äôintero ambiente attraverso un albero, per cui si possono utilizzare gli algoritmi di trasverse di alberi per trovare una soluzione che ora chiamiamo piano condizionale in quanto sar√† constituito da un array di azioni, nel caso si √® andato su un or-node, oppure di if-then, nel caso si stia andando avanti per un and-node.\nNota: soluzioni cicliche\nA volte converrebbe cercare di ragionare sui motivi della non-determinatezza perch√© in questo modo sappiamo se una soluzione ciclica, ossia una soluzione che ha per foglie solamente un obiettivo, ma nel suo percorso pu√≤ avere anche delle foglie che vadano in loop, sia effettivamente una soluzione: ossia il non-raggiungimento sia dovuto al caso, oppure a una sistematicit√† dell‚Äôambiente in cui si √® presenti.\n2.6.2 Osservabilit√† parziale Un aspetto che colpisce √® che in ambienti in cui l‚Äôosservabilit√† √® parziale, si possono ricavare delle informazioni semplicemente muovendosi, non per forza stando ad osservare l‚Äôambiente! diciamo in questo caso che lo stato √® coerced\nPer ricondurci da tale ambiente a un problema di ricerca trattato in Problemi di ricerca, possiamo fare una cosa molto simile a quanto √® fatto per Non-deterministic automata convertito a deterministic automata, ossia si ha una esplosione esplonenziale, ma comunque ben definita degli stati e delle funzioni di transizione che li legano.\nRicerca incrementale\nA volte conviene, invece di esplorare tutto insieme, come fa il non-determinismo, causando computazioni impraticabili, di provare a cercare una soluzione in via incrementale, buildando prima una soluzione che funzioni per un nodo, poi per il secondo, cambiando leggermente la soluzione trovata, e poi via.\nSi ha il risultato di trovare una soluzione o una assenza di essa in modo molto veloce.\n2.6.3 Percezione nell‚Äôosservabilit√† parziale Essendo un ambiente parzialmente osservabile, possiamo dare per scontato che esista una funzione Perceipt(state) che restituisce un insieme di stati osservati. Questa √® una funzione stretttamente legata all‚Äôambiente in cui agisce l‚Äôagente.\nAllora in un ambiente non-deterministico ad osservabilit√† parziale dovremmo approfondire la funzione di transizione, che non si pu√≤ considerare pi√π l‚Äôunione o l‚Äôintersezione dell‚Äôazione che viene applicata a tutti gli stati, ma qualcosa di meno perch√© deve prendere in conto anche la percezione (ad ogni azione corrisponde uno stato che corrisponde subito una percezione).\nLa dividiamo in 3 parti\nPredizione di quello che succede se applico l‚Äôazione a (ritorna un insieme di stati possiibili) Percezioni possibili lista delle percezioni possibili per tutti gli stati raggiunti. Aggiornamento degli stati di belief a un sottoinsieme a seconda degli stati raggiunti e delle percezioni possibili. In questo modo si forma sempre un albero di ricerca, di azioni non-deterministiche.\n2.6.4 Ricerca online La ricerca online ci fa avvicinare a come sia l‚Äôesplorazione in un mondo vero, in pratica ora lo stato del mondo √® dinamico, e dipende dalla presenza fisica dell‚Äôagente osservatore che non pu√≤ pi√π saltare da un nodo o un altro, oltre al fatto che lo stato pu√≤ cambiare anche se non sta facendo niente. (c‚Äô√® un problema riguardo punti di non ritorno, in cui le azioni sono irreversibili, ma questo lo tratteremo in capitolo seguenti).\nPseudocodice per DFS-online\nLa cosa stupida di questo algoritmo √® che non conosce le azioni che pu√≤ fare in un determinato stato, e potrebbe ripetere azioni che si cancellano fra di loro (es. UP e DOWN uno di seguito all‚Äôaltro). Le azioni qui dipendono dallo stato in cui si √® presenti!\nHill Climbing online (LRTA)*\nUn osservazione che si √® fatto con la DFS √® che ora si ha un oggetto fisico che si sposta, e non pu√≤ fare voli dall‚Äôaltra parte del labirinto per vedere come si sviluppa quel nodo di ricerca, per questo motivo possiamo affermare che c‚Äô√® bisogno di un algoritmo di ricerca locale, questo era HILL CLIMBING!\nMa avevamo discusso in precedenza che si poteva bloccare molto facilmente questo algoritmo! Ma non possiamo pi√π utilizzare random restart, dato che non esiste il teletrasporto, allora utilizziamo il random walk, in modo randomico scegli una direzione e la esplori.\nQuesta cosa adattata con anche una euristica che ti direzioni verso la parte giusta diventa un LRTA\nPseudocodice Learning RealTime A*\nIn pratica riaggiorna l‚Äôeuristica del costo a seconda delle proprie mosse.\n",
  "wordCount" : "2662",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/problemi-di-ricerca/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;¬ª&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Problemi di ricerca
    </h1>
    <div class="post-meta">13 min&nbsp;¬∑&nbsp;Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#elementi-di-ripasso" aria-label="Elementi di ripasso">Elementi di ripasso</a></li>
                <li>
                    <a href="#2-problemi-di-ricerca" aria-label="2 Problemi di ricerca">2 Problemi di ricerca</a><ul>
                        
                <li>
                    <a href="#21-il-problema" aria-label="2.1 Il problema">2.1 Il problema</a><ul>
                        
                <li>
                    <a href="#211-framework-di-soluzione" aria-label="2.1.1 Framework di soluzione">2.1.1 Framework di soluzione</a></li>
                <li>
                    <a href="#212-articolazione" aria-label="2.1.2 Articolazione">2.1.2 Articolazione</a></li>
                <li>
                    <a href="#213-problemi-standarizzati-e-reali" aria-label="2.1.3 Problemi standarizzati e reali">2.1.3 Problemi standarizzati e reali</a></li></ul>
                </li>
                <li>
                    <a href="#22-note-generali" aria-label="2.2 Note generali">2.2 Note generali</a><ul>
                        
                <li>
                    <a href="#221-percorsi-ridondanti" aria-label="2.2.1 Percorsi ridondanti">2.2.1 Percorsi ridondanti</a></li>
                <li>
                    <a href="#222-valutazione-dellalgoritmo" aria-label="2.2.2 Valutazione dell&rsquo;algoritmo">2.2.2 Valutazione dell&rsquo;algoritmo</a></li></ul>
                </li>
                <li>
                    <a href="#23-algoritmi-disinformati" aria-label="2.3 Algoritmi disinformati">2.3 Algoritmi disinformati</a><ul>
                        
                <li>
                    <a href="#231-perch%c3%a9-sono-disinformati" aria-label="2.3.1 Perch√© sono disinformati">2.3.1 Perch√© sono disinformati</a></li>
                <li>
                    <a href="#232-carrellata-di-algos" aria-label="2.3.2 Carrellata di algos">2.3.2 Carrellata di algos</a></li></ul>
                </li>
                <li>
                    <a href="#24-algoritmi-informati" aria-label="2.4 Algoritmi informati">2.4 Algoritmi informati</a><ul>
                        
                <li>
                    <a href="#241-euristiche" aria-label="2.4.1 Euristiche">2.4.1 Euristiche</a></li>
                <li>
                    <a href="#242-carrellata-algoritmi-informati" aria-label="2.4.2 Carrellata algoritmi informati">2.4.2 Carrellata algoritmi informati</a></li></ul>
                </li>
                <li>
                    <a href="#25-interesse-stato-finale" aria-label="2.5 Interesse stato finale">2.5 Interesse stato finale</a><ul>
                        
                <li>
                    <a href="#251-hill-climbing" aria-label="2.5.1 Hill Climbing">2.5.1 Hill Climbing</a></li>
                <li>
                    <a href="#252-algoritmi-genetici" aria-label="2.5.2 Algoritmi genetici">2.5.2 Algoritmi genetici</a></li>
                <li>
                    <a href="#253-in-ambienti-continui" aria-label="2.5.3 In ambienti continui">2.5.3 In ambienti continui</a></li></ul>
                </li>
                <li>
                    <a href="#26-non-deterministiche-e-not-fully-observable" aria-label="2.6 non-deterministiche e not-fully observable">2.6 non-deterministiche e not-fully observable</a><ul>
                        
                <li>
                    <a href="#261-and-or-tree-non-det" aria-label="2.6.1 And-Or tree (non-det)">2.6.1 And-Or tree (non-det)</a></li>
                <li>
                    <a href="#262-osservabilit%c3%a0-parziale" aria-label="2.6.2 Osservabilit√† parziale">2.6.2 Osservabilit√† parziale</a></li>
                <li>
                    <a href="#263-percezione-nellosservabilit%c3%a0-parziale" aria-label="2.6.3 Percezione nell‚Äôosservabilit√† parziale">2.6.3 Percezione nell‚Äôosservabilit√† parziale</a></li>
                <li>
                    <a href="#264-ricerca-online" aria-label="2.6.4 Ricerca online">2.6.4 Ricerca online</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Ripasso Prox: 36
Ultima modifica: December 29, 2022 3:24 PM
Primo Abbozzo: June 30, 2022 2:38 PM
Stato: üåïüåïüåïüåïüåó
Studi Personali: No</p>
<h1 id="elementi-di-ripasso">Elementi di ripasso<a hidden class="anchor" aria-hidden="true" href="#elementi-di-ripasso">#</a></h1>
<p>September 10, 2022</p>
<ul>
<li>Mi sono scordato gli stati possibili.</li>
<li>
<ul>
<li>Quasi niente sulla ricerca per algoritmi non deterministici e non osservabili.</li>
</ul>
</li>
</ul>
<h1 id="2-problemi-di-ricerca">2 Problemi di ricerca<a hidden class="anchor" aria-hidden="true" href="#2-problemi-di-ricerca">#</a></h1>
<p>In questa prima parte si tratta di ricerca semplice, ossia si utilizza un modello basato su obiettivi, di struttura atomica, in un ambiente che risulti singolo-agente, episodico, totalmente osservabile, deterministico, statico, discreto, conosciuto.</p>
<h2 id="21-il-problema">2.1 Il problema<a hidden class="anchor" aria-hidden="true" href="#21-il-problema">#</a></h2>
<p>Vogliamo cercare di enunciare in un modo che possa essere formale, senza nessuna ambiguit√† il concetto di problema di ricerca.</p>
<h3 id="211-framework-di-soluzione">2.1.1 Framework di soluzione<a hidden class="anchor" aria-hidden="true" href="#211-framework-di-soluzione">#</a></h3>
<p>Individuiamo 4 fasi principali per un problema di ricerca, questo √® un framework molto generico.</p>
<ol>
<li>Formulazione dell&rsquo;obiettivo (si cerca di individuare l&rsquo;obiettivo della nostra ricerca).</li>
<li>Individuazione del problema (in cui si va a trascrivere il problema utilizzando una impostazione formale, solitamente astraendo dettagli non interessanti, il formato √® descritto subito dopo nella sezione articolazione)</li>
<li>Ricerca della soluzione (in cui si cerca una effettiva soluzione per il problema di ricerca, probabilmente √® la parte pi√π dispendiosa di algoritmica).</li>
<li>esecuzione della soluzione (in cui gli attuatori eseguino la soluzione del problema trovato)</li>
</ol>
<h3 id="212-articolazione">2.1.2 Articolazione<a hidden class="anchor" aria-hidden="true" href="#212-articolazione">#</a></h3>
<p>Vogliamo cercare di formalizzare il problema di ricerca nel modo pi√π chiaro possibile, lo facciamo separando le funzioni e dati necessari per definire tutti gli aspetti di un problema di ricerca:</p>
<ol>
<li>Stati possibili</li>
<li>Stato iniziale</li>
<li>Stati obiettivo</li>
<li>Funzione di azioni (da quale stato posso muovermi a quale stato)</li>
<li>Funzione di costo (il movimento da questo stato a quello quanto mi costa ?)</li>
<li>Funzione di transizione (mi muovo da uno stato all&rsquo;altro)</li>
</ol>
<h3 id="213-problemi-standarizzati-e-reali">2.1.3 Problemi standarizzati e reali<a hidden class="anchor" aria-hidden="true" href="#213-problemi-standarizzati-e-reali">#</a></h3>
<p>Questi problemi sono standarizzati proprio perch√© rappresentano un modello su cui comparare altre soluzioni che verranno in seguito sviluppate. Sono un cardine per vedere l&rsquo;efficienza di una propria soluzione, e simili.</p>
<p>Invece i problemi reali possono avere una formulazione vaga, che cio√® √® dipendente dal contesto, o comunque da ci√≤ che sia necessario al momento.</p>
<p><strong>Esempi di standard problems:</strong></p>
<ol>
<li>15/8 tile problem</li>
<li>Knuth factorial problem (partendo da 4, e applicando fattoriale e radici, si pu√≤ fare qualunque numero)</li>
</ol>
<p><strong>Esempi problemi reali</strong></p>
<ol>
<li>Travelling salesman</li>
<li>Chip VSLI</li>
</ol>
<h2 id="22-note-generali">2.2 Note generali<a hidden class="anchor" aria-hidden="true" href="#22-note-generali">#</a></h2>
<h3 id="221-percorsi-ridondanti">2.2.1 Percorsi ridondanti<a hidden class="anchor" aria-hidden="true" href="#221-percorsi-ridondanti">#</a></h3>
<p>Possiamo andare a definire un percorso ridondante, ogni percorso per cui se togli una tappa, il costo √® minore (ricordiamo che in questo libro parliamo sempre di percorsi con un peso positivo), quindi ridondanti sono cicli, o percorsi con qualche tappa in pi√π. Si pu√≤ considerare come se fosse un concetto pi√π generale di ciclo questo.</p>
<p><strong>Ovviare alle ridondanze</strong></p>
<p>Non vogliamo trovare percorsi che siano alla fine ridondati, vogliamo in qualche modo ricordare il nostro percorso:</p>
<ol>
<li>Avere una tavola che ci dica se abbiamo gi√† fatto quel percorso o meno</li>
<li>Avere una struttura, o formulazione del problema che non abbia questo problema di ridondanze (ad esempio una ricerca tipo-albero)</li>
<li>Ovviare solo ai cicli, e non alle ridondanze in generale, come vi adi mezzo.</li>
</ol>
<h3 id="222-valutazione-dellalgoritmo">2.2.2 Valutazione dell&rsquo;algoritmo<a hidden class="anchor" aria-hidden="true" href="#222-valutazione-dellalgoritmo">#</a></h3>
<p>In generale si valuta l&rsquo;algoritmo secondo le risorse utilizzate, nel caso della ricerca in AI potrebbe essere il costo in soldi e in carburante, oltre alla classica memoria e tempo. Si propongono quindi 4 valori su cui valutare ci√≤:</p>
<ol>
<li>Completezza (se esiste una soluzione perfetta la trovo sempre? Se non esiste so che non c&rsquo;√®?)</li>
<li>Ottimalit√† del costo della soluzione (es soldi etc).</li>
<li>Costo in tempo</li>
<li>Costo in memoria</li>
</ol>
<p>Di particolare interesse sarebbe valutare la completezza dell&rsquo;algoritmo.</p>
<h2 id="23-algoritmi-disinformati">2.3 Algoritmi disinformati<a hidden class="anchor" aria-hidden="true" href="#23-algoritmi-disinformati">#</a></h2>
<ul>
<li>
<p>Pseudocodice best-first-search</p>
  <img src="/images/notes/image/universita/ex-notion/Problemi di ricerca/Untitled.png" alt="image/universita/ex-notion/Problemi di ricerca/Untitled">
</li>
</ul>
<h3 id="231-perch√©-sono-disinformati">2.3.1 Perch√© sono disinformati<a hidden class="anchor" aria-hidden="true" href="#231-perch√©-sono-disinformati">#</a></h3>
<p>Chiamiamo questi algoritmi come disinformati perch√© non hanno idea di come √® fatta la struttura del campo di ricerca.</p>
<p>In pratica cercano con informazioni fortemente limitate sulla topologia del proprio ambiente.</p>
<p>Direi che vadano a cercare valutando solamente il costo, o indiscretamente nodi quasi casuali dell‚Äôambiente circostante.</p>
<h3 id="232-carrellata-di-algos">2.3.2 Carrellata di algos<a hidden class="anchor" aria-hidden="true" href="#232-carrellata-di-algos">#</a></h3>
<p>Non mi √® piaciuto molto questa parte, perch√© la maggior parte degli algoritmi esposti √® presente nel corso di Algoritmi e Strutture fanno all&rsquo;uni.</p>
<ul>
<li>BFS</li>
<li>DFS</li>
<li>Dept-limited dfs</li>
<li>Dijkstra/uniform-cost-search</li>
<li>Iterative deepening</li>
</ul>
<h2 id="24-algoritmi-informati">2.4 Algoritmi informati<a hidden class="anchor" aria-hidden="true" href="#24-algoritmi-informati">#</a></h2>
<p>Questi algoritmi informati sono molto pi√π interessanti rispetto agli algoritmi scorsi, per cui ne diamo pi√π larga discussione</p>
<p>Il fatto che siano informati ci sta a significare soltanto che utilizzano un euristica per decidere meglio in che modo espandersi.</p>
<h3 id="241-euristiche">2.4.1 Euristiche<a hidden class="anchor" aria-hidden="true" href="#241-euristiche">#</a></h3>
<p>Bisogna cercare di definire in modo migliore le caratteristiche che ci potrebbero interessare delle euristiche: euristica ammissibile significa che la funzione di euristica √® sempre minore del costo effettivo.</p>
<p>Consistente invece √® in pratica soltanto una forma della disuguaglianza triangolare.</p>
<p><strong>Trovare un euristica √® come risolvere una versione pi√π rilassata del problema</strong>, questa √® una delle osservazioni fondamentali per quando si va a trattare di euristiche.</p>
<p>Altre soluzioni possibili sono Landmarks e pattern databases di cui rispettivamente i primi sono dei punti cardine, in cui si calcola tutto passando prima di quelli (come se mi chiedessi tipo: quanto ci metto se per andare da A a C, passo prima per il landmark B?) prima si calcolano questi landmark e si prendono decisioni in funzione di quanto mi danno ci√≤.</p>
<p>I pattern databases sono solamente un modo per cercare soluzioni gi√† <em>precomputate</em> di pattern che ci sono solito. Si √® utilizzato un pattern database per 8-puzzle e funzionava distintamente bene.</p>
<p><strong>Contours</strong></p>
<p>Come se fossero dei piano di livello di una montagna, anche per dijkstra si potrebbe disegnare un contour, ci indica in pratica in modo semplice in che modo si sta espandendo l‚Äôalgoritmo di ricerca.</p>
<h3 id="242-carrellata-algoritmi-informati">2.4.2 Carrellata algoritmi informati<a hidden class="anchor" aria-hidden="true" href="#242-carrellata-algoritmi-informati">#</a></h3>
<p>quella pi√π bella, usata in tutte le salse √® l‚Äôalgoritmo di A* Search, che in pratica √® un uniform cost search, che invece di utilizzare solamente la funzione costo g(n) che rappresenta quanto effettivamente si paga per raggiungere il nodo n, tiene in considerazione anche una funzione h(n) che cerca di stimare il costo da n a un goal.</p>
<p>Una variante studiata √® il greedy-first-search che praticamente tiene in conto solamente dell‚Äôeuristica, senza la funzione di costo.</p>
<p>Altre varianti come WEIGHTED A* search applicano un fattore di peso sull‚Äôeuristica, spesso rendendola non ammissibile o perfino inconsistente (non ho capito bene in che modo l‚Äôammissibilit√† e la consistenza modificano le caratteristiche dell‚Äôeuristica).</p>
<p><strong>Tecniche che tengono molto in conto la memoria</strong></p>
<p>Altre studiate possono essere la RBFS (Recursive best first search, che √® simile a un MINIMAX con pruning, ma singolo agente, in pratica si espande sempre il nodo migliore, tenendo in conto il secondo valore migliore tra questi vicini, io continuo ad esplorare in profondit√† finch√© non mi converrebbe di pi√π cominciare ad esplorare qualcosa a un livello molto meno profondo).</p>
<p>Oppure la SMA* la simple memory A star, che in pratica tiene in considerazione un numero massimo di nodi in memoria, se nel momento in cui va ad espandere lo ha finito, rimuove il nodo pi√π vecchio, tenendo per√≤ un informazione riguardo quando costava esplorare quella via. (questo comunque pu√≤ condurre a problemi simili al thrashing, in cui continua a switchare percorsi, restando cos√¨ quasi bloccato).</p>
<p>BEAM SEARCH va in modo molto focalizzato verso una direzione sviluppando solamente i primi k nodi migliori sulla frontiera, invece A* si sviluppa nel suo territorio (quindi ++ sui contorni)</p>
<h2 id="25-interesse-stato-finale">2.5 Interesse stato finale<a hidden class="anchor" aria-hidden="true" href="#25-interesse-stato-finale">#</a></h2>
<p>In questi problemi non ci importa pi√π di avere un percorso che ci porta alla soluzione, ma solamente la soluzione stessa. Non ci conviene pi√π utilizzare gli algoritmi di ricerca presentati al capitolo precedente in <a href="//notes/problemi-di-ricerca">Problemi di ricerca</a>. Quindi si sono sviluppati algoritmi che si comportassero bene per massimizzare anche gli obiettivi di questi.</p>
<p>Termini importanti per parlare di questi ambienti:</p>
<ol>
<li>Massimo locale</li>
<li>Ridge (che rende algoritmi greedy molto difficili da essere efficienti)</li>
<li>Plateau, parti piatte</li>
</ol>
<h3 id="251-hill-climbing">2.5.1 Hill Climbing<a hidden class="anchor" aria-hidden="true" href="#251-hill-climbing">#</a></h3>
<ul>
<li>
<p>Hill Climb in breve (pseudoalgo)</p>
  <img src="/images/notes/image/universita/ex-notion/Problemi di ricerca/Untitled 1.png" alt="image/universita/ex-notion/Problemi di ricerca/Untitled 1">
</li>
</ul>
<p>Questo √® uno degli algoritmi pi√π semplici per quanto riguarda la ricerca in questi ambienti, l‚Äôidea principale √® scegliere il migliore fra i propri successori, e seguire quella strada finch√© si pu√≤ migliorare.</p>
<p>Il problema principale √® che questa versione semplice di Hill Climbing si blocca molto facilmente su minimi locali, o piani. Poi l‚Äôambiente di Ridge √® una cosa di difficilissima navigazione.</p>
<p>Quindi si sono inventati variazioni che tentavano di risolvere questo problema:</p>
<ol>
<li>Random restart, ricominciare da un punto random, prendendo alla fine la migliore fra tutte</li>
<li>Local beam search, in cui si tengono ogni step i k migliori successori fra i k punti iniziali.
<ol>
<li>Stochastic local beam search in cui randomicamente si considerano alcuni nodi anche lontani rispetto a questi, per cercare di sfavorire il fatto che tutti i punti migliori si ammassino su uno stesso punto.</li>
</ol>
</li>
<li>Stochastic hill climbing, in cui in cui si seleziona un punto a caso, e lo si segue sempre se √® migliore, e solo a volte se √® peggiore
<ol>
<li>Simulated Annealing in cui la probabilit√† di scegliere il punto peggiore dall‚Äôaltra parte scende col tempo, con una funzione che decade esponenzialmente.</li>
</ol>
</li>
</ol>
<h3 id="252-algoritmi-genetici">2.5.2 Algoritmi genetici<a hidden class="anchor" aria-hidden="true" href="#252-algoritmi-genetici">#</a></h3>
<ul>
<li>
<p>Pseudoalgo</p>
  <img src="/images/notes/image/universita/ex-notion/Problemi di ricerca/Untitled 2.png" alt="image/universita/ex-notion/Problemi di ricerca/Untitled 2">
</li>
</ul>
<p>Le caratteristiche generali di un algoritmo genetico sono in breve queste:</p>
<ol>
<li>Dimensione della popolazione</li>
<li>Rappresentazione della stringa genetica in caratteristiche della popolazione</li>
<li>Funzione scelta dei n elementi pi√π adatti tra la popolazione</li>
<li>Generazione di un figlio da coppie, o singola persona, o anche pi√π persone di queste. (crossover)</li>
<li>Mutazione randomica di caratteri cos√¨ generati</li>
<li>Elitismo o abbattimento di individui non adatti (a volte aiuta a velocizzare il processo).</li>
<li>Ripetizione di ci√≤ fino a tempo finito o caratteristiche cercate trovate.</li>
</ol>
<p>La differenza principale con lo stochastic local beam search √® il momento di generazione di un nodo successore, che in questo caso, in quanto <em>giustificato dalla biologica</em>, o almeno da una forma contorta di biologia perch√© io personalmente credo che sia una forma eccessivamente semplificata, nonostante riconosco che √® un buon punto di partenza) √® generata da una ricombinazione di pi√π individui.</p>
<p><strong>SCHEMAS</strong></p>
<p>Si √® notato nel tempo (e lo si √® anche dimostrato) che gli algoritmi genetici hanno un senso solo se pattern vicini codificano informazioni importanti cio√® se i caratteri vicini non hanno nessuna relazione, √® totalmente inutile utilizzare un algoritmo genetico.</p>
<p>Poi si √® notato che se un pattern specifico aiuta il progenito a sopravvivere, effettivamente √® probabile che si mandi alla generazione successiva. Ciononostante √® doveroso tenere a mente che non tutti i pattern necessari vengono trasferiti, e non tutti i pattern inutili vengono eliminati, leggere l‚Äôapprofondimento in biologia a pagina 136 dell‚Äôedizione cartacea che possiedi.</p>
<h3 id="253-in-ambienti-continui">2.5.3 In ambienti continui<a hidden class="anchor" aria-hidden="true" href="#253-in-ambienti-continui">#</a></h3>
<p>Se l‚Äôambiente √® continuo, √® di gran lunga di pi√π di interesse matematico. Si pu√≤ vedere come un problema di calcolo numerico nella ricerca di un punto di minimo come il <strong>Newton-Raphson-method</strong>, che si pu√≤ estendere anche a pi√π dimensioni.</p>
<p>Oppure si pu√≤ vedere come un problema di ottimizzazione-constrained, che si pu√≤ risolvere con programmazione lineare, cose che riguardano analisi di superfici convesse. In pratica idee e cose altamente tecniche che non conosco ancora.</p>
<p>L‚Äôidea principale di questa parte comunque resta il fatto che si pu√≤ discretizzare l‚Äôambiente continuo, o cercando di aggiornarlo con passi piccoli, delta alla volta, in ogni direzione, o campionando lo spazio, dividendolo in tanti quadrettini lunghi delta, alla fine credo che questi approcci siano equivalenti.</p>
<h2 id="26-non-deterministiche-e-not-fully-observable">2.6 non-deterministiche e not-fully observable<a hidden class="anchor" aria-hidden="true" href="#26-non-deterministiche-e-not-fully-observable">#</a></h2>
<p>Introduciamo ora il concetto di belief state ossia una rappresentazione interna degli stati possibili dell‚Äôambiente. Per gli algoritmi presentati in <a href="//notes/problemi-di-ricerca">Problemi di ricerca</a> ogni singolo stato esterno corrispondeva lo stato di belief state interno, ossia c‚Äôera una corrispondenza, invece in questo caso andiamo a rilassare questo assunto, il <em>determinismo</em>, ossia il fatto che a una singola azione vada a corrispondere un singolo stato, ossia andiamo a dire che a singola azione, possono risultare una serie di stati differenti, maggiori di 1.</p>
<h3 id="261-and-or-tree-non-det">2.6.1 And-Or tree (non-det)<a hidden class="anchor" aria-hidden="true" href="#261-and-or-tree-non-det">#</a></h3>
<p>Con la possibilit√† di avere pi√π stati a seguito di una singola azione cerchiamo di dividere cose che sono sotto il controllo dell‚Äôagente e cosa non lo √®</p>
<ol>
<li>OR-node, √® una cosa che dipende dall‚Äôazione dell‚Äôagente</li>
<li>AND-node, √® una cosa che dipende dalla reazione dell‚Äôambiente in seguito ad azioni dell‚Äôagente.</li>
</ol>
<p>Avendo questi due tipologie di nodi, possiamo andare a rappresentare l‚Äôintero ambiente attraverso un albero, per cui si possono utilizzare gli algoritmi di trasverse di alberi per trovare una soluzione che ora chiamiamo piano condizionale in quanto sar√† constituito da un array di azioni, nel caso si √® andato su un or-node, oppure di if-then, nel caso si stia andando avanti per un and-node.</p>
<p><strong>Nota: soluzioni cicliche</strong></p>
<p>A volte converrebbe cercare di <em>ragionare sui motivi della non-determinatezza</em> perch√© in questo modo sappiamo se una soluzione ciclica, ossia una soluzione che ha per foglie solamente un obiettivo, ma nel suo percorso pu√≤ avere anche delle foglie che vadano in loop, sia effettivamente una soluzione: ossia il non-raggiungimento sia dovuto al caso, oppure a una sistematicit√† dell‚Äôambiente in cui si √® presenti.</p>
<h3 id="262-osservabilit√†-parziale">2.6.2 Osservabilit√† parziale<a hidden class="anchor" aria-hidden="true" href="#262-osservabilit√†-parziale">#</a></h3>
<p>Un aspetto che colpisce √® che in ambienti in cui l‚Äôosservabilit√† √® parziale, si possono ricavare delle informazioni semplicemente muovendosi, non per forza stando ad osservare l‚Äôambiente! diciamo in questo caso che lo stato √® <strong>coerced</strong></p>
<p>Per ricondurci da tale ambiente a un problema di ricerca trattato in <a href="//notes/problemi-di-ricerca">Problemi di ricerca</a>, possiamo fare una cosa molto simile a quanto √® fatto per Non-deterministic automata convertito a deterministic automata, ossia si ha una esplosione esplonenziale, ma comunque ben definita degli stati e delle funzioni di transizione che li legano.</p>
<p><strong>Ricerca incrementale</strong></p>
<p>A volte conviene, invece di esplorare tutto insieme, come fa il non-determinismo, causando computazioni impraticabili, di provare a cercare una soluzione in via incrementale, buildando prima una soluzione che funzioni per un nodo, poi per il secondo, cambiando leggermente la soluzione trovata, e poi via.</p>
<p>Si ha il risultato di trovare una soluzione o una assenza di essa in modo molto veloce.</p>
<h3 id="263-percezione-nellosservabilit√†-parziale">2.6.3 Percezione nell‚Äôosservabilit√† parziale<a hidden class="anchor" aria-hidden="true" href="#263-percezione-nellosservabilit√†-parziale">#</a></h3>
<p>Essendo un ambiente parzialmente osservabile, possiamo dare per scontato che esista una funzione Perceipt(state) che restituisce un insieme di stati osservati. Questa √® una funzione stretttamente legata all‚Äôambiente in cui agisce l‚Äôagente.</p>
<p>Allora in un ambiente non-deterministico ad osservabilit√† parziale dovremmo approfondire la funzione di transizione, che non si pu√≤ considerare pi√π l‚Äôunione o l‚Äôintersezione dell‚Äôazione che viene applicata a tutti gli stati, ma qualcosa di meno perch√© deve prendere in conto anche la percezione (ad ogni azione corrisponde uno stato che corrisponde subito una percezione).</p>
<p>La dividiamo in 3 parti</p>
<ol>
<li><em>Predizione</em> di quello che succede se applico l‚Äôazione a (ritorna un insieme di stati possiibili)</li>
<li><em>Percezioni possibili</em> lista delle percezioni possibili per tutti gli stati raggiunti.</li>
<li><em>Aggiornamento</em> degli stati di belief a un sottoinsieme a seconda degli stati raggiunti e delle percezioni possibili.</li>
</ol>
<p>In questo modo si forma sempre un albero di ricerca, di azioni non-deterministiche.</p>
<h3 id="264-ricerca-online">2.6.4 Ricerca online<a hidden class="anchor" aria-hidden="true" href="#264-ricerca-online">#</a></h3>
<p>La ricerca online ci fa avvicinare a come sia l‚Äôesplorazione in un mondo vero, in pratica ora lo stato del mondo √® dinamico, e dipende dalla presenza fisica dell‚Äôagente osservatore che non pu√≤ pi√π saltare da un nodo o un altro, oltre al fatto che lo stato pu√≤ cambiare anche se non sta facendo niente. (c‚Äô√® un problema riguardo punti di non ritorno, in cui le azioni sono irreversibili, ma questo lo tratteremo in capitolo seguenti).</p>
<ul>
<li>
<p>Pseudocodice per DFS-online</p>
  <img src="/images/notes/image/universita/ex-notion/Problemi di ricerca/Untitled 3.png" alt="image/universita/ex-notion/Problemi di ricerca/Untitled 3">
<p>La cosa stupida di questo algoritmo √® che non conosce le azioni che pu√≤ fare in un determinato stato, e potrebbe ripetere azioni che si cancellano fra di loro (es. UP e DOWN uno di seguito all‚Äôaltro).
Le azioni qui dipendono dallo stato in cui si √® presenti!</p>
</li>
</ul>
<p><em><em>Hill Climbing online (LRTA</em>)</em>*</p>
<p>Un osservazione che si √® fatto con la DFS √® che ora si ha un oggetto fisico che si sposta, e non pu√≤ fare voli dall‚Äôaltra parte del labirinto per vedere come si sviluppa quel nodo di ricerca, per questo motivo possiamo affermare che c‚Äô√® bisogno di un algoritmo di ricerca locale, questo era HILL CLIMBING!</p>
<p>Ma avevamo discusso in precedenza che si poteva bloccare molto facilmente questo algoritmo! Ma non possiamo pi√π utilizzare random restart, dato che non esiste il teletrasporto, allora utilizziamo il <strong>random walk</strong>, in modo randomico scegli una direzione e la esplori.</p>
<p>Questa cosa adattata con anche una euristica che ti direzioni verso la parte giusta diventa un <strong>LRTA</strong></p>
<ul>
<li>
<p>Pseudocodice Learning RealTime A*</p>
  <img src="/images/notes/image/universita/ex-notion/Problemi di ricerca/Untitled 4.png" alt="image/universita/ex-notion/Problemi di ricerca/Untitled 4">
</li>
</ul>
<p>In pratica riaggiorna l‚Äôeuristica del costo a seconda delle proprie mosse.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/no-tags/">No-Tags</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Problemi di ricerca on x"
            href="https://x.com/intent/tweet/?text=Problemi%20di%20ricerca&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fproblemi-di-ricerca%2f&amp;hashtags=no-tags">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Problemi di ricerca on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fproblemi-di-ricerca%2f&amp;title=Problemi%20di%20ricerca&amp;summary=Problemi%20di%20ricerca&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2fproblemi-di-ricerca%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Problemi di ricerca on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2fproblemi-di-ricerca%2f&title=Problemi%20di%20ricerca">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Problemi di ricerca on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2fproblemi-di-ricerca%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Problemi di ricerca on whatsapp"
            href="https://api.whatsapp.com/send?text=Problemi%20di%20ricerca%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2fproblemi-di-ricerca%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Problemi di ricerca on telegram"
            href="https://telegram.me/share/url?text=Problemi%20di%20ricerca&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fproblemi-di-ricerca%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Problemi di ricerca on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Problemi%20di%20ricerca&u=https%3a%2f%2fflecart.github.io%2fnotes%2fproblemi-di-ricerca%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
