<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Cook-Levin and Savitch | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="theoretical-computer-science">
<meta name="description" content="Cook Levin theorem is important because says that in 1971 if $SAT \in P$ then $NP = P$. We will start with this idea to define the concept of NP-completeness. Let&rsquo;s start with the basics.
Poly-reduction
Def: poly-reduction
$$
x \in L&#39; \iff f(x) \in L
$$
This is very similar to the Halting Theorem and Reducibility#Mapping reducibility.
The difference is that it needs to be polynomially-bounded, so to say, it is efficient function.">
<meta name="author" content="
By Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="https://flecart.github.io/notes/cook-levin-and-savitch/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f790d9af969c56c079c1ce2d5972a04486bf3d6144295d5fba319830e1e55a7a.css" integrity="sha256-95DZr5acVsB5wc4tWXKgRIa/PWFEKV1fujGYMOHlWno=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/cook-levin-and-savitch/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>
<script type="text/javascript" async
src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>






      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-WW6NN2QGKF');
        }
      </script><meta property="og:url" content="https://flecart.github.io/notes/cook-levin-and-savitch/">
  <meta property="og:site_name" content="X. Angelo Huang&#39;s Blog">
  <meta property="og:title" content="Cook-Levin and Savitch">
  <meta property="og:description" content="Cook Levin theorem is important because says that in 1971 if $SAT \in P$ then $NP = P$. We will start with this idea to define the concept of NP-completeness. Let’s start with the basics.
Poly-reduction Def: poly-reduction $$ x \in L&#39; \iff f(x) \in L $$ This is very similar to the Halting Theorem and Reducibility#Mapping reducibility. The difference is that it needs to be polynomially-bounded, so to say, it is efficient function.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="notes">
    <meta property="article:tag" content="Theoretical-Computer-Science">
      <meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:title" content="Cook-Levin and Savitch">
<meta name="twitter:description" content="Cook Levin theorem is important because says that in 1971 if $SAT \in P$ then $NP = P$. We will start with this idea to define the concept of NP-completeness. Let&rsquo;s start with the basics.
Poly-reduction
Def: poly-reduction
$$
x \in L&#39; \iff f(x) \in L
$$
This is very similar to the Halting Theorem and Reducibility#Mapping reducibility.
The difference is that it needs to be polynomially-bounded, so to say, it is efficient function.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Cook-Levin and Savitch",
      "item": "https://flecart.github.io/notes/cook-levin-and-savitch/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Cook-Levin and Savitch",
  "name": "Cook-Levin and Savitch",
  "description": "Cook Levin theorem is important because says that in 1971 if $SAT \\in P$ then $NP = P$. We will start with this idea to define the concept of NP-completeness. Let\u0026rsquo;s start with the basics.\nPoly-reduction Def: poly-reduction $$ x \\in L' \\iff f(x) \\in L $$ This is very similar to the Halting Theorem and Reducibility#Mapping reducibility. The difference is that it needs to be polynomially-bounded, so to say, it is efficient function.\n",
  "keywords": [
    "theoretical-computer-science"
  ],
  "articleBody": "Cook Levin theorem is important because says that in 1971 if $SAT \\in P$ then $NP = P$. We will start with this idea to define the concept of NP-completeness. Let’s start with the basics.\nPoly-reduction Def: poly-reduction $$ x \\in L' \\iff f(x) \\in L $$ This is very similar to the Halting Theorem and Reducibility#Mapping reducibility. The difference is that it needs to be polynomially-bounded, so to say, it is efficient function.\nTh: $L' \\leq_{p} L \\land L \\in P \\implies L' \\in P$ This theorem says that if we can reduce with a polynomially bounded function to a class of language in $P$ then we have automatically another language in $P$.\nProof: If $L \\in P$ there exists a $g$ that decides it in poly-time. If $L' \\leq _p L$ then exists $TM$ that polynomially computes a language into $L$, calculating $f$. Then we build this machine:\nGiven $x \\in L'$ in input, we say $g(f(x))$ decides that language. And we know that composition of polynomial functions is polynomial. So that function is polynomial and we proved it.\nTh: $L \\in P \\implies L^{-} \\leq_{p} L$ Given a $\\omega$ let’s run the decider to know whether if $\\omega \\in L$. If we know this then we know if $\\omega \\in L'$ or not just by inverting the last result. Now let’s build the converter, which works in constant time. Take two words $\\omega_{1}, \\omega_{2}$ such that $\\omega_{1} \\in L \\land \\omega_{2} \\not \\in L$ then if $\\omega \\in L' \\implies f(\\omega) = \\omega_{1}$ and if $\\omega \\not \\in L' \\implies f(\\omega) = \\omega_{2}$ this ends the proof. $f$ works in polynomial time thanks to the fact that $L \\in P$.\nCook-Levin Theorem Def: NP-completeness We say that a $L$ is NP-complete if it is in $NP$ and every other $L'$ is reducible in $NP$ using #Poly-reduction.\nDef: NP-hard $L$ is NP-hard if every $L'$ in $NP$ in reducible to it using #Poly-reduction. We don’t need that it is in $NP$.\nTMSAT $$ TMSAT = \\left\\{ \\langle x, w, s,t \\rangle \\mid x = code(M) \\text{ and } M \\text{ accepts } \\langle w, c \\rangle \\right\\} $$ With other constraints of the length of the input and the time of the computation.\nAs this is a verifier we can prove that this language is $NP-complete$ but it is useless, because it says nothing on the class of problems.\nProblem statement We want to prove that $SAT \\in NP-complete$ This is what Cook-Levin states.\nthis would imply that every other problem in $NP$ can be reduced into SAT, for example clique which is in NP, so we prove that $P = NP$\nProof of Cook-Levin SAT is in NP This is quite easy, just non-deterministically take an assignment. If any of these assignments accept, then accept. We can say that SAT is easily verifiable.\nSAT is NP-hard This is the difficult part. The idea is to create a representation of the computation of the Turing Machine of whatever algorithm. So we create a tableau that represents the computation, and we want to translate this tableau as a satisfiability problem. We know that this tableau is finite because the problem is in $NP$.\n$$ F_{w} := F_{cell} \\land F_{start} \\land F_{move} \\land F_{accept} $$ And we want to say that this is satisfiable $\\iff$ exists a tableau as defined above such that accepts $\\iff$ a computation on $w$ of the machine $M$ accepts it.\n$$ \\left\\{ x _{i, j, s} \\mid (i, j) \\in n^{k} \\times n^{k} ,s \\in Q \\cup \\Sigma \\cup \\left\\{ \\# \\right\\} \\right\\} $$$$ F_{start} = x_{1, 1, \\#} \\land x_{1, 2, q_{0}} \\land \\\\ x_{1,3, w_{1}} \\land x_{1, 4, w_{2}} \\land \\dots \\land x_{1, n + 2, w_{n}} \\land \\\\ x_{1, n + 3, \\textvisiblespace} \\land \\dots \\land x_{1, n^{k} - 1, \\textvisiblespace x_{1, n^{k}, \\#}} $$ It means that the initial configuration is that of the Turing machine.\n$$ F_{cell} = \\bigwedge_{1 \\leq i, j \\leq n ^{k}} \\left[ (\\bigvee_{s \\in C} x_{i, j , s}) \\land (\\bigwedge_{s, t \\in C, s\\neq t} (\\bar{x}_{i, j, s} \\lor \\bar{x}_{i,j,t})) \\right] $$In natural language: Exists at least a $s$ that is true, and other are false, for every cell in the tableau. That means that for every single cell, we have something like $x_{1, 2, a}$ which is true.\n$$ F_{accept} = \\bigvee_{1 \\leq i, j \\leq n^{k}} x_{i,j, T} $$Then we need to define the $F_{move}$ function, which is the last formula we would need to define! As we only need to know how the state moves, we just need windows of 3.\nExamples: $$ F_{move} = \\bigwedge_{1 ",
  "wordCount" : "774",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/cook-levin-and-savitch/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Cook-Levin and Savitch
    </h1>
    <div class="post-meta">Reading Time: 4 minutes&nbsp;·&nbsp;
By Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul><ul>
                <li>
                    <a href="#poly-reduction" aria-label="Poly-reduction">Poly-reduction</a><ul>
                        
                <li>
                    <a href="#def-poly-reduction" aria-label="Def: poly-reduction">Def: poly-reduction</a></li>
                <li>
                    <a href="#th-l-leq_p-l-land-l-in-p-implies-l-in-p" aria-label="Th: $L&#39; \leq_{p} L \land L \in P \implies L&#39; \in P$">Th: $L' \leq_{p} L \land L \in P \implies L' \in P$</a></li>
                <li>
                    <a href="#th-l-in-p-implies-l--leq_p-l" aria-label="Th: $L \in P \implies L^{-} \leq_{p} L$">Th: $L \in P \implies L^{-} \leq_{p} L$</a></li></ul>
                </li></ul>
                    
                <li>
                    <a href="#cook-levin-theorem" aria-label="Cook-Levin Theorem">Cook-Levin Theorem</a><ul>
                        
                <li>
                    <a href="#def-np-completeness" aria-label="Def: NP-completeness">Def: NP-completeness</a></li>
                <li>
                    <a href="#def-np-hard" aria-label="Def: NP-hard">Def: NP-hard</a></li>
                <li>
                    <a href="#tmsat" aria-label="TMSAT">TMSAT</a></li>
                <li>
                    <a href="#problem-statement" aria-label="Problem statement">Problem statement</a></li>
                <li>
                    <a href="#proof-of-cook-levin" aria-label="Proof of Cook-Levin">Proof of Cook-Levin</a><ul>
                        
                <li>
                    <a href="#sat-is-in-np" aria-label="SAT is in NP">SAT is in NP</a></li>
                <li>
                    <a href="#sat-is-np-hard" aria-label="SAT is NP-hard">SAT is NP-hard</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#savitch-theorem" aria-label="Savitch Theorem">Savitch Theorem</a><ul>
                        
                <li>
                    <a href="#savitchs-statement" aria-label="Savitch&rsquo;s statement">Savitch&rsquo;s statement</a></li>
                <li>
                    <a href="#sketch-of-the-proof-idea" aria-label="Sketch of the proof idea">Sketch of the proof idea</a></li>
                <li>
                    <a href="#proof-of-savitchs-theorem" aria-label="Proof of Savitch&rsquo;s theorem">Proof of Savitch&rsquo;s theorem</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Cook Levin theorem is important because says that in 1971 if $SAT \in P$ then $NP = P$. We will start with this idea to define the concept of <strong>NP-completeness</strong>. Let&rsquo;s start with the basics.</p>
<h3 id="poly-reduction">Poly-reduction<a hidden class="anchor" aria-hidden="true" href="#poly-reduction">#</a></h3>
<h4 id="def-poly-reduction">Def: poly-reduction<a hidden class="anchor" aria-hidden="true" href="#def-poly-reduction">#</a></h4>
$$
x \in L' \iff f(x) \in L
$$<p>
This is very similar to the <a href="/notes/halting-theorem-and-reducibility#mapping-reducibility">Halting Theorem and Reducibility#Mapping reducibility</a>.
The difference is that it needs to be <em>polynomially-bounded</em>, so to say, it is efficient function.</p>
<h4 id="th-l-leq_p-l-land-l-in-p-implies-l-in-p">Th: $L' \leq_{p} L \land L \in P \implies L' \in P$<a hidden class="anchor" aria-hidden="true" href="#th-l-leq_p-l-land-l-in-p-implies-l-in-p">#</a></h4>
<p>This theorem says that if we can reduce with a polynomially bounded function to a class of language in $P$ then we have automatically another language in $P$.</p>
<p><strong>Proof:</strong>
If $L \in P$ there exists a  $g$ that decides it in poly-time. If $L' \leq _p L$ then exists $TM$ that polynomially computes a language into $L$, calculating $f$. Then we build this machine:</p>
<p>Given $x \in L'$ in input, we say $g(f(x))$ decides that language. And we know that composition of polynomial functions is polynomial. So that function is polynomial and we proved it.</p>
<h4 id="th-l-in-p-implies-l--leq_p-l">Th: $L \in P \implies L^{-} \leq_{p} L$<a hidden class="anchor" aria-hidden="true" href="#th-l-in-p-implies-l--leq_p-l">#</a></h4>
<p>Given a $\omega$ let&rsquo;s run the decider to know whether if $\omega \in L$. If we know this then we know if $\omega \in L'$ or not just by inverting the last result.
Now let&rsquo;s build the converter, which works in constant time. Take two words $\omega_{1}, \omega_{2}$ such that $\omega_{1} \in L \land \omega_{2} \not \in L$ then if $\omega \in L' \implies f(\omega) = \omega_{1}$ and if $\omega \not \in L' \implies f(\omega) = \omega_{2}$ this ends the proof.
$f$ works in polynomial time thanks to the fact that $L \in P$.</p>
<h2 id="cook-levin-theorem">Cook-Levin Theorem<a hidden class="anchor" aria-hidden="true" href="#cook-levin-theorem">#</a></h2>
<h3 id="def-np-completeness">Def: NP-completeness<a hidden class="anchor" aria-hidden="true" href="#def-np-completeness">#</a></h3>
<p>We say that a $L$ is NP-complete if it is in $NP$ and every other $L'$ is reducible in $NP$ using <a href="/notes#poly-reduction">#Poly-reduction</a>.</p>
<h3 id="def-np-hard">Def: NP-hard<a hidden class="anchor" aria-hidden="true" href="#def-np-hard">#</a></h3>
<p>$L$ is NP-hard if every $L'$ in $NP$ in reducible to it using <a href="/notes#poly-reduction">#Poly-reduction</a>. We don&rsquo;t need that it is in $NP$.</p>
<h3 id="tmsat">TMSAT<a hidden class="anchor" aria-hidden="true" href="#tmsat">#</a></h3>
$$
TMSAT = \left\{  \langle x, w, s,t \rangle  \mid x = code(M) \text{ and } M \text{ accepts } \langle w, c \rangle  \right\} 
$$<p>
With other constraints of the length of the input and the time of the computation.</p>
<p>As this is a verifier we can prove that this language is $NP-complete$ but it is useless, because it says nothing on the class of problems.</p>
<h3 id="problem-statement">Problem statement<a hidden class="anchor" aria-hidden="true" href="#problem-statement">#</a></h3>
<p>We want to prove that $SAT \in NP-complete$ This is what Cook-Levin states.</p>
<p>this would imply that every other problem in $NP$ can be reduced into SAT, for example clique which is in NP, so we prove that $P = NP$</p>
<h3 id="proof-of-cook-levin">Proof of Cook-Levin<a hidden class="anchor" aria-hidden="true" href="#proof-of-cook-levin">#</a></h3>
<h4 id="sat-is-in-np">SAT is in NP<a hidden class="anchor" aria-hidden="true" href="#sat-is-in-np">#</a></h4>
<p>This is quite easy, just non-deterministically take an assignment. If any of these assignments accept, then accept.
We can say that SAT is easily verifiable.</p>
<h4 id="sat-is-np-hard">SAT is NP-hard<a hidden class="anchor" aria-hidden="true" href="#sat-is-np-hard">#</a></h4>
<p>This is the difficult part.
The idea is to create a representation of the computation of the Turing Machine of whatever algorithm. So we create a <strong>tableau</strong> that represents the computation, and we want to translate this tableau as a satisfiability problem. We know that this tableau is finite because the problem is in $NP$.</p>
<img src="/images/notes/Cook-Levin Theorem-20240410125141970.webp" style="width: 100%" class="center" alt="Cook-Levin Theorem-20240410125141970">
$$
F_{w} := F_{cell} \land F_{start} \land F_{move} \land F_{accept}
$$<p>
And we want to say that this is satisfiable $\iff$ exists a tableau as defined above such that accepts $\iff$ a computation on $w$ of the machine $M$ accepts it.</p>
$$
\left\{ x _{i, j, s} \mid (i, j) \in n^{k} \times n^{k} ,s \in Q \cup \Sigma \cup \left\{ \# \right\}  \right\} 
$$$$
F_{start} = x_{1, 1, \#} \land x_{1, 2, q_{0}} \land \\
x_{1,3, w_{1}} \land x_{1, 4, w_{2}} \land \dots \land x_{1, n + 2, w_{n}} \land \\
x_{1, n + 3, \textvisiblespace} \land \dots \land x_{1, n^{k} - 1, \textvisiblespace x_{1, n^{k}, \#}}
$$<p>
It means that the initial configuration is that of the Turing machine.</p>
$$
F_{cell} = \bigwedge_{1 \leq i, j \leq n ^{k}} \left[ (\bigvee_{s \in C} x_{i, j , s}) \land (\bigwedge_{s, t \in C, s\neq t} (\bar{x}_{i, j, s} \lor \bar{x}_{i,j,t})) \right] 
$$<p>In natural language:
Exists at least a $s$ that is true, and other are false, for every cell in the tableau. That means that for every single cell, we have something like $x_{1, 2, a}$ which is true.</p>
$$
F_{accept} = \bigvee_{1 \leq i, j \leq n^{k}} x_{i,j, T}
$$<p>Then we need to define the $F_{move}$ function, which is the last formula we would need to define!
As we only need to know how the state moves, we just need <strong>windows</strong> of 3.</p>
<p>Examples:
<img src="/images/notes/Cook-Levin Theorem-20240410131145903.webp" style="width: 100%" class="center" alt="Cook-Levin Theorem-20240410131145903"></p>
$$
F_{move} = \bigwedge_{1 <i\leq n^{k}, 1 < j \leq n^{k}} \left( \bigvee_{a_{1},\dots, a_{6}} x_{i,j-1,a_{1}} \land x_{i,j, a_{2}} \land x_{i, j + 1, a_{3}} \land x_{i+1, j-1, a_{4}} \land x_{i+1, j , a_{5}} \land x_{i+1, j+ 1, a_{6}}\right) 
$$<p>
Where $a_{1}, \dots, a_{6}$ are symbols of admissible windows.
The initial and says that that should hold for every cell. (this is also the reason why we pad with $\#$ at the beginning, because the $(i, j)$ windows is the $2\times{3}$  block such that the center is in the upper center of the rectangle.</p>
<p>This with the idea that Tableau is buildable in poly-bounded time, should finish the proof.</p>
<p>We see with this construction that
$F_{cell} \approx O(n^{2k})$, $F_{start} \approx O(n^{k})$ , and the others $n^{2k}$ as they cycle for every cell in the tableau. So this construction is valid and takes poly time.</p>
<h2 id="savitch-theorem">Savitch Theorem<a hidden class="anchor" aria-hidden="true" href="#savitch-theorem">#</a></h2>
<h3 id="savitchs-statement">Savitch&rsquo;s statement<a hidden class="anchor" aria-hidden="true" href="#savitchs-statement">#</a></h3>
$$
NSPACE(f(N)) \subseteq SPACE(f^{2}(n))
$$$$
NSPACE = PSPACE
$$<h3 id="sketch-of-the-proof-idea">Sketch of the proof idea<a hidden class="anchor" aria-hidden="true" href="#sketch-of-the-proof-idea">#</a></h3>
<p>The proof idea uses a similar idea explored in <a href="/notes/common-problems-in-theoretical-cs#true-quantified-boolean-formula">Common problems in Theoretical CS#True quantified Boolean formula</a>, saying that TQBF was PSPACE-complete.</p>
<p>So given two configurations of the NTM, $c_{1}, c_{2}$ we want to say that it&rsquo;s possible to reach from $c_{1}$ to $c_{2}$ in at most $t$ computational steps in the new deterministic TM that we are going to build.
We already know by hypothesis that the given NTM is in $NSPACE(t(n))$ now we will prove that the built TM is in $SPACE(t(n^{2}))$, so by this reduction we know that we have that inclusion.</p>
<p>For the inductive case, We want to build a function <code>REACH</code> that is true if and only if the TM starting from state $c$ can reach $c'$ in at most $t$ computational steps.
Then we can define a TM in this way.
Run <code>REACH</code>$c_{init}, c_{acc}, 2^{dt(n)}$ if this accepts, accepts. We have chosen that exponential value because at maximum you can modify those number of states with $n$ of input length.</p>
<h3 id="proof-of-savitchs-theorem">Proof of Savitch&rsquo;s theorem<a hidden class="anchor" aria-hidden="true" href="#proof-of-savitchs-theorem">#</a></h3>
<p>We prove it by induction:
If $t=1$ verify if $c_{1} = c_{2}$ or if $c_{2}$ is a reachable configuration with $1$ computational step. You can do this by enumerating all possible transition functions starting with that state for example. If ok accept, else reject.
The logic for enumerating possible transitions is presented in the proof of <a href="/notes#cook-levin-theorem">#Cook-Levin Theorem</a>.</p>
<p>Else we run for each $c_{m}$ configuration of the TM, that is bounded and uses $t(n)$ space.</p>
<ol>
<li><code>REACH(c, c_m, t/2)</code></li>
<li><code>REACH(c_m, c', t/2)</code></li>
<li>If both ends accept, then accept.</li>
</ol>
<p>Let&rsquo;s analyze this algorithm. $dt(n)$ is the depth of the recursion tree. The algorithm is probably exponential in time, but we are only concerned by the width space.
Every recursive step uses only takes $O(n)$ space, and in total we have $O(n)$ in depth, so we can solve this in $O(n^{2})$ space.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/theoretical-computer-science/">Theoretical-Computer-Science</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Cook-Levin and Savitch on x"
            href="https://x.com/intent/tweet/?text=Cook-Levin%20and%20Savitch&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fcook-levin-and-savitch%2f&amp;hashtags=theoretical-computer-science">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Cook-Levin and Savitch on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fcook-levin-and-savitch%2f&amp;title=Cook-Levin%20and%20Savitch&amp;summary=Cook-Levin%20and%20Savitch&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2fcook-levin-and-savitch%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Cook-Levin and Savitch on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2fcook-levin-and-savitch%2f&title=Cook-Levin%20and%20Savitch">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Cook-Levin and Savitch on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2fcook-levin-and-savitch%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Cook-Levin and Savitch on whatsapp"
            href="https://api.whatsapp.com/send?text=Cook-Levin%20and%20Savitch%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2fcook-levin-and-savitch%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Cook-Levin and Savitch on telegram"
            href="https://telegram.me/share/url?text=Cook-Levin%20and%20Savitch&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fcook-levin-and-savitch%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Cook-Levin and Savitch on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Cook-Levin%20and%20Savitch&u=https%3a%2f%2fflecart.github.io%2fnotes%2fcook-levin-and-savitch%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
