<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>La macchina di Turing | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="theoretical-computer-science">
<meta name="description" content="Introduzione
Note filosofiche (non impo)
Bisogna in primo momento cercare di definire cosa è la computazione e cosa è un computer.
Aristotele faceva la distinzione fra proprietà essenziali e accidentali. Quelle essenziali sono proprie dell&rsquo;oggetto.

Una sedia può essere fatta di legno o di metallo, ma questa proprietà è accidentale, ovvero, essa rimane una sedia indipendentemente dal materiale di cui è fatta.
Solitamente in matematica si prova ad astrarre (vedi Astrazione sul controllo per nota generale sull&rsquo;astrazione). Però in questo campo si sono trovati molte concezioni equivalenti. Fino ad arrivare a concepire la tesi di Church-Turing. Il prof. nota che questo è strano, perché in altre discipline si converge in unico modello, mentre qui molte cose sono indifferenti.
Questo è importante per capire come la concezione di Computer Science si è evoluta (Denning 2010).">
<meta name="author" content="Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="https://flecart.github.io/notes/la-macchina-di-turing/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/la-macchina-di-turing/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>
<script type="text/javascript" async
src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>






      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-WW6NN2QGKF');
        }
      </script><meta property="og:url" content="https://flecart.github.io/notes/la-macchina-di-turing/">
  <meta property="og:site_name" content="X. Angelo Huang&#39;s Blog">
  <meta property="og:title" content="La macchina di Turing">
  <meta property="og:description" content="Introduzione Note filosofiche (non impo) Bisogna in primo momento cercare di definire cosa è la computazione e cosa è un computer. Aristotele faceva la distinzione fra proprietà essenziali e accidentali. Quelle essenziali sono proprie dell’oggetto.
Una sedia può essere fatta di legno o di metallo, ma questa proprietà è accidentale, ovvero, essa rimane una sedia indipendentemente dal materiale di cui è fatta.
Solitamente in matematica si prova ad astrarre (vedi Astrazione sul controllo per nota generale sull’astrazione). Però in questo campo si sono trovati molte concezioni equivalenti. Fino ad arrivare a concepire la tesi di Church-Turing. Il prof. nota che questo è strano, perché in altre discipline si converge in unico modello, mentre qui molte cose sono indifferenti. Questo è importante per capire come la concezione di Computer Science si è evoluta (Denning 2010).">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="notes">
    <meta property="article:tag" content="Theoretical-Computer-Science">
      <meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:title" content="La macchina di Turing">
<meta name="twitter:description" content="Introduzione
Note filosofiche (non impo)
Bisogna in primo momento cercare di definire cosa è la computazione e cosa è un computer.
Aristotele faceva la distinzione fra proprietà essenziali e accidentali. Quelle essenziali sono proprie dell&rsquo;oggetto.

Una sedia può essere fatta di legno o di metallo, ma questa proprietà è accidentale, ovvero, essa rimane una sedia indipendentemente dal materiale di cui è fatta.
Solitamente in matematica si prova ad astrarre (vedi Astrazione sul controllo per nota generale sull&rsquo;astrazione). Però in questo campo si sono trovati molte concezioni equivalenti. Fino ad arrivare a concepire la tesi di Church-Turing. Il prof. nota che questo è strano, perché in altre discipline si converge in unico modello, mentre qui molte cose sono indifferenti.
Questo è importante per capire come la concezione di Computer Science si è evoluta (Denning 2010).">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "La macchina di Turing",
      "item": "https://flecart.github.io/notes/la-macchina-di-turing/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "La macchina di Turing",
  "name": "La macchina di Turing",
  "description": "Introduzione Note filosofiche (non impo) Bisogna in primo momento cercare di definire cosa è la computazione e cosa è un computer. Aristotele faceva la distinzione fra proprietà essenziali e accidentali. Quelle essenziali sono proprie dell\u0026rsquo;oggetto.\nUna sedia può essere fatta di legno o di metallo, ma questa proprietà è accidentale, ovvero, essa rimane una sedia indipendentemente dal materiale di cui è fatta.\nSolitamente in matematica si prova ad astrarre (vedi Astrazione sul controllo per nota generale sull\u0026rsquo;astrazione). Però in questo campo si sono trovati molte concezioni equivalenti. Fino ad arrivare a concepire la tesi di Church-Turing. Il prof. nota che questo è strano, perché in altre discipline si converge in unico modello, mentre qui molte cose sono indifferenti. Questo è importante per capire come la concezione di Computer Science si è evoluta (Denning 2010).\n",
  "keywords": [
    "theoretical-computer-science"
  ],
  "articleBody": "Introduzione Note filosofiche (non impo) Bisogna in primo momento cercare di definire cosa è la computazione e cosa è un computer. Aristotele faceva la distinzione fra proprietà essenziali e accidentali. Quelle essenziali sono proprie dell’oggetto.\nUna sedia può essere fatta di legno o di metallo, ma questa proprietà è accidentale, ovvero, essa rimane una sedia indipendentemente dal materiale di cui è fatta.\nSolitamente in matematica si prova ad astrarre (vedi Astrazione sul controllo per nota generale sull’astrazione). Però in questo campo si sono trovati molte concezioni equivalenti. Fino ad arrivare a concepire la tesi di Church-Turing. Il prof. nota che questo è strano, perché in altre discipline si converge in unico modello, mentre qui molte cose sono indifferenti. Questo è importante per capire come la concezione di Computer Science si è evoluta (Denning 2010).\nNascita della calcolabilità: Turing (curiosità) Al tempo si voleva in matematica trovare un formalismo, un fondamenta logico alla matematica che poteva permettere di dimostrare tutto dalle fondamenta. Il contributo principale, e secondo il prof il lavoro più importante in tutta l’informatica era (Turing 1937), che definisce cosa significa calcolare un problema. Questo porta al significato di calcolare un problema. È interessante notare come Turing arriva al suo formalismo. Osserva\nL’esecuzione di certe regole Un foglio di carta in cui sono lette e scritte dei simboli L’azione eseguita dipende dal simbolo precedente Da queste osservazioni iniziali, hanno astratto i dati (ora simboli binari) e le azioni, un set molti semplice. Osservazione: computazione è locale. Questo sembra simile quanto dichiarato in (Dehaene 2014) quando si parla che l’essere umano è capace di porre davanti l’attenzione della coscienza solamente un solo simbolo alla volta.\nLa macchina di Turing Vedere precedente per capire come è stata ideata questa macchina di Turing.\nDefinizione matematica È interessante confrontare questa definizione con Fondamenti teorica#La macchina di turing in cui usiamo un formato leggermente diverso, il formato preciso è quello precedente fatto a linguaggi. In sto corso usiamo un formalismo più semplice). Nel nostro caso è una 5-tupla di\n$\\Sigma$, un alfabeto di simboli finiti, con simbolo speciale per cella vuota $Q$ Un insieme di stati $q_{0} \\in Q$ lo stato iniziale $H \\subseteq Q$ l’insieme degli stati finali $\\delta$ la funzione di transizione che soddisfa questo: $$ \\delta : (Q - H) \\times \\Sigma \\to Q\\times \\Sigma \\times \\left\\{ \\to, \\leftarrow \\right\\} $$ La differenza è che in questo caso l’alfabeto dell’input è uguale all’alfabeto del nastro, ma alla fine cambia poco, basta TODO (capire) secondo me ha sbagliato il prof. tempo fa, perché l’alfabeto di input non è mai preso in considerazione nella funzione di transizione boh. Questa sintassi è più comprensibile della precedente quindi nice.\nCome per tutti i precedenti automi, anche questi hanno una rappresentazione possibile a diagramma: A lezione abbiamo anche visto esempi di macchine che computano moltiplicazione binaria o addizione binaria.\nProblemi di decisione Definizione problemi di decisione Molti problemi si possono codificare attraverso un problema di decisione, ossia un problema in cui abbiamo solamente bisogno di una risposta sì o no. Se riusciamo a codificarlo con il linguaggio delle macchine di Turing, allora forse si può far verificare alla macchina. Si vedrà che molti problemi non vanno.\nSchema di codifica Ossia un dato $\\alpha$ sarà descritto con $code(\\alpha) \\in \\Sigma^{*}$. Una nota interessante è che con Kolmogorov complexity abbiamo un dato di lunghezza minima, qui vediamo bene il link molto diretto. Questo ha delle proprietà:\nÈ Iniettiva Vorremmo capire in $\\Sigma^{*}$ quali siano dei codici possibili per un qualche $\\alpha$ nel nostro dominio. Sarebbe carino poter ritrovare $\\alpha$ a partire dal suo codice. Definizione decidibilità Dato un certo linguaggio, supponiamo di avere una macchina di Turing come definita di sopra #La macchina di Turing tale per cui abbia due stati finali $\\left\\{ H, N \\right\\}$, allora diciamo che $\\mathcal{M}$ decide $L$ se vale che\nQuando $x \\in L$ allora $\\mathcal{M}$ accetta $x$, ossia finisce su stato $H$ Quando $x \\not\\in L$ allora $\\mathcal{M}$ rigetta $x$, ossia finisce su stato $N$ Diciamo che un linguaggio $L$ è decidibile se una macchina di Turing lo decide. Ora abbiamo formalizzato il significato di decidibilità. Un altro modo per dire che una macchina è decidibile è se si ferma per ogni input, questo significa che o finisce in stato accettante o in stato rigettante.\nDefinizione riconoscibilità/semidecibilità Uguale al precedente, con la differenza che quando la stringa non appartiene al linguaggio diverge.\nDiciamo un linguaggio $L$ è riconoscibile se una macchina di Turing lo riconosce. Th: Decidibilità -\u003e Riconoscibilità, è facile costruire una tale macchina di Turing partendo da una che la decide, possiamo estendere il caso negativo in questo modo: se raggiungo lo stato negativo allora vado in loop infinito a caso.\nDefinizione non riconoscibilità Significa che non può dire in tempo finito né sì né no. Quindi è una cosa ancora più forte rispetto la semidecibilità.\nGerarchia di Chomsky Vedere Linguaggi liberi e PDA#Classificazione dei linguaggi alla sezione schema generale delle grammatiche. La cosa da ricordare è che TM è il modello più generale fra tutti i precedenti modelli di macchine di Turing e automi. Tesi di Church-Turing Enunciato della tesi Se la soluzione di un dato problema può essere calcolata attraverso una procedura algoritmica, allora può essere calcolata da una macchina di Turing. (Alonzo Church)\nAlonzo proponeva una altra teoria di calcolo, è stato proponente di lambda calcolo. Quelli che piacevano a Asperti.\nStoricamente sembra vero, perché sempre prendendo qualcosa che sembra più espressibile, resta alla fine equivalente a turing.\nEsempi di conseguenze:\nMacchine di Turing ‘migliorate’ (nondeterministiche, probabilistiche, più nastri…) Macchine a registri Linguaggi di programmazione di alto livello come Python, Java, C, … (Codice macchina di) computer classici • Computer quantistici Espressibilità vs semplicità e efficienza Probabilmente lo abbiamo citato in Fondamenti teorica, il fatto che questo è solamente una congettura perché non è possibile codificare tutti i formalismi possibili. Parla di espressibilità ossia cosa può essere calcolato, e se questo vale permette di dire che è una macchina universale. Infatti non dice nulla su semplicità o efficienza dell’algoritmo (in questa astrazione non ci interesssa).\nGiustificazione valenza di Turing (non impo) La cosa interessante di queste macchine comunque è che La macchina di Turing ci permette di formalizzare!\nRigorosità di algoritmo. (anche se non mi sembra buono per esprimere certe forme di calcolo (Denning 2010)). Teoremi di calcolabilità possono essere estese a qualunque altro formalismo, se vale. Versione rafforzata Questa versione è una estensione della tesi di Church-Turing in modo che comprenda la parte in Time and Space Complexity.\nOgni modello di calcolo deterministico fisicamente realizzabile può essere simulato da una TM (deterministica, su nastro singolo) con overhead al più polinomiale.\nSe ci pensiamo questa versione rafforzata è simile a quanto dimostrato in Kolmogorov complexity riguardo la complessità sulla lunghezza della minima stringa che lo descrive, perché lì abbiamo un overhead al massimo costante per tradurre da una macchina all’altra.\nChiusura del linguaggio di TM Chiusura sulla decidibilità Complemento: è molto semplice decidere sul complemento perché basta scambiare gli stati finali Unione: basta eseguirlo sul multinastro e comparare l’input, vedi Estensioni di Turing e altre macchine. Intersezione: Usi de morgan con i precedenti. Concatenazione: stessa dimostrazione per Grammatiche Regolari, concateni le macchine. Star: sì\nUn esercizio è dettagliare la definizione di queste macchina, in modo simile a quanto facevamo al corso di linguaggi.\nNOTA: ricorda di seguire la struttura della dimostrazione. Se no te la conterà come sbagliata all’esame.\nPer la concatenazione è un po’ più difficile del previsto, perché non so bene dove devo andare a tagliare per la seconda stringa, quindi vado in modo non deterministico sul taglio, così in pratica faccio tutte le cose possibili.\nChiusura sulla riconoscibilità Complemento: No Unione sì, stessa cosa precedente. Intersezione: credo basti concatenarli con reset dell’input e dire che si accetta se arriva in fondo Concatenazione: sì Star: dovrebbe sì.\nLa non chiusura del complemento la trovi in Halting Theorem and Reducibility. Perché si dimostra che $HALT$ e il suo complementare non sono chiusi, e questo basta per il complemento.\nLa macchina di Turing universale Esempi di macchine universali Sono dei programmi in grado di eseguire altri programmi. È una cosa molto particolare dell’informatica questa cosa, permetterebbe per esempio di eseguire un programma su se stesso, una cosa ricorsiva (oroboro quasi). Esempi di macchine universali possono essere\nSistemi operativi Stack di hardware che abbiamo, ognuna universale che esegue una sopra l’altra. Anche questo è stato pensato in (Turing 1937). Una cosa interessante è che prima di esso, la macchina era pensata per una unica cosa, dopo Turing si può usare la stessa macchina per tutti gli algoritmi possibili. Ha introdotto la nozione di programmabilità! Utilizzare il dato (l’algoritmo) come input di sé stesso è stato usato da Gödel nella sua dimostrazione famosa. Ha codificato teoremi come numeri, permettendo l’uso dell’aritmetica stessa.\nDescrizione UTM La cosa importante è che: \u003e La macchina universale deve avere lo stesso comportamento di $\\mathcal{M}$. Se si ferma, si ferma con stesso output, altrimenti non si ferma.\nCostruzione di UTM $$ code(t) = code(q_{i})0code(\\sigma_{n})0code(q_{j})0code(\\sigma(m))0code(\\sigma_{o})0 $$$$ code(\\sigma_{1i}...\\sigma_{in}) = 00code(\\sigma_1)0 code(\\sigma_{12}) 0 ... 0 code(\\sigma_{in}). $$ È interessante osservare che questo formato $code(\\mathcal{M})code(i)$ è una cosa decidibile, perché è un formato che si conosce.\nLettura simboli macchina specifica Interpretazione di essa Poi si può continuare ad utilizzare il nastro per simulare la macchina stessa. Per cominciare una simulazione della UTM:\nPasso di preparazione: verifica che y = code(ℳ)code(x) per qualche TM ℳ e input x. Se no, cicla. Se si, allora nastro 1 contiene code(ℳ)code(x). Vai al passo 2. Sposta code(ℳ) dal nastro 1 al nastro 2. Ora nastro 1 mostra il contenuto del nastro di ℳ su input x alla configurazione iniziale, in forma codificata. Scrivi code(q0) su nastro 3. Posiziona testina 1 sul primo simbolo di code(x), testina 2 sul primo simbolo di code(ℳ), and testina tre sul primo simbolo di code(q0). Quindi poi: Cerco la funzione transizione corretta sul nastro 2 che contiene la codifica, poi aggiorno i nastri 1 e 3 a seconda di cosa scrivo, della testina e dello stato corrente in nastro 3.\nReferences [1] Denning “Ubiquity Symposium 'What Is Computation?': Opening Statement” Ubiquity Vol. 2010(November), pp. 1880066.1880067 2010 [2] Turing “On Computable Numbers, with an Application to the Entscheidungsproblem” Proceedings of the London Mathematical Society Vol. s2-42(1), pp. 230--265 1937 [3] Dehaene “Consciousness and the Brain” Singapore Books 2014 ",
  "wordCount" : "1720",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/la-macchina-di-turing/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      La macchina di Turing
    </h1>
    <div class="post-meta">9 min&nbsp;·&nbsp;Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul><ul><ul>
                <li>
                    <a href="#introduzione" aria-label="Introduzione">Introduzione</a><ul>
                        
                <li>
                    <a href="#note-filosofiche-non-impo" aria-label="Note filosofiche (non impo)">Note filosofiche (non impo)</a></li>
                <li>
                    <a href="#nascita-della-calcolabilit%c3%a0-turing-curiosit%c3%a0" aria-label="Nascita della calcolabilità: Turing (curiosità)">Nascita della calcolabilità: Turing (curiosità)</a></li></ul>
                </li>
                <li>
                    <a href="#la-macchina-di-turing" aria-label="La macchina di Turing">La macchina di Turing</a><ul>
                        
                <li>
                    <a href="#definizione-matematica" aria-label="Definizione matematica">Definizione matematica</a></li></ul>
                </li>
                <li>
                    <a href="#problemi-di-decisione" aria-label="Problemi di decisione">Problemi di decisione</a><ul>
                        
                <li>
                    <a href="#definizione-problemi-di-decisione" aria-label="Definizione problemi di decisione">Definizione problemi di decisione</a></li>
                <li>
                    <a href="#schema-di-codifica" aria-label="Schema di codifica">Schema di codifica</a></li>
                <li>
                    <a href="#definizione-decidibilit%c3%a0" aria-label="Definizione decidibilità">Definizione decidibilità</a></li>
                <li>
                    <a href="#definizione-riconoscibilit%c3%a0semidecibilit%c3%a0" aria-label="Definizione riconoscibilità/semidecibilità">Definizione riconoscibilità/semidecibilità</a></li>
                <li>
                    <a href="#definizione-non-riconoscibilit%c3%a0" aria-label="Definizione non riconoscibilità">Definizione non riconoscibilità</a></li>
                <li>
                    <a href="#gerarchia-di-chomsky" aria-label="Gerarchia di Chomsky">Gerarchia di Chomsky</a></li></ul>
                </li>
                <li>
                    <a href="#tesi-di-church-turing" aria-label="Tesi di Church-Turing">Tesi di Church-Turing</a><ul>
                        
                <li>
                    <a href="#enunciato-della-tesi" aria-label="Enunciato della tesi">Enunciato della tesi</a></li>
                <li>
                    <a href="#espressibilit%c3%a0-vs-semplicit%c3%a0-e-efficienza" aria-label="Espressibilità vs semplicità e efficienza">Espressibilità vs semplicità e efficienza</a></li>
                <li>
                    <a href="#giustificazione-valenza-di-turing-non-impo" aria-label="Giustificazione valenza di Turing (non impo)">Giustificazione valenza di Turing (non impo)</a></li>
                <li>
                    <a href="#versione-rafforzata" aria-label="Versione rafforzata">Versione rafforzata</a></li></ul>
                </li>
                <li>
                    <a href="#chiusura-del-linguaggio-di-tm" aria-label="Chiusura del linguaggio di TM">Chiusura del linguaggio di TM</a><ul>
                        
                <li>
                    <a href="#chiusura-sulla-decidibilit%c3%a0" aria-label="Chiusura sulla decidibilità">Chiusura sulla decidibilità</a></li>
                <li>
                    <a href="#chiusura-sulla-riconoscibilit%c3%a0" aria-label="Chiusura sulla riconoscibilità">Chiusura sulla riconoscibilità</a></li></ul>
                </li>
                <li>
                    <a href="#la-macchina-di-turing-universale" aria-label="La macchina di Turing universale">La macchina di Turing universale</a><ul>
                        
                <li>
                    <a href="#esempi-di-macchine-universali" aria-label="Esempi di macchine universali">Esempi di macchine universali</a></li>
                <li>
                    <a href="#descrizione-utm" aria-label="Descrizione UTM">Descrizione UTM</a></li>
                <li>
                    <a href="#costruzione-di-utm" aria-label="Costruzione di UTM">Costruzione di UTM</a></li></ul>
                </li></ul>
                    </ul>
                    
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="introduzione">Introduzione<a hidden class="anchor" aria-hidden="true" href="#introduzione">#</a></h3>
<h4 id="note-filosofiche-non-impo">Note filosofiche (non impo)<a hidden class="anchor" aria-hidden="true" href="#note-filosofiche-non-impo">#</a></h4>
<p>Bisogna in primo momento cercare di definire <strong>cosa è la computazione</strong> e cosa è un computer.
Aristotele faceva la distinzione fra proprietà <strong>essenziali</strong> e <strong>accidentali</strong>. Quelle essenziali sono proprie dell&rsquo;oggetto.</p>
<blockquote>
<p>Una sedia può essere fatta di legno o di metallo, ma questa proprietà è accidentale, ovvero, essa rimane una sedia indipendentemente dal materiale di cui è fatta.</p></blockquote>
<p>Solitamente in matematica si prova ad astrarre (vedi <a href="/notes/astrazione-sul-controllo">Astrazione sul controllo</a> per nota generale sull&rsquo;astrazione). Però in questo campo si sono trovati molte concezioni equivalenti. Fino ad arrivare a concepire la tesi di Church-Turing. Il prof. nota che questo è strano, perché in altre discipline si converge in unico modello, mentre qui molte cose sono indifferenti.
Questo è importante per capire come la concezione di Computer Science si è evoluta <a href="https://dl.acm.org/doi/10.1145/1880066.1880067">(Denning 2010)</a>.</p>
<h4 id="nascita-della-calcolabilità-turing-curiosità">Nascita della calcolabilità: Turing (curiosità)<a hidden class="anchor" aria-hidden="true" href="#nascita-della-calcolabilità-turing-curiosità">#</a></h4>
<p>Al tempo si voleva in matematica trovare un formalismo, un fondamenta logico alla matematica che poteva permettere di dimostrare tutto dalle fondamenta. Il contributo principale, e secondo il prof il lavoro più importante in tutta l&rsquo;informatica era <a href="http://doi.wiley.com/10.1112/plms/s2-42.1.230">(Turing 1937)</a>, che definisce cosa significa calcolare un problema. Questo porta al significato di calcolare un problema.
È interessante notare come Turing arriva al suo formalismo.
Osserva</p>
<ol>
<li>L&rsquo;esecuzione di certe regole</li>
<li>Un foglio di carta in cui sono lette e scritte dei simboli</li>
<li>L&rsquo;azione eseguita dipende dal simbolo precedente</li>
</ol>
<p>Da queste osservazioni iniziali, hanno <em>astratto i dati</em> (ora simboli binari) e <em>le azioni</em>, un set molti semplice.
Osservazione: <strong>computazione è locale</strong>.
Questo sembra simile quanto dichiarato in <a href="https://books.google.it/books/about/Consciousness_and_the_Brain.html?id=9c02BwAAQBAJ&redir_esc=y">(Dehaene 2014)</a> quando si parla che l&rsquo;essere umano è capace di porre davanti l&rsquo;attenzione della coscienza solamente un solo simbolo alla volta.</p>
<h3 id="la-macchina-di-turing">La macchina di Turing<a hidden class="anchor" aria-hidden="true" href="#la-macchina-di-turing">#</a></h3>
<p>Vedere precedente per capire come è stata ideata questa macchina di Turing.</p>
<h4 id="definizione-matematica">Definizione matematica<a hidden class="anchor" aria-hidden="true" href="#definizione-matematica">#</a></h4>
<p>È interessante confrontare questa definizione con <a href="/notes/fondamenti-teorica#la-macchina-di-turing">Fondamenti teorica#La macchina di turing</a> in cui usiamo un formato leggermente diverso, il formato preciso è quello precedente fatto a linguaggi. In sto corso usiamo un formalismo più semplice).
Nel nostro caso è una 5-tupla di</p>
<ul>
<li>$\Sigma$, un <strong>alfabeto</strong> di simboli finiti, con simbolo speciale per cella vuota</li>
<li>$Q$ Un insieme di stati</li>
<li>$q_{0} \in Q$ lo stato iniziale</li>
<li>$H \subseteq Q$  l&rsquo;insieme degli stati finali</li>
<li>$\delta$ la funzione di transizione che soddisfa questo:
$$
\delta : (Q - H) \times \Sigma \to Q\times \Sigma \times \left\{ \to, \leftarrow \right\} 
$$
La differenza è che in questo caso l&rsquo;alfabeto dell&rsquo;input è uguale all&rsquo;alfabeto del nastro, ma alla fine cambia poco, basta TODO (capire) secondo me ha sbagliato il prof. tempo fa, perché l&rsquo;alfabeto di input non è mai preso in considerazione nella funzione di transizione boh.</li>
</ul>
<p>Questa sintassi è più comprensibile della precedente quindi nice.</p>
<p>Come per tutti i precedenti  automi, anche questi hanno una rappresentazione possibile a diagramma:
<img src="/images/notes/La macchina di Turing-20240221114813908.webp" width="544" class="center" alt="La macchina di Turing-20240221114813908"/></p>
<p>A lezione abbiamo anche visto esempi di macchine che computano moltiplicazione binaria o addizione binaria.</p>
<h3 id="problemi-di-decisione">Problemi di decisione<a hidden class="anchor" aria-hidden="true" href="#problemi-di-decisione">#</a></h3>
<h4 id="definizione-problemi-di-decisione">Definizione problemi di decisione<a hidden class="anchor" aria-hidden="true" href="#definizione-problemi-di-decisione">#</a></h4>
<p>Molti problemi si possono codificare attraverso un problema di decisione, ossia un problema in cui abbiamo solamente bisogno di una risposta sì o no.
Se riusciamo a codificarlo con il linguaggio delle macchine di Turing, allora forse si può far verificare alla macchina. Si vedrà che molti problemi non vanno.</p>
<h4 id="schema-di-codifica">Schema di codifica<a hidden class="anchor" aria-hidden="true" href="#schema-di-codifica">#</a></h4>
<p>Ossia un dato $\alpha$ sarà descritto con $code(\alpha) \in \Sigma^{*}$. Una nota interessante è che con <a href="/notes/kolmogorov-complexity">Kolmogorov complexity</a> abbiamo un dato di lunghezza minima, qui vediamo bene il link molto diretto.
Questo ha delle proprietà:</p>
<ol>
<li>È <strong>Iniettiva</strong></li>
<li>Vorremmo capire in $\Sigma^{*}$ quali siano dei codici possibili per un qualche $\alpha$ nel nostro dominio.</li>
<li>Sarebbe carino poter ritrovare $\alpha$ a partire dal suo codice.</li>
</ol>
<h4 id="definizione-decidibilità">Definizione decidibilità<a hidden class="anchor" aria-hidden="true" href="#definizione-decidibilità">#</a></h4>
<p>Dato un certo linguaggio, supponiamo di avere una macchina di Turing come definita di sopra <a href="/notes#la-macchina-di-turing">#La macchina di Turing</a> tale per cui abbia due stati finali $\left\{ H, N \right\}$, allora diciamo che $\mathcal{M}$ <strong>decide</strong> $L$ se vale che</p>
<ul>
<li>Quando $x \in L$ allora $\mathcal{M}$ accetta $x$, ossia finisce su stato $H$</li>
<li>Quando $x \not\in L$ allora $\mathcal{M}$ rigetta $x$, ossia finisce su stato $N$</li>
</ul>
<p>Diciamo che un linguaggio $L$ è decidibile se una macchina di Turing lo decide.
Ora abbiamo formalizzato il significato di decidibilità.
Un altro modo per dire che una macchina è decidibile è se <strong>si ferma per ogni input</strong>, questo significa che o finisce in stato accettante o in stato rigettante.</p>
<h4 id="definizione-riconoscibilitàsemidecibilità">Definizione riconoscibilità/semidecibilità<a hidden class="anchor" aria-hidden="true" href="#definizione-riconoscibilitàsemidecibilità">#</a></h4>
<p>Uguale al precedente, con la differenza che quando la stringa non appartiene al linguaggio <strong>diverge</strong>.</p>
<p>Diciamo un linguaggio $L$ è riconoscibile se una macchina di Turing lo riconosce.
Th: <strong>Decidibilità -&gt; Riconoscibilità</strong>, è facile costruire una tale macchina di Turing partendo da una che la decide, possiamo estendere il caso negativo in questo modo: se raggiungo lo stato negativo allora vado in loop infinito a caso.</p>
<h4 id="definizione-non-riconoscibilità">Definizione non riconoscibilità<a hidden class="anchor" aria-hidden="true" href="#definizione-non-riconoscibilità">#</a></h4>
<p>Significa che non può dire in tempo finito né sì né no. Quindi è una cosa ancora più forte rispetto la semidecibilità.</p>
<h4 id="gerarchia-di-chomsky">Gerarchia di Chomsky<a hidden class="anchor" aria-hidden="true" href="#gerarchia-di-chomsky">#</a></h4>
<p>Vedere <a href="/notes/linguaggi-liberi-e-pda#classificazione-dei-linguaggi">Linguaggi liberi e PDA#Classificazione dei linguaggi</a> alla sezione schema generale delle grammatiche. La cosa da ricordare è che TM è il modello più generale fra tutti i precedenti modelli di macchine di Turing e automi.
<img src="/images/notes/La macchina di Turing-20240512120403415.webp" style="width: 100%" class="center" alt="La macchina di Turing-20240512120403415"></p>
<h3 id="tesi-di-church-turing">Tesi di Church-Turing<a hidden class="anchor" aria-hidden="true" href="#tesi-di-church-turing">#</a></h3>
<h4 id="enunciato-della-tesi">Enunciato della tesi<a hidden class="anchor" aria-hidden="true" href="#enunciato-della-tesi">#</a></h4>
<blockquote>
<p>Se la soluzione di un dato problema può essere calcolata attraverso una procedura algoritmica, allora può essere calcolata da una macchina di Turing. (<em>Alonzo Church</em>)</p></blockquote>
<p>Alonzo proponeva una altra teoria di calcolo, è stato proponente di <em>lambda calcolo</em>. Quelli che piacevano a Asperti.</p>
<p>Storicamente sembra vero, perché sempre prendendo qualcosa che sembra più espressibile, resta alla fine equivalente a turing.</p>
<p>Esempi di conseguenze:</p>
<ul>
<li>Macchine di Turing &lsquo;migliorate&rsquo; (nondeterministiche, probabilistiche, più nastri…)</li>
<li>Macchine a registri</li>
<li>Linguaggi di programmazione di alto livello come Python, Java, C, …</li>
<li>(Codice macchina di) computer classici • Computer quantistici</li>
</ul>
<h4 id="espressibilità-vs-semplicità-e-efficienza">Espressibilità vs semplicità e efficienza<a hidden class="anchor" aria-hidden="true" href="#espressibilità-vs-semplicità-e-efficienza">#</a></h4>
<p>Probabilmente lo abbiamo citato in <a href="/notes/fondamenti-teorica">Fondamenti teorica</a>, il fatto che questo è solamente una <em>congettura</em> perché  non è possibile codificare tutti i formalismi possibili.
Parla di <strong>espressibilità</strong> ossia cosa può essere calcolato, e se questo vale permette di dire che è una macchina universale.
Infatti <strong>non dice nulla su semplicità o efficienza</strong> dell&rsquo;algoritmo (in questa astrazione non ci interesssa).</p>
<h4 id="giustificazione-valenza-di-turing-non-impo">Giustificazione valenza di Turing (non impo)<a hidden class="anchor" aria-hidden="true" href="#giustificazione-valenza-di-turing-non-impo">#</a></h4>
<p>La cosa interessante di queste macchine comunque è che <a href="/notes/la-macchina-di-turing">La macchina di Turing</a> ci permette di formalizzare!</p>
<ol>
<li>Rigorosità di algoritmo. (anche se non mi sembra buono per esprimere certe forme di calcolo <a href="https://dl.acm.org/doi/10.1145/1880066.1880067">(Denning 2010)</a>).</li>
<li>Teoremi di calcolabilità possono essere estese a qualunque altro formalismo, se vale.</li>
</ol>
<h4 id="versione-rafforzata">Versione rafforzata<a hidden class="anchor" aria-hidden="true" href="#versione-rafforzata">#</a></h4>
<p>Questa versione è una estensione della tesi di Church-Turing in modo che comprenda la parte in <a href="/notes/time-and-space-complexity">Time and Space Complexity</a>.</p>
<blockquote>
<p>Ogni modello di calcolo deterministico
fisicamente realizzabile può essere simulato da
una TM (deterministica, su nastro singolo) con
overhead al <strong>più polinomiale</strong>.</p></blockquote>
<p>Se ci pensiamo questa versione rafforzata è simile a quanto dimostrato in <a href="/notes/kolmogorov-complexity">Kolmogorov complexity</a> riguardo la complessità sulla lunghezza della minima stringa che lo descrive, perché lì abbiamo un overhead al massimo costante per tradurre da una macchina all&rsquo;altra.</p>
<h3 id="chiusura-del-linguaggio-di-tm">Chiusura del linguaggio di TM<a hidden class="anchor" aria-hidden="true" href="#chiusura-del-linguaggio-di-tm">#</a></h3>
<h4 id="chiusura-sulla-decidibilità">Chiusura sulla decidibilità<a hidden class="anchor" aria-hidden="true" href="#chiusura-sulla-decidibilità">#</a></h4>
<p><strong>Complemento:</strong> è molto semplice decidere sul complemento perché basta scambiare gli stati finali
<strong>Unione:</strong> basta eseguirlo sul multinastro e comparare l&rsquo;input, vedi <a href="/notes/estensioni-di-turing-e-altre-macchine">Estensioni di Turing e altre macchine</a>.
<strong>Intersezione</strong>: Usi de morgan con i precedenti.
<strong>Concatenazione</strong>: stessa dimostrazione per <a href="/notes/grammatiche-regolari">Grammatiche Regolari</a>, concateni le macchine.
<strong>Star</strong>: sì</p>
<p>Un esercizio è dettagliare la definizione di queste macchina, in modo simile a quanto facevamo al corso di linguaggi.</p>
<p>NOTA: ricorda di seguire la struttura della dimostrazione. Se no te la conterà come sbagliata all&rsquo;esame.</p>
<p>Per la concatenazione è un po&rsquo; più difficile del previsto, perché <strong>non so bene dove devo andare a tagliare</strong> per la seconda stringa, quindi vado in modo non deterministico sul taglio, così in pratica faccio tutte le cose possibili.</p>
<h4 id="chiusura-sulla-riconoscibilità">Chiusura sulla riconoscibilità<a hidden class="anchor" aria-hidden="true" href="#chiusura-sulla-riconoscibilità">#</a></h4>
<p><strong>Complemento</strong>: No
<strong>Unione</strong> sì, stessa cosa precedente.
<strong>Intersezione</strong>: credo basti concatenarli con reset dell&rsquo;input e dire che si accetta se arriva in fondo
<strong>Concatenazione</strong>: sì
<strong>Star</strong>: dovrebbe sì.</p>
<p>La non chiusura del complemento la trovi in <a href="/notes/halting-theorem-and-reducibility">Halting Theorem and Reducibility</a>. Perché si dimostra che $HALT$ e il suo complementare non sono chiusi, e questo basta per il complemento.</p>
<h3 id="la-macchina-di-turing-universale">La macchina di Turing universale<a hidden class="anchor" aria-hidden="true" href="#la-macchina-di-turing-universale">#</a></h3>
<h4 id="esempi-di-macchine-universali">Esempi di macchine universali<a hidden class="anchor" aria-hidden="true" href="#esempi-di-macchine-universali">#</a></h4>
<p>Sono dei programmi in grado di eseguire altri programmi. È una cosa molto particolare dell&rsquo;informatica questa cosa, permetterebbe per esempio di eseguire un programma su se stesso, una cosa ricorsiva (oroboro quasi).
Esempi di macchine universali possono essere</p>
<ol>
<li>Sistemi operativi</li>
<li>Stack di hardware che abbiamo, ognuna universale che esegue una sopra l&rsquo;altra.</li>
</ol>
<p>Anche questo è stato pensato in <a href="http://doi.wiley.com/10.1112/plms/s2-42.1.230">(Turing 1937)</a>.
Una cosa interessante è che prima di esso, la macchina era pensata per una unica cosa, dopo Turing si può usare la stessa macchina per tutti gli algoritmi possibili. Ha introdotto la nozione di programmabilità!
Utilizzare il dato (l&rsquo;algoritmo) come input di sé stesso è stato usato da Gödel nella sua dimostrazione famosa. Ha codificato teoremi come numeri, permettendo l&rsquo;uso dell&rsquo;aritmetica stessa.</p>
<h4 id="descrizione-utm">Descrizione UTM<a hidden class="anchor" aria-hidden="true" href="#descrizione-utm">#</a></h4>
<img src="/images/notes/La macchina di Turing-20240229124153090.webp" style="width: 100%" class="center" alt="La macchina di Turing-20240229124153090">
La cosa importante è che:
> La macchina universale deve avere lo stesso comportamento di $\mathcal{M}$.
<p>Se si ferma, si ferma con stesso output, altrimenti non si ferma.</p>
<h4 id="costruzione-di-utm">Costruzione di UTM<a hidden class="anchor" aria-hidden="true" href="#costruzione-di-utm">#</a></h4>
$$
code(t) = code(q_{i})0code(\sigma_{n})0code(q_{j})0code(\sigma(m))0code(\sigma_{o})0
$$$$
code(\sigma_{1i}...\sigma_{in}) = 00code(\sigma_1)0 code(\sigma_{12}) 0 ... 0 code(\sigma_{in}).
$$<p>
È interessante osservare che questo formato $code(\mathcal{M})code(i)$ è una cosa decidibile, perché è un formato che si conosce.</p>
<ol>
<li>Lettura simboli macchina specifica</li>
<li>Interpretazione di essa</li>
<li>Poi si può continuare ad utilizzare il nastro per simulare la macchina stessa.</li>
</ol>
<p>Per cominciare una simulazione della UTM:</p>
<ol>
<li>Passo di preparazione: verifica che y = code(ℳ)code(x) per
qualche TM ℳ e input x. Se no, cicla. Se si, allora nastro 1 contiene code(ℳ)code(x). Vai al passo 2.</li>
<li>Sposta code(ℳ) dal nastro 1 al nastro 2. Ora nastro 1 mostra il contenuto del nastro di ℳ su input x alla configurazione iniziale, in forma codificata.</li>
<li>Scrivi code(q0) su nastro 3.</li>
<li>Posiziona testina 1 sul primo simbolo di code(x), testina 2 sul primo simbolo di code(ℳ), and testina tre sul primo simbolo di code(q0).</li>
</ol>
<p>Quindi poi:
Cerco la funzione transizione corretta sul nastro 2 che contiene la codifica, poi aggiorno i nastri 1 e 3 a seconda di cosa scrivo, della testina e dello stato corrente in nastro 3.</p>
<h1 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h1>
<p id=denningUbiquitySymposiumWhat2010>[1] Denning <a href="https://dl.acm.org/doi/10.1145/1880066.1880067">“Ubiquity Symposium 'What Is Computation?': Opening Statement”</a> Ubiquity Vol. 2010(November), pp. 1880066.1880067 2010
 </p>
<p id=turingComputableNumbersApplication1937>[2] Turing <a href="http://doi.wiley.com/10.1112/plms/s2-42.1.230">“On Computable Numbers, with an Application to the Entscheidungsproblem”</a> Proceedings of the London Mathematical Society Vol. s2-42(1), pp. 230--265 1937
 </p>
<p id=dehaeneConsciousnessBrain2014>[3] Dehaene <a href="https://books.google.it/books/about/Consciousness_and_the_Brain.html?id=9c02BwAAQBAJ&redir_esc=y">“Consciousness and the Brain”</a> Singapore Books 2014
 </p>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/theoretical-computer-science/">Theoretical-Computer-Science</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share La macchina di Turing on x"
            href="https://x.com/intent/tweet/?text=La%20macchina%20di%20Turing&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fla-macchina-di-turing%2f&amp;hashtags=theoretical-computer-science">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share La macchina di Turing on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fla-macchina-di-turing%2f&amp;title=La%20macchina%20di%20Turing&amp;summary=La%20macchina%20di%20Turing&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2fla-macchina-di-turing%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share La macchina di Turing on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2fla-macchina-di-turing%2f&title=La%20macchina%20di%20Turing">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share La macchina di Turing on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2fla-macchina-di-turing%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share La macchina di Turing on whatsapp"
            href="https://api.whatsapp.com/send?text=La%20macchina%20di%20Turing%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2fla-macchina-di-turing%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share La macchina di Turing on telegram"
            href="https://telegram.me/share/url?text=La%20macchina%20di%20Turing&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fla-macchina-di-turing%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share La macchina di Turing on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=La%20macchina%20di%20Turing&u=https%3a%2f%2fflecart.github.io%2fnotes%2fla-macchina-di-turing%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
