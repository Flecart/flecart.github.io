<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Block Ciphers | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="üõ°Ô∏ècybersecurity">
<meta name="description" content="Utilizzano blocchi per cifra invece che stream generators. $n$ bits in input and $m$ bits in output generally a key is expanded into multiple keys, one for each rounds, and applied to a round function that iterates on the $m$.
DES 56 bit 3DES 56*3 bit di chiave AES che pu√≤ andare a 128, 196 o 256 Solitamente i stream ciphers studiati in OTP and Stream Ciphers sono pi√π veloci. Cipher Speed MB/sec RC4 126 Salsa20 643 Sosemanuk 727 AES 13 3DES 109 Data Encryption Standard - 1974 da IBM su commissione di NSA (Horst Feistel designed Lucifer at IBM in early 1970) - 1976 DES is federal standard with key-len 56 bits and block-len 64 bits.">
<meta name="author" content="Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="https://flecart.github.io/notes/block-ciphers/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/block-ciphers/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>




<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>
<script type="text/javascript" async
src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>





<script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-WW6NN2QGKF', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Block Ciphers" />
<meta property="og:description" content="Utilizzano blocchi per cifra invece che stream generators. $n$ bits in input and $m$ bits in output generally a key is expanded into multiple keys, one for each rounds, and applied to a round function that iterates on the $m$.
DES 56 bit 3DES 56*3 bit di chiave AES che pu√≤ andare a 128, 196 o 256 Solitamente i stream ciphers studiati in OTP and Stream Ciphers sono pi√π veloci. Cipher Speed MB/sec RC4 126 Salsa20 643 Sosemanuk 727 AES 13 3DES 109 Data Encryption Standard - 1974 da IBM su commissione di NSA (Horst Feistel designed Lucifer at IBM in early 1970) - 1976 DES is federal standard with key-len 56 bits and block-len 64 bits." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://flecart.github.io/notes/block-ciphers/" />
<meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png" />
<meta property="article:section" content="notes" />



<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png" />
<meta name="twitter:title" content="Block Ciphers"/>
<meta name="twitter:description" content="Utilizzano blocchi per cifra invece che stream generators. $n$ bits in input and $m$ bits in output generally a key is expanded into multiple keys, one for each rounds, and applied to a round function that iterates on the $m$.
DES 56 bit 3DES 56*3 bit di chiave AES che pu√≤ andare a 128, 196 o 256 Solitamente i stream ciphers studiati in OTP and Stream Ciphers sono pi√π veloci. Cipher Speed MB/sec RC4 126 Salsa20 643 Sosemanuk 727 AES 13 3DES 109 Data Encryption Standard - 1974 da IBM su commissione di NSA (Horst Feistel designed Lucifer at IBM in early 1970) - 1976 DES is federal standard with key-len 56 bits and block-len 64 bits."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Block Ciphers",
      "item": "https://flecart.github.io/notes/block-ciphers/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Block Ciphers",
  "name": "Block Ciphers",
  "description": "Utilizzano blocchi per cifra invece che stream generators. $n$ bits in input and $m$ bits in output generally a key is expanded into multiple keys, one for each rounds, and applied to a round function that iterates on the $m$.\nDES 56 bit 3DES 56*3 bit di chiave AES che pu√≤ andare a 128, 196 o 256 Solitamente i stream ciphers studiati in OTP and Stream Ciphers sono pi√π veloci. Cipher Speed MB/sec RC4 126 Salsa20 643 Sosemanuk 727 AES 13 3DES 109 Data Encryption Standard - 1974 da IBM su commissione di NSA (Horst Feistel designed Lucifer at IBM in early 1970) - 1976 DES is federal standard with key-len 56 bits and block-len 64 bits.",
  "keywords": [
    "üõ°Ô∏ècybersecurity"
  ],
  "articleBody": "Utilizzano blocchi per cifra invece che stream generators. $n$ bits in input and $m$ bits in output generally a key is expanded into multiple keys, one for each rounds, and applied to a round function that iterates on the $m$.\nDES 56 bit 3DES 56*3 bit di chiave AES che pu√≤ andare a 128, 196 o 256 Solitamente i stream ciphers studiati in OTP and Stream Ciphers sono pi√π veloci. Cipher Speed MB/sec RC4 126 Salsa20 643 Sosemanuk 727 AES 13 3DES 109 Data Encryption Standard - 1974 da IBM su commissione di NSA (Horst Feistel designed Lucifer at IBM in early 1970) - 1976 DES is federal standard with key-len 56 bits and block-len 64 bits. in quel periodo era solamente fatta dalla intelligence, non c‚Äôera bisogno di comunicazioni per il pubblico in quel periodo.\n1977 - 1998 questo era lo standard per gli stati uniti. best studied cipher in the world! Oggi insicuro, esiste una sua variante 3DES che √® pi√π sicura, ma comunque rotto 1997 DES broken by brute force. 2000 AES replaces DES. C‚Äô√® una step di **creazione delle chiavi\nFeistel network ##### Definizione Feistel üü© Definiamo una funzione di Feistel $f(L^{i - 1}, R^{i - 1}, K^{i}) \\to L^{i}, R^{i}$ la seguente: Uno state $u^{i}$ √® diviso in due parti, che vengono cifrati in questo modo: $$\n\\begin{cases} L^{i} = R^{i - 1}\\ R^{i} = L^{i - 1} \\oplus f^{i}(R^{i - 1}, K^{i}) \\end{cases} $$ Dove $f$ √® una funzione invertibile, se si ha la chiave.\nInvertibilit√† di Feistelüü© La caratteristica bella √® che data la chiave questo √® facilmente invertibile, anche se $f$ potrebbe non esserlo. Infatti la seguente funzione inverte in modo facile $$ \\begin{cases} L^{i - 1} = R^{i} \\oplus f^{i}(L^{i}, K^{i})\\\\ R^{i - 1} = L^{i} \\end{cases} $$ Si pu√≤ verificare in modo facile che funziona questo.\nThe $f$ functions are only used in inverse order. AES does not use those.\nTheoretical result: Suppose we have a $f: K \\times \\left\\{ 0, 1 \\right\\}^{n} \\to \\left\\{ 0, 1 \\right\\}^{n}$ then a 3-round Feistel using the same $f$ at each step $F: K^{3}\\times \\left\\{ 0, 1 \\right\\}^{2n} \\to \\left\\{ 0, 1 \\right\\}^{2n}$ is a secure $PRP$ so the security is dependent on the $f$ function, which makes sense to use this function.\nFunzionamento DESüü© Quindi\nmapping iniziale $IP$ che crea $L^{0}R^{0}$ rounds di Feistel Poi output La decryption √® simmetrica con la conoscenza della chiave.\n$f$ function in DESüü® Dove $A$ √® il 32 bit plain-text e $J$ √® la chiave di $48$ bits.\nLe funzioni $S$ sono tra le pi√π importanti per la sicurezza, perch√© resistono a certi tipi di attacchi conosciuti (che se riesco metto in questi appunti qui sotto). Sono in pratica una mappa di 4 bit e 2 bit a un 4 bit: functions $S: \\left\\{ 0, 1 \\right\\}^{6} \\to \\left\\{ 0, 1 \\right\\}^{4}$. These tables are built following some design principles: **Not linear**: Suppose they are linear, aka we can write $S_{i}(x) = A_{i}x \\mod 2$. If this is happens, then it‚Äôs just shuffling and xors, and the whole cipher would be linear because composition of linear functions is linear. If the whole cipher is linear then something like $$ DES(k, m_{1}) \\oplus DES(k, m_{2}) = B \\begin{bmatrix} m_{1} \\\\ k \\end{bmatrix}\\oplus B \\begin{bmatrix} m_{2} \\\\ k \\end{bmatrix}= B\\begin{bmatrix} m_{1} \\oplus m_{2} \\\\ k \\oplus k \\end{bmatrix} $$ Another theoretical result is that if DES is linear most of the time, it would be possible to break it.\nAttacchi a DESüü© Gli attacchi maggiori (alcuni lo vengono anche come servizio commerciale) √® semplicemente bruteforce perch√© la chiave di 56 bit usata non √® che sia molto utile. (In un giorno te o rompe). Gli attacchi con known plaintext esistono, ma usano un insieme di dati non feasible. di $2^{40}$ coppie di plaintext-ciphertext.\nUnicit√† della chiaveüü©- √à notabile osservare che √® probabile sia in DES che AES che √® molto probabile che sia unica la chiave usata per cifrare quello. Questa nota √® utile per dire che se trovi quella chiave, probabilmente ti funziona anche per altre comunicazioni che utilizzano roba simile.\nSuppose DES is a ideal PRF (ideal secure cipher!?): $$ DES:\\pi_{1},\\dots \\pi_{56} \\times \\left\\{ 0, 1 \\right\\}^{64} \\to \\left\\{ 0, 1 \\right\\}^{64} $$ Th: $\\forall m, c$ there is at most one key $k$ such that $c = DES(k, m)$ with probability $\\geq 1 - \\frac{1}{256} \\approx 99.5\\%$. Proof: $$ \\mathbb{P} \\left[ \\exists k' \\neq k : c = DES(k, m) = DES(k', m) \\right] \\leq \\sum_{k' \\in \\left\\{ 0, 1 \\right\\}^{56}} \\mathbb{P}\\left[ DES(k, m) = DES(k', m) \\right] = 2^{56}\\frac{1}{2^{64}} = \\frac{1}{256} $$ Which means that the probability of having a key different from $k$ such that the encryption is the same is $1 / 256$.\nIf you do the same math for two messages we have $1 - 1 / 2^{71}$. Same thing is true for AES. This means that having one or two input pairs is enough for finding the real key.\nAltre versioni di DES Attacco a 2-DESüü© Vorremmo trovare una coppia di chiavi $k_{1}, k_{2}$ tale che per cui $E(k_{2}, m) = D(k_{1}, c)$ ed √® possibile con un meet in the middle, che dovrebbe diminuire lo spazio di ricerca. Conseguenza: Mi basta un $\u003c 2^{63}$ e space $2^{56}$ non un $2^{112}$ per rompere la chiave con questo attacco. Per questo motivo uso un 3-DES che non permette di fare questo. Ma per essere possibile questo attacco ha bisogno della coppia $M, C$ reale. Usato su 3DES abbiamo $2^{118}$ ma da una parte abbiamo il doppio.\nDESX (non impo) Wikipedia, this is not standardized, but should resist more against meet in the middle attacks. Ha key len of $184$. (Best attach is $2^{120}$.)\nConsidero tre chiavi e considero $$ k_{1} \\oplus E(k_{2}, m\\oplus k_{3}) $$ In parole semplici ho due chiavi in pi√π che uso per fare un xor prima di mandarlo in #Data Encryption standard normale. La cosa da notare √® che non cresce la complessit√† di quanto ci si aspetta.\n3-DES In modo semplice per renderlo pi√π sicuro √® il 3-DES in pratica DES applicato 3 volte, con chiave lunga il triplo, quindi pi√π resistente a brute-force.\n$$ 3E(k_{1},k_{2},k_{3}, m) = E(k_{1}, D(k_{2}, E(k_{3}, m))) $$ We add a decryption because we can implement $DES$ if we want. 3 times slower. Keysize is $2^{168}$. But attach in time $2^{118}$ is present, so 3DES is usually considered secure.\nAdvanced Encryption Standard It‚Äôs a substitution permutation network.\nNote storiche di AES Da un punto di vista storico √® stata una competizione internazionale 1997 che poi √® stata standardizzata nel 2000. Una conferenza per questo (in particolare al seconda) √® stata fatta a Roma, cosa che era curiosa, solitamente non si faceva cos√¨). √à stato scelto in base a\nSicurezza Costo implementazione Velocit√† hardware e software. (DES troppo lento e insicuro) Alla fine √® un algoritmo molto parallelizzabile. Generazione della chiaveüü®- La lunghezza della chiave decide il numero di rounds, rispettivamente 10, 12, 14. In base al fatto che usiamo 128, 192, o 256. Vedere 4.6 di (Stinson 2005). Per l‚Äôalgoritmo. La cosa √® che avremo una chiave di 16 bytes in output per il numero di rounds.\nFunzionamento del cifrarioüü©- Definiamo le operazioni (inizio con 16 bytes (blocco da 128 bits)) SubBytes (byte-by-byte substitution using an S-box) ShiftRows (a permutation, which cyclically shifts the last three rows in the State) MixColumns (substitution that uses Galois Fields, GF(2^8) arithmetic) Add Round key (bit-by-bit XOR with an expanded key\nSuboperations: Is a 1 byte S-box, a 256 byte table, so it is easily computable. $$ \\forall i,j : A_{k+1}[i, j] = S[A_{k}[i,j]] $$ Con $k$ lo step.\nMix Column is a linear transformation done independently (like $\\oplus$ xor operations and similar).\nCode-size vs performance Those tables can be compressed with a code that produces that. This has trade-offs for code-size and performance, but it can be allowed to be easily stored and implemented in embedded systems (like 8-bit wrist watches).\nModes of operation Electronic Code Book (ECB) Il problema principale di questo metodo na√Øve √® il fatto che posso vedere s e blocchi hanno avuto stesso input, perch√© non dipendono dalla posizione.\nQuesto non √® semantically secure secondo note in OTP and Stream Ciphers#Semantic security (!)\nDeterministic Counter (DETCTR) In pratica creo stream di bytes a blocchi per cifrare Th: questo cipher √® semanticamente sicuro se la funzione $F$ usata √® sicura. Ossia ha un buone garanzie teoriche se esiste e trovo tale $F$.\nCipher Block Chaining (CBC) Lo conosci.\nUna nota importante √® che si pu√≤ fare una analisi teorica, e sapere dopo quanti riusi di chiave √® necessario cambiarla, al fine di mantenere garanzie di sicurezza.\nSe si guarda le slides possiamo avere un risultato, che √® circa di $2^{48}$ blocchi per CBC. Si pu√≤ fare la stessa analisi per #Data Encryption Standard (per DES √® di circa $2^{12}$ (se ho pi√π di $2^{48}$ blocchi))\nNOTA: CBC non √® sicuro con un chosen plaintext se ho la capacit√† di predire gli IV Come:\nScelgo come mio chosen-plaintext $0$ cos√¨ ho in pratica la versione criptata di $IV$. Poi mando $m_{0} = IV \\oplus IV_{2}$ e $m_{1} \\neq m_{0}$ , se $c(m_{0})$ √® uguale al primo, allora ho indovinato il messaggio. Questo chiaramente d√† advantage 1 e rompe la definizione di semantic security. Diventa sicuro solamente se $IV$ √® abbastanza randomico.\nUna possibilit√† √® usare un IV creato dalla cifrazione di un Nonce, cos√¨ sei abbastanza sicuro che IV sia sicuro.\nCounter Mode (CTR) molto simile al counter mode per #Electronic Code Book (ECB) per√≤ ora abbiamo IV. Anche in questo caso possiamo usare una nonce based version. Per nonce-CTR abbiamo un $2^{64}$ di usage blocks (solitamente pi√π sicuro, e anche pi√π veloce, quindi verr√† pi√π utilizzato). Substitution-Permutation Networks (not required for exam) 2 componenti principali Abbiamo un box di sostituzione e un box di permutazione. La stringa iniziale viene divisa in molti blocchi di lunghezza $m$, e in totale avr√† lunghezza $lm$. Con padding finale possibile. C‚Äô√® un algoritmo abbastanza generale per questo genere di cifrari, che √® il 4.1 in (Stinson 2005). la cosa carina √® che queste funzioni alla fine sono molto semplici da implementare, sia in hardware e software. Non so bene su security garantuess\nKey generation and rounds In un unico round, viene encryptato molte volte (un round √® fra 10-20 cicli di criptazione) si chiamano iterated ciphers, e dalla chiave iniziale vengono generate 16 chiavi, una per ogni round. Questo lo chiamiamo round function e la funzione che genera le chiavi per ogni round sono key schedule.\nPseudo random function Main definition A $PRF$ defined over $(K, X, Y)$ (key, input, output space) is a function $$ F: K \\times X \\to Y $$ That has an efficient algorithm to evaluate this function. We say that this is random because we are considering three spaces of random variables (so the output should be a probability distribution over possible values!?)\nPseudo random permutation Solamente una pseudorandom-function tale per cui inizio e fine sono le stesse, quindi √® bigettiva\n$PRP$ defined over $K, X$ is a $$ E: K \\times X \\to X $$ Such that\n$E$ is easy to evaluate $E$ is one-to-one $E$ is easily invertible, a function $D: K \\times X \\to X$ that is invertible knowing the key. Secure Pseudo random functions Consider the set of all functions to $X \\to Y$ as $Funs\\left[ X, Y \\right]$ of size $Y^{X}$. Consider $S_{F} = \\left\\{ F(k, \\cdot) \\text{ s.t. } k \\in K \\right\\} \\subseteq Funs\\left[ X, Y \\right]$, which has the size of the $K$ keyspace\nWe say that PRF is secure if a random function in $Funs\\left[ X, Y \\right]$ is not distinguishable (with statistical tests or similar) from $S_{F}$. This is the similar idea from previous definitions of security (advantage with statistical tests, semantic security OTP and Stream Ciphers#Security necessities for PRNGs), if this is true it means an adversary has not knowledge of the original.\nFormal definition of secure PRF We define experiments in a way similar for semantic security. $b \\in \\left\\{ 0, 1 \\right\\}^{}$ we say that if $b=0$ then a PRF is sent. if $b= 1$ is sent a truly random function from $Funs$. We say that this is secure if the adversary doesn‚Äôt have any advantage.\nSame thing for $PRP$.\nPRF -\u003e PRG Let‚Äôs take a valid $PRF$ $F: K \\times \\left\\{ 0,1 \\right\\}^{n} \\to \\left\\{ 0, 1 \\right\\}^{n}$we want to show that we can generate a $G: K \\to \\left\\{ 0, 1 \\right\\}^{nt}$\nWe define $$ G(k) = F(k, 0) \\mid \\dots \\mid F(k, t) $$ This is easily parallelizable. Output of the generation of the truly random function is indistinguishable from output of pseudo-random thanks to security.\nReferences [1] Stinson ‚ÄúCryptography: Theory and Practice, Third Edition‚Äù CRC Press 2005\n",
  "wordCount" : "2134",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/block-ciphers/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;¬ª&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Block Ciphers
    </h1>
    <div class="post-meta">11 min&nbsp;¬∑&nbsp;Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul><ul><ul>
                <li>
                    <a href="#data-encryption-standard" aria-label="Data Encryption Standard">Data Encryption Standard</a><ul>
                        
                <li>
                    <a href="#feistel-network" aria-label="Feistel network">Feistel network</a><ul>
                        
                <li>
                    <a href="#invertibilit%c3%a0-di-feistel" aria-label="Invertibilit√† di Feistelüü©">Invertibilit√† di Feistelüü©</a></li></ul>
                </li>
                <li>
                    <a href="#funzionamento-des" aria-label="Funzionamento DESüü©">Funzionamento DESüü©</a></li>
                <li>
                    <a href="#f-function-in-des" aria-label="$f$ function in DESüü®">$f$ function in DESüü®</a></li>
                <li>
                    <a href="#attacchi-a-des" aria-label="Attacchi a DESüü©">Attacchi a DESüü©</a></li>
                <li>
                    <a href="#unicit%c3%a0-della-chiave-" aria-label="Unicit√† della chiaveüü©-">Unicit√† della chiaveüü©-</a></li></ul>
                </li>
                <li>
                    <a href="#altre-versioni-di-des" aria-label="Altre versioni di DES">Altre versioni di DES</a><ul>
                        
                <li>
                    <a href="#attacco-a-2-des" aria-label="Attacco a 2-DESüü©">Attacco a 2-DESüü©</a></li>
                <li>
                    <a href="#desx-non-impo" aria-label="DESX (non impo)">DESX (non impo)</a></li></ul>
                </li>
                <li>
                    <a href="#3-des" aria-label="3-DES">3-DES</a></li></ul>
                    
                <li>
                    <a href="#advanced-encryption-standard" aria-label="Advanced Encryption Standard">Advanced Encryption Standard</a><ul>
                        <ul>
                        
                <li>
                    <a href="#note-storiche-di-aes" aria-label="Note storiche di AES">Note storiche di AES</a></li>
                <li>
                    <a href="#generazione-della-chiave-" aria-label="Generazione della chiaveüü®-">Generazione della chiaveüü®-</a></li>
                <li>
                    <a href="#funzionamento-del-cifrario-" aria-label="Funzionamento del cifrarioüü©-">Funzionamento del cifrarioüü©-</a><ul>
                        
                <li>
                    <a href="#suboperations" aria-label="Suboperations:">Suboperations:</a></li>
                <li>
                    <a href="#code-size-vs-performance" aria-label="Code-size vs performance">Code-size vs performance</a></li></ul>
                </li></ul>
                    
                <li>
                    <a href="#modes-of-operation" aria-label="Modes of operation">Modes of operation</a><ul>
                        
                <li>
                    <a href="#electronic-code-book-ecb" aria-label="Electronic Code Book (ECB)">Electronic Code Book (ECB)</a></li>
                <li>
                    <a href="#deterministic-counter-detctr" aria-label="Deterministic Counter (DETCTR)">Deterministic Counter (DETCTR)</a></li>
                <li>
                    <a href="#cipher-block-chaining-cbc" aria-label="Cipher Block Chaining (CBC)">Cipher Block Chaining (CBC)</a></li>
                <li>
                    <a href="#counter-mode-ctr" aria-label="Counter Mode (CTR)">Counter Mode (CTR)</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#substitution-permutation-networks-not-required-for-exam" aria-label="Substitution-Permutation Networks (not required for exam)">Substitution-Permutation Networks (not required for exam)</a><ul>
                        <ul>
                        
                <li>
                    <a href="#2-componenti-principali" aria-label="2 componenti principali">2 componenti principali</a></li>
                <li>
                    <a href="#key-generation-and-rounds" aria-label="Key generation and rounds">Key generation and rounds</a></li></ul>
                    </ul>
                </li>
                <li>
                    <a href="#pseudo-random-function" aria-label="Pseudo random function">Pseudo random function</a><ul>
                        <ul>
                        
                <li>
                    <a href="#main-definition" aria-label="Main definition">Main definition</a></li>
                <li>
                    <a href="#pseudo-random-permutation" aria-label="Pseudo random permutation">Pseudo random permutation</a></li>
                <li>
                    <a href="#secure-pseudo-random-functions" aria-label="Secure Pseudo random functions">Secure Pseudo random functions</a></li>
                <li>
                    <a href="#formal-definition-of-secure-prf" aria-label="Formal definition of secure PRF">Formal definition of secure PRF</a></li>
                <li>
                    <a href="#prf---prg" aria-label="PRF -&gt; PRG">PRF -&gt; PRG</a></li></ul>
                    </ul>
                </li></ul>
                    
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Utilizzano blocchi per cifra invece che stream generators. $n$ bits in input and $m$ bits in output generally a key is <strong>expanded</strong> into multiple keys, one for each rounds, and applied to a <em>round function</em> that iterates on the $m$.</p>
<ul>
<li>DES 56 bit</li>
<li>3DES 56*3 bit di chiave</li>
<li>AES che pu√≤ andare a 128, 196 o 256
Solitamente i stream ciphers studiati in <a href="/notes/otp-and-stream-ciphers/">OTP and Stream Ciphers</a> sono pi√π veloci.</li>
</ul>
<table>
<thead>
<tr>
<th>Cipher</th>
<th>Speed MB/sec</th>
</tr>
</thead>
<tbody>
<tr>
<td>RC4</td>
<td>126</td>
</tr>
<tr>
<td>Salsa20</td>
<td>643</td>
</tr>
<tr>
<td>Sosemanuk</td>
<td>727</td>
</tr>
<tr>
<td>AES</td>
<td>13</td>
</tr>
<tr>
<td>3DES</td>
<td>109</td>
</tr>
</tbody>
</table>
<h3 id="data-encryption-standard">Data Encryption Standard<a hidden class="anchor" aria-hidden="true" href="#data-encryption-standard">#</a></h3>
<img src="/images/notes/Block Ciphers-20240525101348320.webp" alt="Block Ciphers-20240525101348320">
- 1974 da IBM su commissione di NSA (Horst Feistel designed Lucifer at IBM in early 1970)
- 1976 DES is federal standard with key-len 56 bits and block-len 64 bits.
<p>in quel periodo era solamente fatta dalla intelligence, non c‚Äôera bisogno di comunicazioni per il pubblico in quel periodo.</p>
<ul>
<li>1977 - 1998 questo era lo standard per gli stati uniti.</li>
<li>best studied cipher in the world!</li>
<li>Oggi insicuro, esiste una sua variante 3DES che √® pi√π sicura, ma comunque rotto</li>
<li>1997 DES broken by brute force.</li>
<li>2000 AES replaces DES.</li>
</ul>
<p>C&rsquo;√® una step di **creazione delle chiavi</p>
<h4 id="feistel-network">Feistel network<a hidden class="anchor" aria-hidden="true" href="#feistel-network">#</a></h4>
<img src="/images/notes/Block Ciphers-20240525101733613.webp" alt="Block Ciphers-20240525101733613">
##### Definizione Feistel üü©
Definiamo una funzione di Feistel $f(L^{i - 1}, R^{i - 1}, K^{i}) \to L^{i}, R^{i}$ la seguente:
<p>Uno state $u^{i}$ √® diviso in due parti, che vengono cifrati in questo modo:
$$</p>
<p>\begin{cases}
L^{i} = R^{i - 1}\
R^{i} = L^{i - 1} \oplus  f^{i}(R^{i - 1}, K^{i})
\end{cases}
$$
Dove $f$ √® una funzione invertibile, se si ha la chiave.</p>
<h5 id="invertibilit√†-di-feistel">Invertibilit√† di Feistelüü©<a hidden class="anchor" aria-hidden="true" href="#invertibilit√†-di-feistel">#</a></h5>
<p>La caratteristica bella √® che <strong>data la chiave</strong> questo √® facilmente invertibile, anche se $f$ potrebbe non esserlo. Infatti la seguente funzione inverte in modo facile
</p>
$$
\begin{cases}
L^{i - 1} =  R^{i} \oplus  f^{i}(L^{i}, K^{i})\\
R^{i - 1} = L^{i}
\end{cases}
$$
<p>
Si pu√≤ verificare in modo facile che funziona questo.</p>
<p>The $f$ functions are only used in inverse order. AES does not use those.</p>
<p>Theoretical result:
Suppose we have a $f: K \times \left\{ 0, 1 \right\}^{n} \to \left\{ 0, 1 \right\}^{n}$ then a 3-round Feistel using the same $f$ at each step $F: K^{3}\times \left\{ 0, 1 \right\}^{2n} \to \left\{ 0, 1 \right\}^{2n}$ is a secure $PRP$ so the security is dependent on the $f$ function, which makes sense to use this function.</p>
<h4 id="funzionamento-des">Funzionamento DESüü©<a hidden class="anchor" aria-hidden="true" href="#funzionamento-des">#</a></h4>
<p>Quindi</p>
<ol>
<li>mapping iniziale $IP$ che crea $L^{0}R^{0}$</li>
<li>rounds di Feistel</li>
<li>Poi output</li>
</ol>
<p>La decryption √® simmetrica con la conoscenza della chiave.</p>
<img src="/images/notes/Block Ciphers-20240305095533560.webp" alt="Block Ciphers-20240305095533560">
<h4 id="f-function-in-des">$f$ function in DESüü®<a hidden class="anchor" aria-hidden="true" href="#f-function-in-des">#</a></h4>
<p>Dove $A$ √® il 32 bit plain-text e $J$ √® la chiave di $48$ bits.</p>
<img src="/images/notes/Block Ciphers-20240305100001596.webp" alt="Block Ciphers-20240305100001596">
Le funzioni $S$ sono tra le pi√π importanti per la sicurezza, perch√© resistono a certi tipi di attacchi conosciuti (che se riesco metto in questi appunti qui sotto).
Sono in pratica una mappa di 4 bit e 2 bit a un 4 bit: functions $S: \left\{ 0, 1 \right\}^{6} \to \left\{ 0, 1 \right\}^{4}$.
<img src="/images/notes/Block Ciphers-20240525102622373.webp" alt="Block Ciphers-20240525102622373">
These tables are built following some design principles:
**Not linear**:
<p>Suppose they are linear, aka we can write $S_{i}(x) = A_{i}x \mod 2$. If this is happens, then it&rsquo;s just shuffling and xors, and the whole cipher would be linear because composition of linear functions is linear.
If the whole cipher is linear then something like
</p>
$$
DES(k, m_{1}) \oplus DES(k, m_{2}) = B \begin{bmatrix}
m_{1}  \\
k
\end{bmatrix}\oplus  
B \begin{bmatrix}
m_{2} \\
k
\end{bmatrix}= B\begin{bmatrix}
m_{1} \oplus m_{2}  \\
k \oplus k
\end{bmatrix}
$$
<p>
Another theoretical result is that if DES is linear most of the time, it would be possible to break it.</p>
<h4 id="attacchi-a-des">Attacchi a DESüü©<a hidden class="anchor" aria-hidden="true" href="#attacchi-a-des">#</a></h4>
<p>Gli attacchi maggiori (alcuni lo vengono anche come servizio commerciale) √® semplicemente <strong>bruteforce</strong> perch√© la chiave di 56 bit usata non √® che sia molto utile.
(In un giorno te o rompe).
Gli attacchi con known plaintext esistono, ma usano un insieme di dati non feasible. di $2^{40}$ coppie di plaintext-ciphertext.</p>
<h4 id="unicit√†-della-chiave-">Unicit√† della chiaveüü©-<a hidden class="anchor" aria-hidden="true" href="#unicit√†-della-chiave-">#</a></h4>
<p>√à notabile osservare che √® probabile sia in DES che AES che √® molto probabile che sia unica la chiave usata per cifrare quello.
Questa nota √® utile per dire che se trovi quella chiave, probabilmente ti funziona anche per altre comunicazioni che utilizzano roba simile.</p>
<p>Suppose DES is a ideal PRF (ideal secure cipher!?):
</p>
$$
DES:\pi_{1},\dots \pi_{56} \times \left\{ 0, 1 \right\}^{64} \to \left\{ 0, 1 \right\}^{64}
$$
<p>
Th:
$\forall m, c$ there is at most <strong>one</strong> key $k$ such that $c = DES(k, m)$ with probability $\geq 1 - \frac{1}{256} \approx 99.5\%$.
Proof:
</p>
$$
\mathbb{P} \left[ \exists k' \neq k : c = DES(k, m) = DES(k', m) \right] \leq \sum_{k' \in \left\{ 0, 1 \right\}^{56}} \mathbb{P}\left[ DES(k, m) = DES(k', m) \right]  = 2^{56}\frac{1}{2^{64}} = \frac{1}{256}
$$
<p>
Which means that the probability of having a key different from $k$ such that the encryption is the same is $1 / 256$.</p>
<p>If you do the same math for two messages we have $1 - 1 / 2^{71}$. Same thing is true for AES.
This means that having one or two input pairs is enough for finding the real key.</p>
<h3 id="altre-versioni-di-des">Altre versioni di DES<a hidden class="anchor" aria-hidden="true" href="#altre-versioni-di-des">#</a></h3>
<h4 id="attacco-a-2-des">Attacco a 2-DESüü©<a hidden class="anchor" aria-hidden="true" href="#attacco-a-2-des">#</a></h4>
<p>Vorremmo trovare una coppia di chiavi $k_{1}, k_{2}$ tale che per cui $E(k_{2}, m) = D(k_{1}, c)$ ed √® possibile con un meet in the middle, che dovrebbe diminuire lo spazio di ricerca.
<img src="/images/notes/Block Ciphers-20240305112238931.webp" alt="Block Ciphers-20240305112238931">
<strong>Conseguenza</strong>:
Mi basta un $< 2^{63}$ e space $2^{56}$ non un $2^{112}$ per rompere la chiave con questo attacco.
Per questo motivo uso un 3-DES che non permette di fare questo.
Ma per essere possibile questo attacco ha bisogno della coppia $M, C$ reale.
Usato su 3DES abbiamo $2^{118}$ ma da una parte abbiamo il doppio.</p>
<h4 id="desx-non-impo">DESX (non impo)<a hidden class="anchor" aria-hidden="true" href="#desx-non-impo">#</a></h4>
<p><a href="https://en.wikipedia.org/wiki/DES-X">Wikipedia</a>, this is not standardized, but should resist more against meet in the middle attacks. Ha key len of $184$. (Best attach is $2^{120}$.)</p>
<p>Considero tre chiavi e considero
</p>
$$
k_{1} \oplus  E(k_{2}, m\oplus  k_{3})
$$
<p>
In parole semplici ho due chiavi in pi√π che uso per fare un xor prima di mandarlo in <a href="/notes/block-ciphers/#data-encryption-standard">#Data Encryption standard</a> normale.
La cosa da notare √® che non cresce la complessit√† di quanto ci si aspetta.</p>
<h3 id="3-des">3-DES<a hidden class="anchor" aria-hidden="true" href="#3-des">#</a></h3>
<p>In modo semplice per renderlo pi√π sicuro √® il <strong>3-DES</strong> in pratica DES applicato 3 volte, con chiave lunga il triplo, quindi pi√π resistente a brute-force.</p>
$$
3E(k_{1},k_{2},k_{3}, m) = E(k_{1}, D(k_{2}, E(k_{3}, m)))
$$
<p>
We add a decryption because we can implement $DES$ if we want.
3 times slower. Keysize is $2^{168}$. But attach in time $2^{118}$ is present, so 3DES is usually considered secure.</p>
<h2 id="advanced-encryption-standard">Advanced Encryption Standard<a hidden class="anchor" aria-hidden="true" href="#advanced-encryption-standard">#</a></h2>
<p>It&rsquo;s a <strong>substitution permutation network</strong>.</p>
<h4 id="note-storiche-di-aes">Note storiche di AES<a hidden class="anchor" aria-hidden="true" href="#note-storiche-di-aes">#</a></h4>
<p>Da un punto di vista storico √® stata una competizione internazionale 1997 che poi √® stata standardizzata nel 2000. Una conferenza per questo (in particolare al seconda) √® stata fatta a Roma, cosa che era curiosa, solitamente non si faceva cos√¨).
√à stato scelto in base a</p>
<ol>
<li>Sicurezza</li>
<li>Costo implementazione</li>
<li>Velocit√† hardware e software. (DES troppo lento e insicuro)
Alla fine √® un algoritmo molto parallelizzabile.</li>
</ol>
<h4 id="generazione-della-chiave-">Generazione della chiaveüü®-<a hidden class="anchor" aria-hidden="true" href="#generazione-della-chiave-">#</a></h4>
<p>La lunghezza della chiave <strong>decide il numero di rounds</strong>, rispettivamente 10, 12, 14. In base al fatto che usiamo 128, 192, o 256.
Vedere 4.6 di <a href="https://books.google.it/books/about/Cryptography.html?id=FAPLBQAAQBAJ">(Stinson 2005)</a>. Per l&rsquo;algoritmo.
La cosa √® che avremo una chiave di 16 bytes in output per il numero di rounds.</p>
<h4 id="funzionamento-del-cifrario-">Funzionamento del cifrarioüü©-<a hidden class="anchor" aria-hidden="true" href="#funzionamento-del-cifrario-">#</a></h4>
<p>Definiamo le operazioni (inizio con 16 bytes (blocco da 128 bits))
<strong>SubBytes</strong> (byte-by-byte substitution using an S-box)
<strong>ShiftRows</strong> (a permutation, which cyclically shifts the last three rows in the State)
<strong>MixColumns</strong> (substitution that uses Galois Fields, GF(2^8) arithmetic)
<strong>Add</strong> Round key (bit-by-bit XOR with an expanded key</p>
<img src="/images/notes/Block Ciphers-20240305115629432.webp" alt="Block Ciphers-20240305115629432">
<h5 id="suboperations">Suboperations:<a hidden class="anchor" aria-hidden="true" href="#suboperations">#</a></h5>
<p>Is a 1 byte S-box, a 256 byte table, so it is easily computable.
</p>
$$
\forall i,j : A_{k+1}[i, j] = S[A_{k}[i,j]]
$$
<p>
Con $k$ lo step.</p>
<img src="/images/notes/Block Ciphers-20240525114937125.webp" alt="Block Ciphers-20240525114937125">
<p>Mix Column is a linear transformation done independently (like $\oplus$ xor operations and similar).</p>
<h5 id="code-size-vs-performance">Code-size vs performance<a hidden class="anchor" aria-hidden="true" href="#code-size-vs-performance">#</a></h5>
<p>Those tables can be compressed with a code that produces that. This has trade-offs for code-size and performance, but it can be allowed to be easily stored and implemented in embedded systems (like 8-bit wrist watches).</p>
<h3 id="modes-of-operation">Modes of operation<a hidden class="anchor" aria-hidden="true" href="#modes-of-operation">#</a></h3>
<h4 id="electronic-code-book-ecb">Electronic Code Book (ECB)<a hidden class="anchor" aria-hidden="true" href="#electronic-code-book-ecb">#</a></h4>
<p>Il problema principale di questo metodo na√Øve √® il fatto che posso vedere s e blocchi hanno avuto stesso input, perch√© non dipendono dalla posizione.</p>
<img src="/images/notes/Block Ciphers-20240307095344292.webp" alt="Block Ciphers-20240307095344292">
<p>Questo <strong>non √® semantically secure</strong> secondo note in <a href="/notes/otp-and-stream-ciphers/#semantic-security-(!)">OTP and Stream Ciphers#Semantic security (!)</a></p>
<h4 id="deterministic-counter-detctr">Deterministic Counter (DETCTR)<a hidden class="anchor" aria-hidden="true" href="#deterministic-counter-detctr">#</a></h4>
<p>In pratica <strong>creo stream di bytes a blocchi</strong> per cifrare
<img src="/images/notes/Block Ciphers-20240307111202941.webp" alt="Block Ciphers-20240307111202941"></p>
<p><strong>Th:</strong> questo cipher √® semanticamente sicuro se la funzione $F$ usata √® sicura.
Ossia ha un buone garanzie teoriche se esiste e trovo tale $F$.</p>
<h4 id="cipher-block-chaining-cbc">Cipher Block Chaining (CBC)<a hidden class="anchor" aria-hidden="true" href="#cipher-block-chaining-cbc">#</a></h4>
<p>Lo conosci.</p>
<img src="/images/notes/Block Ciphers-20240307115310428.webp" alt="Block Ciphers-20240307115310428">
<p>Una nota importante √® che si pu√≤ fare una analisi teorica, e sapere <strong>dopo quanti riusi di chiave</strong> √® necessario cambiarla, al fine di mantenere garanzie di sicurezza.</p>
<p>Se si guarda le slides possiamo avere un risultato, che √® circa di $2^{48}$ blocchi per CBC. Si pu√≤ fare la stessa analisi per <a href="/notes/block-ciphers/#data-encryption-standard">#Data Encryption Standard</a> (per DES √® di circa $2^{12}$ (se ho pi√π di $2^{48}$ blocchi))</p>
<p><strong>NOTA:</strong> CBC non √® sicuro con un chosen plaintext  se ho la capacit√† di predire gli <em>IV</em>
Come:</p>
<ol>
<li>Scelgo come mio chosen-plaintext $0$ cos√¨ ho in pratica la versione criptata di $IV$.</li>
<li>Poi mando $m_{0} = IV \oplus IV_{2}$   e $m_{1} \neq m_{0}$ , se $c(m_{0})$ √® uguale al primo, allora ho indovinato il messaggio.
Questo chiaramente d√† advantage 1 e rompe la definizione di semantic security.</li>
</ol>
<p>Diventa sicuro solamente se $IV$ √® abbastanza randomico.</p>
<p>Una possibilit√† √® usare un <strong>IV</strong> creato dalla cifrazione di un Nonce, cos√¨ sei abbastanza sicuro che IV sia sicuro.</p>
<h4 id="counter-mode-ctr">Counter Mode (CTR)<a hidden class="anchor" aria-hidden="true" href="#counter-mode-ctr">#</a></h4>
<p>molto simile al counter mode per <a href="/notes/block-ciphers/#electronic-code-book-(ecb)">#Electronic Code Book (ECB)</a> per√≤ ora abbiamo IV.
<img src="/images/notes/Block Ciphers-20240312101447979.webp" width="544" alt="Block Ciphers-20240312101447979">
Anche in questo caso possiamo usare una <strong>nonce based version</strong>.
Per nonce-CTR abbiamo un $2^{64}$ di usage blocks (solitamente pi√π sicuro, e anche pi√π veloce, quindi verr√† pi√π utilizzato).
<img src="/images/notes/Block Ciphers-20240525130219107.webp" width="636" alt="Block Ciphers-20240525130219107"></p>
<h2 id="substitution-permutation-networks-not-required-for-exam">Substitution-Permutation Networks (not required for exam)<a hidden class="anchor" aria-hidden="true" href="#substitution-permutation-networks-not-required-for-exam">#</a></h2>
<h4 id="2-componenti-principali">2 componenti principali<a hidden class="anchor" aria-hidden="true" href="#2-componenti-principali">#</a></h4>
<p>Abbiamo un box di sostituzione e un box di permutazione.
La stringa iniziale viene divisa in molti blocchi di lunghezza $m$, e in totale avr√† lunghezza $lm$. Con padding finale possibile.
C&rsquo;√® un algoritmo abbastanza generale per questo genere di cifrari, che √® il 4.1 in <a href="https://books.google.it/books/about/Cryptography.html?id=FAPLBQAAQBAJ">(Stinson 2005)</a>.
la cosa carina √® che queste funzioni alla fine sono molto semplici da implementare, sia in hardware e software. Non so bene su security garantuess</p>
<h4 id="key-generation-and-rounds">Key generation and rounds<a hidden class="anchor" aria-hidden="true" href="#key-generation-and-rounds">#</a></h4>
<p>In un unico round, viene encryptato molte volte (un round √® fra 10-20 cicli di criptazione) si chiamano <strong>iterated ciphers</strong>, e dalla chiave iniziale vengono generate 16 chiavi, una per ogni round.
Questo lo chiamiamo <strong>round function</strong> e la funzione che genera le chiavi per ogni round sono <strong>key schedule</strong>.</p>
<h2 id="pseudo-random-function">Pseudo random function<a hidden class="anchor" aria-hidden="true" href="#pseudo-random-function">#</a></h2>
<h4 id="main-definition">Main definition<a hidden class="anchor" aria-hidden="true" href="#main-definition">#</a></h4>
<p>A $PRF$ defined over $(K, X, Y)$ (key, input, output space) is a function
</p>
$$
F: K \times X \to Y
$$
<p>
That has an efficient algorithm to evaluate this function. We say that this is random because we are considering three spaces of random variables (so the output should be a probability distribution over possible values!?)</p>
<img src="/images/notes/OTP and Stream Ciphers-20240307110352630.webp" alt="OTP and Stream Ciphers-20240307110352630">
<h4 id="pseudo-random-permutation">Pseudo random permutation<a hidden class="anchor" aria-hidden="true" href="#pseudo-random-permutation">#</a></h4>
<p>Solamente una <strong>pseudorandom-function</strong> tale per cui inizio e fine sono le stesse, quindi √® <strong>bigettiva</strong></p>
<p>$PRP$ defined over $K, X$ is a
</p>
$$
E: K \times X \to X
$$
<p>
Such that</p>
<ul>
<li>$E$ is easy to evaluate</li>
<li>$E$ is <strong>one-to-one</strong></li>
<li>$E$ is easily invertible, a function $D: K \times X \to X$ that is invertible knowing the key.</li>
</ul>
<h4 id="secure-pseudo-random-functions">Secure Pseudo random functions<a hidden class="anchor" aria-hidden="true" href="#secure-pseudo-random-functions">#</a></h4>
<p>Consider the set of <strong>all</strong> functions to $X \to Y$ as $Funs\left[ X, Y \right]$ of size $Y^{X}$.
Consider $S_{F} = \left\{  F(k, \cdot) \text{ s.t. } k \in K \right\} \subseteq Funs\left[ X, Y \right]$, which has the size of the $K$ keyspace</p>
<p>We say that PRF is secure if a random function in $Funs\left[ X, Y \right]$ is not distinguishable (with statistical tests or similar) from $S_{F}$. This is the similar idea from previous definitions of security (advantage with statistical tests, semantic security <a href="/notes/otp-and-stream-ciphers/#security-necessities-for-prngs">OTP and Stream Ciphers#Security necessities for PRNGs</a>), if this is true it means an adversary has not knowledge of the original.</p>
<h4 id="formal-definition-of-secure-prf">Formal definition of secure PRF<a hidden class="anchor" aria-hidden="true" href="#formal-definition-of-secure-prf">#</a></h4>
<p>We define experiments in a way similar for semantic security.
$b \in \left\{ 0, 1 \right\}^{}$ we say that if $b=0$ then a PRF is sent. if $b= 1$ is sent a truly random function from $Funs$.
We say that this is secure if the adversary doesn&rsquo;t have any advantage.</p>
<p>Same thing for $PRP$.</p>
<h4 id="prf---prg">PRF -&gt; PRG<a hidden class="anchor" aria-hidden="true" href="#prf---prg">#</a></h4>
<p>Let&rsquo;s take a valid $PRF$ $F: K \times \left\{ 0,1 \right\}^{n} \to \left\{ 0, 1 \right\}^{n}$we want to show that we can generate a $G: K \to \left\{ 0, 1 \right\}^{nt}$</p>
<p>We define
</p>
$$
G(k) = F(k, 0) \mid \dots \mid F(k, t)
$$
<p>
This is easily <strong>parallelizable</strong>.
Output of the generation of the truly random function is indistinguishable from output of pseudo-random thanks to security.</p>
<h1 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h1>
<p>[1] Stinson <a href="https://books.google.it/books/about/Cryptography.html?id=FAPLBQAAQBAJ">‚ÄúCryptography: Theory and Practice, Third Edition‚Äù</a> CRC Press 2005</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/%EF%B8%8Fcybersecurity/">üõ°Ô∏èCybersecurity</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Block Ciphers on x"
            href="https://x.com/intent/tweet/?text=Block%20Ciphers&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fblock-ciphers%2f&amp;hashtags=%f0%9f%9b%a1%ef%b8%8fcybersecurity">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Block Ciphers on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fblock-ciphers%2f&amp;title=Block%20Ciphers&amp;summary=Block%20Ciphers&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2fblock-ciphers%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Block Ciphers on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2fblock-ciphers%2f&title=Block%20Ciphers">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Block Ciphers on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2fblock-ciphers%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Block Ciphers on whatsapp"
            href="https://api.whatsapp.com/send?text=Block%20Ciphers%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2fblock-ciphers%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Block Ciphers on telegram"
            href="https://telegram.me/share/url?text=Block%20Ciphers&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fblock-ciphers%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Block Ciphers on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Block%20Ciphers&u=https%3a%2f%2fflecart.github.io%2fnotes%2fblock-ciphers%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
