<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Cluster Resource Management | X. Angelo Huang&#39;s Blog</title>
<meta name="keywords" content="☁cloud-computing">
<meta name="description" content="We need to find an efficient and effective manner to allocate the resources around. This is what the resource management layer does.
Introduction to the problem
What is Cluster Resource Management?
Most of the time, the user specifies an amount of resources, and then the cluster decides how much to allocate (but approaches like (Delimitrou &amp; Kozyrakis 2014), do it differently).
There are mainly two parts in cluster resource management:

Allocation: deciding how many resources an application (techniques for this is presented in Cluster Management Policies.
Assignment: from which physical machine you can effectively put the application.

Types of management architectures
We mainly divide the management architectures in three ways:">
<meta name="author" content="
By Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="https://flecart.github.io/notes/cluster-resource-management/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f790d9af969c56c079c1ce2d5972a04486bf3d6144295d5fba319830e1e55a7a.css" integrity="sha256-95DZr5acVsB5wc4tWXKgRIa/PWFEKV1fujGYMOHlWno=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://flecart.github.io/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://flecart.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://flecart.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://flecart.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://flecart.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://flecart.github.io/notes/cluster-resource-management/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>
<script type="text/javascript" async
src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>






      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-WW6NN2QGKF');
        }
      </script><meta property="og:url" content="https://flecart.github.io/notes/cluster-resource-management/">
  <meta property="og:site_name" content="X. Angelo Huang&#39;s Blog">
  <meta property="og:title" content="Cluster Resource Management">
  <meta property="og:description" content="We need to find an efficient and effective manner to allocate the resources around. This is what the resource management layer does.
Introduction to the problem What is Cluster Resource Management? Most of the time, the user specifies an amount of resources, and then the cluster decides how much to allocate (but approaches like (Delimitrou &amp; Kozyrakis 2014), do it differently). There are mainly two parts in cluster resource management:
Allocation: deciding how many resources an application (techniques for this is presented in Cluster Management Policies. Assignment: from which physical machine you can effectively put the application. Types of management architectures We mainly divide the management architectures in three ways:">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="notes">
    <meta property="article:tag" content="☁Cloud-Computing">
      <meta property="og:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://flecart.github.io/images/papermod-cover.png">
<meta name="twitter:title" content="Cluster Resource Management">
<meta name="twitter:description" content="We need to find an efficient and effective manner to allocate the resources around. This is what the resource management layer does.
Introduction to the problem
What is Cluster Resource Management?
Most of the time, the user specifies an amount of resources, and then the cluster decides how much to allocate (but approaches like (Delimitrou &amp; Kozyrakis 2014), do it differently).
There are mainly two parts in cluster resource management:

Allocation: deciding how many resources an application (techniques for this is presented in Cluster Management Policies.
Assignment: from which physical machine you can effectively put the application.

Types of management architectures
We mainly divide the management architectures in three ways:">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "https://flecart.github.io/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Cluster Resource Management",
      "item": "https://flecart.github.io/notes/cluster-resource-management/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Cluster Resource Management",
  "name": "Cluster Resource Management",
  "description": "We need to find an efficient and effective manner to allocate the resources around. This is what the resource management layer does.\nIntroduction to the problem What is Cluster Resource Management? Most of the time, the user specifies an amount of resources, and then the cluster decides how much to allocate (but approaches like (Delimitrou \u0026amp; Kozyrakis 2014), do it differently). There are mainly two parts in cluster resource management:\nAllocation: deciding how many resources an application (techniques for this is presented in Cluster Management Policies. Assignment: from which physical machine you can effectively put the application. Types of management architectures We mainly divide the management architectures in three ways:\n",
  "keywords": [
    "☁cloud-computing"
  ],
  "articleBody": "We need to find an efficient and effective manner to allocate the resources around. This is what the resource management layer does.\nIntroduction to the problem What is Cluster Resource Management? Most of the time, the user specifies an amount of resources, and then the cluster decides how much to allocate (but approaches like (Delimitrou \u0026 Kozyrakis 2014), do it differently). There are mainly two parts in cluster resource management:\nAllocation: deciding how many resources an application (techniques for this is presented in Cluster Management Policies. Assignment: from which physical machine you can effectively put the application. Types of management architectures We mainly divide the management architectures in three ways:\n#Centralized: where you have a master-slave architectures #Two-level: where you have a two step allocation process (one proposes, and application accepts or refutes). #Distributed Cluster managers: where you have many many Centralized The resources of the cluster are managed in a single place.\nKubernetes Borg Quasar (Delimitrou \u0026 Kozyrakis 2014). Kubernetes Kubernetes is a container orchestration system. It is a platform that allows you to run containers at scale. It is a system that helps you run and manage containers.\nMonitors and reschedules containers. Provides persistent storage API, and communication APIs between containers. Users interface with a master node, which is responsible for managing the cluster. Nodes are called kubelets. The design is inspired by Borg, closed source used by Google. Discovery, naming, is a big problem in the cluster. The same problem is also for LLM services, how do you find the best offerer of a certain service? General architecture of Kubernetes.\nThe inspiration: Borg Cluster Pods These are a group of containers with the same:\nLifecycle (live and die together). Network Storage volumes They should run a common task. Labels and Selectors These are used to control node placement: how do you decide where to run a pod? You can label certain nodes, and then specify that a pod should run on a node with a certain label, or node-selectors. Kubernetes has also a simple control loop to keep a certain number of pods running.\nif you don’t have hard constraints, then the placement is done by following some affinity, taits, and toleration measures.\nThe service abstraction A service in Kube is a group of pods that work together to offer a certain service. They are usually behind a load balancer. Every service has a\nRequest: resources requested by the container Limit: max resource a container can access. Usage \u003e Request: resources might be available • Usage \u003e Limit: container is throttled or killed Quality of Service We can set some quality of service parameters on kubernetes: to have guaranteed requests and limits. We have three possible settings:\nGuaranteed: the requests are equal to the limit. Every container has a requests and limits set. They cannot get more resources, but they are the least likely to get killed, usually used for reliable resource availability. Burstable: if the process needs more resources, it can be killed. At least one container has a limit set. They can use additional resources when available.fdfd Best effort: none of the containers has a limit. Highest protection means less likely to be killed. Example:\napiVersion: v1 kind: Pod metadata: name: qos-example spec: containers: - name: app-container image: nginx resources: requests: cpu: \"250m\" memory: \"256Mi\" limits: cpu: \"500m\" memory: \"512Mi\" This falls into the burstable category, as limits are higher than the requests, if they were equal, then it would have been a guaranteed, if they were not set, then it would have been a best effort pod.\nKeep Alive Sandboxes can be kept alive to process more invocations. Usually sandboxes are kept alive after a request is processed (for some seconds). The cost is that they use more memory. Knative decides the sandbox count as number of inflight requests divided by sandbox parallelism (number of requests that a sandbox can execute in parallel). This is run periodically every 2 seconds. Policies can vary:\nParallelism Keep alive period. Service Mesh If you have a bunch of services that need to communicate with each other, it is helpful to have a service mesh. This mesh makes it easier to connect and manage secure traffic between services. One example is Istio. This is a service ran along the main service, that provides:\nData Plane: the part that actually processes the traffic, usually a sidecar container (see Design patterns). Control Plane: configure how communication is managed (security policies, who can talk to another? load balancing and similar). Horizontal Pod Autoscaler Kubernetes can scale based on utilization on the machine, this is called Horizontal Pod Autoscaler. You can:\nSet user-define min/max bounds for some resources. Currently only does it with CPU utilization. Dirigent Classical FaaS (see Cloud Computing Services) are not low-latency in scheduling functions, cold starts are especially slow.\nClassical FaaS systems Previously, people have focused on single worker node optimizations (startup time, namespace management, container image formats), but the control plane (similar to Control Plane for networks), the part that actually issues the commands, have been overlooked.\nKnative Classically Knative on K8s (but originally build for long workloads, so it has a high latency), classically about 1000 ms to start one function, and about 3000 for 100 functions. The main latency is from the control plane. On average 300 sandbox creations per second on cold start.\nAnalysis of Bottlenecks Each function has multiple hierarchical abstractions to decide the scheduling:\ndeployment ReplicaSet Pods You have a controller for each abstraction, that attempts to make it to the desired state, this created lots of overhead. You have too many controllers. Each controller needs to write to the etcd Database, which is a bottleneck. API server consumes a lot of CPU time, as everything passess through this (serialization bottleneck). Another bottleneck is high number of RPC communications due to the microservice architecture.\nSo in brief, three main bottlenecks:\nHierarchical abstraction with independent controllers Synchronous persistence for cluster updates (Serialization bottlencks) Microservice architecture with per-sandbox sidecars (Communication bottlenecks) Dirigent Innovations This is a simple architecture independent of Kubernetes (difficult to make it compatible). But remember: this is still a research preview, and has lots of limitations currently.\nAttacking bottlenecks Single controller: One controller for all the abstractions. They abolished hierarchical complex abstractions Mainly three abstractions (Function, sandbox, dataplane, workernode). Highly efficient, some couple of bytes (16), instead of some kilybytes Persistence-free latency-critical operations: Only function, dataplane and workernode are persisted, the other can be reconstructed. The sandbox can get different placement or IP address (cluster manager is quicker), user doesn’t need to know this. Monolithic control and data plane provides simplifying state management and simple deployment, instead of many RPCs. Evaluations The paper compares to Knative and OpenWhisk, on hello-world and busy-loop functions.\nImage from the paper\nWe some some orders of magnitude improvements. Two-level Mesos Mesos is an example of two level cluster managers: One global, central controller and multiple framework schedulers Mesos hands out the so called resource offer to applications, who then decide whether to take the offer or not. Mesos adopts a classical master-slave architecture, akin to what we have seen for Apache Spark, Massive Parallel Processing, Distributed file systems and similars.\nMesos Architecture We have three parts:\nWorkers: they continuously send resource usage statistics to the controller. They have some executor API to accept jobs from the application frameworks (Spark, Kube, etc). Controller: decides about resource offerings Application frameworks: decide whether to accept or not, and provides tasks to the workers. Distributed Cluster managers One would start from centralized solutions, and then move to this mode or Two-level only if we see some scalability issue. We have Omega (just a proof of concept, but never actually developed) and Sparrow.\nSparrow Sparrow is an example of a distributed scheduler. The main advantage is being more robust: it doesn’t have a single point of failure anymore.\nSparrow’s main architecture You have a bunch of schedulers, that assign tasks to workers. They do it independently.\nPower of two choices This is a way to choose the worker for the task:\nProbing: I query two workers and chose the one that has least load. Assigning: properly starting the task after gathering some info. It creates a lot of network overhead. To reduce this we batch the requests (not probe for every request).\nLate Binding This is an optimization to the early binding (solves if I choose a worker that has a very long job queue problem).\nAfter probing, instead of issuing the job, we make a reservation on some workers. When the worker is ready, it notifies the scheduler, and the scheduler assigns the job to the worker and cancels other reservations.\nReferences [1] Delimitrou \u0026 Kozyrakis “Quasar: Resource-Efficient and QoS-aware Cluster Management” Association for Computing Machinery 2014 ",
  "wordCount" : "1458",
  "inLanguage": "en",
  "image": "https://flecart.github.io/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://flecart.github.io/notes/cluster-resource-management/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. Angelo Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://flecart.github.io/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://flecart.github.io/" accesskey="h" title="X. Angelo Huang&#39;s Blog (Alt + H)">X. Angelo Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://flecart.github.io/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://flecart.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://flecart.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://flecart.github.io/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Cluster Resource Management
    </h1>
    <div class="post-meta">Reading Time: 7 minutes&nbsp;·&nbsp;
By Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul><ul><ul>
                <li>
                    <a href="#introduction-to-the-problem" aria-label="Introduction to the problem">Introduction to the problem</a><ul>
                        
                <li>
                    <a href="#what-is-cluster-resource-management" aria-label="What is Cluster Resource Management?">What is Cluster Resource Management?</a></li>
                <li>
                    <a href="#types-of-management-architectures" aria-label="Types of management architectures">Types of management architectures</a></li></ul>
                </li></ul>
                    
                <li>
                    <a href="#centralized" aria-label="Centralized">Centralized</a><ul>
                        
                <li>
                    <a href="#kubernetes" aria-label="Kubernetes">Kubernetes</a><ul>
                        
                <li>
                    <a href="#the-inspiration-borg-cluster" aria-label="The inspiration: Borg Cluster">The inspiration: Borg Cluster</a></li>
                <li>
                    <a href="#pods" aria-label="Pods">Pods</a></li>
                <li>
                    <a href="#labels-and-selectors" aria-label="Labels and Selectors">Labels and Selectors</a></li>
                <li>
                    <a href="#the-service-abstraction" aria-label="The service abstraction">The service abstraction</a></li>
                <li>
                    <a href="#quality-of-service" aria-label="Quality of Service">Quality of Service</a></li>
                <li>
                    <a href="#keep-alive" aria-label="Keep Alive">Keep Alive</a></li>
                <li>
                    <a href="#service-mesh" aria-label="Service Mesh">Service Mesh</a></li>
                <li>
                    <a href="#horizontal-pod-autoscaler" aria-label="Horizontal Pod Autoscaler">Horizontal Pod Autoscaler</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#dirigent" aria-label="Dirigent">Dirigent</a><ul>
                        
                <li>
                    <a href="#classical-faas-systems" aria-label="Classical FaaS systems">Classical FaaS systems</a><ul>
                        
                <li>
                    <a href="#knative" aria-label="Knative">Knative</a></li>
                <li>
                    <a href="#analysis-of-bottlenecks" aria-label="Analysis of Bottlenecks">Analysis of Bottlenecks</a></li></ul>
                </li>
                <li>
                    <a href="#dirigent-innovations" aria-label="Dirigent Innovations">Dirigent Innovations</a><ul>
                        
                <li>
                    <a href="#attacking-bottlenecks" aria-label="Attacking bottlenecks">Attacking bottlenecks</a></li>
                <li>
                    <a href="#evaluations" aria-label="Evaluations">Evaluations</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#two-level" aria-label="Two-level">Two-level</a><ul>
                        
                <li>
                    <a href="#mesos" aria-label="Mesos">Mesos</a><ul>
                        
                <li>
                    <a href="#mesos-architecture" aria-label="Mesos Architecture">Mesos Architecture</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#distributed-cluster-managers" aria-label="Distributed Cluster managers">Distributed Cluster managers</a><ul>
                        
                <li>
                    <a href="#sparrow" aria-label="Sparrow">Sparrow</a><ul>
                        
                <li>
                    <a href="#sparrows-main-architecture" aria-label="Sparrow&rsquo;s main architecture">Sparrow&rsquo;s main architecture</a></li>
                <li>
                    <a href="#power-of-two-choices" aria-label="Power of two choices">Power of two choices</a></li>
                <li>
                    <a href="#late-binding" aria-label="Late Binding">Late Binding</a></li></ul>
                </li></ul>
                </li></ul>
                    
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>We need to find an efficient and effective manner to allocate the resources around. This is what the resource management layer does.</p>
<h3 id="introduction-to-the-problem">Introduction to the problem<a hidden class="anchor" aria-hidden="true" href="#introduction-to-the-problem">#</a></h3>
<h4 id="what-is-cluster-resource-management">What is Cluster Resource Management?<a hidden class="anchor" aria-hidden="true" href="#what-is-cluster-resource-management">#</a></h4>
<p>Most of the time, the user specifies an amount of resources, and then the cluster decides how much to allocate (but approaches like <a href="https://doi.org/10.1145/2541940.2541941">(Delimitrou &amp; Kozyrakis 2014)</a>, do it differently).
There are mainly two parts in cluster resource management:</p>
<ul>
<li><strong>Allocation</strong>: deciding how many resources an application (techniques for this is presented in <a href="/notes/cluster-management-policies">Cluster Management Policies</a>.</li>
<li><strong>Assignment</strong>: from which physical machine you can effectively put the application.</li>
</ul>
<h4 id="types-of-management-architectures">Types of management architectures<a hidden class="anchor" aria-hidden="true" href="#types-of-management-architectures">#</a></h4>
<p>We mainly divide the management architectures in three ways:</p>
<ul>
<li><a href="/notes#centralized">#Centralized</a>: where you have a master-slave architectures</li>
<li><a href="/notes#two-level">#Two-level</a>: where you have a two step allocation process (one proposes, and application accepts or refutes).</li>
<li><a href="/notes#distributed-cluster-managers">#Distributed Cluster managers</a>: where you have many many</li>
</ul>
<h2 id="centralized">Centralized<a hidden class="anchor" aria-hidden="true" href="#centralized">#</a></h2>
<p>The resources of the cluster are managed in a single place.</p>
<ul>
<li>Kubernetes</li>
<li>Borg</li>
<li>Quasar <a href="https://doi.org/10.1145/2541940.2541941">(Delimitrou &amp; Kozyrakis 2014)</a>.</li>
</ul>
<h3 id="kubernetes">Kubernetes<a hidden class="anchor" aria-hidden="true" href="#kubernetes">#</a></h3>
<p>Kubernetes is a container orchestration system. It is a platform that allows you to run containers at scale. It is a system that helps you run and manage containers.</p>
<ul>
<li>Monitors and reschedules containers.</li>
<li>Provides persistent storage API, and communication APIs between containers.</li>
<li>Users interface with a <strong>master node</strong>, which is responsible for managing the cluster.</li>
<li>Nodes are called <strong>kubelets</strong>.</li>
<li>The design is inspired by <strong>Borg</strong>, closed source used by Google.</li>
<li>Discovery, naming, is a big problem in the cluster. The same problem is also for LLM services, how do you find the best offerer of a certain service?</li>
</ul>
<figure class="center">
<img src="/images/notes/Cluster Resource Management-20250525201453136.webp" style="width: 100%"   alt="Cluster Resource Management-20250525201453136" title="Cluster Resource Management-20250525201453136"/>
<figcaption><p style="text-align:center;">General architecture of Kubernetes.</p></figcaption>
</figure>
<h4 id="the-inspiration-borg-cluster">The inspiration: Borg Cluster<a hidden class="anchor" aria-hidden="true" href="#the-inspiration-borg-cluster">#</a></h4>
<img src="/images/notes/Cluster Resource Management-20250525201530606.webp" style="width: 100%" class="center" alt="Cluster Resource Management-20250525201530606">
<h4 id="pods">Pods<a hidden class="anchor" aria-hidden="true" href="#pods">#</a></h4>
<p>These are a group of containers with the same:</p>
<ul>
<li>Lifecycle (live and die together).</li>
<li>Network</li>
<li>Storage volumes</li>
<li>They should run a common task.</li>
</ul>
<h4 id="labels-and-selectors">Labels and Selectors<a hidden class="anchor" aria-hidden="true" href="#labels-and-selectors">#</a></h4>
<p>These are used to control <strong>node placement</strong>: how do you decide where to run a pod?
You can label certain nodes, and then specify that a pod should run on a node with a certain <strong>label</strong>, or <em>node-selectors</em>.
Kubernetes has also a simple control loop to keep a certain number of pods running.</p>
<p>if you don&rsquo;t have hard constraints, then the placement is done by following some <strong>affinity, taits, and toleration</strong> measures.</p>
<h4 id="the-service-abstraction">The service abstraction<a hidden class="anchor" aria-hidden="true" href="#the-service-abstraction">#</a></h4>
<p>A service in Kube is a group of pods that work together to offer a certain service.
They are usually behind a load balancer.
Every service has a</p>
<ul>
<li>Request: resources requested by the container</li>
<li>Limit: max resource a container can access.
Usage &gt; Request: resources might be available • Usage &gt; Limit: container is throttled or killed</li>
</ul>
<h4 id="quality-of-service">Quality of Service<a hidden class="anchor" aria-hidden="true" href="#quality-of-service">#</a></h4>
<p>We can set some quality of service parameters on kubernetes: to have guaranteed requests and <strong>limits</strong>.
We have three possible settings:</p>
<ul>
<li><strong>Guaranteed</strong>: the requests are equal to the limit. Every container has a requests and limits set. They cannot get more resources, but they are the <strong>least likely to get killed</strong>, usually used for reliable resource availability.</li>
<li><strong>Burstable</strong>: if the process needs more resources, it can be killed. At least one container has a limit set. They can use additional resources when available.fdfd</li>
<li><strong>Best effort</strong>: none of the containers has a limit.
Highest protection means <strong>less likely to be killed</strong>.</li>
</ul>
<p>Example:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Pod</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">qos-example</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">app-container</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">nginx</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">resources</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">requests</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">cpu</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;250m&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">memory</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;256Mi&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">limits</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">cpu</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;500m&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">memory</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;512Mi&#34;</span><span class="w">
</span></span></span></code></pre></div><p>This falls into the <strong>burstable category</strong>, as limits are higher than the requests, if they were equal, then it would have been a <strong>guaranteed</strong>, if they were not set, then it would have been a best effort pod.</p>
<h4 id="keep-alive">Keep Alive<a hidden class="anchor" aria-hidden="true" href="#keep-alive">#</a></h4>
<p>Sandboxes can be kept alive to process more invocations. Usually sandboxes are kept alive after a request is processed (for some seconds). The cost is that they use more memory.
Knative decides the sandbox count as number of inflight requests divided by sandbox parallelism (number of requests that a sandbox can execute in parallel). This is run periodically every 2 seconds.
Policies can vary:</p>
<ul>
<li>Parallelism</li>
<li>Keep alive period.</li>
</ul>
<h4 id="service-mesh">Service Mesh<a hidden class="anchor" aria-hidden="true" href="#service-mesh">#</a></h4>
<p>If you have a bunch of services that need to communicate with each other, it is helpful to have a <strong>service mesh</strong>. This mesh makes it easier to connect and manage <em>secure</em> traffic between services. One example is Istio.
This is a service ran along the main service, that provides:</p>
<ul>
<li><strong>Data Plane</strong>: the part that actually processes the traffic, usually a sidecar container (see <a href="/notes/design-patterns">Design patterns</a>).</li>
<li><strong>Control Plane</strong>: configure how communication is managed (security policies, who can talk to another? load balancing and similar).</li>
</ul>
<h4 id="horizontal-pod-autoscaler">Horizontal Pod Autoscaler<a hidden class="anchor" aria-hidden="true" href="#horizontal-pod-autoscaler">#</a></h4>
<p>Kubernetes can scale based on utilization on the machine, this is called <strong>Horizontal Pod Autoscaler</strong>.
You can:</p>
<ul>
<li>Set user-define min/max bounds for some resources.</li>
<li>Currently only does it with CPU utilization.</li>
</ul>
<h2 id="dirigent">Dirigent<a hidden class="anchor" aria-hidden="true" href="#dirigent">#</a></h2>
<p>Classical FaaS (see <a href="/notes/cloud-computing-services">Cloud Computing Services</a>) are not low-latency in scheduling functions, cold starts are especially slow.</p>
<h3 id="classical-faas-systems">Classical FaaS systems<a hidden class="anchor" aria-hidden="true" href="#classical-faas-systems">#</a></h3>
<p>Previously, people have focused on single worker node optimizations (startup time, namespace management, container image formats), but the <strong>control plane</strong> (similar to <a href="/notes/control-plane">Control Plane</a> for networks), the part that actually issues the commands, have been overlooked.</p>
<h4 id="knative">Knative<a hidden class="anchor" aria-hidden="true" href="#knative">#</a></h4>
<p>Classically Knative on K8s (but originally build for long workloads, so it has a high latency), classically about 1000 ms to start one function, and about 3000 for 100 functions. The main latency is from the control plane.
On average 300 sandbox creations per second on cold start.</p>
<h4 id="analysis-of-bottlenecks">Analysis of Bottlenecks<a hidden class="anchor" aria-hidden="true" href="#analysis-of-bottlenecks">#</a></h4>
<p>Each function has multiple hierarchical abstractions to decide the scheduling:</p>
<ul>
<li>deployment</li>
<li>ReplicaSet</li>
<li>Pods
You have a controller for each abstraction, that attempts to make it to the desired state, this created lots of overhead. You have too many controllers.
Each controller needs to write to the etcd Database, which is a bottleneck.
API server consumes a lot of CPU time, as everything passess through this (<strong>serialization bottleneck</strong>).</li>
</ul>
<p>Another bottleneck is high number of <strong>RPC</strong> communications due to the microservice architecture.</p>
<p>So in brief, three main bottlenecks:</p>
<ul>
<li>Hierarchical abstraction with independent controllers</li>
<li>Synchronous persistence for cluster updates (Serialization bottlencks)</li>
<li>Microservice architecture with per-sandbox sidecars (Communication bottlenecks)</li>
</ul>
<h3 id="dirigent-innovations">Dirigent Innovations<a hidden class="anchor" aria-hidden="true" href="#dirigent-innovations">#</a></h3>
<p>This is a simple architecture independent of Kubernetes (difficult to make it compatible).
But remember: this is still a research preview, and has lots of limitations currently.</p>
<h4 id="attacking-bottlenecks">Attacking bottlenecks<a hidden class="anchor" aria-hidden="true" href="#attacking-bottlenecks">#</a></h4>
<ul>
<li><strong>Single controller</strong>: One controller for all the abstractions.
<ul>
<li>They abolished hierarchical complex abstractions</li>
<li>Mainly three abstractions (Function, sandbox, dataplane, workernode).</li>
<li>Highly efficient, some couple of bytes (16), instead of some kilybytes</li>
</ul>
</li>
<li><strong>Persistence-free latency-critical operations</strong>:
<ul>
<li>Only function, dataplane and workernode are persisted, the other can be reconstructed.</li>
<li>The sandbox can get different placement or IP address (cluster manager is quicker), user doesn&rsquo;t need to know this.</li>
</ul>
</li>
<li><strong>Monolithic control and data plane</strong> provides simplifying state management and simple deployment, instead of many RPCs.</li>
</ul>
<h4 id="evaluations">Evaluations<a hidden class="anchor" aria-hidden="true" href="#evaluations">#</a></h4>
<p>The paper compares to Knative and OpenWhisk, on hello-world and busy-loop functions.</p>
<figure class="center">
<img src="/images/notes/Cluster Resource Management-20250324155357870.webp" style="width: 100%"   alt="Cluster Resource Management-20250324155357870" title="Cluster Resource Management-20250324155357870"/>
<figcaption><p style="text-align:center;">Image from the paper</p></figcaption>
</figure>
We some some orders of magnitude improvements.
<h2 id="two-level">Two-level<a hidden class="anchor" aria-hidden="true" href="#two-level">#</a></h2>
<h3 id="mesos">Mesos<a hidden class="anchor" aria-hidden="true" href="#mesos">#</a></h3>
<p>Mesos is an example of two level cluster managers: One global, central controller and multiple framework schedulers
Mesos hands out the so called <strong>resource offer</strong> to applications, who then decide whether to take the offer or not.
Mesos adopts a classical <strong>master-slave</strong> architecture, akin to what we have seen for <a href="/notes/apache-spark">Apache Spark</a>, <a href="/notes/massive-parallel-processing">Massive Parallel Processing</a>, <a href="/notes/distributed-file-systems">Distributed file systems</a> and similars.</p>
<h4 id="mesos-architecture">Mesos Architecture<a hidden class="anchor" aria-hidden="true" href="#mesos-architecture">#</a></h4>
<p>We have three parts:</p>
<ul>
<li>Workers: they continuously send resource usage statistics to the controller. They have some <em>executor</em> API to accept jobs from the application frameworks (Spark, Kube, etc).</li>
<li>Controller: decides about resource offerings</li>
<li>Application frameworks: decide whether to accept or not, and provides tasks to the workers.</li>
</ul>
<h2 id="distributed-cluster-managers">Distributed Cluster managers<a hidden class="anchor" aria-hidden="true" href="#distributed-cluster-managers">#</a></h2>
<p>One would start from centralized solutions, and then move to this mode or Two-level only if we see some scalability issue.
We have Omega (just a proof of concept, but never actually developed) and <a href="https://people.eecs.berkeley.edu/~matei/papers/2013/sosp_sparrow.pdf">Sparrow</a>.</p>
<h3 id="sparrow">Sparrow<a hidden class="anchor" aria-hidden="true" href="#sparrow">#</a></h3>
<p>Sparrow is an example of a distributed scheduler. The main advantage is being more robust: it doesn&rsquo;t have a single point of failure anymore.</p>
<h4 id="sparrows-main-architecture">Sparrow&rsquo;s main architecture<a hidden class="anchor" aria-hidden="true" href="#sparrows-main-architecture">#</a></h4>
<p>You have a bunch of schedulers, that assign tasks to workers.
<img src="/images/notes/Cluster Resource Management-20250324152225659.webp" style="width: 100%" class="center" alt="Cluster Resource Management-20250324152225659">
They do it independently.</p>
<h4 id="power-of-two-choices">Power of two choices<a hidden class="anchor" aria-hidden="true" href="#power-of-two-choices">#</a></h4>
<p>This is a way to choose the worker for the task:</p>
<ul>
<li><strong>Probing</strong>: I query two workers and chose the one that has least load.</li>
<li><strong>Assigning</strong>: properly starting the task after gathering some info.</li>
</ul>
<p>It creates a lot of network overhead. To reduce this we <strong>batch</strong> the requests (not probe for every request).</p>
<h4 id="late-binding">Late Binding<a hidden class="anchor" aria-hidden="true" href="#late-binding">#</a></h4>
<p>This is an optimization to the early binding (solves if I choose a worker that has a very long job queue problem).</p>
<p>After probing, instead of issuing the job, we make a <strong>reservation</strong> on some workers. When the worker is ready, it notifies the scheduler, and the scheduler assigns the job to the worker and cancels other reservations.</p>
<h1 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h1>
<p id=delimitrouQuasarResourceefficientQoSaware2014>[1] Delimitrou & Kozyrakis <a href="https://doi.org/10.1145/2541940.2541941">“Quasar: Resource-Efficient and QoS-aware Cluster Management”</a> Association for Computing Machinery  2014
 </p>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://flecart.github.io/tags/cloud-computing/">☁Cloud-Computing</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Cluster Resource Management on x"
            href="https://x.com/intent/tweet/?text=Cluster%20Resource%20Management&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fcluster-resource-management%2f&amp;hashtags=%e2%98%81cloud-computing">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Cluster Resource Management on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fcluster-resource-management%2f&amp;title=Cluster%20Resource%20Management&amp;summary=Cluster%20Resource%20Management&amp;source=https%3a%2f%2fflecart.github.io%2fnotes%2fcluster-resource-management%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Cluster Resource Management on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fflecart.github.io%2fnotes%2fcluster-resource-management%2f&title=Cluster%20Resource%20Management">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Cluster Resource Management on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fflecart.github.io%2fnotes%2fcluster-resource-management%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Cluster Resource Management on whatsapp"
            href="https://api.whatsapp.com/send?text=Cluster%20Resource%20Management%20-%20https%3a%2f%2fflecart.github.io%2fnotes%2fcluster-resource-management%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Cluster Resource Management on telegram"
            href="https://telegram.me/share/url?text=Cluster%20Resource%20Management&amp;url=https%3a%2f%2fflecart.github.io%2fnotes%2fcluster-resource-management%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Cluster Resource Management on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Cluster%20Resource%20Management&u=https%3a%2f%2fflecart.github.io%2fnotes%2fcluster-resource-management%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://flecart.github.io/">X. Angelo Huang&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
