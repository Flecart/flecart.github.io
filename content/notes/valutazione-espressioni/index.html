<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Valutazione Espressioni | X. A. Huang&#39;s Blog</title>
<meta name="keywords" content="no-tags">
<meta name="description" content="Ripasso Prox: 40 Ripasso: May 31, 2023 Ultima modifica: May 29, 2023 3:58 PM Primo Abbozzo: March 6, 2023 9:19 AM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso Espressioni, Comandi, Ricorsione Espressioni Con espressione intendiamo una entità sintattica, che una volta valutata ritornerà un valore, oppure non termina, in questo caso si dice che la espressione è INDEFINITA.
Questa è una definizione è leggermente ambigua dato che non abbiamo una definizione precisa di valutazoine, che è fortemente dipendente dalla macchina astratta in cui viene eseguito.">
<meta name="author" content="Xuanqiang &#39;Angelo&#39; Huang">
<link rel="canonical" href="http://localhost:1313/content/notes/valutazione-espressioni/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon-192x192.png">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/content/notes/valutazione-espressioni/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-WW6NN2QGKF"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-WW6NN2QGKF', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Valutazione Espressioni" />
<meta property="og:description" content="Ripasso Prox: 40 Ripasso: May 31, 2023 Ultima modifica: May 29, 2023 3:58 PM Primo Abbozzo: March 6, 2023 9:19 AM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso Espressioni, Comandi, Ricorsione Espressioni Con espressione intendiamo una entità sintattica, che una volta valutata ritornerà un valore, oppure non termina, in questo caso si dice che la espressione è INDEFINITA.
Questa è una definizione è leggermente ambigua dato che non abbiamo una definizione precisa di valutazoine, che è fortemente dipendente dalla macchina astratta in cui viene eseguito." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/content/notes/valutazione-espressioni/" />
<meta property="og:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta property="article:section" content="notes" />



<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta name="twitter:title" content="Valutazione Espressioni"/>
<meta name="twitter:description" content="Ripasso Prox: 40 Ripasso: May 31, 2023 Ultima modifica: May 29, 2023 3:58 PM Primo Abbozzo: March 6, 2023 9:19 AM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No
Elementi di ripasso Espressioni, Comandi, Ricorsione Espressioni Con espressione intendiamo una entità sintattica, che una volta valutata ritornerà un valore, oppure non termina, in questo caso si dice che la espressione è INDEFINITA.
Questa è una definizione è leggermente ambigua dato che non abbiamo una definizione precisa di valutazoine, che è fortemente dipendente dalla macchina astratta in cui viene eseguito."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Notes",
      "item": "http://localhost:1313/notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Valutazione Espressioni",
      "item": "http://localhost:1313/content/notes/valutazione-espressioni/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Valutazione Espressioni",
  "name": "Valutazione Espressioni",
  "description": "Ripasso Prox: 40 Ripasso: May 31, 2023 Ultima modifica: May 29, 2023 3:58 PM Primo Abbozzo: March 6, 2023 9:19 AM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No\nElementi di ripasso Espressioni, Comandi, Ricorsione Espressioni Con espressione intendiamo una entità sintattica, che una volta valutata ritornerà un valore, oppure non termina, in questo caso si dice che la espressione è INDEFINITA.\nQuesta è una definizione è leggermente ambigua dato che non abbiamo una definizione precisa di valutazoine, che è fortemente dipendente dalla macchina astratta in cui viene eseguito.",
  "keywords": [
    "no-tags"
  ],
  "articleBody": "Ripasso Prox: 40 Ripasso: May 31, 2023 Ultima modifica: May 29, 2023 3:58 PM Primo Abbozzo: March 6, 2023 9:19 AM Stato: 🌕🌕🌕🌕🌗 Studi Personali: No\nElementi di ripasso Espressioni, Comandi, Ricorsione Espressioni Con espressione intendiamo una entità sintattica, che una volta valutata ritornerà un valore, oppure non termina, in questo caso si dice che la espressione è INDEFINITA.\nQuesta è una definizione è leggermente ambigua dato che non abbiamo una definizione precisa di valutazoine, che è fortemente dipendente dalla macchina astratta in cui viene eseguito.\nNotazioni (sintassi possibili) (3) 🟩 Notazione infissa\nQuesta è la notazione classica matematica, per cose tipo $a -b$, in cui l’operando sta nel mezzo degli operatori.\nAbbiamo il vantaggio di famigliarità e semplicità della istruzione, ma perdiamo con ambiguità di precendenza degli operatori e associatività degli operatori, cioè non sempre sappiamo se una espressione ha precedenza con l’altra, per esempio una espressione del tipo x == y and y == 1d in un certo linguaggio and ha una precedenza, e quindi farebbe perdere di senso all’espressione.\nProblemi di precedenza abbiamo per cose come $1 - 1 -1$, che a seconda se facciamo prima il primo - o il secondo meno possiamo avere dei risultati differenti.\nQuindi se utilizziamo una notazione infissa, guadagniamo di semplicità e famigliarità, e perdiamo in complessità della valutazione, che per essere eseguita vorremmo creare un albero di valutazione, che spesso si deriva dall’albero di derivazione dopo il parser.\nNotazione prefissa (polacca)\nSono scritture come questo: $+ , a,b$, in qui scriviamo prima il + e poi gli operandi.\nÈ una cosa molto comoda perché non abbiamo la necessità di specificare precedenze né parentesi, ma basta sapere l’arietà del nostro operatore per poter valutare l’espressione.\nNotazione postfissa (polacca inversa)\nQuesta è uguale alla precedente, ma al contrario, quindi abbiamo cose come $a, b,+$, è anche più semplice da valutare, ma in generale molto semplice.\nPrefissa matematica e di cambridge\ncome f(a, b), oppure (f a b) per cambridge\nInterpretazione dell’albero\nSi potrebbe interpretare la notazione infissa, prefissa o postfissa come una visita dell’albero di valutazione.\nsimmetrica = visita infissa prefissa = visita prefissa (anticipata) (provo a valutare l’operatore e poi vado giù) Postfissa = visita postfissa (valuta dopo aver eseguito sinistra e destra) Semantica 🟩 Con la semantica andiamo ad indicare il processo di valutazione di una espressione. Abbiamo detto prima che per la notazione infissa è più complicata, infatti dovremmo andare a creare un albero di valutazione, creato dall’albero di derivazione (che quando compiliamo col parser è facile da creare dalle foglie).\nInvece se proviamo a valutare con la notazione prefissa, questa è una cosa molto più semplice, perché basta una singola scansione che va con questo algoritmo:\nSe è un operatore inizializzo un counter e torno a leggere Se vedo un operando pusho in pila e decremento il counter. Se counter è 0 faccio l’operazione e metto in stack, se è diverso da 0 torno a leggere Se è postfissa allora è ancora più semplice, se ho un operando pusho in pila, se ho un operatore prelevo quanto mi serve ed eseguo e pusho in pila il risultato.\nOrdine di valutazione delle sottoespressioni (4) 🟩— Matematicamente parlando non sarebbe molto importante andare a considerare l’ordine di valutazione, però in questo caso diventa molto importante perché l’ordine stesso potrebbe incidere sul risultato dell’espressione, un esempio è quando una espressione implica un side effect.\nSide effect (come potrebbe essere la chiamata di una funzione con side effect mentre valutiamo l’espressione!)\nPossibilità di overfow per aritmetica finita eg. (INT_MAX - 10 + 5) vs (INT_MAX + 5 - 10)\nCorto circuito e operatori non definiti.\nPer esempio una scrittura del tipo (p ≠ NULL) \u0026\u0026 (p.next == 1)sarebbe un errore in pascal, perché fa una esecuzione eager, cioè valuta tutto prima di valutare qualcosa, mentre in C se è null torno subito, questo si dice corto circuito perché non vado a valutare tutto. Efficienza, l’ordine di valutazione può anche cambiare l’efficienza dell’esecuzione, ad esempio inizializzando un accesso in memoria, e poi andare a fare altre operazioni che non avevano bisogno di accesso. Perché nell’esempio di sotto è probabile che aa non sia ancora disponibile, quindi conveniva fare cd prima di andare sull’altro, che deve attendere.\nEsempio a= vettore[i]; b = a*a + c*d In questa sede quindi è importante fare differenza fra\nComandi Definizione di comandi 🟩 Per comando intendiamo una entità sintattica che quando valutata non necessariamente ritorna un valore, inoltre potrebbe fare un effetto collaterale. (NOTA: anche le espressioni possono avere effetto collaterale)\nDa questa definizione non sembra ci sia una differenza chiara con l’espressione. però concettualmente dovremmo tenerci in mente che un comando è qualcosa di utile per cambiare lo stato del programma, ossia alla fine del comando ho uno stato differente, quindi ho avuto un side effect, mentre una espressione è qualcosa che idealmente non dovrebbe avere side-effect, ma alla fine ritorna sempre un valore.\nUn esempio di side-effect del comando può essere la stampa a schermo, che avrò cambiato la zona memory mapped come descritto in Note sull’architettura.\nStato computazione = valore di tutte le variabili nel programma in un certo momento (oppure memoria, boh), va a modificare questo l´effetto collaterale.\nVariabili (2) 🟩 È importante tenere a mente che le variabili sono diverse rispetto a quelle definite in matematica, lì sono incognite che possono assumere valori in un certo insieme che non sono modificabili.\nInvece in informatica per le variabili abbiamo due modi principale di interpretazione, una reference model e l’altra come variabili modificabili\nIl primo modo intende la variabile come una reference a una zona di memoria in cui veramente è presente il dato che ho, quindi come se fosse un puntatore (senza possibilità di modifica) (solitamente messo nella heap). Quindi la variabile denota il riferimento, alla variabile, non il contenitore al valore.\nIl secondo modo intende le variabili proprio per il valore che possiedono, quindi come contenitore o locazione di memoria che contiene qualcosa che può cambiare nel tempo. Sembra molto simile, ma nel secondo modo vado a riferirmi al valore, che è proprio in quella zona, mentre nel primo caso è un puntatore ad una altra zona.\nAltri modelli\nSlide altri modelli di variabile\nNei linguaggi funzionali, come le variabili matematiche, che una volta assegnata non è più modificabile un valore. O modificabili in un certo senso nei linguaggi logici.\nAssegnamento 🟩 Solitamente l’assegnamento ha una forma exp1 assignmentOp exp2a ed è importante andare a distinguere l-value e r-value.\nl-value è l’indirizzo di memoria (quindi denota una locazione) in cui si dovrà andare a scrivere la r-value, che solitamente può essere la locazione se utilizzo la reference model (e quindi in pratica sposto il pointer in questo modello), o proprio una copia del valore se utilizzo l’altra interpretazione, quella delle variabili modificabili, in questo caso indica (un valore che può essere contenuto)\nSolitamente questa istruzione produce un side effect (quindi si può notare che il side effect sia un necessario), dato che il valore della variabile è stato modificato, e solitamente non ritiorna nessun valore (tranne in C che ritorna sempre una variabile, perché credo che l’assegnamento è visto come se fosse una espressione).\nIMPLICAZIONI IMPORTANTI PER SIDE EFFECT.\nÈ importante tenere a mente la possibilità di side effect, perché se provo a fare una cosa come a[f(x)] = a[f(x)] + 1 Questo potrebbe dare risultati differenti a seconda del fatto che io abbia side effect o meno. Sarebbe meglio fare cose come j = f(x); a[j] = a[j] + 1\nGli operatori come += e quelli della stessa famiglia sono utili a ovviare a questo side effect dovuto all’esempio di prima, ecco una loro utilità 😀, non è solo un modo compatto lel.\nControllo della sequenza Ambiente e memoria (3) (ni) 🟨— Slide ambiente e memoria\nSolitamente una associazione del tipo f: nome -\u003e Valore Non è sufficiente perché non posso esprimere che un assegnamento per reference cambi i valori per entrambi (secondo questo modello dovrebbe cambiarlo solo per il singolo nome!).\nSolitamente andiamo a definire 3 modelli di valore:\nValori denotabili da variabili Valori memorizzabili in locazioni di memoria Valori esprimibili come risultati di espressione. All’interno del nostro linguaggio imperativo imperativo abbiamo bisogno delle prime due, mentre in un linugaggio funzionale solamente il primo che associa valori a variabili.\nInfatti per utilizzare l-value vogliamo andare a modificare il valore associato alla variabile. mentre per accedere al r-value dobbiamo andare a prendere il contenitore, quindi dovremmo prima accedere alla locazione, e poi dalla locazione andare a riprenderci il valore.\nPoi il fatto che la l-value cambi anche il valore in memoria è una altra cosa credo… Non lo ho capito dovrei chiederlo. Questa parte non ha molto senso, e non è importante posso saltare però tenere a mente che esistono quelle 3 cose.\nComandi sequenziali 🟩 Sono comandi come\n; Ossia il singolo comando sequenziali begin ... end Che sono i comandi a blocchi anche indicati con {} in C goto Che è ora in disuso ma in passato era molto importante. Il goto ha avuto una fortissima discussione negli anni 1970 con Dijkstra. Si basava sull’idea di assembly e labels che permettevano di fare salti a piacere.\nIl goto ha la stessa espressività di un programma senza di esso (th di Böhn Jacopini) Il goto rende il codice difficilmente leggibile, quindi non permette la facile manutenzione. (si pensi a un goto per uscire da un loop 100 righe dopo, non è più strutturata la lettura diciamo). Come posso interpretare il fatto di goto che salta all’interno di un blocco? Come gestire RdA?? Sarebbe buono utilizzarlo come break e continue, ma ci sono già quei comandi… Produce spaghetti code (che crea proprio un grafo a forma di spaghetti se seguiamo il flusso di controllo del programma) Viola il concetto della programmazione strutturata, di cui tratteremo in software engineering l’anno prossimo. Slides programmazione strutturata\nCondizionali (2) 🟩 if Bexp then Cl e1se C2 Semmai potremmo dire che ci siano qualche ambiguità quando ho qualche if annidato senza delimitatori. Per la valutazione di questi if è importante tenere a mente che esiste il short-circuit per rendere più efficiente la cosa.\nCase la cosa bella è che ho un jumping table, quindi rende tutte le operazioni di controllo e salto leggermente più efficienti.\nVelocità per la jumping table (faccio solo 2 salti, invece in if-then else è lineare nel numero di if annidati). Chiarezza del costrutto. Slide case\nEsempio di Jumping table\nIterativi (2) 🟩 I comandi iterativi sono necessari per la turing completezza del linguaggio\nIterazione indeterminata\nSono comandi come while o repeat ... until oppure il do while. Ed è indeterminata perché prima dell’esecuzione non so esattamente quante iterazioni andrò a fare. dal punto della macchina fisica è molto facile implementarlo, dato che basta un salto con un check, più facile da implementare di un for.\nCon, if, ass, while ho già un linguaggio turning completo! Esattamente come è descritto in Fondamenti teorica.\nIterazione determinata\nQueste sono tutte le iterazioni in cui conosciamo a priori il numero di iterazioni da compiere (a runtime, prima di cominciare l’esecuzione del comando), per esempio for e foreach . Di solito credo che nell’implementazione si può calcolare il numero di iterazioni\nSi può osservare che la iterazione determinata sia meno espressiva dell’iterazione indeterminata, però da un punto di vista pragmatico è molto utile perché mi compatta tutta la struttura che esisteva per l’iterazione indeterminata.\nMeno espressiva perché non posso computare programmi come\n$$ f(x) = \\begin{cases} x \\text{ se è pari} \\ \\uparrow \\text{ altrimenti }\\end{cases} $$\nSe ho iterazione determinata non riesco a divergere.\nfor {exp1; expz; exp3) comando è la sintassi di C, ma nota che qui non è determinata! perché posso modificare il valore dell’indice e anche del controllo, quindi in pratica è equivalente all’iterazione determinata (posso renderlo indeterminato modificando l’indice all’interno).\nNOTE DI IMPLEMENTAZIONE\nÈ importante capire che in questo caso esiste il vincolo di semantica statica, che il fine e il valore del passo non dovrebbero essere modificati (cosa che non vale in C, per questo non è il for settato bene).\nCome fare ad implementare il passo? Se è negativo? Proco a costruire il concetto di iteration counter definito come segue:\n$$ ic = \\lfloor \\dfrac{fine - inizio + passo}{passo}\\rfloor $$\n+passo perché il fine è incluso nella iterazione, per questo aggiungo 1.\nRicorsione Definizioni induttive 🟩 Una cosa cosa molto interessante è che se possediamo una funzione da $g: \\N \\times A \\to A$, e abbiamo una funzione $f: \\N \\to A$, e un qualunque valore $a \\in A$, allora posto\n$$ f(0) = a \\ f(n + 1) = g(n, f(n)) $$\nf è univocamente determinata per tutti i valori del dominio. Basta che g sia una funzione totale.\nCredo che questa definizione della funzione f, sfrutti la struttura dei numeri naturali (la stessa struttura su cui si basa il principio di induzione). Studieremo queste definizioni in maggior dettaglio in informatica teorica.\nIn modo simile una funzione ricorsiva è simile a questa, è definita in termini di funzioni precedenti già definite. Nonostante ciò ci possono essere dei casi in cui è calcolabile, ma si discosta un pò dalle definizioni matematiche.\nCasi in cui ciò si discosta\nSi può dimostrare, cosa che non facciamo in questa sede che ricorsione è equivalente alla iterazione. Nonostante ciò in alcune implementazioni, in particolare l’implementazione standard della ricorsione, questo porti a forti inefficienze. Analizzeremo solamente la tail recursion come ottimizzazione possibile.\nTail recursion 🟩- Una chiamata di g in f di si dice “chiamata in coda” (o tail call) se f restituisce il valore restituito da g senza ulteriore computazione.\nQuando faccio una chiamata ricorsiva alla fine, prima di ritornare dalla funzione, allora posso ottimizzare tutto il discorso che abbiamo fatto sugli RdA in Nomi e Scope, perché non avrei bisogno di allocare un nuovo RdA, mi basta lo spazio attuale!\nÈ una cosa molto particolare perché con questo riesco a implementare la ricorsione con memoria statica! Un singolo RdA.\nTail recursion si ha quando l’ultima istruzione di ritorno non possiede computazioni aggiuntive, avendo questa proprietà, la chiamata della funzione può essere posta in modo che sovrascriva tutti i parametri, le variabili locali, con l’indirizzo di ritorno e il valore di ritorno le stesse della funzione chaiamante.\nIn pratica invece di far crescere continuamente la stack, posso fare in modo di utilizzare lo stesso record scrivendoci i nuovi parametri, un risparmio di memoria non da niente!\n",
  "wordCount" : "2402",
  "inLanguage": "en",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Xuanqiang 'Angelo' Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/content/notes/valutazione-espressioni/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X. A. Huang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon-192x192.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="X. A. Huang&#39;s Blog (Alt + H)">X. A. Huang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/notes/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/notes/">Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      Valutazione Espressioni
    </h1>
    <div class="post-meta">12 min&nbsp;·&nbsp;Xuanqiang &#39;Angelo&#39; Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#elementi-di-ripasso" aria-label="Elementi di ripasso">Elementi di ripasso</a></li>
                <li>
                    <a href="#espressioni-comandi-ricorsione" aria-label="Espressioni, Comandi, Ricorsione">Espressioni, Comandi, Ricorsione</a><ul>
                        
                <li>
                    <a href="#espressioni" aria-label="Espressioni">Espressioni</a><ul>
                        
                <li>
                    <a href="#notazioni-sintassi-possibili-3-" aria-label="Notazioni (sintassi possibili) (3) 🟩">Notazioni (sintassi possibili) (3) 🟩</a></li>
                <li>
                    <a href="#semantica-" aria-label="Semantica 🟩">Semantica 🟩</a></li>
                <li>
                    <a href="#ordine-di-valutazione-delle-sottoespressioni-4-" aria-label="Ordine di valutazione delle sottoespressioni (4) 🟩—">Ordine di valutazione delle sottoespressioni (4) 🟩—</a></li></ul>
                </li>
                <li>
                    <a href="#comandi" aria-label="Comandi">Comandi</a><ul>
                        
                <li>
                    <a href="#definizione-di-comandi-" aria-label="Definizione di comandi 🟩">Definizione di comandi 🟩</a></li>
                <li>
                    <a href="#variabili-2-" aria-label="Variabili (2) 🟩">Variabili (2) 🟩</a></li>
                <li>
                    <a href="#assegnamento-" aria-label="Assegnamento 🟩">Assegnamento 🟩</a></li></ul>
                </li>
                <li>
                    <a href="#controllo-della-sequenza" aria-label="Controllo della sequenza">Controllo della sequenza</a><ul>
                        
                <li>
                    <a href="#ambiente-e-memoria-3-ni-" aria-label="Ambiente e memoria (3) (ni) 🟨—">Ambiente e memoria (3) (ni) 🟨—</a></li>
                <li>
                    <a href="#comandi-sequenziali-" aria-label="Comandi sequenziali 🟩">Comandi sequenziali 🟩</a></li>
                <li>
                    <a href="#condizionali-2-" aria-label="Condizionali (2) 🟩">Condizionali (2) 🟩</a></li>
                <li>
                    <a href="#iterativi-2-" aria-label="Iterativi (2) 🟩">Iterativi (2) 🟩</a></li></ul>
                </li>
                <li>
                    <a href="#ricorsione" aria-label="Ricorsione">Ricorsione</a><ul>
                        
                <li>
                    <a href="#definizioni-induttive-" aria-label="Definizioni induttive 🟩">Definizioni induttive 🟩</a></li>
                <li>
                    <a href="#tail-recursion--" aria-label="Tail recursion 🟩-">Tail recursion 🟩-</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Ripasso Prox: 40
Ripasso: May 31, 2023
Ultima modifica: May 29, 2023 3:58 PM
Primo Abbozzo: March 6, 2023 9:19 AM
Stato: 🌕🌕🌕🌕🌗
Studi Personali: No</p>
<h1 id="elementi-di-ripasso">Elementi di ripasso<a hidden class="anchor" aria-hidden="true" href="#elementi-di-ripasso">#</a></h1>
<h1 id="espressioni-comandi-ricorsione">Espressioni, Comandi, Ricorsione<a hidden class="anchor" aria-hidden="true" href="#espressioni-comandi-ricorsione">#</a></h1>
<h2 id="espressioni">Espressioni<a hidden class="anchor" aria-hidden="true" href="#espressioni">#</a></h2>
<blockquote>
<p>Con espressione intendiamo una entità sintattica, che una volta valutata <strong>ritornerà un valore</strong>, oppure non termina, in questo caso si dice che la espressione è INDEFINITA.</p>
</blockquote>
<p>Questa è una definizione è leggermente ambigua dato che non abbiamo una definizione precisa di valutazoine, che è fortemente dipendente dalla macchina astratta in cui viene eseguito.</p>
<h3 id="notazioni-sintassi-possibili-3-">Notazioni (sintassi possibili) (3) 🟩<a hidden class="anchor" aria-hidden="true" href="#notazioni-sintassi-possibili-3-">#</a></h3>
<p><strong>Notazione infissa</strong></p>
<p>Questa è la notazione classica matematica, per cose tipo $a -b$, in cui l&rsquo;operando sta nel mezzo degli operatori.</p>
<p>Abbiamo il vantaggio di famigliarità e semplicità della istruzione, ma perdiamo con ambiguità di precendenza degli operatori e associatività degli operatori, cioè non sempre sappiamo se una espressione ha precedenza con l’altra, per esempio una espressione del tipo <code>x == y and y == 1</code>d in un certo linguaggio and ha una precedenza, e quindi farebbe perdere di senso all&rsquo;espressione.</p>
<p>Problemi di precedenza abbiamo per cose come $1 - 1 -1$, che a seconda se facciamo prima il primo - o il secondo meno possiamo avere dei risultati differenti.</p>
<p>Quindi se utilizziamo una notazione infissa, guadagniamo di semplicità e famigliarità, e perdiamo in complessità della valutazione, che per essere eseguita vorremmo creare un albero di valutazione, che spesso si deriva dall&rsquo;albero di derivazione dopo il parser.</p>
<p><strong>Notazione prefissa (polacca)</strong></p>
<p>Sono scritture come questo: $+ , a,b$, in qui scriviamo prima il + e poi gli operandi.</p>
<p>È una cosa molto comoda perché non abbiamo la necessità di specificare precedenze né parentesi, ma basta sapere l&rsquo;arietà del nostro operatore per poter valutare l&rsquo;espressione.</p>
<p><strong>Notazione postfissa (polacca inversa)</strong></p>
<p>Questa è uguale alla precedente, ma al contrario, quindi abbiamo cose come $a, b,+$, è anche più semplice da valutare, ma in generale molto semplice.</p>
<p><strong>Prefissa matematica e di cambridge</strong></p>
<p>come f(a, b), oppure (f a b) per cambridge</p>
<p><strong>Interpretazione dell’albero</strong></p>
<p>Si potrebbe interpretare la notazione infissa, prefissa o postfissa come una visita dell’albero di valutazione.</p>
<ol>
<li>simmetrica = visita infissa</li>
<li>prefissa = visita prefissa (anticipata) (provo a valutare l’operatore e poi vado giù)</li>
<li>Postfissa = visita postfissa (valuta dopo aver eseguito sinistra e destra)</li>
</ol>
<h3 id="semantica-">Semantica 🟩<a hidden class="anchor" aria-hidden="true" href="#semantica-">#</a></h3>
<p>Con la semantica andiamo ad indicare il processo di valutazione di una espressione. Abbiamo detto prima che per la notazione infissa è più complicata, infatti dovremmo andare a creare un <strong>albero di valutazione</strong>, creato dall&rsquo;albero di derivazione (che quando compiliamo col parser è facile da creare dalle foglie).</p>
<p>Invece se proviamo a valutare con la notazione prefissa, questa è una cosa molto più semplice, perché basta una singola scansione che va con questo algoritmo:</p>
<ol>
<li>Se è un operatore inizializzo un counter e torno a leggere</li>
<li>Se vedo un operando pusho in pila  e decremento il counter.</li>
<li>Se counter è 0 faccio l&rsquo;operazione e metto in stack, se è diverso da 0 torno a leggere</li>
</ol>
<p>Se è postfissa allora è ancora più semplice, se ho un operando pusho in pila, se ho un operatore prelevo quanto mi serve ed eseguo e pusho in pila il risultato.</p>
<h3 id="ordine-di-valutazione-delle-sottoespressioni-4-">Ordine di valutazione delle sottoespressioni (4) 🟩—<a hidden class="anchor" aria-hidden="true" href="#ordine-di-valutazione-delle-sottoespressioni-4-">#</a></h3>
<p>Matematicamente parlando non sarebbe molto importante andare a considerare l’ordine di valutazione, però in questo caso diventa molto importante perché l’ordine stesso potrebbe incidere sul risultato dell&rsquo;espressione, un esempio è quando <strong>una espressione implica un side effect.</strong></p>
<ol>
<li>
<p>Side effect (come potrebbe essere la chiamata di una funzione con side effect mentre valutiamo l&rsquo;espressione!)</p>
</li>
<li>
<p>Possibilità di overfow per aritmetica finita eg. <code>(INT_MAX - 10 + 5)</code> vs <code>(INT_MAX + 5 - 10)</code></p>
</li>
<li>
<p>Corto circuito e operatori non definiti.</p>
<ol>
<li>Per esempio una scrittura del tipo <code>(p ≠ NULL) &amp;&amp; (p.next == 1)</code>sarebbe un errore in pascal, perché fa una esecuzione <strong>eager</strong>, cioè valuta tutto prima di valutare qualcosa, mentre in C se è null torno subito, questo si dice <strong>corto circuito</strong> perché non vado a valutare tutto.</li>
</ol>
</li>
<li>
<p>Efficienza, l&rsquo;ordine di valutazione può anche cambiare l’efficienza dell’esecuzione, ad esempio inizializzando un accesso in memoria, e poi andare a fare altre operazioni che non avevano bisogno di accesso. Perché nell’esempio di sotto è probabile che a<em>a non sia ancora disponibile, quindi conveniva fare  c</em>d prima di andare sull’altro, che deve attendere.</p>
<ol>
<li>Esempio</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl">a= vettore[i];
</span></span><span class="line"><span class="cl">b = a*a + c*d
</span></span></code></pre></div></li>
</ol>
<p>In questa sede quindi è importante fare differenza fra</p>
<h2 id="comandi">Comandi<a hidden class="anchor" aria-hidden="true" href="#comandi">#</a></h2>
<h3 id="definizione-di-comandi-">Definizione di comandi 🟩<a hidden class="anchor" aria-hidden="true" href="#definizione-di-comandi-">#</a></h3>
<p>Per comando intendiamo una entità sintattica che quando valutata non necessariamente ritorna un valore, inoltre potrebbe fare un effetto collaterale. (NOTA: anche le espressioni possono avere effetto collaterale)</p>
<p>Da questa definizione non sembra ci sia una differenza chiara con l’espressione. però concettualmente dovremmo tenerci in mente che un comando è qualcosa di utile per cambiare lo stato del programma, ossia alla fine del comando ho uno stato differente, quindi ho avuto un side effect, mentre una espressione è qualcosa che idealmente non dovrebbe avere side-effect, ma alla fine ritorna sempre un valore.</p>
<p>Un esempio di side-effect del comando può essere la stampa a schermo, che avrò cambiato la zona memory mapped come descritto in <a href="//notes/note-sull%E2%80%99architettura">Note sull’architettura</a>.</p>
<p><strong>Stato computazione</strong> = valore di tutte le variabili nel programma in un certo momento (oppure memoria, boh), va a modificare questo l´effetto collaterale.</p>
<h3 id="variabili-2-">Variabili (2) 🟩<a hidden class="anchor" aria-hidden="true" href="#variabili-2-">#</a></h3>
<p>È importante tenere a mente che le variabili sono diverse rispetto a quelle definite in matematica, lì sono incognite che possono assumere valori in un certo insieme che <strong>non sono modificabili</strong>.</p>
<p>Invece in informatica per le variabili abbiamo due modi principale di interpretazione, una <strong>reference model</strong> e l&rsquo;altra come <strong>variabili modificabili</strong></p>
<p>Il primo modo intende la variabile come una <strong>reference</strong> a una zona di memoria in cui veramente è presente il dato che ho, quindi come se fosse un puntatore (senza possibilità di modifica) (solitamente messo nella heap). Quindi la variabile denota il riferimento, alla variabile, non il contenitore al valore.</p>
<p>Il secondo modo intende le variabili proprio per il valore che possiedono, quindi come contenitore o locazione di memoria che contiene qualcosa che può cambiare nel tempo. Sembra molto simile, ma nel secondo modo vado a riferirmi al valore, che è proprio in quella zona, mentre nel primo caso è un puntatore ad una altra zona.</p>
<p><strong>Altri modelli</strong></p>
<ul>
<li>
<p>Slide altri modelli di variabile</p>
  <img src="/images/notes/image/universita/ex-notion/Valutazione Espressioni/Untitled.png" alt="image/universita/ex-notion/Valutazione Espressioni/Untitled">
</li>
</ul>
<p>Nei linguaggi funzionali, come le variabili matematiche, che una volta assegnata non è più modificabile un valore. O modificabili in un certo senso nei linguaggi logici.</p>
<h3 id="assegnamento-">Assegnamento 🟩<a hidden class="anchor" aria-hidden="true" href="#assegnamento-">#</a></h3>
<p>Solitamente l&rsquo;assegnamento ha una forma <code>exp1 assignmentOp exp2</code>a ed è importante andare a distinguere <strong>l-value</strong> e <strong>r-value</strong>.</p>
<p>l-value è l&rsquo;indirizzo di memoria (quindi <strong>denota una locazione</strong>) in cui si dovrà andare a scrivere la r-value, che solitamente può essere la locazione se utilizzo la reference model (e quindi in pratica sposto il pointer in questo modello), o proprio una copia del valore se utilizzo l’altra interpretazione, quella delle <strong>variabili modificabili</strong>, in questo caso indica (<strong>un valore che può essere contenuto</strong>)</p>
<p>Solitamente questa istruzione <strong>produce un side effect</strong> (quindi si può notare che il side effect sia un necessario), dato che il valore della variabile è stato modificato, e solitamente non ritiorna nessun valore (tranne in C che ritorna sempre una variabile, perché credo che l’assegnamento è visto come se fosse una espressione).</p>
<p><strong>IMPLICAZIONI IMPORTANTI PER SIDE EFFECT</strong>.</p>
<p>È importante tenere a mente la possibilità di side effect, perché se provo a fare una cosa come <code>a[f(x)] = a[f(x)] + 1</code> Questo potrebbe dare risultati differenti a seconda del fatto che io abbia side effect o meno. Sarebbe meglio fare cose come <code>j = f(x); a[j] = a[j] + 1</code></p>
<p>Gli operatori come <code>+=</code> e quelli della stessa famiglia sono utili a ovviare a questo side effect dovuto all’esempio di prima, ecco una loro utilità 😀, non è solo un modo compatto lel.</p>
<h2 id="controllo-della-sequenza">Controllo della sequenza<a hidden class="anchor" aria-hidden="true" href="#controllo-della-sequenza">#</a></h2>
<h3 id="ambiente-e-memoria-3-ni-">Ambiente e memoria (3) (ni) 🟨—<a hidden class="anchor" aria-hidden="true" href="#ambiente-e-memoria-3-ni-">#</a></h3>
<ul>
<li>
<p>Slide ambiente e memoria</p>
  <img src="/images/notes/image/universita/ex-notion/Valutazione Espressioni/Untitled 1.png" alt="image/universita/ex-notion/Valutazione Espressioni/Untitled 1">
</li>
</ul>
<p>Solitamente una associazione del tipo <code>f: nome -&gt; Valore</code> Non è sufficiente perché non posso esprimere che un assegnamento per reference cambi i valori per entrambi (secondo questo modello dovrebbe cambiarlo solo per il singolo nome!).</p>
<p>Solitamente andiamo a definire 3 modelli di valore:</p>
<ol>
<li>Valori denotabili da variabili</li>
<li>Valori memorizzabili in locazioni di memoria</li>
<li>Valori esprimibili come risultati di espressione.</li>
</ol>
<p>All&rsquo;interno del nostro linguaggio imperativo imperativo abbiamo bisogno delle prime due, mentre in un linugaggio funzionale solamente il primo che associa valori a variabili.</p>
<p>Infatti per utilizzare l-value vogliamo andare a modificare il valore associato alla variabile. mentre per accedere al r-value dobbiamo andare a prendere il contenitore, quindi dovremmo prima accedere alla locazione, e poi dalla locazione andare a riprenderci il valore.</p>
<p>Poi il fatto che la l-value cambi anche il valore in memoria è una altra cosa credo… Non lo ho capito dovrei chiederlo. Questa parte non ha molto senso, e non è importante posso saltare però tenere a mente che esistono quelle 3 cose.</p>
<h3 id="comandi-sequenziali-">Comandi sequenziali 🟩<a hidden class="anchor" aria-hidden="true" href="#comandi-sequenziali-">#</a></h3>
<p>Sono comandi come</p>
<ol>
<li><code>;</code> Ossia il singolo comando sequenziali</li>
<li><code>begin ... end</code>  Che sono i comandi a blocchi anche indicati con <code>{}</code> in C</li>
<li><code>goto</code> Che è ora in disuso ma in passato era molto importante.</li>
</ol>
<p>Il goto ha avuto una fortissima discussione negli anni 1970 con Dijkstra. Si basava sull&rsquo;idea di assembly e labels che permettevano di fare salti a piacere.</p>
<ol>
<li>Il goto ha la stessa espressività di un programma senza di esso (th di Böhn Jacopini)</li>
<li>Il goto rende il codice difficilmente leggibile, quindi non permette la facile manutenzione. (si pensi a un goto per uscire da un loop 100 righe dopo, non è più strutturata la lettura diciamo).</li>
<li>Come posso interpretare il fatto di goto che salta all&rsquo;interno di un blocco? Come gestire RdA??</li>
<li>Sarebbe buono utilizzarlo come break e continue, ma ci sono già quei comandi…</li>
<li>Produce spaghetti code (che crea proprio un grafo a forma di spaghetti se seguiamo il flusso di controllo del programma)
<ol>
<li>Viola il concetto della <strong>programmazione strutturata</strong>, di cui tratteremo in software engineering l&rsquo;anno prossimo.</li>
</ol>
<ul>
<li>
<p>Slides programmazione strutturata</p>
  <img src="/images/notes/image/universita/ex-notion/Valutazione Espressioni/Untitled 2.png" alt="image/universita/ex-notion/Valutazione Espressioni/Untitled 2">
</li>
</ul>
</li>
</ol>
<h3 id="condizionali-2-">Condizionali (2) 🟩<a hidden class="anchor" aria-hidden="true" href="#condizionali-2-">#</a></h3>
<p><code>if Bexp then Cl e1se C2</code> Semmai potremmo dire che ci siano qualche ambiguità quando ho qualche if annidato senza delimitatori. Per la valutazione di questi if è importante tenere a mente che esiste il short-circuit per rendere più efficiente la cosa.</p>
<p><strong>Case</strong> la cosa bella è che ho un jumping table, quindi rende tutte le operazioni di controllo e salto leggermente più efficienti.</p>
<ol>
<li>Velocità per la jumping table (faccio solo 2 salti, invece in if-then else è lineare nel numero di if annidati).</li>
<li>Chiarezza del costrutto.</li>
</ol>
<ul>
<li>
<p>Slide case</p>
  <img src="/images/notes/image/universita/ex-notion/Valutazione Espressioni/Untitled 3.png" alt="image/universita/ex-notion/Valutazione Espressioni/Untitled 3">
</li>
<li>
<p>Esempio di Jumping table</p>
  <img src="/images/notes/image/universita/ex-notion/Valutazione Espressioni/Untitled 4.png" alt="image/universita/ex-notion/Valutazione Espressioni/Untitled 4">
</li>
</ul>
<h3 id="iterativi-2-">Iterativi (2) 🟩<a hidden class="anchor" aria-hidden="true" href="#iterativi-2-">#</a></h3>
<p>I comandi iterativi sono necessari per la turing completezza del linguaggio</p>
<p><strong>Iterazione indeterminata</strong></p>
<p>Sono comandi come <code>while</code> o <code>repeat ... until</code>  oppure il do while. Ed è indeterminata perché prima dell&rsquo;esecuzione non so esattamente quante iterazioni andrò a fare. dal punto della macchina fisica è molto facile implementarlo, dato che basta un salto con un check, più facile da implementare di un for.</p>
<p>Con, <code>if, ass, while</code> ho già un linguaggio turning completo! Esattamente come è descritto in <a href="//notes/fondamenti-teorica">Fondamenti teorica</a>.</p>
<p><strong>Iterazione determinata</strong></p>
<p>Queste sono tutte le iterazioni in cui conosciamo a priori il numero di iterazioni da compiere (a runtime, prima di cominciare l&rsquo;esecuzione del comando), per esempio <code>for</code> e <code>foreach</code> . Di solito credo che nell&rsquo;implementazione si può calcolare il numero di iterazioni</p>
<p>Si può osservare che la iterazione determinata sia meno espressiva dell’iterazione indeterminata, però da un punto di vista pragmatico è molto utile perché mi compatta tutta la struttura che esisteva per l’iterazione indeterminata.</p>
<p>Meno espressiva perché non posso computare programmi come</p>
<p>$$
f(x) = \begin{cases} x \text{   se è pari} \
\uparrow \text{ altrimenti }\end{cases}
$$</p>
<p>Se ho iterazione determinata non riesco a divergere.</p>
<p><code>for {exp1; expz; exp3) comando</code>  è la sintassi di C, ma nota che qui non è determinata! perché posso modificare il valore dell’indice e anche del controllo, quindi in pratica è equivalente all’iterazione determinata (posso renderlo indeterminato modificando l’indice all&rsquo;interno).</p>
<p><strong>NOTE DI IMPLEMENTAZIONE</strong></p>
<p>È importante capire che in questo caso esiste il vincolo di semantica statica, che il fine e il valore del passo non dovrebbero essere modificati (cosa che non vale in C, per questo non è il for settato bene).</p>
<p>Come fare ad implementare il passo? Se è negativo? Proco a costruire il concetto di <strong>iteration counter</strong> definito come segue:</p>
<p>$$
ic = \lfloor \dfrac{fine - inizio + passo}{passo}\rfloor
$$</p>
<p>+passo perché il fine è incluso nella iterazione, per questo aggiungo 1.</p>
<h2 id="ricorsione">Ricorsione<a hidden class="anchor" aria-hidden="true" href="#ricorsione">#</a></h2>
<h3 id="definizioni-induttive-">Definizioni induttive 🟩<a hidden class="anchor" aria-hidden="true" href="#definizioni-induttive-">#</a></h3>
<p>Una cosa cosa molto interessante è che se possediamo una funzione da $g: \N \times A \to A$, e abbiamo una funzione $f: \N \to A$, e un qualunque valore $a \in A$, allora posto</p>
<p>$$
f(0) = a \
f(n + 1) = g(n, f(n))
$$</p>
<p>f è univocamente determinata per tutti i valori del dominio. Basta che g sia una funzione totale.</p>
<p>Credo che questa definizione della funzione f, sfrutti la struttura dei numeri naturali (la stessa struttura su cui si basa il principio di induzione). Studieremo queste definizioni in maggior dettaglio in informatica teorica.</p>
<p>In modo simile una funzione ricorsiva è simile a questa, è definita in termini di funzioni precedenti già definite. Nonostante ciò ci possono essere dei casi in cui è calcolabile, ma si discosta un pò dalle definizioni matematiche.</p>
<ul>
<li>
<p>Casi in cui ciò si discosta</p>
  <img src="/images/notes/image/universita/ex-notion/Valutazione Espressioni/Untitled 5.png" alt="image/universita/ex-notion/Valutazione Espressioni/Untitled 5">
</li>
</ul>
<p>Si può dimostrare, cosa che non facciamo in questa sede che <strong>ricorsione è equivalente alla iterazione</strong>. Nonostante ciò in alcune implementazioni, in particolare l&rsquo;implementazione standard della ricorsione, questo porti a forti inefficienze. Analizzeremo solamente la tail recursion come ottimizzazione possibile.</p>
<h3 id="tail-recursion--">Tail recursion 🟩-<a hidden class="anchor" aria-hidden="true" href="#tail-recursion--">#</a></h3>
<blockquote>
<p>Una chiamata di g in f di si dice “chiamata in coda” (o tail call) se
f restituisce il valore restituito da g senza ulteriore computazione.</p>
</blockquote>
<p>Quando faccio una chiamata ricorsiva alla fine, prima di ritornare dalla funzione, allora posso ottimizzare tutto il discorso che abbiamo fatto sugli RdA in <a href="//notes/nomi-e-scope">Nomi e Scope</a>, perché non avrei bisogno di allocare un nuovo RdA, mi basta lo spazio attuale!</p>
<p>È una cosa molto particolare perché con questo riesco a implementare la ricorsione con memoria statica! Un singolo RdA.</p>
<p>Tail recursion si ha quando l’ultima istruzione di ritorno <strong>non possiede computazioni aggiuntive</strong>, avendo questa proprietà, la chiamata della funzione può essere posta in modo che sovrascriva tutti i parametri, le variabili locali, con l&rsquo;indirizzo di ritorno e il valore di ritorno le stesse della funzione chaiamante.</p>
<p>In pratica invece di far crescere continuamente la stack, posso fare in modo di utilizzare lo stesso record scrivendoci i nuovi parametri, un risparmio di memoria non da niente!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/no-tags/">No-Tags</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Valutazione Espressioni on x"
            href="https://x.com/intent/tweet/?text=Valutazione%20Espressioni&amp;url=http%3a%2f%2flocalhost%3a1313%2fcontent%2fnotes%2fvalutazione-espressioni%2f&amp;hashtags=no-tags">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Valutazione Espressioni on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fcontent%2fnotes%2fvalutazione-espressioni%2f&amp;title=Valutazione%20Espressioni&amp;summary=Valutazione%20Espressioni&amp;source=http%3a%2f%2flocalhost%3a1313%2fcontent%2fnotes%2fvalutazione-espressioni%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Valutazione Espressioni on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fcontent%2fnotes%2fvalutazione-espressioni%2f&title=Valutazione%20Espressioni">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Valutazione Espressioni on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fcontent%2fnotes%2fvalutazione-espressioni%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Valutazione Espressioni on whatsapp"
            href="https://api.whatsapp.com/send?text=Valutazione%20Espressioni%20-%20http%3a%2f%2flocalhost%3a1313%2fcontent%2fnotes%2fvalutazione-espressioni%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Valutazione Espressioni on telegram"
            href="https://telegram.me/share/url?text=Valutazione%20Espressioni&amp;url=http%3a%2f%2flocalhost%3a1313%2fcontent%2fnotes%2fvalutazione-espressioni%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Valutazione Espressioni on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Valutazione%20Espressioni&u=http%3a%2f%2flocalhost%3a1313%2fcontent%2fnotes%2fvalutazione-espressioni%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="http://localhost:1313/">X. A. Huang&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
